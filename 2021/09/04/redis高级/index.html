<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] 1、Redis初级（Windows）1、Redis入门1、Redis 简介1、Nosql的出现NoSql出现的解决的问题：  海量用户 高并发  罪魁祸首——关系型数据库：  性能瓶颈：磁盘IO性能低下 扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群  解决思路：  降低磁盘IO次数，越低越好—— 内存存储 去除数据间关系，越简单越好——不存储关系，仅存储数据  以上解决思路的实际">
<meta property="og:type" content="article">
<meta property="og:title" content="redis高级">
<meta property="og:url" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] 1、Redis初级（Windows）1、Redis入门1、Redis 简介1、Nosql的出现NoSql出现的解决的问题：  海量用户 高并发  罪魁祸首——关系型数据库：  性能瓶颈：磁盘IO性能低下 扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群  解决思路：  降低磁盘IO次数，越低越好—— 内存存储 去除数据间关系，越简单越好——不存储关系，仅存储数据  以上解决思路的实际">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904222259291.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/1.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224324322.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224540396.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224628786.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904225148243.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904225203708.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905002926897.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905003004908.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907223152303.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905003405704.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905005605687.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010101165.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905004145945.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010321037.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010413422.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905013542306.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905013558179.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907224104786.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021040556.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021259230.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021315084.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905023025448.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907225230388.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907225311811.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905024857928.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905024953197.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905025121657.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905025305653.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905030341819.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905030731903.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200615143051518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZGMwNTIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200615133913102.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/16.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905032008447.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905174735216.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905174748200.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175219504.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175236464.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175450021.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905180056763.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905181851353.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905183132934.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905183605904.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905184840300.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905184924236-16308389669061.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905185022041.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905185033618.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908114833273.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/22.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/23.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908022740502.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905203742252.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908023051641.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905204241205.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905204405680.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905210951460.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905211328753.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905211533959.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905212056307.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/82.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905213148222.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/83.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/84.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905213301214.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905214141050.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908021224660.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905215436319.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905220109563.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907010831610.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011143290.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011448753.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011537226.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011704140.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011806247.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907012115436.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907012520884.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907013653595.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907014215104.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015127642.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015201028.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015608735.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907020216293.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021639156.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021811296.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021944455.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907024141976.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907024754653.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025006909.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025536975.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025643655.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907030402598.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907031723596.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032103510.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032507122.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032548910-16309563510901.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/43.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907033026543.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032817263.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032922698.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907033351047.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/38.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/39.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/40.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/41.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/42.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907135258255.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907135434580.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907140357232.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907140650632.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141043430.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141310592.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141859784.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142218680.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142908730.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142958347.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143341529.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143626170.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143842881.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143414489.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143641578.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144153900.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143504078.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143531076.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144324055.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144225353.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144755729.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144740458.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145044928.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145201995.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145908556.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907150019576.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907150133315.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/89.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/90.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/91.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907151332317.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907151254348.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908131731307.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/87.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/88.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908131718336.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/85.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/86.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/92.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907163642955.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907203723504.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907203751485.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907214051175.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907214058698.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907215836602.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907215842362.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907220207887.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907220243094.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000334131.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000425633.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000556177.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000618247.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000707970.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000750174.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000853907.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908001813330.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002103758.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002228723.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002305616.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002345229.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002458862.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002536352.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002619005.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002648683.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002803930.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908003003737.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908004811841.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908004839416.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/44.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908014220373.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908014312523.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/45.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/46.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908024325395.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132433758.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132718079.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132730836.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/17.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133631954.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133725918-16310794468831.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133748625.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908134006188.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908134140316.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/18.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/19.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/20.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/21.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/24.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/25.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/26.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200617164523228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZGMwNTIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/27.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/28.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/29.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/30.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/31.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/32.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/33.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/34.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/35.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/36.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/37.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/47.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/48.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/49.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/50.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/51.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/52.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/53.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/54.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/55.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/56.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/57.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/58.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/60.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/61.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/62.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/63.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/64.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/65.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/66.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/67.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/68.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/69.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/70.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/71.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/72.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/73.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/74.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/75.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/76.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/77.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/78.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/79.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/80.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/81.png">
<meta property="article:published_time" content="2021-09-04T13:17:09.000Z">
<meta property="article:modified_time" content="2021-09-11T07:26:06.328Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904222259291.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis高级 | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis高级
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-04 21:17:09" itemprop="dateCreated datePublished" datetime="2021-09-04T21:17:09+08:00">2021-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-11 15:26:06" itemprop="dateModified" datetime="2021-09-11T15:26:06+08:00">2021-09-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis-redis%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">redis - redis高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="1、Redis初级（Windows）"><a href="#1、Redis初级（Windows）" class="headerlink" title="1、Redis初级（Windows）"></a>1、Redis初级（Windows）</h1><h2 id="1、Redis入门"><a href="#1、Redis入门" class="headerlink" title="1、Redis入门"></a>1、Redis入门</h2><h3 id="1、Redis-简介"><a href="#1、Redis-简介" class="headerlink" title="1、Redis 简介"></a>1、Redis 简介</h3><h4 id="1、Nosql的出现"><a href="#1、Nosql的出现" class="headerlink" title="1、Nosql的出现"></a>1、Nosql的出现</h4><p>NoSql出现的解决的问题：</p>
<ul>
<li>海量用户</li>
<li>高并发</li>
</ul>
<p>罪魁祸首——关系型数据库：</p>
<ul>
<li>性能瓶颈：磁盘IO性能低下</li>
<li>扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群</li>
</ul>
<p>解决思路：</p>
<ul>
<li>降低磁盘IO次数，越低越好—— 内存存储</li>
<li>去除数据间关系，越简单越好——不存储关系，仅存储数据</li>
</ul>
<p>以上解决思路的实际实现：NoSql</p>
<h4 id="2、Nosql-简介"><a href="#2、Nosql-简介" class="headerlink" title="2、Nosql 简介"></a>2、Nosql 简介</h4><p>NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。</p>
<p>作用：应对<strong>基于海量用户和海量数据前提下的数据处理问题</strong>。</p>
<p>特征：</p>
<ul>
<li>可扩容，可伸缩</li>
<li>大数据量下高性能</li>
<li>灵活的数据模型</li>
<li>高可用</li>
</ul>
<p>常见 Nosql 数据库：</p>
<ul>
<li>==Redis==</li>
<li>memcache</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
<h4 id="3、具体解决方案-——（电商场景）"><a href="#3、具体解决方案-——（电商场景）" class="headerlink" title="3、具体解决方案 ——（电商场景）"></a>3、具体解决方案 ——（电商场景）</h4><ol>
<li>商品基本信息 ——MySQL<ul>
<li>名称</li>
<li>价格</li>
<li>厂商</li>
</ul>
</li>
<li>商品附加信息 —— MongoDB<ul>
<li>描述</li>
<li>详情</li>
<li>评论</li>
</ul>
</li>
<li>图片信息 —— 分布式文件系统</li>
<li>搜索关键字 —— ES、Lucene、solr</li>
<li>热点信息 —— Redis、memcache、tair<ul>
<li>高频</li>
<li>波段性</li>
</ul>
</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904222259291.png" alt="image-20210904222259291"></p>
<h4 id="4、Redis"><a href="#4、Redis" class="headerlink" title="4、Redis"></a>4、Redis</h4><p>概念：Redis (REmote DIctionary Server) 是用 ==C 语言==开发的一个==开源==的高性能==键值对==（key-value）数据库。</p>
<p>在线测试：<a target="_blank" rel="noopener" href="http://try.redis.io/">http://try.redis.io/</a> </p>
<p>使用文档：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p>
<p>特征：</p>
<ol>
<li><strong>数据间没有必然的关联关系</strong></li>
<li><strong>内部采用单线程机制进行工作</strong></li>
<li><strong>高性能</strong>。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</li>
<li><strong>多数据类型支持</strong><ul>
<li>字符串类型——string</li>
<li>列表类型——list</li>
<li>散列类型——hash</li>
<li>集合类型——set</li>
<li>有序集合类型——sorted_set</li>
</ul>
</li>
<li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是<strong>原子性</strong>的。</li>
<li>在此基础上，Redis支持各种不同方式的<strong>排序</strong>。</li>
<li>与memcached一样，为了保证效率，<strong>数据都是缓存在内存</strong>中。</li>
<li>区别的是Redis会<strong>周期性</strong>的把更新的<strong>数据写入磁盘</strong>或者把修改操作写入追加的记录文件。</li>
<li><strong>持久化支持</strong>。可以进行数据灾难恢复</li>
<li>并且在此基础上实现了**master-slave(主从)**同步</li>
</ol>
<p><strong>Redis是单线程+多路IO复用技术</strong></p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>==串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)==</p>
<p>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） </p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/1.gif" alt="1"></p>
<h4 id="5、Redis-的应用"><a href="#5、Redis-的应用" class="headerlink" title="5、Redis 的应用"></a>5、Redis 的应用</h4><ul>
<li>配合关系型数据库做高速缓存<ul>
<li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li>
<li>任务队列，如秒杀、抢购、购票排队等</li>
<li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li>
<li>时效性信息控制，如验证码控制、投票控制等</li>
<li>布式数据共享，如分布式集群架构中的 session 分离</li>
</ul>
</li>
<li>多样的数据结构存储持久化数据</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h3 id="2、Redis-的下载与安装"><a href="#2、Redis-的下载与安装" class="headerlink" title="2、Redis 的下载与安装"></a>2、Redis 的下载与安装</h3><h4 id="1、Redis-的下载"><a href="#1、Redis-的下载" class="headerlink" title="1、Redis 的下载"></a>1、Redis 的下载</h4><p>Linux 版：（适用于企业级开发）</p>
<ul>
<li>Redis 高级开始使用</li>
<li>以4.0 版本作为主版本</li>
</ul>
<p>Windows 版本（适合零基础学习）</p>
<ul>
<li>Redis 入门使用</li>
<li>以 3.2 版本作为主版本</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/tags">下载地址</a></li>
</ul>
<h4 id="2、安装-Redis"><a href="#2、安装-Redis" class="headerlink" title="2、安装 Redis"></a>2、安装 Redis</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224324322.png" alt="image-20210904224324322"></p>
<p>核心文件：</p>
<ul>
<li>redis-server.exe：服务器启动命令</li>
<li>redis-cli.exe：命令行客户端</li>
<li>redis.windows.conf：redis核心配置文件<ul>
<li>Linux环境下是redis.conf</li>
</ul>
</li>
<li>redis-benchmark.exe ：性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>
<li>redis-check-aof.exe：AOF文件修复工具，修复有问题的AOF文件</li>
<li>redis-check-dump.exe：RDB文件检查工具（快照持久化文件），修复有问题的dump.rdb文件</li>
<li>在Linux环境下还有一个redis-sentinel：Redis集群使用</li>
</ul>
<h4 id="3、启动-Redis"><a href="#3、启动-Redis" class="headerlink" title="3、启动 Redis"></a>3、启动 Redis</h4><p>服务器启动：</p>
<h5 id="1、前台启动（不推荐）"><a href="#1、前台启动（不推荐）" class="headerlink" title="1、前台启动（不推荐）"></a>1、前台启动（不推荐）</h5><ul>
<li>端口：6379</li>
<li>PID：随机生成</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224540396.png" alt="image-20210904224540396"></p>
<p>客户端连接：<img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904224628786.png" alt="image-20210904224628786"></p>
<p>前台启动，命令行窗口不能关闭，否则服务器停止。</p>
<h5 id="2、后台启动（推荐）"><a href="#2、后台启动（推荐）" class="headerlink" title="2、后台启动（推荐）"></a>2、后台启动（推荐）</h5><p>修改redis.windows.conf文件将里面的daemonize no 改成 yes，让服务在后台启动。</p>
<p>可以使用客户端Ping一下看看能不能连接成功</p>
<h3 id="3、Redis-的基本操作"><a href="#3、Redis-的基本操作" class="headerlink" title="3、Redis 的基本操作"></a>3、Redis 的基本操作</h3><h4 id="1、命令行模式工具使用思考"><a href="#1、命令行模式工具使用思考" class="headerlink" title="1、命令行模式工具使用思考"></a>1、命令行模式工具使用思考</h4><ul>
<li>功能性命令</li>
<li>清除屏幕信息</li>
<li>帮助信息查阅</li>
<li>退出指令</li>
</ul>
<h4 id="2、信息添加"><a href="#2、信息添加" class="headerlink" title="2、信息添加"></a>2、信息添加</h4><ul>
<li><p>功能：设置 key，value 数据</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>范例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name zhangsan</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、信息查询"><a href="#3、信息查询" class="headerlink" title="3、信息查询"></a>3、信息查询</h4><ul>
<li><p>功能：根据 key 查询对应的 value，如果不存在，返回空（nil）</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>
</li>
<li><p>范例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、清除屏幕信息"><a href="#4、清除屏幕信息" class="headerlink" title="4、清除屏幕信息"></a>4、清除屏幕信息</h4><ul>
<li><p>功能：清除屏幕中的信息</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="5、退出客户端命令行模式"><a href="#5、退出客户端命令行模式" class="headerlink" title="5、退出客户端命令行模式"></a>5、退出客户端命令行模式</h4><ul>
<li><p>功能：退出客户端</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">&lt;ESC&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="6、帮助"><a href="#6、帮助" class="headerlink" title="6、帮助"></a>6、帮助</h4><ul>
<li><p>功能：获取命令帮助文档，获取组中所有命令信息名称</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> 命令名称</span><br><span class="line"><span class="built_in">help</span> @组名</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904225148243.png" alt="image-20210904225148243"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210904225203708.png" alt="image-20210904225203708"></p>
</li>
</ul>
<hr>
<h2 id="2、Redis-数据类型"><a href="#2、Redis-数据类型" class="headerlink" title="2、Redis 数据类型"></a>2、Redis 数据类型</h2><h3 id="1、数据存储类型介绍"><a href="#1、数据存储类型介绍" class="headerlink" title="1、数据存储类型介绍"></a>1、数据存储类型介绍</h3><h4 id="1、业务数据的特殊性"><a href="#1、业务数据的特殊性" class="headerlink" title="1、业务数据的特殊性"></a>1、业务数据的特殊性</h4><h5 id="1、作为缓存使用"><a href="#1、作为缓存使用" class="headerlink" title="1、作为缓存使用"></a>1、作为缓存使用</h5><ol>
<li>原始业务功能设计<ul>
<li>秒杀</li>
<li>618活动</li>
<li>双11活动</li>
<li>排队购票</li>
</ul>
</li>
<li>运营平台监控到的突发高频访问数据<ul>
<li>突发时政要闻，被强势关注围观</li>
</ul>
</li>
<li>高频、复杂的统计数据</li>
</ol>
<ul>
<li>在线人数</li>
<li>投票排行榜</li>
</ul>
<h5 id="2、附加功能"><a href="#2、附加功能" class="headerlink" title="2、附加功能"></a>2、附加功能</h5><p>系统功能优化或升级</p>
<ul>
<li>单服务器升级集群</li>
<li>Session 管理</li>
<li>Token 管理</li>
</ul>
<h4 id="2、Redis-数据类型（5种常用）"><a href="#2、Redis-数据类型（5种常用）" class="headerlink" title="2、Redis 数据类型（5种常用）"></a>2、Redis 数据类型（5种常用）</h4><table>
<thead>
<tr>
<th>redis</th>
<th>java</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>hash</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>LinkedList</td>
</tr>
<tr>
<td>set</td>
<td>HashSet</td>
</tr>
<tr>
<td>sorted_set</td>
<td>TreeSet</td>
</tr>
</tbody></table>
<h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String"></a>2、String</h3><h4 id="1、redis-数据存储格式"><a href="#1、redis-数据存储格式" class="headerlink" title="1、redis 数据存储格式"></a>1、redis 数据存储格式</h4><p>redis 自身是一个 Map，其中所有的数据都是采用 <code>key : value</code> 的形式存储</p>
<p><strong>数据类型指的是存储的数据的类型，也就是 value 部分的类型</strong>，==key 部分永远都是字符串==</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905002926897.png" alt="image-20210905002926897"></p>
<h4 id="2、string-类型"><a href="#2、string-类型" class="headerlink" title="2、string 类型"></a>2、string 类型</h4><ul>
<li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li>
<li>存储数据的格式：<strong>一个存储空间保存一个数据</strong></li>
<li>存储内容：通常使用<strong>字符串</strong>，如果字符串以<strong>整数的形式</strong>展示，可以<strong>作为数字</strong>操作使用<ul>
<li>String类型是<strong>二进制安全</strong>的。<ul>
<li>意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li>
</ul>
</li>
<li>String类型是Redis最基本的数据类型，<strong>一个Redis中字符串value最多可以是512M</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905003004908.png" alt="image-20210905003004908"></p>
<h4 id="3、String类型的数据结构"><a href="#3、String类型的数据结构" class="headerlink" title="3、String类型的数据结构"></a>3、String类型的数据结构</h4><p>String的数据结构为<strong>简单动态字符串</strong>(Simple Dynamic String，缩写SDS)。是可以修改的字符串，<strong>内部结构实现上类似于Java的ArrayList</strong>，采用==预分配冗余空间==的方式来减少内存的频繁分配.</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907223152303.png" alt="image-20210907223152303"></p>
<p>如图中所示：</p>
<ul>
<li>内部为<strong>当前字符串实际分配的空间capacity一般要高于实际字符串长度len</strong>。</li>
<li><strong>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间</strong>。</li>
<li>需要注意的是<strong>字符串最大长度为512M</strong>。</li>
</ul>
<h4 id="4、string-类型数据的基本操作"><a href="#4、string-类型数据的基本操作" class="headerlink" title="4、string 类型数据的基本操作"></a>4、string 类型数据的基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有在 key 不存在时  设置 key 的值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 value 覆写 key 所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加/修改多个数据（m:Multiple[ˈmʌltɪpl]）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 …</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取多个数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 …</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据字符个数（字符串长度）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数值数据增加指定范围的值(操作具有原子性)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定的key的值加1</span></span><br><span class="line">incr key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的key的值加 increment （increment为整型）</span></span><br><span class="line"><span class="comment"># 当然increment也可以为负数，若increment为负数，则功能相当于decrby</span></span><br><span class="line">incrby key increment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的key的值加 increment，increment为浮点数</span></span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数值数据减少指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定的key的值减1</span></span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的key的值减 increment （increment为整型）</span></span><br><span class="line"><span class="comment"># 当然increment也可以为负数，若increment为负数，则功能相当于incrby</span></span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据具有指定的生命周期</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line"></span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>单数据操作与多数据操作的选择之惑：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br><span class="line"></span><br><span class="line">mset key1 value1 key2 value2 …</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905003405704.png" alt="image-20210905003405704"></p>
<ul>
<li>假设需要花费时间的操作有：<ul>
<li>set 过程</li>
<li>存储过程</li>
<li>返回结果的过程（result）</li>
</ul>
</li>
<li>并且set与result的时间一样</li>
<li>发送100条数据<ul>
<li>单指令发送：200 * set/result过程 + 100 * 存储过程</li>
<li>多指令发送：2 * set/result过程 + 100 * 存储过程</li>
</ul>
</li>
<li>这样看来似乎多数据操作会比单数据操作好</li>
<li>其实不然，看似多数据操作会比单数据操作好要快，但是多数据操作数据的回馈并没有比单数据操作好<ul>
<li>这里的数据的回馈指的是进行展示的数据</li>
</ul>
</li>
<li>当数据量达到一亿，一次性发送一亿的数据，客户端这边需要等待数据存储的过程将会更长，而使用100万次发送100万次数据的复合操作来说，用户的体验会更好</li>
<li>结论：具体情况具体分析。</li>
</ul>
<h4 id="5、string-作为数值操作"><a href="#5、string-作为数值操作" class="headerlink" title="5、string 作为数值操作"></a>5、string 作为数值操作</h4><ul>
<li>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会<strong>转成数值型进行计算</strong>。</li>
<li><strong>redis所有的操作都是原子性的</strong>，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li>
<li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或<strong>超越了redis 数值上限范围</strong>，将报错。<br><code>9223372036854775807</code>（java中long型数据最大值，Long.MAX_VALUE）</li>
</ul>
<h4 id="6、string-类型数据操作的注意事项"><a href="#6、string-类型数据操作的注意事项" class="headerlink" title="6、string 类型数据操作的注意事项"></a>6、string 类型数据操作的注意事项</h4><ul>
<li>数据操作不成功的反馈与数据正常操作之间的差异<ul>
<li>表示运行结果是否成功<ul>
<li>(integer) 0 → false：失败</li>
<li>(integer) 1 → true：成功</li>
</ul>
</li>
<li>表示运行结果值<ul>
<li>(integer) 3 → 3：3个</li>
<li>(integer) 1 → 1：1个</li>
</ul>
</li>
</ul>
</li>
<li>数据未获取到<ul>
<li>（nil）等同于null</li>
</ul>
</li>
<li>数据最大存储量<ul>
<li>512MB</li>
</ul>
</li>
<li>数值计算最大范围（java中的long的最大值）<ul>
<li>9223372036854775807</li>
</ul>
</li>
</ul>
<h4 id="7、string-类型应用场景"><a href="#7、string-类型应用场景" class="headerlink" title="7、string 类型应用场景"></a>7、string 类型应用场景</h4><h5 id="1、业务场景"><a href="#1、业务场景" class="headerlink" title="1、业务场景"></a>1、业务场景</h5><p>主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905005605687.png" alt="image-20210905005605687"></p>
<h5 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h5><ul>
<li><p>在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user:id:3506728370:fans → 12210947</span><br><span class="line"></span><br><span class="line">user:id:3506728370:blogs → 6164</span><br><span class="line"></span><br><span class="line">user:id:3506728370:focuss → 83</span><br></pre></td></tr></table></figure>
</li>
<li><p>在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:id:3506728370 → &#123;<span class="string">&quot;id&quot;</span>:3506728370,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;春晚&quot;</span>,<span class="string">&quot;fans&quot;</span>:12210862,<span class="string">&quot;blogs&quot;</span>:6164, <span class="string">&quot;focus&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="8、key-的设置约定"><a href="#8、key-的设置约定" class="headerlink" title="8、key 的设置约定"></a>8、key 的设置约定</h4><p>数据库中的热点数据key命名惯例</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010101165.png" alt="image-20210905010101165"></p>
<h4 id="9、string-类型应用场景"><a href="#9、string-类型应用场景" class="headerlink" title="9、string 类型应用场景"></a>9、string 类型应用场景</h4><ul>
<li><p><font color="red"><strong>Tips 1</strong> </font>：</p>
<ul>
<li><p><strong>redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</strong></p>
</li>
<li><p><strong>此方案适用于所有数据库，且支持数据库集群</strong></p>
<ul>
<li><p>大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键 id 必须保证统一性，不能重复。Oracle 数据库具有 sequence 设定，可以解决该问题，redis 可以解决 MySQL数据库该问题</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905004145945.png" alt="image-20210905004145945"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red"><strong>Tips 2</strong> </font>：</p>
<ul>
<li><strong>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</strong><ul>
<li>“最强女生”启动海选投票，只能通过微信投票，每个微信号每 4 小时只能投1票。</li>
<li>电商商家开启热门商品推荐，热门商品不能一直处于热门期，每种商品热门期维持3天，3天后自动取消热门。</li>
<li>新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red"><strong>Tips 3</strong> </font>：</p>
<ul>
<li><strong>redis应用于各种结构型和非结构型高热度数据访问加速</strong><ul>
<li>主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、hash"><a href="#3、hash" class="headerlink" title="3、hash"></a>3、hash</h3><h4 id="1、hash-类型"><a href="#1、hash-类型" class="headerlink" title="1、hash 类型"></a>1、hash 类型</h4><h5 id="存储的困惑"><a href="#存储的困惑" class="headerlink" title="存储的困惑"></a>存储的困惑</h5><p>对象类数据的存储如果具有较频繁的更新需求操作会显得笨重</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010321037.png" alt="image-20210905010321037"></p>
<ul>
<li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li>
<li>需要的存储结构：一个存储空间保存多个键值对数据</li>
<li>hash类型：底层使用哈希表结构实现数据存储</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905010413422.png" alt="image-20210905010413422"></p>
<p>hash存储结构优化：</p>
<ul>
<li>如果field数量较少，存储结构优化为类数组结构</li>
<li>如果field数量较多，存储结构使用HashMap结构</li>
</ul>
<h4 id="2、Hash-的数据结构"><a href="#2、Hash-的数据结构" class="headerlink" title="2、Hash 的数据结构"></a>2、Hash 的数据结构</h4><p>Hash类型对应的数据结构是两种：</p>
<ul>
<li>ziplist（压缩列表）</li>
<li>hashtable（哈希表）。</li>
</ul>
<p><strong>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</strong></p>
<h4 id="3、hash-类型数据的基本操作"><a href="#3、hash-类型数据的基本操作" class="headerlink" title="3、hash 类型数据的基本操作"></a>3、hash 类型数据的基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置存储的hashMap 的key 和 value</span></span><br><span class="line">hset key field value</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取存储的 hashMap的key——field</span></span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取存储的hashMap的所有key</span></span><br><span class="line">hgetall key</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加/修改多个数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2 …</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取多个数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2 …</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取哈希表中字段的数量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取哈希表中是否存在指定的字段</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取哈希表中所有的字段名或字段值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line"></span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置指定字段的数值数据增加指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整型</span></span><br><span class="line">hincrby key field increment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点</span></span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果key存在就不改变，如果key不存在就设置filed 与 value</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、hash-类型数据操作的注意事项"><a href="#4、hash-类型数据操作的注意事项" class="headerlink" title="4、hash 类型数据操作的注意事项"></a>4、hash 类型数据操作的注意事项</h4><ul>
<li>hash类型下的<strong>value只能存储==字符串==**，</strong>不允许存储其他数据类型，不存在嵌套现象<strong>。</strong>如果数据未获取到，对应的值为（nil）**</li>
<li><strong>每个 hash 可以存储 2^32 - 1 个键值对</strong></li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但<strong>hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</strong></li>
<li><strong>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</strong></li>
</ul>
<h4 id="5、string存储对象（json）与hash存储对象"><a href="#5、string存储对象（json）与hash存储对象" class="headerlink" title="5、string存储对象（json）与hash存储对象"></a>5、string存储对象（json）与hash存储对象</h4><ul>
<li>string存储对象（json）<ul>
<li>讲究整体性——一次性数据以整体操作：要么一次性更新，要么一次性获取</li>
<li>讲究的是<strong>以 ==读== 为主</strong></li>
</ul>
</li>
<li>hash存储对象<ul>
<li>由于使用hash存储的话可以使用field将属性隔离开，所以hash讲究的是==更新==操作</li>
<li>hash讲究的是==群组==概念，把一系列的数据包装成一个群组，对外产生唯一一个接口——key</li>
<li>如果业务环境以更新操作或修改数量比较多的操作，推荐使用hash的方法存储对象</li>
</ul>
</li>
<li>总结：具体情况具体分析</li>
</ul>
<h4 id="6、hash-类型应用场景"><a href="#6、hash-类型应用场景" class="headerlink" title="6、hash 类型应用场景"></a>6、hash 类型应用场景</h4><ul>
<li><font color="red"><strong>Tips 4</strong> </font><ul>
<li>redis 应用于购物车数据存储设计<ul>
<li>电商网站购物车设计与实现</li>
</ul>
</li>
</ul>
</li>
<li><font color="red"><strong>Tips 5</strong> </font><ul>
<li><strong>redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</strong><ul>
<li>双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000张</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4、list"><a href="#4、list" class="headerlink" title="4、list"></a>4、list</h3><h4 id="1、list-类型"><a href="#1、list-类型" class="headerlink" title="1、list 类型"></a>1、list 类型</h4><ul>
<li>数据存储需求：存储多个数据，并<strong>对数据进入存储空间的顺序进行区分</strong></li>
<li>需要的存储结构：一个存储空间保存多个数据，且<strong>通过数据可以体现进入顺序</strong></li>
<li>list类型：保存多个数据，<strong>底层使用双向链表存储结构实现</strong></li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905013542306.png" alt="image-20210905013542306"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905013558179.png" alt="image-20210905013558179"></p>
<h4 id="2、list-的数据结构"><a href="#2、list-的数据结构" class="headerlink" title="2、list 的数据结构"></a>2、list 的数据结构</h4><p>List的数据结构为<strong>快速链表quickList</strong>。</p>
<p><strong>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表</strong>。</p>
<ul>
<li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li>
</ul>
<p><strong>当数据量比较多的时候才会改成quicklist</strong>。</p>
<p>因为<strong>普通的链表需要的附加指针空间太大，会比较浪费空间</strong>。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907224104786.png" alt="image-20210907224104786"></p>
<p><strong>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</strong></p>
<h4 id="3、list-类型数据基本操作"><a href="#3、list-类型数据基本操作" class="headerlink" title="3、list 类型数据基本操作"></a>3、list 类型数据基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从队列左边添加数据</span></span><br><span class="line">lpush key value1 [value2] ……</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列右边添加数据</span></span><br><span class="line">rpush key value1 [value2] ……</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从队列的左边获取数据，从start到stop（队列的最右边第一个数据的下标为-1）</span></span><br><span class="line"><span class="comment"># 所以取出所有数据的命令为:lrange key 0 -1</span></span><br><span class="line">lrange key start stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列的左边获取第index个数据</span></span><br><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的key个数</span></span><br><span class="line">llen key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取并移除数据（<strong>值在键在，值光键亡</strong>）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure>
</li>
<li><p>规定时间内获取并移除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在规定时间内从左/右边获取并移除数据，若以达规定时间key1没有数据，返回（nil）</span></span><br><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表中取出最后一个元素，并插入到另外一个列表的头部；</span></span><br><span class="line"><span class="comment"># 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></span><br><span class="line"><span class="comment"># source 为 想要取出数据的列表，destination 为 目标列表，timeout 为超时时间</span></span><br><span class="line">brpoplpush <span class="built_in">source</span> destination timeout</span><br></pre></td></tr></table></figure>
</li>
<li><p>从key1列表右边吐出一个值，插到key2列表左边。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush  &lt;key1&gt;&lt;key2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在value的后面插入newvalue插入值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linsert &lt;key&gt;  before &lt;value&gt;&lt;newvalue&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表key下标为index的值替换成value</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset &lt;key&gt;&lt;index&gt;&lt;value&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除指定数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、list-类型数据操作注意事项"><a href="#4、list-类型数据操作注意事项" class="headerlink" title="4、list 类型数据操作注意事项"></a>4、list 类型数据操作注意事项</h4><ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (<code>4294967295</code>)。</li>
<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li>
<li><strong>获取全部数据操作结束索引设置为-1</strong></li>
<li><strong>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</strong></li>
</ul>
<h4 id="5、list-类型应用场景"><a href="#5、list-类型应用场景" class="headerlink" title="5、list 类型应用场景"></a>5、list 类型应用场景</h4><ul>
<li><p><font color="red">**Tips 6 ** </font></p>
<ul>
<li><strong>redis 应用于具有操作先后顺序的数据控制</strong><ul>
<li>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息；如果取消点赞，移除对应好友信息</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red">**Tips 7 ** </font></p>
<ul>
<li><p><strong>redis 应用于最新消息展示</strong></p>
<ul>
<li><p>twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</p>
</li>
<li><p>新闻、资讯类网站将最新的新闻或资讯按照发生的时间顺序展示</p>
</li>
<li><p>企业运营过程中，系统将产生出大量的运营数据，保障多台服务器操作日志的统一顺序输出</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021040556.png" alt="image-20210905021040556"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5、set"><a href="#5、set" class="headerlink" title="5、set"></a>5、set</h3><h4 id="1、set-类型"><a href="#1、set-类型" class="headerlink" title="1、set 类型"></a>1、set 类型</h4><ul>
<li>新的存储需求：存储大量的数据，在查询方面提供更高的效率</li>
<li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，<strong>便于查询</strong></li>
<li>set类型：与hash存储结构完全相同，<strong>仅存储键，不存储值（nil），并且值是不允许重复的</strong>(自动排重)</li>
<li>Redis的Set是<strong>string类型的无序集合</strong>。它底层其实是<strong>一个value为null的hash表</strong>，所以添加，删除，查找的==复杂度都是O(1)。==</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021259230.png" alt="image-20210905021259230"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905021315084.png" alt="image-20210905021315084"></p>
<h4 id="2、Set-的数据结构"><a href="#2、Set-的数据结构" class="headerlink" title="2、Set 的数据结构"></a>2、Set 的数据结构</h4><p><strong>Set数据结构是dict字典，字典是用哈希表实现的。</strong></p>
<ul>
<li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。</li>
<li><strong>Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</strong></li>
</ul>
<h4 id="3、set-类型数据的基本操作"><a href="#3、set-类型数据的基本操作" class="headerlink" title="3、set 类型数据的基本操作"></a>3、set 类型数据的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取全部数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取集合数据总量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断集合中是否包含指定数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机获取集合中指定数量的数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机获取集合中的某个数据并将该数据移出集合</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个集合的交、并、差集</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集</span></span><br><span class="line">sinter key1 [key2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">sunion key1 [key2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集（注意差集的key1与key2互换的话可能导致结果不同）</span></span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个集合的交、并、差集并存储到指定集合中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集</span></span><br><span class="line">sinterstore destination key1 [key2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">sunionstore destination key1 [key2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集（注意差集的key1与key2互换的话可能导致结果不同）</span></span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定数据从原始集合中==移动==到目标集合中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove <span class="built_in">source</span> destination member</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、set-类型数据操作的注意事项"><a href="#4、set-类型数据操作的注意事项" class="headerlink" title="4、set 类型数据操作的注意事项"></a>4、set 类型数据操作的注意事项</h4><ul>
<li><strong>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</strong></li>
<li><strong>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</strong></li>
</ul>
<h4 id="5、set-类型应用场景"><a href="#5、set-类型应用场景" class="headerlink" title="5、set 类型应用场景"></a>5、set 类型应用场景</h4><ul>
<li><font color="red">**Tips 8 ** </font><ul>
<li><strong>redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</strong><ul>
<li>每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 9 ** </font><ul>
<li><strong>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</strong><ul>
<li>显示共同关注（一度）</li>
<li>显示共同好友（一度）</li>
<li>由用户A出发，获取到好友用户B的好友信息列表（一度）</li>
<li>由用户A出发，获取到好友用户B的购物清单列表（二度）</li>
<li>由用户A出发，获取到好友用户B的游戏充值列表（二度）</li>
<li>脉脉为了促进用户间的交流，保障业务成单率的提升，需要让每位用户拥有大量的好友，事实上职场新人不具有更多的职场好友，如何快速为用户积累更多的好友？</li>
<li>新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门话题，如何提高用户关注他人的总量？</li>
<li>QQ新用户入网年龄越来越低，这些用户的朋友圈交际圈非常小，往往集中在一所学校甚至一个班级中，如何帮助用户快速积累好友用户带来更多的活跃度？</li>
<li>微信公众号是微信信息流通的渠道之一，增加用户关注的公众号成为提高用户活跃度的一种方式，如何帮助用户积累更多关注的公众号？</li>
<li>美团外卖为了提升成单量，必须帮助用户挖掘美食需求，如何推荐给用户最适合自己的美食？</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 10 ** </font><ul>
<li><strong>redis应用于同类型不重复数据的合并操作</strong><ul>
<li>集团公司共具有12000名员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多种数据，每位员工具有一个或多个角色，如何快速进行业务操作的权限校验？</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 11 ** </font><ul>
<li><strong>redis 应用于同类型数据的快速去重</strong><ul>
<li>公司对旗下新的网站做推广，统计网站的PV（访问量）,UV（独立访客）,IP（独立IP）。<ul>
<li>PV：网站被访问次数，可通过刷新页面提高访问量</li>
<li>UV：网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变</li>
<li>IP：网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 12 ** </font><ul>
<li><strong>redis 应用于基于黑名单与白名单设定的服务控制</strong><ul>
<li>黑名单<ul>
<li>资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火车票、机票、酒店刷票代购软件，电商刷评论、刷好评。</li>
<li>同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。</li>
<li>ps：不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</li>
</ul>
</li>
<li>白名单<ul>
<li>对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体，依赖白名单做更为苛刻的访问验证。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6、sorted-set"><a href="#6、sorted-set" class="headerlink" title="6、sorted_set"></a>6、sorted_set</h3><h4 id="1、sorted-set-类型"><a href="#1、sorted-set-类型" class="headerlink" title="1、sorted_set 类型"></a>1、sorted_set 类型</h4><ul>
<li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</li>
<li>需要的存储结构：新的存储模型，可以保存可排序的数据</li>
<li>sorted_set类型：在set的存储结构基础上添加可排序字段</li>
<li><strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905023025448.png" alt="image-20210905023025448"></p>
<h4 id="2、Sorted-set-的数据结构"><a href="#2、Sorted-set-的数据结构" class="headerlink" title="2、Sorted_set 的数据结构"></a>2、Sorted_set 的数据结构</h4><p>Sorted_set(zset)是Redis提供的一个非常特别的数据结构：</p>
<ol>
<li>一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score；</li>
<li>另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</li>
</ol>
<p>zset底层使用了两个数据结构：</p>
<ol>
<li><strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li>
<li><strong>跳跃表</strong>，跳跃表的目的在于<strong>给元素value排序，根据score的范围获取元素列表</strong>。</li>
</ol>
<h5 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h5><h6 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h6><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。</p>
<p>对于有序集合的底层实现，可以用：</p>
<ul>
<li><strong>数组</strong><ul>
<li>数组不便元素的插入、删除</li>
</ul>
</li>
<li><strong>平衡树</strong><ul>
<li>平衡树或红黑树虽然效率高但结构复杂</li>
</ul>
</li>
<li><strong>链表</strong><ul>
<li>链表查询需要遍历所有效率低。</li>
</ul>
</li>
</ul>
<p><strong>Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</strong></p>
<h6 id="2、实例"><a href="#2、实例" class="headerlink" title="2、实例"></a>2、实例</h6><p>对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1）  有序链表</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907225230388.png" alt="image-20210907225230388"></p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。<strong>共需要6次比较</strong>。</p>
<p>（2）  跳跃表</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907225311811.png" alt="image-20210907225311811"></p>
<ol>
<li>从第2层开始，1节点比51节点小，向后比较。</li>
<li>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</li>
<li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li>
<li>在第0层，51节点为要查找的节点，节点被找到，<strong>共查找4次</strong>。</li>
</ol>
<p> <strong>从此可以看出跳跃表比有序链表效率要高</strong></p>
<h4 id="3、sorted-set-类型数据的基本操作"><a href="#3、sorted-set-类型数据的基本操作" class="headerlink" title="3、sorted_set 类型数据的基本操作"></a>3、sorted_set 类型数据的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取全部数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从start到stop顺序获取key当中的数据</span></span><br><span class="line"><span class="comment"># WITHSCORES 获取key的member的同时获取member的scores</span></span><br><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从start到stop逆序获取key当中的数据</span></span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>按条件获取数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># min与max用于限定搜索查询的条件</span></span><br><span class="line"><span class="comment"># LIMIT 与mysql的LIMIT用法一样，用来限制数据的数量</span></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line"></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件删除数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br><span class="line"></span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取集合数据总量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line"></span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>min与max用于限定搜索查询的条件</li>
<li>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
</li>
<li><p>集合交、并操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求最大最小值</span></span><br><span class="line"><span class="comment"># zinterstore sss 3 s1 s2 s3 agggregate max/min</span></span><br><span class="line">zinterstore destination numkeys key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求公共部分的和</span></span><br><span class="line"><span class="comment"># zinterstore ss 3 s1 s2 s3</span></span><br><span class="line">zunionstore destination numkeys key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据对应的索引（排名）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line"></span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure>
</li>
<li><p>score值获取与修改</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line"></span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前系统时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># score 秒</span></span><br><span class="line"><span class="comment"># member 毫秒</span></span><br><span class="line">time</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、sorted-set-类型数据操作的注意事项"><a href="#4、sorted-set-类型数据操作的注意事项" class="headerlink" title="4、sorted_set 类型数据操作的注意事项"></a>4、sorted_set 类型数据操作的注意事项</h4><ul>
<li>score保存的数据存储空间是64位，<strong>如果是整数范围是-9007199254740992~9007199254740992</strong></li>
<li><strong>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</strong></li>
<li>sorted_set 底层存储还是基于set结构的，因此<strong>数据不能重复</strong>，<strong>如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</strong></li>
</ul>
<h4 id="5、sorted-set-类型应用场景"><a href="#5、sorted-set-类型应用场景" class="headerlink" title="5、sorted_set 类型应用场景"></a>5、sorted_set 类型应用场景</h4><ul>
<li><font color="red">**Tips 13 ** </font><ul>
<li><strong>redis 应用于计数器组合排序功能对应的排名</strong><ul>
<li>票选广东十大杰出青年，各类综艺选秀海选投票</li>
<li>各类资源网站TOP10（电影，歌曲，文档，电商，游戏等）</li>
<li>聊天室活跃度统计</li>
<li>游戏好友亲密度</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 14 ** </font><ul>
<li><strong>redis 应用于定时任务执行顺序管理或任务过期管理</strong><ul>
<li>基础服务+增值服务类网站会设定各位会员的试用，让用户充分体验会员优势。例如观影试用VIP、游戏VIP体验、云盘下载体验VIP、数据查看体验VIP。当VIP体验到期后，如果有效管理此类信息。即便对于正式VIP用户也存在对应的管理方式。</li>
<li>网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 15 ** </font><ul>
<li><strong>redis 应用于即时任务/消息队列执行管理</strong><ul>
<li>任务/消息权重设定应用：<ul>
<li>当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，如何实现任务权重管理。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7、数据类型实践案例"><a href="#7、数据类型实践案例" class="headerlink" title="7、数据类型实践案例"></a>7、数据类型实践案例</h3><h4 id="1、业务场景1"><a href="#1、业务场景1" class="headerlink" title="1、业务场景1"></a>1、业务场景1</h4><p>人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905024857928.png" alt="image-20210905024857928"></p>
<h4 id="2、解决方案-1"><a href="#2、解决方案-1" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><ul>
<li>设计计数器，记录调用次数，用于控制业务执行次数。以用户id作为key，使用次数作为value</li>
<li>在调用前获取次数，判断是否超过限定次数<ul>
<li>不超过次数的情况下，每次调用计数+1</li>
<li>业务调用失败，计数-1</li>
</ul>
</li>
<li>为计数器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905024953197.png" alt="image-20210905024953197"></p>
<h4 id="3、解决方案改良"><a href="#3、解决方案改良" class="headerlink" title="3、解决方案改良"></a>3、解决方案改良</h4><ul>
<li>取消最大值的判定，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值</li>
<li>判断是否为nil，<ul>
<li>如果是，设置为Max-次数</li>
<li>如果不是，计数+1</li>
<li>业务调用失败，计数-1</li>
</ul>
</li>
<li>遇到异常即+操作超过上限，视为使用达到上限</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905025121657.png" alt="image-20210905025121657"></p>
<p><font color="red">**Tips 16 ** </font></p>
<ul>
<li><strong>redis 应用于限时按次结算的服务控制</strong></li>
</ul>
<h4 id="4、业务场景2"><a href="#4、业务场景2" class="headerlink" title="4、业务场景2"></a>4、业务场景2</h4><p>使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示？</p>
<h4 id="5、业务分析"><a href="#5、业务分析" class="headerlink" title="5、业务分析"></a>5、业务分析</h4><p> <img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905025305653.png" alt="image-20210905025305653"></p>
<h4 id="6、解决方案"><a href="#6、解决方案" class="headerlink" title="6、解决方案"></a>6、解决方案</h4><ul>
<li>依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用</li>
<li>对置顶与普通会话分别创建独立的list分别管理</li>
<li>当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）</li>
<li><strong>多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id</strong></li>
<li>推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据</li>
<li><strong>消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新</strong></li>
</ul>
<p><font color="red">**Tips 17 ** </font></p>
<p>redis 应用于基于时间顺序的数据操作，而不关注具体时间</p>
<h3 id="8、解决方案列表"><a href="#8、解决方案列表" class="headerlink" title="8、解决方案列表"></a>8、解决方案列表</h3><ol>
<li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</li>
<li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li>
<li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</li>
<li>Tips 4：redis 应用于购物车数据存储设计</li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</li>
<li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li>
<li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作</li>
<li>Tips 11：redis 应用于同类型数据的快速去重</li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理</li>
<li>Tips 15：redis 应用于及时任务/消息队列执行管理</li>
<li>Tips 16：redis 应用于按次结算的服务控制</li>
<li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ol>
<hr>
<h2 id="3、Redis-通用指令"><a href="#3、Redis-通用指令" class="headerlink" title="3、Redis 通用指令"></a>3、Redis 通用指令</h2><h3 id="1、key通用指令"><a href="#1、key通用指令" class="headerlink" title="1、key通用指令"></a>1、key通用指令</h3><h4 id="1、key-特征"><a href="#1、key-特征" class="headerlink" title="1、key 特征"></a>1、key 特征</h4><ul>
<li>key是一个字符串，通过key获取redis中保存的数据</li>
<li>key应该设计哪些操作？<ul>
<li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li>
<li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li>
<li>对于key快速查询操作，例如：按指定策略查询key</li>
<li>……</li>
</ul>
</li>
</ul>
<h4 id="2、key-基本操作"><a href="#2、key-基本操作" class="headerlink" title="2、key 基本操作"></a>2、key 基本操作</h4><ul>
<li><p>删除指定key</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据value选择非阻塞删除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink key</span><br></pre></td></tr></table></figure>

<p>仅将keys从keyspace元数据中删除，真正的删除会在后续<strong>异步</strong>操作。</p>
<ul>
<li>惰性删除lazyfree的机制，它可以将删除键或数据库的操作放在后台线程里执行，删除对象时只是进行逻辑删除，从而尽可能地避免服务器阻塞。</li>
</ul>
</li>
<li><p>获取key是否存在</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取key的类型</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、key-扩展操作"><a href="#3、key-扩展操作" class="headerlink" title="3、key 扩展操作"></a>3、key 扩展操作</h4><h5 id="1、key-扩展操作——时效性控制"><a href="#1、key-扩展操作——时效性控制" class="headerlink" title="1、key 扩展操作——时效性控制"></a>1、key 扩展操作——时效性控制</h5><ul>
<li><p>为指定key设置有效期</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置的是时间</span></span><br><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置的是时间戳</span></span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取key的有效时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time to live</span></span><br><span class="line"><span class="comment"># 不存在返回-2</span></span><br><span class="line"><span class="comment"># 存在返回-1（永久）</span></span><br><span class="line"><span class="comment"># 存在并且设置了有效期（返回有效时间）</span></span><br><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换key从时效性转换为永久性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、key-扩展操作——查询模式"><a href="#2、key-扩展操作——查询模式" class="headerlink" title="2、key 扩展操作——查询模式"></a>2、key 扩展操作——查询模式</h5><ul>
<li><p>查询key</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>查询模式规则</strong>：</p>
<ul>
<li><code>*</code>：匹配任意数量的任意符号</li>
<li><code>?</code>：配合一个任意符号</li>
<li><code>[]</code>：匹配一个指定符号</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905030341819.png" alt="image-20210905030341819"></p>
<h4 id="4、key-其他操作"><a href="#4、key-其他操作" class="headerlink" title="4、key 其他操作"></a>4、key 其他操作</h4><ul>
<li><p>为key改名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果修改的名称在redis当中存在，则会进行覆盖（将里面的内容进行覆盖）</span></span><br><span class="line"><span class="comment"># 解决方法：renamenx（如果存在则改名失败）</span></span><br><span class="line">rename key newkey</span><br><span class="line"></span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure>
</li>
<li><p>对所有key排序</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只是排序，不动元数据存储的顺序</span></span><br><span class="line">sort</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他key通用操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @generic</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2、数据库通用指令"><a href="#2、数据库通用指令" class="headerlink" title="2、数据库通用指令"></a>2、数据库通用指令</h3><h4 id="1、数据库"><a href="#1、数据库" class="headerlink" title="1、数据库"></a>1、数据库</h4><p><strong>key 的重复问题</strong>：</p>
<ul>
<li>key是由程序员定义的</li>
<li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li>
<li>数据不区分种类、类别混杂在一起，极易出现重复或冲突</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>redis为每个服务提供有16个数据库，编号从0到15<ul>
<li>默认使用的是第0号数据库</li>
</ul>
</li>
<li>每个数据库之间的数据相互独立<ul>
<li>这些数据库共用一块空间</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905030731903.png" alt="image-20210905030731903"></p>
<h4 id="2、db-基本操作"><a href="#2、db-基本操作" class="headerlink" title="2、db 基本操作"></a>2、db 基本操作</h4><ul>
<li><p>切换数据库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># PONG</span></span><br><span class="line"><span class="comment"># 进行数据回显，测试海外是否连通</span></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给redis控制台输出日志</span></span><br><span class="line"><span class="comment"># eg：</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; echo abc</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; &quot;abc&quot;</span></span><br><span class="line"><span class="built_in">echo</span> message</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据移动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure>

<ol>
<li>move相当于剪切操作</li>
<li>如果原数据库没有数据，move失败</li>
<li>如果目标数据库已存在数据，move失败</li>
<li>注意：<ul>
<li>进行move操作的是原数据库</li>
<li>数据移动的数据库是目标数据库</li>
</ul>
</li>
</ol>
</li>
<li><p>数据清除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查当前数据库有多少个key</span></span><br><span class="line">dbsize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除当前数据库的所有数据</span></span><br><span class="line">flushdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除redis当中所有数据（最强大的一个命令，慎用）</span></span><br><span class="line"><span class="comment"># 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、常用服务器命令"><a href="#3、常用服务器命令" class="headerlink" title="3、常用服务器命令"></a>3、常用服务器命令</h4><ul>
<li><p>检验连接状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果连接成功返回PONG，连接失败返回错误信息</span></span><br><span class="line">PING</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/10.png" alt="img"></p>
</li>
<li><p>验证密码是否正确</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/11.png" alt="img"></p>
</li>
<li><p>查看服务器信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO [section]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/12.png" alt="img"></p>
</li>
<li><p>查看配置信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get patten</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/8.png" alt="img"></p>
</li>
<li><p>修改当前配置信息</p>
<p>Config Set 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启，但此时配置文件中仍是修改前的配置，可搭配config rewrite命令一起使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET parameter value</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/9.png" alt="img"></p>
</li>
<li><p>重写配置文件</p>
<p>Config rewrite 命令对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写。与config set不同，set之后会将配置信息修改而无需重启服务，但此时redis.conf配置文件里记录的参数仍是set之前的值，如果将redis服务重启后会读取conf文件中的配置，这时候读到的还是set之前的配置，因此我们可以在set配置之后使用rewrite命令将当前的配置回写至配置文件内，这样就能不停机修改配置信息了，因此config set和config rewrite是配合使用的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG REWRITE</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200615143051518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZGMwNTIx,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p>重置统计信息</p>
<ul>
<li>使用Config Resetstat 命令重置 INFO 命令中的某些统计数据，包括：<ul>
<li>Keyspace hits (键空间命中次数)</li>
<li>Keyspace misses (键空间不命中次数)</li>
<li>Number of commands processed (执行命令的次数)</li>
<li>Number of connections received (连接服务器的次数)</li>
<li>Number of expired keys (过期key的数量)</li>
<li>Number of rejected connections (被拒绝的连接数量)</li>
<li>Latest fork(2) time(最后执行 fork(2) 的时间)</li>
<li>The aof_delayed_fsync counter(aof_delayed_fsync 计数器的值)</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG RESETSTAT</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前时间</p>
<p>Time 命令用于返回当前服务器时间，返回一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200615133913102.png" alt="img"></p>
</li>
<li><p>DeBug</p>
<p>debug object key获取 key 的调试信息，当key不存在时返回错误信息。</p>
<p>debug segfault 命令执行一个非法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 调试，执行后需要重启服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug object key</span><br><span class="line">debug segfault </span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/14.png" alt="img"></p>
</li>
<li><p>查看当前Redis中所有可用命令</p>
<ul>
<li><p>使用Command 命令用于返回所有的Redis命令的详细信息，以数组形式展示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用command count命令查看当前Redis中命令的数量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> count</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用command info命令查看当前Redis中指定的命令的详细信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMAND INFO command-name [command-name ...]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/15.png" alt="img"></p>
</li>
<li><p>彩蛋</p>
<p>Redis5之后新增的彩蛋，使用LOLWUT命令即可返回一副随机图像以及当前redis的版本信息。事实上LOLWUT没有任何作用，但它想告诉我们的是：”<strong>编程不仅仅是把一些代码放在一起创建有用的东西，也可以是无用但有趣的。</strong>“</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOLWUT</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/16.png" alt="img"></p>
</li>
</ul>
<hr>
<h2 id="4、Jedis"><a href="#4、Jedis" class="headerlink" title="4、Jedis"></a>4、Jedis</h2><h3 id="1、Jedis简介"><a href="#1、Jedis简介" class="headerlink" title="1、Jedis简介"></a>1、Jedis简介</h3><p>编程语言与redis：</p>
<ul>
<li>Java语言连接redis服务<ul>
<li>Jedis </li>
<li>SpringData Redis</li>
<li>Lettuce</li>
</ul>
</li>
<li>C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala</li>
<li>可视化连接redis客户端<ul>
<li>Redis Desktop Manager</li>
<li>Redis Client</li>
<li>Redis Studio</li>
</ul>
</li>
</ul>
<h3 id="2、HelloWorld（Jedis版）"><a href="#2、HelloWorld（Jedis版）" class="headerlink" title="2、HelloWorld（Jedis版）"></a>2、HelloWorld（Jedis版）</h3><h4 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h4><ul>
<li><p>jar包导入</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/redis.clients/jedis">下载地址</a></li>
</ul>
</li>
<li><p>基于maven</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2、客户端连接redis"><a href="#2、客户端连接redis" class="headerlink" title="2、客户端连接redis"></a>2、客户端连接redis</h4><ul>
<li><p><a target="_blank" rel="noopener" href="http://xetorthio.github.io/jedis/">API文档</a></p>
</li>
<li><p>连接redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作redis(jedis的API与redis的命令是一样的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">jedis.get(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭redis连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3、Jedis简易工具类开发"><a href="#3、Jedis简易工具类开发" class="headerlink" title="3、Jedis简易工具类开发"></a>3、Jedis简易工具类开发</h3><h4 id="1、基于连接池获取连接"><a href="#1、基于连接池获取连接" class="headerlink" title="1、基于连接池获取连接"></a>1、基于连接池获取连接</h4><ul>
<li>JedisPool：Jedis提供的连接池技术<ul>
<li>poolConfig：连接池配置对象</li>
<li>host：redis服务地址</li>
<li>port：redis服务端口号</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* JedisPool(org.apache.commons.pool2.impl.GenericObjectPoolConfig poolConfig, String host, int port, int timeout, String password, int database, String clientName)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="keyword">int</span> port)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="keyword">null</span>, <span class="number">0</span>, (String)<span class="keyword">null</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、封装连接参数"><a href="#2、封装连接参数" class="headerlink" title="2、封装连接参数"></a>2、封装连接参数</h4><p>jedis.properties：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jedis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">jedis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">jedis.maxTotal</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">jedis.maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>



<h4 id="3、加载配置信息"><a href="#3、加载配置信息" class="headerlink" title="3、加载配置信息"></a>3、加载配置信息</h4><p>静态代码块初始化资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//读取配置文件 获得参数值</span></span><br><span class="line">    ResourceBundle rb = ResourceBundle.getBundle(<span class="string">&quot;jedis&quot;</span>);</span><br><span class="line">    host = rb.getString(<span class="string">&quot;jedis.host&quot;</span>);</span><br><span class="line">    port = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.port&quot;</span>));</span><br><span class="line">    maxTotal = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.maxTotal&quot;</span>));</span><br><span class="line">    maxIdle = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.maxIdle&quot;</span>));</span><br><span class="line">    poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    poolConfig.setMaxTotal(maxTotal);</span><br><span class="line">    poolConfig.setMaxIdle(maxIdle);</span><br><span class="line">    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig,host,port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、加载配置信息"><a href="#4、加载配置信息" class="headerlink" title="4、加载配置信息"></a>4、加载配置信息</h4><p>对外访问接口，提供jedis连接对象，连接从连接池获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    <span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、可视化客户端"><a href="#4、可视化客户端" class="headerlink" title="4、可视化客户端"></a>4、可视化客户端</h3><p>Redis Desktop Manager：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905032008447.png" alt="image-20210905032008447"></p>
<hr>
<h1 id="2、Redis高级（Linux）"><a href="#2、Redis高级（Linux）" class="headerlink" title="2、Redis高级（Linux）"></a>2、Redis高级（Linux）</h1><h2 id="1、基于Linux环境安装Redis"><a href="#1、基于Linux环境安装Redis" class="headerlink" title="1、基于Linux环境安装Redis"></a>1、基于Linux环境安装Redis</h2><h3 id="1、Redis在Linux环境下的安装"><a href="#1、Redis在Linux环境下的安装" class="headerlink" title="1、Redis在Linux环境下的安装"></a>1、Redis在Linux环境下的安装</h3><ul>
<li><p>下载安装包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-?.?.?.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf 文件名.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install [destdir=/目录]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2、Redis基础环境设置"><a href="#2、Redis基础环境设置" class="headerlink" title="2、Redis基础环境设置"></a>2、Redis基础环境设置</h3><ul>
<li><p>创建软链接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 原始目录名 快速访问目录名</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件管理目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir conf</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">mkdir config</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据文件管理目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3、Redis服务启动"><a href="#3、Redis服务启动" class="headerlink" title="3、Redis服务启动"></a>3、Redis服务启动</h3><ul>
<li><p>默认配置启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis-server –-port 6379</span><br><span class="line">redis-server –-port 6380 ……</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定配置文件启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-server redis-6380.conf ……</span><br><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server config/redis-6380.conf ……</span><br></pre></td></tr></table></figure>
</li>
<li><p>开机自启动</p>
<ul>
<li><p>注册服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/redis.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/redis_6379.pid</span><br><span class="line">ExecStart=/opt/app/redis6/bin/redis-server /opt/app/redis6/bin/redis.conf</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用systemctl命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重载服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis 　　  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> redis</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/7.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4、Redis客户端连接"><a href="#4、Redis客户端连接" class="headerlink" title="4、Redis客户端连接"></a>4、Redis客户端连接</h3><ul>
<li><p>默认连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p>其中加上–raw可以防止中文乱码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --raw</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接指定服务器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1</span><br><span class="line">redis-cli –port 6379</span><br><span class="line">redis-cli -h 127.0.0.1 –port 6379</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5、Redis服务端配置"><a href="#5、Redis服务端配置" class="headerlink" title="5、Redis服务端配置"></a>5、Redis服务端配置</h3><ul>
<li><p>基本配置</p>
<ul>
<li><p>以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消绑定ip，监听所有IP</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把这一行注释，监听所有IP</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启保护模式</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># protected-mode yes 如果改为no，则是关闭保护模式，这种模式下不能配置系统服务，建议还是开启</span></span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>设定当前服务启动端口号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6***</span><br></pre></td></tr></table></figure>
</li>
<li><p>设定当前服务文件保存位置，包含日志文件、持久化文件（后面详细讲解）等</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir <span class="string">&quot;/自定义目录/redis/data&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设定日志文件名，便于查阅</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="string">&quot;6***.log&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2、Redis-持久化"><a href="#2、Redis-持久化" class="headerlink" title="2、Redis 持久化"></a>2、Redis 持久化</h2><h3 id="1、持久化简介"><a href="#1、持久化简介" class="headerlink" title="1、持久化简介"></a>1、持久化简介</h3><h4 id="1、什么是持久化"><a href="#1、什么是持久化" class="headerlink" title="1、什么是持久化"></a>1、什么是持久化</h4><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<h4 id="2、为什么要进行持久化"><a href="#2、为什么要进行持久化" class="headerlink" title="2、为什么要进行持久化"></a>2、为什么要进行持久化</h4><p>防止数据的意外丢失，确保数据安全性</p>
<h4 id="3、持久化过程保存什么"><a href="#3、持久化过程保存什么" class="headerlink" title="3、持久化过程保存什么"></a>3、持久化过程保存什么</h4><ul>
<li><p>将<strong>当前数据状态</strong>进行保存，<strong>快照形式</strong>，存储数据结果，存储格式简单，<strong>关注点在数据</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905174735216.png" alt="image-20210905174735216"></p>
</li>
<li><p>将<strong>数据的操作过程</strong>进行保存，<strong>日志形式</strong>，存储操作过程，存储格式复杂，<strong>关注点在数据的操作过程</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905174748200.png" alt="image-20210905174748200"></p>
</li>
</ul>
<h3 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h3><h4 id="1、RDB普通启动方式"><a href="#1、RDB普通启动方式" class="headerlink" title="1、RDB普通启动方式"></a>1、RDB普通启动方式</h4><h5 id="1、RDB启动方式-——-save指令"><a href="#1、RDB启动方式-——-save指令" class="headerlink" title="1、RDB启动方式 —— save指令"></a>1、RDB启动方式 —— save指令</h5><h6 id="1、RDB启动方式"><a href="#1、RDB启动方式" class="headerlink" title="1、RDB启动方式"></a>1、RDB启动方式</h6><p>谁，什么时间，干什么事情</p>
<p>命令执行：</p>
<ul>
<li>谁：redis操作者（用户）</li>
<li>什么时间：即时（随时进行）</li>
<li>干什么事情：保存数据</li>
</ul>
<h6 id="2、RDB启动方式-——-save指令"><a href="#2、RDB启动方式-——-save指令" class="headerlink" title="2、RDB启动方式 —— save指令"></a>2、RDB启动方式 —— save指令</h6><ul>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：手动执行一次保存操作</p>
</li>
</ul>
<h6 id="3、RDB启动方式-——-save指令相关配置"><a href="#3、RDB启动方式-——-save指令相关配置" class="headerlink" title="3、RDB启动方式 —— save指令相关配置"></a>3、RDB启动方式 —— save指令相关配置</h6><ul>
<li><pre><code class="sh">dbfilename dump.rdb
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：**设置本地数据库文件名，默认值为 dump.rdb**</span><br><span class="line">  - 经验：通常设置为&#x3D;&#x3D;dump-端口号.rdb&#x3D;&#x3D;，方便查看</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sh</span><br><span class="line">  dir</span><br></pre></td></tr></table></figure>

- 说明：**设置存储.rdb文件的路径**
- 经验：通常设置成存储空间较大的目录中，==目录名称data==</code></pre>
</li>
<li><pre><code class="sh">rdbcompression yes
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：**设置存储至本地数据库时是否压缩数据，默认为 yes**，采用 &#96;LZF 压缩&#96;</span><br><span class="line">  - 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sh</span><br><span class="line">  rdbchecksum yes</span><br></pre></td></tr></table></figure>

- 说明：**设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行**（让redis使用CRC64算法来进行数据校验）
- 经验：**通常默认为开启状态**，如果设置为no，可以节约读写性过程约10%时间消耗，但是==存储一定的数据损坏风险==
</code></pre>
</li>
</ul>
<h6 id="4、RDB启动方式-——-save指令工作原理"><a href="#4、RDB启动方式-——-save指令工作原理" class="headerlink" title="4、RDB启动方式 —— save指令工作原理"></a>4、RDB启动方式 —— save指令工作原理</h6><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175219504.png" alt="image-20210905175219504"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175236464.png" alt="image-20210905175236464"></p>
<p>注意：<strong>save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</strong>。</p>
<h5 id="2、RDB启动方式-——-bgsave指令"><a href="#2、RDB启动方式-——-bgsave指令" class="headerlink" title="2、RDB启动方式 —— bgsave指令"></a>2、RDB启动方式 —— bgsave指令</h5><h6 id="1、RDB启动方式-1"><a href="#1、RDB启动方式-1" class="headerlink" title="1、RDB启动方式"></a>1、RDB启动方式</h6><p>数据量过大，单线程执行方式造成效率过低如何处理？</p>
<p>后台执行：</p>
<ul>
<li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li>
<li>什么时间：即时（发起）；合理的时间（执行）</li>
<li>干什么事情：保存数据</li>
</ul>
<h6 id="2、RDB启动方式-——-bgsave指令-1"><a href="#2、RDB启动方式-——-bgsave指令-1" class="headerlink" title="2、RDB启动方式 —— bgsave指令"></a>2、RDB启动方式 —— bgsave指令</h6><ul>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：手动启动后台保存操作，但不是立即执行</p>
</li>
</ul>
<h6 id="3、RDB启动方式-——-bgsave指令工作原理"><a href="#3、RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="3、RDB启动方式 —— bgsave指令工作原理"></a>3、RDB启动方式 —— bgsave指令工作原理</h6><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905175450021.png" alt="image-20210905175450021"></p>
<ol>
<li>Redis会单独创建（fork）一个子进程来进行持久化；</li>
<li>Redis会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 </li>
<li>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li>
</ol>
<p>关于fork：</p>
<ol>
<li>Fork的作用是复制一个与当前进程<strong>一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<strong>作为原进程的子进程</strong></li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li>
<li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ol>
<p>注意：</p>
<ul>
<li>bgsave命令是针对save阻塞问题做的优化。</li>
<li><strong>Redis内部所有涉及到RDB操作都采用bgsave的方式</strong></li>
<li><strong>save命令可以放弃使用。</strong></li>
</ul>
<h6 id="4、RDB启动方式-——-bgsave指令相关配置"><a href="#4、RDB启动方式-——-bgsave指令相关配置" class="headerlink" title="4、RDB启动方式 —— bgsave指令相关配置"></a>4、RDB启动方式 —— bgsave指令相关配置</h6><ul>
<li><p>dbfilename dump.rdb</p>
</li>
<li><p>dir</p>
</li>
<li><p>rdbcompression yes</p>
</li>
<li><p>rdbchecksum yes</p>
</li>
<li><pre><code class="sh">stop-writes-on-bgsave-error yes
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：**后台存储过程中如果出现错误现象，是否停止保存操作**</span><br><span class="line">  - 经验：通常**默认为开启状态**</span><br><span class="line"></span><br><span class="line">##### 3、RDB启动方式 ——save配置</span><br><span class="line"></span><br><span class="line">###### 1、RDB启动方式</span><br><span class="line"></span><br><span class="line">反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？</span><br><span class="line"></span><br><span class="line">自动执行：</span><br><span class="line"></span><br><span class="line">- 谁：redis服务器发起指令（基于条件）</span><br><span class="line">- 什么时间：满足条件</span><br><span class="line">- 干什么事情：保存数据</span><br><span class="line"></span><br><span class="line">###### 2、RDB启动方式 ——save配置</span><br><span class="line"></span><br><span class="line">- 配置</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;sh</span><br><span class="line">  save second changes</span><br></pre></td></tr></table></figure>

底层使用了`bgsave`指令</code></pre>
</li>
<li><p>作用：满足限定时间范围内key的变化数量达到指定数量即进行持久化</p>
</li>
<li><p>参数</p>
<ul>
<li><code>second</code>：监控时间范围</li>
<li><code>changes</code>：监控key的变化量</li>
</ul>
</li>
<li><p>位置：在conf文件中进行配置</p>
</li>
<li><p>范例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>一般second与changes两个值的设置差别会比较大，要不就前小后大，要不就前大后小。具体看相关的业务。</li>
<li>两个值差别不大的话，设置没什么意义。</li>
</ul>
</li>
</ul>
<h6 id="3、RDB启动方式-——save配置原理"><a href="#3、RDB启动方式-——save配置原理" class="headerlink" title="3、RDB启动方式 ——save配置原理"></a>3、RDB启动方式 ——save配置原理</h6><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905180056763.png" alt="image-20210905180056763"></p>
<p>注意：</p>
<ul>
<li><strong>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</strong></li>
<li><strong>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</strong></li>
<li>save配置启动后执行的是bgsave操作</li>
</ul>
<h6 id="4、save配置相关配置"><a href="#4、save配置相关配置" class="headerlink" title="4、save配置相关配置"></a>4、save配置相关配置</h6><ul>
<li>dbfilename dump.rdb</li>
<li>dir</li>
<li>rdbcompression yes</li>
<li>rdbchecksum yes</li>
</ul>
<h4 id="2、RDB的备份"><a href="#2、RDB的备份" class="headerlink" title="2、RDB的备份"></a>2、RDB的备份</h4><ol>
<li>先通过config get dir 查询rdb文件的目录 </li>
<li>将*.rdb的文件拷贝到别的地方<ol>
<li>rdb的恢复<ol>
<li>关闭Redis</li>
<li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li>
<li>启动Redis, 备份数据会直接加载</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="3、RDB的停止"><a href="#3、RDB的停止" class="headerlink" title="3、RDB的停止"></a>3、RDB的停止</h4><p>动态停止RDB：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#save后给空值，表示禁用保存策略</span></span><br><span class="line">redis-cli config <span class="built_in">set</span> save <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="4、RDB三种启动方式对比"><a href="#4、RDB三种启动方式对比" class="headerlink" title="4、RDB三种启动方式对比"></a>4、RDB三种启动方式对比</h4><table>
<thead>
<tr>
<th>方式</th>
<th>save指令</th>
<th>bgsave指令</th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<p>注：由于替换save配置启动RDB在底层也是调用了bgsave指令，所以这里不做展示。</p>
<h4 id="5、RDB特殊启动形式"><a href="#5、RDB特殊启动形式" class="headerlink" title="5、RDB特殊启动形式"></a>5、RDB特殊启动形式</h4><ul>
<li><p>全量复制</p>
<ul>
<li>在主从复制中详细讲解</li>
</ul>
</li>
<li><p>服务器运行过程中重启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure>

<p><strong>默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</strong></p>
</li>
</ul>
<h4 id="6、RDB优缺点"><a href="#6、RDB优缺点" class="headerlink" title="6、RDB优缺点"></a>6、RDB优缺点</h4><h5 id="1、RDB优点"><a href="#1、RDB优点" class="headerlink" title="1、RDB优点"></a>1、RDB优点</h5><ol>
<li>RDB是一个==紧凑压缩的二进制文件，存储效率较高==</li>
<li>RDB内部存储的是redis在==某个时间点==的数据快照，<strong>非常适合用于数据备份，全量复制等场景</strong></li>
<li>RDB==恢复数据==的速度要比AOF==快==很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，==用于灾难恢复==。</li>
</ol>
<h5 id="2、RDB缺点"><a href="#2、RDB缺点" class="headerlink" title="2、RDB缺点"></a>2、RDB缺点</h5><ol>
<li>RDB方式无论是执行指令还是利用配置，==无法做到实时持久化，具有较大的可能性丢失数据==</li>
<li>bgsave指令==每次运行要执行fork操作创建子进程，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑，要牺牲掉一些性能==</li>
<li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</li>
<li>Redis的==众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象==</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会<strong>丢失最后一次快照后的所有修改。</strong></li>
</ol>
<p>关于第四缺点的相关说明：</p>
<ul>
<li>redis2.0的RDB文件不能恢复成redis4.0的数据</li>
</ul>
<p>一个解决方法：（不得已的方法）</p>
<ol>
<li>先将redis2.0的RDB文件恢复成redis2.0的数据；</li>
<li>在将数据存储到数据库当中；</li>
<li>最后将数据库作为数据源将数据恢复成redis4.0的数据，并生成redis4.0的RDB文件</li>
</ol>
<h3 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h3><h4 id="1、RDB存储的弊端"><a href="#1、RDB存储的弊端" class="headerlink" title="1、RDB存储的弊端"></a>1、RDB存储的弊端</h4><ul>
<li><strong>存储数据量较大，效率较低</strong><ul>
<li>基于快照思想，每次读写都是全部数据，<strong>当数据量巨大时，效率非常低</strong></li>
</ul>
</li>
<li><strong>大数据量下的IO性能较低</strong></li>
<li><strong>基于fork创建子进程，内存产生额外消耗</strong></li>
<li><strong>宕机带来的数据丢失风险</strong></li>
</ul>
<p>解决思路：</p>
<ul>
<li>不写全数据，<strong>仅记录部分数据</strong></li>
<li>降低区分数据是否改变的难度，<strong>改记录数据为记录操作过程</strong></li>
<li><strong>对所有操作均进行记录</strong>，排除丢失数据的风险</li>
</ul>
<h4 id="2、AOF概念"><a href="#2、AOF概念" class="headerlink" title="2、AOF概念"></a>2、AOF概念</h4><ul>
<li>AOF(append only file)持久化：<ul>
<li>以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。</li>
<li><strong>与RDB相比可以简单描述为改记录数据为记录数据产生的过程</strong></li>
</ul>
</li>
<li>AOF的主要作用是<strong>解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</strong></li>
</ul>
<h4 id="3、AOF写数据过程"><a href="#3、AOF写数据过程" class="headerlink" title="3、AOF写数据过程"></a>3、AOF写数据过程</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905181851353.png" alt="image-20210905181851353"></p>
<ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内；</li>
<li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ol>
<h4 id="4、AOF写数据三种策略-appendfsync"><a href="#4、AOF写数据三种策略-appendfsync" class="headerlink" title="4、AOF写数据三种策略(appendfsync)"></a>4、AOF写数据三种策略(appendfsync)</h4><ul>
<li>always(每次）：<ul>
<li>每次写入操作均同步到AOF文件中，==数据零误差，性能较低==，<strong>不建议使用</strong>。</li>
</ul>
</li>
<li>everysec（每秒）：<ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，==数据准确性较高，性能较高==，<strong>建议使用，也是默认配置</strong></li>
<li>在系统突然==宕机的情况下丢失1秒内的数据==</li>
</ul>
</li>
<li>no（系统控制）：<ul>
<li>由操作系统控制每次同步到AOF文件的周期，==整体过程不可控==</li>
</ul>
</li>
</ul>
<h4 id="5、AOF功能开启"><a href="#5、AOF功能开启" class="headerlink" title="5、AOF功能开启"></a>5、AOF功能开启</h4><ul>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：<strong>是否开启AOF持久化功能，默认为不开启状态</strong></p>
</li>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：<strong>AOF写数据策略</strong></p>
</li>
</ul>
<h4 id="6、AOF相关配置"><a href="#6、AOF相关配置" class="headerlink" title="6、AOF相关配置"></a>6、AOF相关配置</h4><ul>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：</p>
<ul>
<li><strong>AOF持久化文件名，默认文件名为<code>appendonly.aof</code></strong></li>
<li>**建议配置为<code>appendonly-端口号.aof</code>**，方便查看</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：<strong>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</strong></p>
</li>
</ul>
<h4 id="7、AOF写数据遇到的问题"><a href="#7、AOF写数据遇到的问题" class="headerlink" title="7、AOF写数据遇到的问题"></a>7、AOF写数据遇到的问题</h4><p>如果连续执行如下指令该如何处理？</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905183132934.png" alt="image-20210905183132934"></p>
<h4 id="8、AOF重写"><a href="#8、AOF重写" class="headerlink" title="8、AOF重写"></a>8、AOF重写</h4><ul>
<li><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。</p>
</li>
<li><p>AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。</p>
</li>
<li><p>简单说就是将<strong>对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录</strong>。</p>
</li>
</ul>
<h4 id="9、AOF重写作用"><a href="#9、AOF重写作用" class="headerlink" title="9、AOF重写作用"></a>9、AOF重写作用</h4><ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<h4 id="10、AOF重写规则"><a href="#10、AOF重写规则" class="headerlink" title="10、AOF重写规则"></a>10、AOF重写规则</h4><ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令<ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。</li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，<strong>每条指令最多写入64个元素</strong></li>
</ul>
</li>
</ul>
<h4 id="11、AOF重写方式"><a href="#11、AOF重写方式" class="headerlink" title="11、AOF重写方式"></a>11、AOF重写方式</h4><ul>
<li><p>手动重写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动重写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="12、AOF手动重写-——-bgrewriteaof指令工作原理"><a href="#12、AOF手动重写-——-bgrewriteaof指令工作原理" class="headerlink" title="12、AOF手动重写 —— bgrewriteaof指令工作原理"></a>12、AOF手动重写 —— bgrewriteaof指令工作原理</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905183605904.png" alt="image-20210905183605904"></p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，<strong>redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no-appendfsync-on-rewrite=yes</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 no-appendfsync-on-rewrite=yes，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</li>
<li>如果 no-appendfsync-on-rewrite=no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</li>
</ul>
<h4 id="13、AOF自动重写方式"><a href="#13、AOF自动重写方式" class="headerlink" title="13、AOF自动重写方式"></a>13、AOF自动重写方式</h4><ul>
<li><p>自动重写触发条件设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置重写的基准值，最小文件64MB。达到这个值开始重写。</span></span><br><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</span></span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动重写触发条件</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905184840300.png" alt="image-20210905184840300"></p>
</li>
<li><p>列出当前redis的所有的运行属性值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>AOF什么时候会自动重写？</p>
<ul>
<li>Redis会记录上次重写时的AOF大小，<strong>默认配置是当AOF文件大小是上次rewrite后大小的一倍</strong>且<strong>文件大于64M</strong>时触发</li>
<li>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</li>
</ul>
<p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p>
<p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size，如果Redis的AOF当前大小 &gt;=  base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</p>
<h4 id="14、AOF工作流程"><a href="#14、AOF工作流程" class="headerlink" title="14、AOF工作流程"></a>14、AOF工作流程</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905184924236-16308389669061.png" alt="image-20210905184924236"></p>
<h4 id="15、AOF重写流程"><a href="#15、AOF重写流程" class="headerlink" title="15、AOF重写流程"></a>15、AOF重写流程</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905185022041.png" alt="image-20210905185022041"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905185033618.png" alt="image-20210905185033618"></p>
<ol>
<li>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li>
<li>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</li>
<li>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</li>
<li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。</li>
<li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li>
<li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li>
</ol>
<h4 id="16、系统调用write和fsync说明"><a href="#16、系统调用write和fsync说明" class="headerlink" title="16、系统调用write和fsync说明"></a>16、系统调用write和fsync说明</h4><p>AOF缓冲区同步文件策略，由参数appendfsync控制</p>
<p>系统调用write和fsync说明：</p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。<ul>
<li>write操作在写入系统缓冲区后直接返回。</li>
<li>同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。</li>
<li>同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li>
</ul>
</li>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。 </li>
</ul>
<p>除了write、fsync、Linx还提供了sync、fdatasync操作，具体参见API说明。</p>
<h4 id="17、AOF的优缺点"><a href="#17、AOF的优缺点" class="headerlink" title="17、AOF的优缺点"></a>17、AOF的优缺点</h4><h5 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h5><ul>
<li>备份机制更稳健，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<h5 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h5><ul>
<li>比起RDB占用更多的磁盘空间。</li>
<li>恢复备份速度要慢。</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>存在个别Bug，造成恢复不能。</li>
</ul>
<h3 id="4、RDB与AOF区别"><a href="#4、RDB与AOF区别" class="headerlink" title="4、RDB与AOF区别"></a>4、RDB与AOF区别</h3><h4 id="1、RDB-VS-AOF"><a href="#1、RDB-VS-AOF" class="headerlink" title="1、RDB VS AOF"></a>1、RDB VS AOF</h4><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用存储空间</td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h4 id="2、RDB与AOF的选择之惑"><a href="#2、RDB与AOF的选择之惑" class="headerlink" title="2、RDB与AOF的选择之惑"></a>2、RDB与AOF的选择之惑</h4><ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li>
</ul>
</li>
</ul>
<p>官方推荐两个都启用。</p>
<ul>
<li>如果对数据不敏感，可以选单独用RDB。</li>
<li>不建议单独用 AOF，因为可能会出现Bug。</li>
<li>如果只是做纯内存缓存，可以都不用。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908114833273.png" alt="image-20210908114833273"></p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。</li>
<li>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ <ul>
<li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li>
<li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</li>
<li>代价：<ol>
<li>一是带来了持续的IO</li>
<li>二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li>
</ol>
</li>
<li>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</li>
<li>默认超过原大小100%大小时重写可以改到适当的数值。</li>
</ul>
</li>
</ul>
<h3 id="5、AOF-RDB混合-推荐"><a href="#5、AOF-RDB混合-推荐" class="headerlink" title="5、AOF+RDB混合[推荐]"></a>5、AOF+RDB混合[推荐]</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>看了上面的RDB和AOF的介绍后，我们可以发现：</p>
<ul>
<li>使用RDB持久化会有数据丢失的风险，但是恢复速度快，</li>
<li>而使用AOF持久化可以保证数据完整性，但恢复数据的时候会很慢。</li>
</ul>
<p>于是从Redis4之后新增了混合AOF和RDB的模式：</p>
<ol>
<li>先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，</li>
<li>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。</li>
<li>这样的话，重启服务的时候会从RDB何AOF两部分恢复数据，即保证了数据完整性，又提高了恢复的性能。</li>
</ol>
<p>开启混合模式后：</p>
<ul>
<li>每当bgrewriteaof命令之后会在AOF文件中以RDB格式写入当前最新的数据，之后的新的写操作继续以AOF的追加形式追加写命令。</li>
<li>当redis重启的时候，加载 aof 文件进行恢复数据：先加载 rdb 的部分再加载剩余的 aof部分。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/22.png" alt="img"></p>
<h4 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h4><p>修改下面的参数即可开启AOF，RDB混合持久化：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>



<h4 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h4><p>开启混合持久化模式后，重写之后的aof文件里和rdb一样存储二进制的 快照数据，继续往redis中进行写操作，后续操作在aof中仍然是以命令的方式追加。</p>
<p>因此重写后aof文件由两部分组成：</p>
<ul>
<li>一部分是类似rdb的二进制快照</li>
<li>另一部分是追加的命令文本：</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/23.png" alt="img"></p>
<h3 id="6、持久化应用场景"><a href="#6、持久化应用场景" class="headerlink" title="6、持久化应用场景"></a>6、持久化应用场景</h3><ul>
<li><del>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</del></li>
<li><del>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</del></li>
<li><del>Tips 4：redis 应用于购物车数据存储设计</del></li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li><del>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</del></li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li><del>Tips 15：redis 应用于即时任务/消息队列执行管理</del></li>
<li><del>Tips 16：redis 应用于按次结算的服务控制</del></li>
</ul>
<hr>
<h2 id="3、Redis-事务"><a href="#3、Redis-事务" class="headerlink" title="3、Redis 事务"></a>3、Redis 事务</h2><h3 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h3><h4 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务"></a>1、什么是事务</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908022740502.png" alt="image-20210908022740502"></p>
<p><strong>Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队</strong></p>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905203742252.png" alt="image-20210905203742252"></p>
<h3 id="2、事务基本操作"><a href="#2、事务基本操作" class="headerlink" title="2、事务基本操作"></a>2、事务基本操作</h3><h4 id="1、事务的边界"><a href="#1、事务的边界" class="headerlink" title="1、事务的边界"></a>1、事务的边界</h4><p>redis的事务发生在 <code>multi</code> 与 <code>exec</code>之间，能保证一系列预定义命令一次性按照添加顺序依次执行，中间不会被打断或者干扰。在执行事务当中出现错误，可以使用discard取消事务。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908023051641.png" alt="image-20210908023051641"></p>
<h4 id="2、事务的基本操作"><a href="#2、事务的基本操作" class="headerlink" title="2、事务的基本操作"></a>2、事务的基本操作</h4><ul>
<li><p>开启事务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p>
</li>
<li><p>执行事务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</p>
</li>
</ul>
<p>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p>
<p><strong>事务定义过程中发现出了问题，怎么办？</strong></p>
<ul>
<li><p>取消事务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：终止当前事务的定义，发生在multi之后，exec之前</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905204241205.png" alt="image-20210905204241205"></p>
</li>
</ul>
<h4 id="3、事务的工作流程"><a href="#3、事务的工作流程" class="headerlink" title="3、事务的工作流程"></a>3、事务的工作流程</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905204405680.png" alt="image-20210905204405680"></p>
<h4 id="4、事务的注意事项"><a href="#4、事务的注意事项" class="headerlink" title="4、事务的注意事项"></a>4、事务的注意事项</h4><h5 id="1、定义事务的过程中，命令格式输入错误怎么办？"><a href="#1、定义事务的过程中，命令格式输入错误怎么办？" class="headerlink" title="1、定义事务的过程中，命令格式输入错误怎么办？"></a>1、定义事务的过程中，命令格式输入错误怎么办？</h5><ul>
<li>语法错误<ul>
<li>指命令书写格式有误</li>
</ul>
</li>
<li>处理结果<ul>
<li>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li>
</ul>
</li>
</ul>
<h5 id="2、定义事务的过程中，命令执行出现错误怎么办？"><a href="#2、定义事务的过程中，命令执行出现错误怎么办？" class="headerlink" title="2、定义事务的过程中，命令执行出现错误怎么办？"></a>2、定义事务的过程中，命令执行出现错误怎么办？</h5><ul>
<li>运行错误<ul>
<li>指命令格式正确，但是无法正确的执行。例如对list进行incr操作</li>
</ul>
</li>
<li>处理结果<ul>
<li>能够正确运行的命令会执行，运行错误的命令不会被执行</li>
</ul>
</li>
</ul>
<p><strong>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</strong></p>
<h5 id="3、手动进行事务回滚"><a href="#3、手动进行事务回滚" class="headerlink" title="3、手动进行事务回滚"></a>3、手动进行事务回滚</h5><ul>
<li>记录操作过程中被影响的数据之前的状态<ul>
<li>单数据：string</li>
<li>多数据：hash、list、set、zset</li>
</ul>
</li>
<li>设置指令恢复所有的被修改的项<ul>
<li>单数据：直接set（注意周边属性，例如时效）</li>
<li>多数据：修改对应值或整体克隆复制</li>
</ul>
</li>
</ul>
<p>由于redis的事务没有自动进行回滚的功能，需要程序员进行手动的回滚，需要程序员自己记录事务执行前变量的值，非常的不方便。因此，redis的事务控制很少使用。</p>
<h4 id="5、Redis-事务三特性"><a href="#5、Redis-事务三特性" class="headerlink" title="5、Redis 事务三特性"></a>5、Redis 事务三特性</h4><ul>
<li><strong>单独的隔离操作</strong><ul>
<li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </li>
</ul>
</li>
<li><strong>没有隔离级别的概念</strong> <ul>
<li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li>
</ul>
</li>
<li><strong>不保证原子性</strong> <ul>
<li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </li>
</ul>
</li>
</ul>
<h3 id="3、锁"><a href="#3、锁" class="headerlink" title="3、锁"></a>3、锁</h3><h4 id="1、基于特定条件的事务执行——锁"><a href="#1、基于特定条件的事务执行——锁" class="headerlink" title="1、基于特定条件的事务执行——锁"></a>1、基于特定条件的事务执行——锁</h4><p>Redis是的锁基于乐观锁的，<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<code>check-and-set机制</code>实现事务的</p>
<ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>不能在事务当中进行watch操作，即在mutil当中使用，会报错。</strong></p>
</li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 setnx 设置一个公共锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock-key value</span><br></pre></td></tr></table></figure>

<p>利用setnx命令的返回值特征，<strong>有值则返回设置失败，无值则返回设置成功</strong></p>
<ul>
<li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li>
<li>对于返回设置失败的，不具有控制权，排队或等待 操作完毕通过del操作释放锁</li>
</ul>
<p>注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p>
</li>
<li><p>使用 expire 为锁key添加时间限定，到时不释放，放弃锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure>

<p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li>
<li>锁时间设定推荐：最大耗时 * 120% + 平均网络延迟 * 110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li>
</ul>
</li>
</ul>
<h4 id="2、锁的应用场景"><a href="#2、锁的应用场景" class="headerlink" title="2、锁的应用场景"></a>2、锁的应用场景</h4><ul>
<li><font color="red">**Tips 18 ** </font><ul>
<li><strong>redis 应用基于状态控制的批量任务执行</strong><ul>
<li>天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？</li>
</ul>
</li>
</ul>
</li>
<li><font color="red">**Tips 19 ** </font><ul>
<li><strong>redis 应用基于分布式锁对应的场景控制</strong><ul>
<li>天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4、redssion"><a href="#4、redssion" class="headerlink" title="4、redssion"></a>4、redssion</h3><p>众所周知，Redis 其实并没有对 Java 提供原生支持。作为 Java 开发人员，我们若想在程序中集成 Redis，必须使用 Redis 的第三方库。而 Redisson 就是用于在 Java 程序中操作 Redis 的库，它使得我们可以在程序中轻松地使用 Redis。Redisson 在 <code>java.util</code> 中常用接口的基础上，为我们提供了一系列具有分布式特性的工具类。</p>
<h4 id="1、如何安装-Redisson"><a href="#1、如何安装-Redisson" class="headerlink" title="1、如何安装 Redisson"></a>1、如何安装 Redisson</h4><p>安装 Redisson 最便捷的方法是使用 Maven</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以通过搜索 Maven 中央仓库 <a href="https://link.juejin.cn/?target=https://mvnrepository.com/artifact/org.redisson/redisson">mvnrepository</a> 来找到 Redisson 的各种版本。</p>
<h4 id="2、如何编译运行-Redisson"><a href="#2、如何编译运行-Redisson" class="headerlink" title="2、如何编译运行 Redisson"></a>2、如何编译运行 Redisson</h4><p>安装 Redisson 后，只需使用 Java 编译器即可编译和运行 Redisson 代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac RedissonExamples.java</span><br><span class="line"></span><br><span class="line">java RedissonExamples</span><br></pre></td></tr></table></figure>



<h4 id="3、对Redisson-API的相关使用"><a href="#3、对Redisson-API的相关使用" class="headerlink" title="3、对Redisson API的相关使用"></a>3、对Redisson API的相关使用</h4><p>对Redisson API的相关使用，可以参考以下博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903962521387015">厉害了，原来 Redisson 这么好用！</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/11273205.html">Redisson基本用法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/075aa887a4d0">Java中间件 - Redisson(上) - 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ac5ee0b3d561">Java中间件 - Redisson(中) - SpringBoot整合Redisson</a></li>
</ul>
<hr>
<h2 id="4、Redis-删除策略"><a href="#4、Redis-删除策略" class="headerlink" title="4、Redis 删除策略"></a>4、Redis 删除策略</h2><h3 id="1、过期数据"><a href="#1、过期数据" class="headerlink" title="1、过期数据"></a>1、过期数据</h3><h4 id="1、Redis中的数据特征"><a href="#1、Redis中的数据特征" class="headerlink" title="1、Redis中的数据特征"></a>1、Redis中的数据特征</h4><p>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态：</p>
<ul>
<li>XX ：具有时效性的数据</li>
<li>-1 ：永久有效的数据</li>
<li>-2 ：已经过期的数据 或 被删除的数据 或 未定义的数据</li>
</ul>
<p>过期的数据真的删除了吗？</p>
<p>并不是，过期数据的删除其实主要是由redis的删除策略进行控制。但一般来说，过期的数据并不是马上删除的，还是存放在redis的内存当中，只是根据redis的删除策略对过期的数据在不同情况下进行真正删除。</p>
<h4 id="2、数据删除策略"><a href="#2、数据删除策略" class="headerlink" title="2、数据删除策略"></a>2、数据删除策略</h4><p>redis有三种数据删除策略，分别是：</p>
<ol>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ol>
<h3 id="2、数据删除策略-1"><a href="#2、数据删除策略-1" class="headerlink" title="2、数据删除策略"></a>2、数据删除策略</h3><p>官网：<a target="_blank" rel="noopener" href="https://redis.io/commands/expire#expire-accuracy">https://redis.io/commands/expire#expire-accuracy</a> </p>
<h4 id="1、时效性数据的存储结构"><a href="#1、时效性数据的存储结构" class="headerlink" title="1、时效性数据的存储结构"></a>1、时效性数据的存储结构</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905210951460.png" alt="image-20210905210951460"></p>
<h4 id="2、数据删除策略的目标"><a href="#2、数据删除策略的目标" class="headerlink" title="2、数据删除策略的目标"></a>2、数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露。</p>
<h4 id="3、数据删除策略——定时删除"><a href="#3、数据删除策略——定时删除" class="headerlink" title="3、数据删除策略——定时删除"></a>3、数据删除策略——定时删除</h4><ul>
<li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905211328753.png" alt="image-20210905211328753"></p>
<h4 id="4、数据删除策略——惰性删除"><a href="#4、数据删除策略——惰性删除" class="headerlink" title="4、数据删除策略——惰性删除"></a>4、数据删除策略——惰性删除</h4><p>数据到达过期时间，不做处理。等下次访问该数据时</p>
<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除</li>
<li>缺点：内存压力很大，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能（拿空间换时间）</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905211533959.png" alt="image-20210905211533959"></p>
<h4 id="5、数据删除策略——定期删除"><a href="#5、数据删除策略——定期删除" class="headerlink" title="5、数据删除策略——定期删除"></a>5、数据删除策略——定期删除</h4><p>两种方案都走极端，有没有折中方案？</p>
<ul>
<li>Redis启动服务器初始化时，读取配置<code>server.hz</code>的值，<strong>默认为10</strong><ul>
<li>每秒钟执行server.hz次<strong>serverCron()</strong> –》 <strong>activeExpireCycle()</strong> – 》<strong>activeExpireCycle()</strong></li>
<li>*<em>activeExpireCycle()**对每个expires[</em>]逐一进行检测，<strong>每次执行250ms/server.hz</strong></li>
<li>对某个expires[*]检测时，随机挑选W个key检测<ul>
<li>如果key超时，删除key</li>
<li>如果一轮中删除的key的数量 &gt; W * 25%，循环该过程</li>
<li>如果一轮中删除的key的数量 ≤ W * 25%，检查下一个expires[*]，0-15循环</li>
<li>W取值 = <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>属性值</li>
</ul>
</li>
<li>参数current_db用于记录<strong>activeExpireCycle()</strong> 进入哪个expires[*] 执行</li>
<li>如果**activeExpireCycle()**执行时间到期，下次从current_db继续向下执行databasesCron</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905212056307.png" alt="image-20210905212056307"></p>
<ul>
<li><strong>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</strong></li>
<li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li>总结：周期性抽查存储空间（<strong>随机抽查，重点抽查</strong>）</li>
</ul>
<h4 id="6、删除策略比对"><a href="#6、删除策略比对" class="headerlink" title="6、删除策略比对"></a>6、删除策略比对</h4><table>
<thead>
<tr>
<th><strong>定时删除</strong></th>
<th><strong>节约内存，无占用</strong></th>
<th><strong>不分时段占用CPU资源，频度高</strong></th>
<th><strong>拿时间换空间</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>惰性删除</strong></td>
<td><strong>内存占用严重</strong></td>
<td><strong>延时执行，CPU利用率高</strong></td>
<td><strong>拿空间换时间</strong></td>
</tr>
<tr>
<td><strong>定期删除</strong></td>
<td><strong>内存定期随机清理</strong></td>
<td><strong>每秒花费固定的CPU资源维护内存</strong></td>
<td><strong>随机抽查，重点抽查</strong></td>
</tr>
</tbody></table>
<p>redis会使用的两个删除策略：</p>
<ul>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<h3 id="3、逐出算法"><a href="#3、逐出算法" class="headerlink" title="3、逐出算法"></a>3、逐出算法</h3><h4 id="1、新数据进入检测"><a href="#1、新数据进入检测" class="headerlink" title="1、新数据进入检测"></a>1、新数据进入检测</h4><p><strong>当新数据进入redis时，如果内存不足怎么办？</strong></p>
<ul>
<li><p>Redis使用内存存储数据，在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code><strong>检测内存是否充足</strong>。如果内存不满足新加入数据的最低存储要求，redis要<strong>临时删除一些数据为当前指令清理存储空间</strong>。<strong>清理数据的策略称为逐出算法</strong>。</p>
</li>
<li><p>注意：<strong>逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM <span class="built_in">command</span> not allowed when used memory &gt;<span class="string">&#x27;maxmemory&#x27;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2、影响数据逐出的相关配置"><a href="#2、影响数据逐出的相关配置" class="headerlink" title="2、影响数据逐出的相关配置"></a>2、影响数据逐出的相关配置</h4><ul>
<li><p>最大可使用内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<p><strong>占用物理内存的比例，默认值为0，表示不限制</strong>。<strong>生产环境</strong>中根据需求设定，<strong>通常设置在50%以上</strong>。</p>
</li>
<li><p>查看当前最大可使用内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br><span class="line">1) <span class="string">&quot;maxmemory&quot;</span></span><br><span class="line">2) <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>默认值为0</strong></p>
</li>
<li><p>设置当前最大可使用内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> maxmemory 1GB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br><span class="line">1) <span class="string">&quot;maxmemory&quot;</span></span><br><span class="line">2) <span class="string">&quot;1073741824&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以通过配置文件对最大可使用内存进行配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"><span class="comment"># 下面的写法均合法：</span></span><br><span class="line">maxmemory 1024000</span><br><span class="line">maxmemory 1GB</span><br><span class="line">maxmemory 1G</span><br><span class="line">maxmemory 1024KB</span><br><span class="line">maxmemory 1024K</span><br><span class="line">maxmemory 1024MB</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/82.png" alt="img"></p>
<blockquote>
<p>maxmemory参数默认值为0。因32位系统支持的最大内存为4GB，所以在32位系统上Redis的默认最大内存限制为3GB；在64位系统上默认Redis最大内存即为物理机的可用内存；</p>
</blockquote>
</li>
<li><p>每次选取待删除数据的个数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用<strong>随机获取数据的方式作为待检测删除数据</strong></p>
</li>
<li><p>删除策略</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行</span></span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> maxmemory-policy allkeys-random</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;allkeys-random&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>达到最大内存后的，对被挑选出来的数据进行删除的策略</strong></p>
</li>
</ul>
<p><strong>redis有8种删除策略</strong>：</p>
<ul>
<li><p><strong>检测易失数据</strong>（可能会过期的数据集server.db[i].expires）</p>
<ul>
<li><p><code>volatile-lru</code>：挑选<strong>最近最少使用的数据</strong>淘汰（<strong>早期redis一般的默认策略</strong>）</p>
</li>
<li><p><code>volatile-lfu</code>：挑选<strong>最近使用次数最少的数据</strong>淘汰</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905213148222.png" alt="image-20210905213148222"></p>
</li>
<li><p><code>volatile-ttl</code>：挑选<strong>将要过期的数据</strong>淘汰</p>
</li>
<li><p><code>volatile-random</code>：<strong>任意选择数据</strong>淘汰</p>
</li>
</ul>
</li>
<li><p>检测全库数据（所有数据集server.db[i].dict ）</p>
<ul>
<li>allkeys-lru：挑选最近最少使用的数据淘汰</li>
<li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>allkeys-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p>放弃数据驱逐</p>
<ul>
<li><code>no-enviction（驱逐）</code>：<strong>禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</strong>。当内存达到设置的最大值时，所有申请内存的操作都会报错(如set,lpush等)，只读操作如get命令可以正常执行</li>
</ul>
</li>
</ul>
<p>在配置启动的文件中配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>



<h4 id="3、LRU算法"><a href="#3、LRU算法" class="headerlink" title="3、LRU算法"></a>3、LRU算法</h4><h5 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>LRU（Least Recently Used）表示最近最少使用，该算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>”。</p>
<h5 id="2、底层实现"><a href="#2、底层实现" class="headerlink" title="2、底层实现"></a>2、底层实现</h5><p><strong>LRU算法的常见实现方式为链表：</strong>新数据放在链表头部 ，链表中的数据被访问就移动到链头，链表满的时候从链表尾部移出数据。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/83.png" alt="img"></p>
<p>而在Redis中使用的是近似LRU算法，为什么说是近似呢？<strong>Redis中是随机采样5个</strong>（可以修改参数<code>maxmemory-samples</code>配置）key，然后从中选择访问时间最早的key进行淘汰，因此当采样key的数量与Redis库中key的数量越接近，淘汰的规则就越接近LRU算法。但<strong>官方推荐5个就足够了，最多不超过10个，越大就越消耗CPU的资源。</strong></p>
<p>但在LRU算法下，如果一个热点数据最近很少访问，而非热点数据近期访问了，就会误把热点数据淘汰而留下了非热点数据，因此在Redis4.x中新增了LFU算法。</p>
<blockquote>
<p>在<code>LRU算法</code>下，<strong>Redis会为每个key新增一个3字节的内存空间用于存储key的访问时间</strong>；</p>
</blockquote>
<h4 id="4、LFU算法"><a href="#4、LFU算法" class="headerlink" title="4、LFU算法"></a>4、LFU算法</h4><h5 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>LFU（Least Frequently Used）表示最不经常使用，它是根据数据的历史访问频率来淘汰数据，其核心思想是“<strong>如果数据过去被访问多次，那么将来被访问的频率也更高</strong>”。</p>
<p>LFU算法反映了一个key的热度情况，不会因LRU算法的偶尔一次被访问被误认为是热点数据。</p>
<h5 id="2、底层实现-1"><a href="#2、底层实现-1" class="headerlink" title="2、底层实现"></a>2、底层实现</h5><p><strong>LFU算法的常见实现方式为链表：</strong>新数据放在链表尾部 ，链表中的数据按照被访问次数降序排列，访问次数相同的按最近访问时间降序排列，链表满的时候从链表尾部移出数据。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/84.png" alt="img">    </p>
<h4 id="5、数据逐出策略配置依据"><a href="#5、数据逐出策略配置依据" class="headerlink" title="5、数据逐出策略配置依据"></a>5、数据逐出策略配置依据</h4><p>使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905213301214.png" alt="image-20210905213301214"></p>
<hr>
<h2 id="5、Redis-核心配置"><a href="#5、Redis-核心配置" class="headerlink" title="5、Redis 核心配置"></a>5、Redis 核心配置</h2><h3 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h3><h4 id="1、服务器端设定"><a href="#1、服务器端设定" class="headerlink" title="1、服务器端设定"></a>1、服务器端设定</h4><ul>
<li><p>设置服务器以守护进程的方式运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定主机地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>没有配置bind的话，默认使用的是127.0.0.1，localhost也是可以。</p>
<p>但是一旦配置了bind，就必须使用配置的IP进行访问，localhost也不行了</p>
</li>
<li><p>设置服务器端口号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库数量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2、日志配置"><a href="#2、日志配置" class="headerlink" title="2、日志配置"></a>2、日志配置</h4><ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志记录文件名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile 端口号.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意：<strong>日志级别==开发期设置为verbose==即可，==生产环境中配置为notice==，简化日志输出量，降低写日志IO的频度</strong></p>
<h4 id="3、客户端配置"><a href="#3、客户端配置" class="headerlink" title="3、客户端配置"></a>3、客户端配置</h4><ul>
<li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0，单位是：秒/s</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、多服务器快捷配置"><a href="#4、多服务器快捷配置" class="headerlink" title="4、多服务器快捷配置"></a>4、多服务器快捷配置</h4><ul>
<li><p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /path/server-端口号.conf</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>即：如果配置文件过多，可以将一些公共部分抽取出来作为一个公共的配置文件，在其他的配置文件当中，使用以上配置将公共配置文件进行导入</p>
<hr>
<h2 id="6、高级数据类型"><a href="#6、高级数据类型" class="headerlink" title="6、高级数据类型"></a>6、高级数据类型</h2><h3 id="1、Bitmaps"><a href="#1、Bitmaps" class="headerlink" title="1、Bitmaps"></a>1、Bitmaps</h3><h4 id="1、存储需求"><a href="#1、存储需求" class="headerlink" title="1、存储需求"></a>1、存储需求</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905214141050.png" alt="image-20210905214141050"></p>
<p>计算机所能操作的最小单位是：Byte字节，1Byte = 8bit</p>
<p>而使用Bitmaps能让我们去操作bit，用于状态的判断（即：非真既假的情况）</p>
<p><strong>合理地使用操作位能够有效地提高内存使用率和开发效率</strong>。</p>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ol>
<li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是<strong>它可以对字符串的位进行操作</strong>。</li>
<li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908021224660.png" alt="image-20210908021224660"></p>
<h4 id="2、Bitmaps类型的基础操作"><a href="#2、Bitmaps类型的基础操作" class="headerlink" title="2、Bitmaps类型的基础操作"></a>2、Bitmaps类型的基础操作</h4><ul>
<li><p>获取指定key对应偏移量上的bit值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a:0110 0011 --》 getbit a 6 &lt;-&gt; 1</span></span><br><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a:0110 0011 --》 getbit a 6 0 &lt;-&gt; a:0100 0011</span></span><br><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>
</li>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a:01010011 b:11011001</span></span><br><span class="line"><span class="comment"># bitop or c a b &lt;-&gt; c:11011011</span></span><br><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>and</code>：交</li>
<li><code>or</code>：并</li>
<li><code>not</code>：非</li>
<li><code>xor</code>：异或</li>
</ul>
</li>
<li><p>统计指定key中1的数量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bitcount c &lt;-&gt; 6</span></span><br><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、Bitmaps与set对比"><a href="#3、Bitmaps与set对比" class="headerlink" title="3、Bitmaps与set对比"></a>3、Bitmaps与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<p>set和Bitmaps存储一天活跃用户对比：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个用户id占用空间</th>
<th>需要存储的用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>集合类型</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmap</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p>
<p>set和Bitmaps存储独立用户空间对比：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>一天</th>
<th>一个月</th>
<th>一年</th>
</tr>
</thead>
<tbody><tr>
<td>集合类型</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<p><strong>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个userid占用空间</th>
<th>需要存储的用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>集合类型</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h4 id="4、Bitmaps的应用场景"><a href="#4、Bitmaps的应用场景" class="headerlink" title="4、Bitmaps的应用场景"></a>4、Bitmaps的应用场景</h4><ul>
<li><font color="red">**Tips 21 ** </font><ul>
<li><strong>redis 应用于信息状态统计</strong><ul>
<li>电影网站<ul>
<li>统计每天某一部电影是否被点播</li>
<li>统计每天有多少部电影被点播</li>
<li>统计每周/月/年有多少部电影被点播</li>
<li>统计年度哪部电影没有被点播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、HyperLogLog"><a href="#2、HyperLogLog" class="headerlink" title="2、HyperLogLog"></a>2、HyperLogLog</h3><h4 id="1、基数"><a href="#1、基数" class="headerlink" title="1、基数"></a>1、基数</h4><ul>
<li><strong>基数是数据集去重后元素个数</strong></li>
<li>HyperLogLog 是用来做基数统计的，<strong>运用了LogLog的算法</strong></li>
<li>HyperLogLog 的优点是：<strong>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</strong></li>
<li>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li>
<li>但是，<strong>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</li>
<li>示例：<ul>
<li>{1, 3, 5, 7, 5, 7, 8}<ul>
<li>基数集： {1, 3, 5 ,7, 8}</li>
<li>基数：5</li>
</ul>
</li>
<li>{1, 1, 1, 1, 1, 7, 1}<ul>
<li>基数集： {1,7}</li>
<li>基数：2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2、LogLog算法（跳过）"><a href="#2、LogLog算法（跳过）" class="headerlink" title="2、LogLog算法（跳过）"></a>2、LogLog算法（跳过）</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905215436319.png" alt="image-20210905215436319"></p>
<h4 id="3、HyperLogLog类型的基本操作"><a href="#3、HyperLogLog类型的基本操作" class="headerlink" title="3、HyperLogLog类型的基本操作"></a>3、HyperLogLog类型的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4、HyperLogLog的相关说明"><a href="#4、HyperLogLog的相关说明" class="headerlink" title="4、HyperLogLog的相关说明"></a>4、HyperLogLog的相关说明</h4><ul>
<li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<h4 id="5、HyperLogLog的应用场景"><a href="#5、HyperLogLog的应用场景" class="headerlink" title="5、HyperLogLog的应用场景"></a>5、HyperLogLog的应用场景</h4><ul>
<li><font color="red">**Tips 22 ** </font><ul>
<li><strong>redis 应用于独立信息统计</strong><ul>
<li>统计独立UV<ul>
<li>原始方案：set<ul>
<li>存储每个用户的id（字符串）</li>
</ul>
</li>
<li>改进方案：Bitmaps<ul>
<li>存储每个用户状态（bit）</li>
</ul>
</li>
<li>全新的方案：Hyperloglog</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、GEO"><a href="#3、GEO" class="headerlink" title="3、GEO"></a>3、GEO</h3><h4 id="1、GEO简介"><a href="#1、GEO简介" class="headerlink" title="1、GEO简介"></a>1、GEO简介</h4><ul>
<li>Redis 3.2 中增加了对GEO类型的支持。</li>
<li>GEO，Geographic，地理信息的缩写。</li>
<li>该类型，就是元素的2维坐标，在地图上就是经纬度。</li>
<li>redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作</li>
</ul>
<p><strong>GEO用于计算两地经纬度的距离</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210905220109563.png" alt="image-20210905220109563"></p>
<h4 id="2、GEO类型的基本操作"><a href="#2、GEO类型的基本操作" class="headerlink" title="2、GEO类型的基本操作"></a>2、GEO类型的基本操作</h4><ul>
<li><p>添加坐标点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geoadd + 容器key + 经度 + 维度 + 名称</span></span><br><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取坐标点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure>

<p>它会做一些经纬度的度分秒的转换</p>
</li>
<li><p>计算坐标点距离，单位：米/m</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unit为单位，默认为米/m，可以设置成千米/km</span></span><br><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>geo计算的是水平位置的距离</strong></p>
</li>
<li><p>根据坐标求范围内的数据（不定点，如移动当中的位置）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>

<ul>
<li>[withcoord]：结果跟随坐标</li>
<li>[withdist]：结果跟随距离</li>
<li>[withhash]：结果跟坐标的hash值</li>
<li>[count count]：结果取一定的范围，从count到count</li>
</ul>
<p>另外，还能再加上两个参数：</p>
<ul>
<li>asc/desc：<strong>按照距离进行升序/降序</strong></li>
</ul>
</li>
<li><p>根据点求范围内的数据（定点）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>

<p>一些操作与上面一样</p>
</li>
<li><p>获取指定点对应的坐标hash值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、GEO的应用场景"><a href="#3、GEO的应用场景" class="headerlink" title="3、GEO的应用场景"></a>3、GEO的应用场景</h4><ul>
<li><font color="red">**Tips 23 ** </font><ul>
<li><strong>redis 应用于地理位置计算</strong><ul>
<li>火热的生活服务类软件（当中显示的距离）<ul>
<li>微信 / 陌陌</li>
<li>美团 / 饿了么</li>
<li>携程 / 马蜂窝</li>
<li>高德 / 百度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7、主从复制"><a href="#7、主从复制" class="headerlink" title="7、主从复制"></a>7、主从复制</h2><h3 id="1、主从复制简介"><a href="#1、主从复制简介" class="headerlink" title="1、主从复制简介"></a>1、主从复制简介</h3><h4 id="1、互联网“三高”架构"><a href="#1、互联网“三高”架构" class="headerlink" title="1、互联网“三高”架构"></a>1、互联网“三高”架构</h4><ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
<p>对于高可用：</p>
<p>假设在一年当中，服务器的宕机有：</p>
<ul>
<li>在一月，服务器宕机4小时27分15秒</li>
<li>在四月，服务器宕机11分36秒</li>
<li>在十月，服务器宕机2分16秒</li>
</ul>
<p>那么在这一年当中服务器的可用性为：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907010831610.png" alt="image-20210907010831610"></p>
<h4 id="2、“Redis”是否高可用"><a href="#2、“Redis”是否高可用" class="headerlink" title="2、“Redis”是否高可用"></a>2、“Redis”是否高可用</h4><p>单机redis的风险与问题：</p>
<ul>
<li>问题1：机器故障<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis.</li>
</ul>
</li>
<li>问题2：容量瓶颈<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
</li>
<li>结论： <ul>
<li>为了避免单点Redis服务器故障，<strong>准备多台服务器，互相连通</strong>。</li>
<li>将数据复制多个副本保存在不同的服务器上，<strong>连接在一起，并保证数据是同步的</strong>。</li>
<li>即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时<strong>实现数据冗余备份。</strong></li>
</ul>
</li>
</ul>
<h4 id="3、多台服务器连接方案"><a href="#3、多台服务器连接方案" class="headerlink" title="3、多台服务器连接方案"></a>3、多台服务器连接方案</h4><ul>
<li>提供数据方：master<ul>
<li>主服务器，主节点，主库</li>
<li>主客户端</li>
</ul>
</li>
<li>接收数据方：slave <ul>
<li>从服务器，从节点，从库</li>
<li>从客户端</li>
</ul>
</li>
<li>需要解决的问题： <strong>数据同步</strong></li>
<li>核心工作： <strong>master的数据复制到slave中</strong></li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011143290.png" alt="image-20210907011143290"></p>
<h4 id="4、主从复制"><a href="#4、主从复制" class="headerlink" title="4、主从复制"></a>4、主从复制</h4><p>主从复制即将master中的数据即时、有效的复制到slave中</p>
<p>特征：<strong>一个master可以拥有多个slave，一个slave只对应一个master</strong></p>
<p>职责：（读写分离）</p>
<ul>
<li>master：<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（禁止）</li>
</ul>
</li>
</ul>
<h4 id="5、高可用集群"><a href="#5、高可用集群" class="headerlink" title="5、高可用集群"></a>5、高可用集群</h4><h5 id="1、在一个slave结点宕机之后，并不影响redis可用性"><a href="#1、在一个slave结点宕机之后，并不影响redis可用性" class="headerlink" title="1、在一个slave结点宕机之后，并不影响redis可用性"></a>1、在一个slave结点宕机之后，并不影响redis可用性</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011448753.png" alt="image-20210907011448753"></p>
<h5 id="2、在一个master结点宕机之后，可以有一个slave升级为master继续使用，并不影响redis可用性"><a href="#2、在一个master结点宕机之后，可以有一个slave升级为master继续使用，并不影响redis可用性" class="headerlink" title="2、在一个master结点宕机之后，可以有一个slave升级为master继续使用，并不影响redis可用性"></a>2、在一个master结点宕机之后，可以有一个slave升级为master继续使用，并不影响redis可用性</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011537226.png" alt="image-20210907011537226"></p>
<h5 id="3、在一个master结点压力过大，可以将一部分工作交给一个slave结点去做，让这个slave作为master去管理它的从结点（master与slave只是相对来说的）"><a href="#3、在一个master结点压力过大，可以将一部分工作交给一个slave结点去做，让这个slave作为master去管理它的从结点（master与slave只是相对来说的）" class="headerlink" title="3、在一个master结点压力过大，可以将一部分工作交给一个slave结点去做，让这个slave作为master去管理它的从结点（master与slave只是相对来说的）"></a>3、在一个master结点压力过大，可以将一部分工作交给一个slave结点去做，让这个slave作为master去管理它的从结点（master与slave只是相对来说的）</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011704140.png" alt="image-20210907011704140"></p>
<h5 id="4、如果一个master来接收外界数据不太安全的话，也可以将多个master做成集群"><a href="#4、如果一个master来接收外界数据不太安全的话，也可以将多个master做成集群" class="headerlink" title="4、如果一个master来接收外界数据不太安全的话，也可以将多个master做成集群"></a>4、如果一个master来接收外界数据不太安全的话，也可以将多个master做成集群</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907011806247.png" alt="image-20210907011806247"></p>
<h4 id="6、主从复制的作用"><a href="#6、主从复制的作用" class="headerlink" title="6、主从复制的作用"></a>6、主从复制的作用</h4><ul>
<li><strong>读写分离</strong>：<strong>master写、slave读</strong>，提高服务器的读写负载能力</li>
<li><strong>负载均衡</strong>：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，<strong>通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</strong></li>
<li><strong>故障恢复</strong>：<strong>当master出现问题时，由slave提供服务，实现快速的故障恢复</strong></li>
<li><strong>数据冗余</strong>：<strong>实现数据热备份，是持久化之外的一种数据冗余方式</strong></li>
<li><strong>高可用基石</strong>：基于主从复制，<strong>构建哨兵模式与集群，实现Redis的高可用方案</strong></li>
</ul>
<h3 id="2、主从复制工作流程"><a href="#2、主从复制工作流程" class="headerlink" title="2、主从复制工作流程"></a>2、主从复制工作流程</h3><h4 id="1、总述"><a href="#1、总述" class="headerlink" title="1、总述"></a>1、总述</h4><ul>
<li>主从复制过程大体可以分为3个阶段<ol>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ol>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907012115436.png" alt="image-20210907012115436"></p>
<h4 id="2、阶段一：建立连接阶段"><a href="#2、阶段一：建立连接阶段" class="headerlink" title="2、阶段一：建立连接阶段"></a>2、阶段一：建立连接阶段</h4><ul>
<li>建立slave到master的连接，使master能够识别slave，并保存slave端口号</li>
</ul>
<h5 id="1、建立连接阶段工作流程"><a href="#1、建立连接阶段工作流程" class="headerlink" title="1、建立连接阶段工作流程"></a>1、建立连接阶段工作流程</h5><ol>
<li>步骤1：<strong>设置master的地址和端口，保存master信息</strong></li>
<li>步骤2：<strong>建立socket连接</strong></li>
<li>步骤3：<strong>发送ping命令（定时器任务）</strong></li>
<li>步骤4：<strong>身份验证</strong></li>
<li>步骤5：<strong>发送slave端口信息</strong></li>
<li>至此，主从连接成功！</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907012520884.png" alt="image-20210907012520884"></p>
<p>状态：</p>
<ul>
<li>slave：<ul>
<li>保存master的地址与端口</li>
</ul>
</li>
<li>master：<ul>
<li>保存slave的端口</li>
</ul>
</li>
<li>总体：<ul>
<li>之间创建了连接的socket</li>
</ul>
</li>
</ul>
<h5 id="2、主从连接（slave连接master）"><a href="#2、主从连接（slave连接master）" class="headerlink" title="2、主从连接（slave连接master）"></a>2、主从连接（slave连接master）</h5><ul>
<li><p>方式一：客户端发送命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：启动服务器参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：服务器配置（常用）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>slave系统信息：</p>
<ul>
<li>master_link_down_since_seconds：主从断开的持续时间（以秒为单位) .</li>
<li>masterhost</li>
<li>masterport</li>
</ul>
<p>master系统信息：</p>
<ul>
<li>slave_listening_port(多个)</li>
</ul>
<h5 id="3、主从断开连接"><a href="#3、主从断开连接" class="headerlink" title="3、主从断开连接"></a>3、主从断开连接</h5><ul>
<li><p>客户端发送命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
<h5 id="4、授权访问"><a href="#4、授权访问" class="headerlink" title="4、授权访问"></a>4、授权访问</h5><ul>
<li><p>master客户端发送命令设置密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>master配置文件设置密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass &lt;password&gt;</span><br><span class="line"></span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave客户端发送命令设置密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &lt;password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave配置文件设置密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave启动服务器设置密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>由于redis在主从进行数据交流的是在内网上进行的，所以一般不设置密码也没有关系。</p>
<h4 id="2、阶段二：数据同步阶段工作流程"><a href="#2、阶段二：数据同步阶段工作流程" class="headerlink" title="2、阶段二：数据同步阶段工作流程"></a>2、阶段二：数据同步阶段工作流程</h4><ul>
<li>在slave初次连接master后，<strong>复制master中的所有数据到slave</strong></li>
<li><strong>将slave的数据库状态更新成master当前的数据库状态</strong></li>
</ul>
<h5 id="1、数据同步阶段工作流程"><a href="#1、数据同步阶段工作流程" class="headerlink" title="1、数据同步阶段工作流程"></a>1、数据同步阶段工作流程</h5><ol>
<li>步骤1：<strong>请求同步数据</strong></li>
<li>步骤2：<strong>创建<code>RDB同步</code>数据</strong>（全量复制）</li>
<li>步骤3：<strong>恢复RDB同步数据</strong></li>
<li>步骤4：<strong>请求<code>部分同步</code>数据</strong>（部分复制）(AOF同步)</li>
<li>步骤5：<strong>恢复部分同步数据</strong></li>
<li>至此，数据同步工作完成！</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907013653595.png" alt="image-20210907013653595"></p>
<p>状态： </p>
<ul>
<li>slave： 具有master端全部数据，包含RDB过程接收的数据</li>
<li>master： 保存slave当前数据同步的位置</li>
<li>总体： 完成了数据克隆</li>
</ul>
<h5 id="2、数据同步阶段master说明"><a href="#2、数据同步阶段master说明" class="headerlink" title="2、数据同步阶段master说明"></a>2、数据同步阶段master说明</h5><ol>
<li><p><strong>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</strong></p>
<ul>
<li>可以选择在半夜的3、4点钟进行数据同步</li>
<li>注意：这是全量复制的时候，也就是你新增从属服务器要同步的时候，一般之后的实时同步都是部分复制  量很少的，速度很快。</li>
</ul>
</li>
<li><p><strong>复制缓冲区大小设定不合理，会导致数据溢出</strong>。如<strong>进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907014215104.png" alt="image-20210907014215104"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure>

<p>通过设置复制缓冲区大小就能解决这个问题</p>
</li>
<li><p><strong>master单机内存占用主机内存的比例不应过大，建议使用<code>50%-70%</code>的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</strong></p>
</li>
</ol>
<h5 id="3、数据同步阶段slave说明"><a href="#3、数据同步阶段slave说明" class="headerlink" title="3、数据同步阶段slave说明"></a>3、数据同步阶段slave说明</h5><ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启只读服务应该是这个指令：</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当主服务器挂掉时是否提供过期数据</span></span><br><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p><strong>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</strong></p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。</p>
<ul>
<li>注意使用树状结构时，<strong>由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</strong></li>
</ul>
</li>
</ol>
<h4 id="3、阶段三：命令传播阶段"><a href="#3、阶段三：命令传播阶段" class="headerlink" title="3、阶段三：命令传播阶段"></a>3、阶段三：命令传播阶段</h4><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步的动作称为命令传播</strong></li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
</ul>
<h5 id="1、命令传播阶段的部分复制"><a href="#1、命令传播阶段的部分复制" class="headerlink" title="1、命令传播阶段的部分复制"></a>1、命令传播阶段的部分复制</h5><ul>
<li>命令传播阶段出现了断网现象<ul>
<li>网络闪断闪连：忽略</li>
<li>短时间网络中断：部分复制</li>
<li>长时间网络中断：全量复制</li>
</ul>
</li>
<li>部分复制的三个核心要素<ul>
<li><strong>服务器的运行 id（run id）</strong></li>
<li><strong>主服务器的复制积压缓冲区</strong></li>
<li><strong>主从服务器的复制偏移量</strong></li>
</ul>
</li>
</ul>
<h5 id="2、服务器运行ID（runid）"><a href="#2、服务器运行ID（runid）" class="headerlink" title="2、服务器运行ID（runid）"></a>2、服务器运行ID（runid）</h5><ul>
<li>概念：服务器运行ID是<strong>每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</strong></li>
<li>组成：<strong>运行id由40位字符组成，是一个随机的十六进制字符</strong><ul>
<li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
</ul>
</li>
<li>作用：运行id被用于<strong>在服务器间进行传输，识别身份</strong><ul>
<li><strong>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</strong></li>
</ul>
</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<code>info Server</code>命令，可以查看节点的runid</li>
</ul>
<h5 id="3、复制缓冲区"><a href="#3、复制缓冲区" class="headerlink" title="3、复制缓冲区"></a>3、复制缓冲区</h5><ul>
<li><p>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列，用于存储服务器执行过的命令</strong>，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015127642.png" alt="image-20210907015127642"></p>
</li>
<li><p>由来：<strong>每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</strong></p>
</li>
<li><p>作用：<strong>用于保存master收到的所有指令</strong>（<strong>仅影响数据变更的指令</strong>，例如set，select）</p>
</li>
<li><p>数据来源：<strong>当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</strong></p>
</li>
<li><p>组成：</p>
<ul>
<li>偏移量</li>
<li>字节值</li>
</ul>
</li>
<li><p>工作原理</p>
<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015201028.png" alt="image-20210907015201028"></p>
<h5 id="4、主从服务器复制偏移量（offset）"><a href="#4、主从服务器复制偏移量（offset）" class="headerlink" title="4、主从服务器复制偏移量（offset）"></a>4、主从服务器复制偏移量（offset）</h5><ul>
<li>概念：<strong>一个数字，描述复制缓冲区中的指令字节位置</strong></li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
<li>之后通过master与slave之间的offset对比，就知道当前的slave有多少数据没有复制过去，相等表示当前slave已经有master的全部数据</li>
</ul>
</li>
<li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h4 id="4、数据同步-命令传播阶段工作流程"><a href="#4、数据同步-命令传播阶段工作流程" class="headerlink" title="4、数据同步+命令传播阶段工作流程"></a>4、数据同步+命令传播阶段工作流程</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907015608735.png" alt="image-20210907015608735"></p>
<h4 id="5、心跳机制"><a href="#5、心跳机制" class="headerlink" title="5、心跳机制"></a>5、心跳机制</h4><ul>
<li>进入命令传播阶段候，master与slave间需要进行信息交换，<strong>使用心跳机制进行维护，实现双方连接保持在线</strong></li>
<li>master心跳：<ul>
<li>指令：<code>PING</code></li>
<li>周期：由<code>repl-ping-slave-period</code>决定，<strong>默认10秒</strong>（由于一个master会有多个slave，所以周期相对于slave来说会比较长）</li>
<li>作用：<strong>判断slave是否在线</strong></li>
<li>查询：<code>INFO replication</code> <strong>获取slave最后一次连接时间间隔</strong>，<strong>lag项维持在0或1视为正常</strong><ul>
<li>关于lag：如果在网络上的话，较为稳定，出现0的次数会比较少</li>
</ul>
</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li>指令：<code>REPLCONF ACK &#123;offset&#125;</code></li>
<li>周期：<strong>1秒</strong>（由于一个slave会对应一个master，所以周期会比较短）</li>
<li>作用1：<strong>汇报slave自己的复制偏移量，获取最新的数据变更指令</strong></li>
<li>作用2：<strong>判断master是否在线</strong></li>
</ul>
</li>
</ul>
<h4 id="6、心跳阶段注意事项"><a href="#6、心跳阶段注意事项" class="headerlink" title="6、心跳阶段注意事项"></a>6、心跳阶段注意事项</h4><ul>
<li><p><strong>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2</span><br><span class="line"></span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p>
</li>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认</p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p>
</li>
</ul>
<h4 id="7、主从复制工作流程（完整）"><a href="#7、主从复制工作流程（完整）" class="headerlink" title="7、主从复制工作流程（完整）"></a>7、主从复制工作流程（完整）</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907020216293.png" alt="image-20210907020216293"></p>
<h3 id="3、主从复制常见问题"><a href="#3、主从复制常见问题" class="headerlink" title="3、主从复制常见问题"></a>3、主从复制常见问题</h3><h4 id="1、频繁的全量复制（1）"><a href="#1、频繁的全量复制（1）" class="headerlink" title="1、频繁的全量复制（1）"></a>1、频繁的全量复制（1）</h4><p><strong>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</strong></p>
<p>内部优化调整方案：</p>
<ol>
<li><strong>master内部创建master_replid变量，使用runid相同的策略生成，长度<code>41</code>位，并发送给所有slave</strong></li>
<li>在master关闭时执行命令 <code>shutdown save</code>，<strong>进行RDB持久化，将runid与offset保存到RDB文件中</strong><ul>
<li>repl-id repl-offset</li>
<li>通过<code>redis-check-rdb</code>命令可以查看该信息</li>
</ul>
</li>
<li>master重启后加载RDB文件，恢复数据<ul>
<li><strong>重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</strong><ul>
<li>master_repl_id = repl</li>
<li>master_repl_offset = repl-offset</li>
</ul>
</li>
<li>通过info命令可以查看该信息</li>
</ul>
</li>
<li>作用：<strong>本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</strong></li>
</ol>
<h4 id="2、频繁的全量复制（2）"><a href="#2、频繁的全量复制（2）" class="headerlink" title="2、频繁的全量复制（2）"></a>2、频繁的全量复制（2）</h4><ul>
<li><p>问题现象：网络环境不佳，出现网络中断，slave不提供服务</p>
</li>
<li><p>问题原因：<strong>复制缓冲区过小，断网后slave的offset越界，触发全量复制</strong></p>
</li>
<li><p>最终结果：slave反复进行全量复制，对外不提供服务</p>
</li>
<li><p>解决方案：修改复制缓冲区大小</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议设置如下：</p>
<ol>
<li>测算从master到slave的重连平均时长second</li>
<li>获取master平均每秒产生写命令数据总量write_size_per_second</li>
<li><code>最优复制缓冲区空间 = 2 * second * write_size_per_second</code></li>
</ol>
</li>
</ul>
<h4 id="3、频繁的网络中断（1）"><a href="#3、频繁的网络中断（1）" class="headerlink" title="3、频繁的网络中断（1）"></a>3、频繁的网络中断（1）</h4><ul>
<li><p>问题现象：master的CPU占用过高 或 slave频繁断开连接</p>
</li>
<li><p>问题原因：</p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master</li>
<li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li>
</ul>
</li>
<li><p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
</li>
<li><p>解决方案：通过设置合理的超时时间，确认是否释放slave</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure>

<p>该参数<strong>定义了超时时间的阈值</strong>（<strong>默认60秒</strong>），超过该值，释放slave</p>
</li>
</ul>
<h4 id="4、频繁的网络中断（2）"><a href="#4、频繁的网络中断（2）" class="headerlink" title="4、频繁的网络中断（2）"></a>4、频繁的网络中断（2）</h4><ul>
<li><p>问题现象：slave与master连接断开</p>
</li>
<li><p>问题原因：</p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短</li>
<li>ping指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方案：提高ping指令发送的频度</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure>

<p><strong>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</strong></p>
</li>
</ul>
<h4 id="5、数据不一致"><a href="#5、数据不一致" class="headerlink" title="5、数据不一致"></a>5、数据不一致</h4><ul>
<li><p>问题现象：多个slave获取相同数据不同步</p>
</li>
<li><p>问题原因：网络信息不同步，数据发送有延迟</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p><strong>优化主从间的网络环境，通常放置在同一个机房部署</strong></p>
<ul>
<li>如使用阿里云等云服务器时要注意此现象，因为对于云服务器来说，在同一城市服务器不一定同一个机房</li>
</ul>
</li>
<li><p><strong>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure>

<p><strong>开启后仅响应info、slaveof等少数命令</strong>（慎用，除非对数据一致性要求很高）</p>
<p>注意：</p>
<ul>
<li><strong>开启后并不是说关掉这台服务器，而是关掉对这台服务器数据的访问，一般在==调试==当中使用</strong></li>
<li>另外，数据不同步在分布式的数据层级上面是属于非常正常的一件事，主要看你的业务需求对该数据的一致性是否有严格的要求。</li>
<li>如果对某些数据的一致性特别严格的话，建议把这一部分数据单独存放，找一台机器又读又写，数据量不是特别大。</li>
<li>对那些数据特别不是特别高的分开放。</li>
<li>这样可以在一定程度上解决问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8、哨兵模式"><a href="#8、哨兵模式" class="headerlink" title="8、哨兵模式"></a>8、哨兵模式</h2><h3 id="1、哨兵简介"><a href="#1、哨兵简介" class="headerlink" title="1、哨兵简介"></a>1、哨兵简介</h3><h4 id="1、主机“宕机”"><a href="#1、主机“宕机”" class="headerlink" title="1、主机“宕机”"></a>1、主机“宕机”</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021639156.png" alt="image-20210907021639156"></p>
<p>当主机宕机了怎么办？</p>
<ul>
<li>关闭master和所有slave</li>
<li>找一个slave作为master</li>
<li>修改其他slave的配置，连接新的主</li>
<li>启动新的master与slave</li>
<li>全量复制 * N + 部分复制 * N</li>
</ul>
<p>相关问题：</p>
<ul>
<li>关闭期间的数据服务谁来承接？</li>
<li>找一个主？怎么找法？</li>
<li>修改配置后，原始的主恢复了怎么办？</li>
</ul>
<p>问题解决：哨兵机制</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021811296.png" alt="image-20210907021811296"></p>
<h4 id="2、哨兵"><a href="#2、哨兵" class="headerlink" title="2、哨兵"></a>2、哨兵</h4><p><strong>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行==监控==，当出现故障时通过投票机制==选择==新的master并将所有slave连接到新的master。</strong></p>
<p><strong>哨兵(sentinel) 也是一个redis服务器集群</strong>，只是配置文件的与平常的redis服务器有一点不同</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907021944455.png" alt="image-20210907021944455"></p>
<h4 id="3、哨兵的作用"><a href="#3、哨兵的作用" class="headerlink" title="3、哨兵的作用"></a>3、哨兵的作用</h4><ul>
<li>监控<ul>
<li><strong>不断的检查master和slave是否正常运行</strong>。</li>
<li><strong>master存活检测</strong>、<strong>master与slave运行情况检测</strong></li>
</ul>
</li>
<li>通知（提醒）<ul>
<li>当被监控的服务器出现问题时，<strong>向其他（哨兵间，客户端）发送通知</strong>。</li>
</ul>
</li>
<li>自动故障转移<ul>
<li><strong>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</strong></li>
</ul>
</li>
<li>注意：<ul>
<li><strong>哨兵也是一台redis服务器，只是不提供数据服务</strong></li>
<li><strong>通常哨兵配置数量为==单数==</strong><ul>
<li>防止哨兵在竞选中打平的这种尴尬局面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、启用哨兵模式"><a href="#2、启用哨兵模式" class="headerlink" title="2、启用哨兵模式"></a>2、启用哨兵模式</h3><h4 id="1、配置哨兵"><a href="#1、配置哨兵" class="headerlink" title="1、配置哨兵"></a>1、配置哨兵</h4><ul>
<li><p>配置一拖二的主从结构——1个master对应2个slave</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同） 参看sentinel.conf</p>
</li>
</ul>
<ul>
<li><p>启动哨兵</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel-端口号.conf</span><br></pre></td></tr></table></figure>

<p>启动哨兵的时候，哨兵相应的配置文件也会改变。</p>
<p>添加进去哨兵的相关内容：<strong>其他哨兵的主机名、IP、端口、runid</strong>等等</p>
</li>
</ul>
<h4 id="2、配置哨兵"><a href="#2、配置哨兵" class="headerlink" title="2、配置哨兵"></a>2、配置哨兵</h4><p>查看redis原配置的一个好命令：如果你不想看配置文件当中的注释，使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sentinel.conf | grep -v <span class="string">&quot;#&quot;</span> | grep -v <span class="string">&quot;^$&quot;</span> </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>配置项</th>
<th>范例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>sentinel auth-pass &lt;自定义服务器名称&gt; &lt;password&gt;</code></td>
<td><code>sentinel auth-pass mymaster itcast</code></td>
<td><strong>连接服务器口令</strong></td>
</tr>
<tr>
<td><code>sentinel monitor &lt;自定义服务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</code></td>
<td>sentinel monitor mymaster 192.168.194.131 6381 1</td>
<td>设置哨兵监听的主服务器信息，<strong>最后的参数决定了最终参与选举的服务器数量</strong>（-1）</td>
</tr>
<tr>
<td><code>sentinel down-after-milliseconds&lt;自定义服务名称&gt;&lt;毫秒数（整数）&gt;</code></td>
<td>sentinel down-after-milliseconds mymaster 3000</td>
<td><strong>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换的启动条件之一</strong></td>
</tr>
<tr>
<td><code>sentinel parallel-syncs&lt;服务名称&gt;&lt;服务器数（整数）&gt;</code></td>
<td>sentinel parallel-syncs mymaster 1</td>
<td><strong>指定每次同时进行主从的slave数量</strong>，数值越大，要求网络资源越高，要求越小，同步时间越长</td>
</tr>
<tr>
<td><code>sentinel failover-timeout&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</code></td>
<td>sentinel failover-timeout mymaster 9000</td>
<td><strong>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</strong>。即在进行同步的时候，如果同步时间过慢也算失败</td>
</tr>
<tr>
<td><code>sentinel notification-script&lt;服务名称&gt;&lt;脚本路径&gt;</code></td>
<td></td>
<td>服务器无法正常联通时，设定的执行脚本，通常<strong>调试</strong>使用。</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>关于<code>&lt;自定义服务名称&gt;</code>，上面设定的是mymaster，设定之后在配置文件当中的各项配置中就不要修改</li>
<li>关于sentinel monitor 的最后一个参数<code>&lt;主从服务器总量&gt;</code>，上面设定这个值为x（这里的x = 1）<ul>
<li>x 的意义：如果有x个哨兵认为当前master宕机了，那么就认定该master已经宕机了——这是判断master是否宕机的一个标准</li>
<li>这个值通常设定为<code>哨兵的数量 的一半+1</code>——这里也是为什么设定哨兵的数量最好是单数（防止出现打平的局面）</li>
</ul>
</li>
</ul>
<h3 id="3、哨兵工作原理"><a href="#3、哨兵工作原理" class="headerlink" title="3、哨兵工作原理"></a>3、哨兵工作原理</h3><h4 id="1、主从切换"><a href="#1、主从切换" class="headerlink" title="1、主从切换"></a>1、主从切换</h4><ul>
<li>哨兵在进行主从切换过程中经历三个阶段：<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
<h4 id="2、阶段一：监控阶段"><a href="#2、阶段一：监控阶段" class="headerlink" title="2、阶段一：监控阶段"></a>2、阶段一：监控阶段</h4><ul>
<li>用于同步各个节点的状态信息<ul>
<li>获取各个sentinel的状态（是否在线）</li>
<li>获取master的状态<ul>
<li>master属性<ul>
<li>runid</li>
<li>role：master</li>
</ul>
</li>
<li>各个slave的详细信息</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）<ul>
<li>slave属性<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907024141976.png" alt="image-20210907024141976"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907024754653.png" alt="image-20210907024754653"></p>
<h4 id="3、阶段二：通知阶段"><a href="#3、阶段二：通知阶段" class="headerlink" title="3、阶段二：通知阶段"></a>3、阶段二：通知阶段</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025006909.png" alt="image-20210907025006909"></p>
<h4 id="4、阶段三：故障转移阶段"><a href="#4、阶段三：故障转移阶段" class="headerlink" title="4、阶段三：故障转移阶段"></a>4、阶段三：故障转移阶段</h4><h5 id="1、sentinel1发现master宕机"><a href="#1、sentinel1发现master宕机" class="headerlink" title="1、sentinel1发现master宕机"></a>1、sentinel1发现master宕机</h5><ol>
<li>先将master的状态修改为<strong>flags:SRI_S_DOWN</strong>——主观下线</li>
<li>将这个信息在sentinel集群当中传播<ul>
<li>sentinel1报出sdown，并通知其他哨兵，发送指令<code>sentinel is-master-down-by-address-port</code>给其余哨兵节点；</li>
<li>哨兵的选举机制是以各哨兵节点接收到发送<em>sentinel is-master-down-by-address-port</em>指令的哨兵id 投票，票数最高的哨兵id会成为本次故障转移工作的哨兵Leader；</li>
</ul>
</li>
<li>其他的sentinel前往围观，查看master是不是真的宕机</li>
<li>当有一半以上的sentinel认定master已经宕机，则将master的状态修改为<strong>flags:SRI_O_DOWN</strong>——客观下线</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025536975.png" alt="image-20210907025536975"></p>
<h5 id="2、选举一个sentinel去解决当前master宕机问题"><a href="#2、选举一个sentinel去解决当前master宕机问题" class="headerlink" title="2、选举一个sentinel去解决当前master宕机问题"></a>2、选举一个sentinel去解决当前master宕机问题</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907025643655.png" alt="image-20210907025643655"></p>
<p>每竞选轮回一次，竞选次数加1</p>
<h5 id="3、服务器列表中挑选备选master"><a href="#3、服务器列表中挑选备选master" class="headerlink" title="3、服务器列表中挑选备选master"></a>3、服务器列表中挑选备选master</h5><ul>
<li>在线的</li>
<li>响应快的</li>
<li>与原master断开时间短的</li>
<li>优先原则<ul>
<li>优先级，优先级越高胜出</li>
<li>offset，offset越大胜出</li>
<li>runid，runid越小胜出</li>
</ul>
</li>
<li>发送指令（ sentinel ）<ul>
<li>向新的master发送<code>slaveof no one</code></li>
<li>向其他slave发送<code>slaveof 新masterIP端口</code></li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907030402598.png" alt="image-20210907030402598"></p>
<h5 id="4、故障转移阶段总结"><a href="#4、故障转移阶段总结" class="headerlink" title="4、故障转移阶段总结"></a>4、故障转移阶段总结</h5><ul>
<li>监控<ul>
<li>同步信息</li>
</ul>
</li>
<li>通知<ul>
<li>保持联通</li>
<li>故障转移</li>
<li>发现问题</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障回复后连接</li>
</ul>
</li>
</ul>
<h3 id="4、日志查看"><a href="#4、日志查看" class="headerlink" title="4、日志查看"></a>4、日志查看</h3><p>哨兵1（sentinel1）日志：</p>
<p>master6379下线之后：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907031723596.png" alt="image-20210907031723596"></p>
<p>master6379重新上线：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032103510.png" alt="image-20210907032103510"></p>
<hr>
<h2 id="9、集群"><a href="#9、集群" class="headerlink" title="9、集群"></a>9、集群</h2><h3 id="1、集群简介"><a href="#1、集群简介" class="headerlink" title="1、集群简介"></a>1、集群简介</h3><h4 id="1、现状问题"><a href="#1、现状问题" class="headerlink" title="1、现状问题"></a>1、现状问题</h4><p>业务发展过程中遇到的峰值瓶颈：</p>
<ul>
<li>redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到10万/秒</li>
<li>内存单机容量达到256G，当前业务需求内存容量1T</li>
</ul>
<p>使用集群的方式可以快速解决上述问题</p>
<h4 id="2、集群架构"><a href="#2、集群架构" class="headerlink" title="2、集群架构"></a>2、集群架构</h4><p><strong>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其====。</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032507122.png" alt="image-20210907032507122"></p>
<h4 id="3、集群作用"><a href="#3、集群作用" class="headerlink" title="3、集群作用"></a>3、集群作用</h4><ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032548910-16309563510901.png" alt="image-20210907032548910"></p>
<h4 id="4、Redis-集群的限制"><a href="#4、Redis-集群的限制" class="headerlink" title="4、Redis 集群的限制"></a>4、Redis 集群的限制</h4><ul>
<li><strong>db库</strong>：单机的Redis默认有16个db数据库，但在集群模式下只有一个db0；</li>
<li><strong>复制结构</strong>：上面的复制结构有树状结构，但在集群模式下只允许单层复制结构；</li>
<li><strong>事务/lua脚本</strong>：<strong>仅允许操作的key在同一个节点上才可以在集群下使用事务或lua脚本</strong>；(使用Hash Tag可以解决)<ul>
<li>多键的Redis事务是不被支持的。</li>
<li>lua脚本不被支持</li>
</ul>
</li>
<li><strong>key的批量操作</strong>：如mget、mset操作，只有当操作的key都在同一个节点上才可以执行；(使用Hash Tag可以解决)<ul>
<li>多键操作是不被支持的 </li>
</ul>
</li>
<li><strong>keys/flushall</strong>：只会在该节点之上进行操作，不会对集群的其他节点进行操作；</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ul>
<h5 id="Hash-Tag"><a href="#Hash-Tag" class="headerlink" title="Hash Tag"></a>Hash Tag</h5><p>上面介绍集群限制的时候，由于key被分布在不同的节点之上，因此无法跨节点做事务或lua脚本操作，但我们可以使用hash tag方式解决。</p>
<p>hash tag：<strong>当key包含{}的时候，不会对整个key做hash，只会对{}包含的部分做hash然后分配槽slot</strong>；因此我们可以让不同的key在同一个槽内，这样就可以解决key的批量操作和事务及lua脚本的限制了；</p>
<p><strong>但由于hash tag会将不同的key分配在相同的slot中，如果使用不当，会造成数据分布不均的情况，需要注意。</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/43.png" alt="img"></p>
<h3 id="2、Redis集群结构设计"><a href="#2、Redis集群结构设计" class="headerlink" title="2、Redis集群结构设计"></a>2、Redis集群结构设计</h3><h4 id="1、数据存储设计"><a href="#1、数据存储设计" class="headerlink" title="1、数据存储设计"></a>1、数据存储设计</h4><ul>
<li><p>通过算法设计，<strong>计算出key应该保存的位置</strong></p>
</li>
<li><p>将所有的存储空间计划切割成<code>16384</code>份，每台主机保存一部分 </p>
<ul>
<li><strong>==每份代表的是一个存储空间==，不是一个key的保存空间</strong></li>
</ul>
</li>
<li><p><strong>将key按照计算出的结果放到对应的存储空间</strong></p>
</li>
<li><p>增强可扩展性</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907033026543.png" alt="image-20210907033026543"></p>
</li>
</ul>
<p>原本redis的数据存储：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032817263.png" alt="image-20210907032817263"></p>
<p>经过Redis集群结构的数据存储：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907032922698.png" alt="image-20210907032922698"></p>
<h4 id="2、集群内部通讯设计（迭代查询）"><a href="#2、集群内部通讯设计（迭代查询）" class="headerlink" title="2、集群内部通讯设计（迭代查询）"></a>2、集群内部通讯设计（迭代查询）</h4><ul>
<li>各个数据库相互通信，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体位置</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907033351047.png" alt="image-20210907033351047"></p>
<h4 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h4><h5 id="1、数据分区规则"><a href="#1、数据分区规则" class="headerlink" title="1、数据分区规则"></a>1、数据分区规则</h5><p>衡量数据分区方法的标准有两个重要因素：</p>
<ol>
<li>是否均匀分区；</li>
<li>增减节点对数据分布的影响；</li>
</ol>
<p>由于哈希算法具有随机性，可以保证数据均匀分布，因此<strong>Redis集群采用哈希分区的方式对数据进行分区</strong>，哈希分区就是对数据的特征值进行哈希，然后根据哈希值决定数据放在哪里。</p>
<h5 id="2、常见的哈希分区"><a href="#2、常见的哈希分区" class="headerlink" title="2、常见的哈希分区"></a>2、常见的哈希分区</h5><h6 id="1、哈希取余："><a href="#1、哈希取余：" class="headerlink" title="1、哈希取余："></a>1、哈希取余：</h6><p>计算key的hash值，对节点数量做取余计算，根据结果将数据映射到对应节点；但<strong>当节点增减时，系统中所有数据都需要重新计算映射关系，引发大量数据迁移</strong>；</p>
<h6 id="2、一致性哈希"><a href="#2、一致性哈希" class="headerlink" title="2、一致性哈希"></a>2、一致性哈希</h6><p>将hash值区间抽象为一个环形，节点均匀分布在该环形之上，然后根据数据的key计算hash值，在该hash值所在的圆环上的位置延<strong>顺时针</strong>行走找到的第一个节点的位置，该数据就放在该节点之上。相比于哈希取余，<strong>一致性哈希分区将增减节点的影响限制为相邻节点</strong>。</p>
<p>例：在AB节点中新增一个节点E时，因为B上的数据的key的hash值在A和B所在的hash区间之内，因此只有C上的一部分数据会迁移到B节点之上；同理如果从BCD中移除C节点，由于C上的数据的key的hash值在B和C所在的hash区间之内，因此C上的数据顺时针找到的第一个节点就是D节点，因此C的数据会全部迁移到D节点之上。 但当节点数量较少的时候，增删节点对单个节点的影响较大，会造成数据分布不均，如移除C节点时，C的数据会全部迁移到D节点上，此时D节点拥有的数据由原来的1/4变成现在的1/2，相比于节点A和B来说负载更高。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/38.png" alt="img"></p>
<h6 id="3、带虚拟节点的一致性哈希-Redis集群"><a href="#3、带虚拟节点的一致性哈希-Redis集群" class="headerlink" title="3、带虚拟节点的一致性哈希 (Redis集群)"></a>3、带虚拟节点的一致性哈希 (Redis集群)</h6><p>Redis采用的方案，在一致性哈希基础之上，引入虚拟节点的概念，虚拟节点被称为槽(slot)。<strong>Redis集群中，槽的数量为16384。</strong></p>
<p>槽介于数据和节点之间，将节点划分为一定数量的槽，每个槽包含哈希值一定范围内的数据。由原来的hash–&gt;node 变为 hash–&gt;slot–&gt;node。</p>
<p>当增删节点时，该节点所有拥有的槽会被重新分配给其他节点，可以避免在一致性哈希分区中由于某个节点的增删造成数据的严重分布不均。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/39.png" alt="img"></p>
<h5 id="3、通信机制"><a href="#3、通信机制" class="headerlink" title="3、通信机制"></a>3、通信机制</h5><p>在上面的哨兵方案中，节点被分为数据节点和哨兵节点，哨兵节点也是redis服务，但只作为选举监控使用，只有数据节点会存储数据。而<strong>在Redis集群中，所有节点都是数据节点，也都参与集群的状态维护</strong>。</p>
<p>在Redis集群中，数据节点提供两个TCP端口，在配置防火墙时需要同时开启下面两类端口：</p>
<ul>
<li>普通端口：即客户端访问端口，如默认的6379；</li>
<li>集群端口：普通端口号加10000，如6379的集群端口为16379，用于集群节点之间的通讯；</li>
</ul>
<p>集群的节点之间通讯采用<code>Gossip协议</code>，节点根据固定频率(每秒10次)定时任务进行判断，<strong>当集群状态发生变化，如增删节点、槽状态变更时，会通过节点间通讯同步集群状态，使集群收敛</strong>。</p>
<p>集群间发送的Gossip消息有下面五种消息类型：</p>
<ul>
<li><code>MEET</code>：在节点握手阶段，对新加入的节点发送meet消息，请求新节点加入当前集群，新节点收到消息会回复PONG消息；</li>
<li><code>PING</code>：节点之间互相发送ping消息，收到消息的会回复pong消息。ping消息内容包含本节点和其他节点的状态信息，以此达到状态同步；</li>
<li><code>PONG</code>：pong消息包含自身的状态数据，在接收到ping或meet消息时会回复pong消息，也会主动向集群广播pong消息；</li>
<li><code>FAIL</code>：当一个主节点判断另一个主节点进入fail状态时，会向集群广播这个消息，接收到的节点会保存该消息并对该fail节点做状态判断；</li>
<li><code>PUBLISH</code>：当节点收到publish命令时，会先执行命令，然后向集群广播publish消息，接收到消息的节点也会执行publish命令；</li>
</ul>
<h5 id="4、访问集群"><a href="#4、访问集群" class="headerlink" title="4、访问集群"></a>4、访问集群</h5><p>上面介绍了槽的概念，在每个节点存储着不同范围的槽，数据也分布在不同的节点之上，<strong>我们在访问集群的时候，如何知道数据在哪个节点或者在哪个槽之上呢</strong>？ 下面介绍两种访问连接：</p>
<h6 id="1、Dummy客户端"><a href="#1、Dummy客户端" class="headerlink" title="1、Dummy客户端"></a>1、Dummy客户端</h6><p>使用redis-cli客户端连接集群被称为dummy客户端，只会在执行命令之后通过MOVED错误重定向找到对应的节点，如图，我们可以使用redis-cli -c命令进入集群命令行，当查看或设置key的时候会根据上面提到的CRC16算法计算key的hash值找到对应的槽slot，然后重定向到对应的节点之后才能操作，我们也使用cluster keyslot命令查看key所在的槽solt：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-c进入集群命令行模式</span></span><br><span class="line">redis-cli -c -p 6381</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用命令查看key所在的槽</span></span><br><span class="line">cluster keyslot key1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/40.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/41.png" alt="img"></p>
<h6 id="2、Smart客户端"><a href="#2、Smart客户端" class="headerlink" title="2、Smart客户端"></a>2、Smart客户端</h6><p>相比于dummy客户端，smart客户端在初始化连接集群时就缓存了槽slot和节点node的对应关系， 也就是在连接任意节点后执行cluster slots，我们使用的JedisCluster就是smart客户端：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster slots</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/42.png" alt="img"></p>
<blockquote>
<p>集群代理：Redis6版本中新增的特性，<strong>客户端不需要知道集群中的具体节点个数和主从身份，可以直接通过代理访问集群。</strong>与Redis在不同的分支，将在后面的文章中具体介绍。 </p>
</blockquote>
<h3 id="3、cluster集群结构搭建"><a href="#3、cluster集群结构搭建" class="headerlink" title="3、cluster集群结构搭建"></a>3、cluster集群结构搭建</h3><h4 id="1、搭建方式"><a href="#1、搭建方式" class="headerlink" title="1、搭建方式"></a>1、搭建方式</h4><ul>
<li>原生安装（单条命令）<ul>
<li>配置服务器（3主3从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
</li>
<li>工具安装（批处理）</li>
</ul>
<h4 id="2、Cluster配置"><a href="#2、Cluster配置" class="headerlink" title="2、Cluster配置"></a>2、Cluster配置</h4><p>配置一个配置文件，借助这个配置文件去配置其他类型配置文件的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/6379/6380/g&quot;</span> redis-6379.conf &gt; redis-7380.conf</span><br></pre></td></tr></table></figure>

<p>将redis-6379.conf配置文件当中的6379修改为6380之后生成一个redis-6380.conf的配置文件</p>
<ul>
<li><p>添加节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>这里建议修改cluster的配置文件的名字，因为如果在同一个目录下有多个cluster结点的话，可能会因为相关的配置文件的同名而导致一定的问题。<br>建议改名：<strong>nodes-端口.conf</strong></p>
</li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure>

<p>与后面当master宕机之后，slave日志的展示有关</p>
<p>对于线上，30s或60s都行，看具体的业务</p>
</li>
<li><p>master连接的slave最小数量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-migration-barrier &lt;count&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、启动redis服务"><a href="#3、启动redis服务" class="headerlink" title="3、启动redis服务"></a>3、启动redis服务</h4><h5 id="1、启动master结点"><a href="#1、启动master结点" class="headerlink" title="1、启动master结点"></a>1、启动master结点</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /redis-4.0.0/conf/redis-6379.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907135258255.png" alt="image-20210907135258255"></p>
<p>按照上面的方法依次启动另外的五个结点（三主三从）</p>
<h5 id="2、查看当前redis服务"><a href="#2、查看当前redis服务" class="headerlink" title="2、查看当前redis服务"></a>2、查看当前redis服务</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907135434580.png" alt="image-20210907135434580"></p>
<h5 id="3、将当前的六个结点相连"><a href="#3、将当前的六个结点相连" class="headerlink" title="3、将当前的六个结点相连"></a>3、将当前的六个结点相连</h5><p>把启动的一个个redis结点进行连接</p>
<p>相关命令：下载的redis包下的src目录下的<code>redis-trib.rb</code></p>
<p>要想启动redis-trib.rb，需要两个工具：</p>
<ol>
<li>ruby</li>
<li>rubygem</li>
</ol>
<p>需要将它们先进行下载。<br>注意：</p>
<ul>
<li>redis的版本不同，对应下载的ruby也会有所不同</li>
<li>如果ruby和gem的版本不够，它会提醒你升级到对应的版本</li>
</ul>
<blockquote>
<p>在Redis 6当中，<em>redis-cli –cluster</em>代替了之前的<em>redis-trib.rb</em>，我们无需安装ruby环境即可直接使用它附带的所有功能：<strong>创建集群、增删节点、槽迁移、完整性检查、数据重平衡</strong>等等。</p>
</blockquote>
<p>redis-trib.rb命令的执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果直接执行redis-trib.rb它是识别不出来的，而且只有在当前目录下有效，需要将它用./redis-trib.rb方式执行</span></span><br><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384</span><br></pre></td></tr></table></figure>

<p><strong>当中的1表示master与slave之间的数量</strong></p>
<ul>
<li>eg：<ul>
<li>1：1个master有1个slave</li>
<li>2：1个master有2个slave</li>
</ul>
</li>
</ul>
<p><strong>对应的，后面的结点IP和端口需要与前面的数字相对应</strong></p>
<ul>
<li>eg：<ul>
<li>前面1，后面6：3对——1个muster1个slave</li>
<li>前面2，后面6：2对——1个muster2个slave</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907140357232.png" alt="image-20210907140357232"></p>
<p>在选择yes之前，也就是生成相关配置文件之前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907140650632.png" alt="image-20210907140650632"></p>
<p>选择yes之后生成相关配置文件：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141043430.png" alt="image-20210907141043430"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141310592.png" alt="image-20210907141310592"></p>
<h5 id="4、此时redis服务端的日志"><a href="#4、此时redis服务端的日志" class="headerlink" title="4、此时redis服务端的日志"></a>4、此时redis服务端的日志</h5><p>master服务端：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907141859784.png" alt="image-20210907141859784"></p>
<p>slave服务端：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142218680.png" alt="image-20210907142218680"></p>
<h4 id="4、使用cluster设置与获取数据"><a href="#4、使用cluster设置与获取数据" class="headerlink" title="4、使用cluster设置与获取数据"></a>4、使用cluster设置与获取数据</h4><p>存取数据：</p>
<ul>
<li><p>若是按照之前的方法启动：</p>
<ul>
<li><pre><code class="sh">redis-cli
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 则你在进行set&#x2F;get等操作的时候会报错，redis会告诉你当前数据应该设置在哪一个槽当中，很麻烦</span><br><span class="line"></span><br><span class="line">  ![image-20210907142834922](redis高级&#x2F;image-20210907142834922.png)</span><br><span class="line"></span><br><span class="line">- 所以应当商量说过的另一个启动方式：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;sh</span><br><span class="line">  redis-cli -c</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>再进行set/get操作，发现成功，redis会返回该值已经重定向到对应的槽当中，并且返回OK</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142908730.png" alt="image-20210907142908730"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907142958347.png" alt="image-20210907142958347"></p>
</li>
</ul>
<h4 id="5、在Cluster集群下出现相关问题的解决方法"><a href="#5、在Cluster集群下出现相关问题的解决方法" class="headerlink" title="5、在Cluster集群下出现相关问题的解决方法"></a>5、在Cluster集群下出现相关问题的解决方法</h4><p>在Cluster集群下测试出现的相关问题：</p>
<ol>
<li>当slave结点宕机会出现什么问题？</li>
<li>当master结点宕机会出现什么问题？</li>
</ol>
<h5 id="1、当slave结点宕机会出现什么问题？"><a href="#1、当slave结点宕机会出现什么问题？" class="headerlink" title="1、当slave结点宕机会出现什么问题？"></a>1、当slave结点宕机会出现什么问题？</h5><p>宕机的slave结点对应的master：</p>
<ul>
<li><p>宕机前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143341529.png" alt="image-20210907143341529"></p>
</li>
<li><p>宕机后：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143626170.png" alt="image-20210907143626170"></p>
</li>
<li><p>对应的从结点重新上线：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143842881.png" alt="image-20210907143842881"></p>
</li>
</ul>
<p>其他master结点：</p>
<ul>
<li><p>宕机前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143414489.png" alt="image-20210907143414489"></p>
</li>
<li><p>宕机后：（这里包括其他的从结点也一样）</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143641578.png" alt="image-20210907143641578"></p>
</li>
<li><p>重新上线：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144153900.png" alt="image-20210907144153900"></p>
</li>
</ul>
<p>宕机的从结点：</p>
<ul>
<li><p>宕机前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143504078.png" alt="image-20210907143504078"></p>
</li>
<li><p>宕机后：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907143531076.png" alt="image-20210907143531076"></p>
</li>
<li><p>重新上线</p>
</li>
</ul>
<p>由上面可以得到，在Cluster集群当中，当一个slave结点宕机并不会产生多大的影响，只是将相应宕机的从结点进行标记而已，整一个redis集群依旧是可用的。当宕机的slave结点重新上线之后在将它加入对应的主节点就行。</p>
<h5 id="2、当master结点宕机会出现什么问题？"><a href="#2、当master结点宕机会出现什么问题？" class="headerlink" title="2、当master结点宕机会出现什么问题？"></a>2、当master结点宕机会出现什么问题？</h5><p>宕机的master结点：</p>
<ul>
<li><p>宕机前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144324055.png" alt="image-20210907144324055"></p>
</li>
<li><p>宕机后：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144225353.png" alt="image-20210907144225353"></p>
</li>
<li><p>重新上线</p>
</li>
</ul>
<p>宕机的master结点对应的slave结点：</p>
<ul>
<li><p>宕机前：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144755729.png" alt="image-20210907144755729"></p>
</li>
<li><p>宕机后：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907144740458.png" alt="image-20210907144740458"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145044928.png" alt="image-20210907145044928"></p>
<p>此时通过<code>cluster nodes</code>命令去查看当前cluster集群的状态：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145201995.png" alt="image-20210907145201995"></p>
<p>把宕机的master结点标记为fail，因为宕机的结点可能重新上线，所以这里只是做了标记</p>
</li>
<li><p>重新上线：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907145908556.png" alt="image-20210907145908556"></p>
<p>使用<code>cluster nodes</code>查看当前cluster集群的状态：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907150019576.png" alt="image-20210907150019576"></p>
</li>
</ul>
<p>其他结点只是更新一下当前结点的状态而已</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907150133315.png" alt="image-20210907150133315"></p>
<h4 id="6、Cluster节点操作命令"><a href="#6、Cluster节点操作命令" class="headerlink" title="6、Cluster节点操作命令"></a>6、Cluster节点操作命令</h4><ul>
<li><p>查看集群节点信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入一个从节点 redis，切换其主节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现一个新节点，新增主节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略一个没有solt的节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动故障转移</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="7、redis-trib命令"><a href="#7、redis-trib命令" class="headerlink" title="7、redis-trib命令"></a>7、redis-trib命令</h4><ul>
<li><p>添加节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb del-node</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新分片</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="4、集群参数优化"><a href="#4、集群参数优化" class="headerlink" title="4、集群参数优化"></a>4、集群参数优化</h3><p><code>cluster_node_timeout</code></p>
<ul>
<li><strong>默认值为15s</strong>。</li>
<li><strong>影响ping消息接收节点的选择，值越大对延迟容忍度越高，选择的接收节点就越少</strong>，可以降低带宽，但会影响收敛速度。应该根据带宽情况和实际要求具体调整。</li>
<li><strong>影响故障转移的判定，值越大越不容易误判，但完成转移所消耗的时间就越长</strong>。应根据网络情况和实际要求具体调整。</li>
</ul>
<p><code>cluster-require-full-coverage</code></p>
<ul>
<li>为了保证集群的完整性，只有当16384个槽slot全部分配完毕，集群才可以上线，但同时，若主节点发生故障且故障转移还未完成时，原主节点的槽不在任何节点中，集群会处于下线状态，影响客户端的使用。</li>
<li>该参数可以改变此设定：<ul>
<li>no：表示当槽没有完全分配时，集群仍然可以上线；</li>
<li>yes：<strong>默认配置</strong>，只有槽完全分配，集群才可以上线；</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10、企业级解决方案"><a href="#10、企业级解决方案" class="headerlink" title="10、企业级解决方案"></a>10、企业级解决方案</h2><h3 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h3><h4 id="1、“宕机”"><a href="#1、“宕机”" class="headerlink" title="1、“宕机”"></a>1、“宕机”</h4><p>服务器启动后迅速宕机</p>
<h4 id="2、问题排查"><a href="#2、问题排查" class="headerlink" title="2、问题排查"></a>2、问题排查</h4><ol>
<li><strong>请求数量较高</strong></li>
<li>主从之间数据吞吐量较大，<strong>数据同步操作频度较高</strong></li>
</ol>
<h4 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h4><p>前置准备工作：</p>
<ol>
<li><strong>日常例行统计数据访问记录，统计访问频度较高的热点数据</strong></li>
<li><strong>利用LRU数据删除策略，构建数据留存队列</strong><ul>
<li>例如：storm与kafka配合</li>
</ul>
</li>
</ol>
<p>准备工作：</p>
<ol>
<li><strong>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</strong></li>
<li><strong>利用分布式多服务器同时进行数据读取，提速数据加载过程</strong></li>
<li><strong>热点数据主从同时预热</strong></li>
</ol>
<p>实施：</p>
<ol>
<li><strong>使用脚本程序固定触发数据预热过程</strong></li>
<li><strong>如果条件允许，使用了CDN（内容分发网络），效果会更好</strong></li>
</ol>
<h4 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论"></a>4、结论</h4><p><strong>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统</strong>。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h3><h4 id="1、数据库服务器崩溃（1）"><a href="#1、数据库服务器崩溃（1）" class="headerlink" title="1、数据库服务器崩溃（1）"></a>1、数据库服务器崩溃（1）</h4><ol>
<li>系统平稳运行过程中，<strong>忽然数据库连接量激增</strong></li>
<li><strong>应用服务器无法及时处理请求</strong></li>
<li><strong>大量408，500错误页面出现</strong></li>
<li><strong>客户反复刷新页面获取数据</strong></li>
<li><strong>数据库崩溃</strong></li>
<li><strong>应用服务器崩溃</strong></li>
<li><strong>重启应用服务器无效</strong></li>
<li><strong>Redis服务器崩溃</strong></li>
<li><strong>Redis集群崩溃</strong></li>
<li><strong>重启数据库后再次被瞬间流量放倒</strong></li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/89.png" alt="img"></p>
<h4 id="2、问题排查-1"><a href="#2、问题排查-1" class="headerlink" title="2、问题排查"></a>2、问题排查</h4><ol>
<li><strong>在一个==较短==的时间内，缓存中==较多==的key==集中过期==</strong></li>
<li><strong>此周期内请求访问过期的数据</strong>，redis未命中，<strong>redis向数据库获取数据</strong></li>
<li><strong>数据库同时接收到大量的请求无法及时处理</strong></li>
<li><strong>Redis大量请求被积压，开始出现超时现象</strong></li>
<li><strong>数据库流量激增，数据库崩溃</strong></li>
<li><strong>重启后仍然面对缓存中无数据可用</strong></li>
<li><strong>Redis服务器资源被严重占用，Redis服务器崩溃</strong></li>
<li><strong>Redis集群呈现崩塌，集群瓦解</strong></li>
<li><strong>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</strong></li>
<li><strong>应用服务器，redis，数据库全部重启，效果不理想</strong></li>
</ol>
<h4 id="3、问题分析"><a href="#3、问题分析" class="headerlink" title="3、问题分析"></a>3、问题分析</h4><ul>
<li>短时间范围内</li>
<li>大量key集中过期</li>
</ul>
<h4 id="4、解决方案（道）"><a href="#4、解决方案（道）" class="headerlink" title="4、解决方案（道）"></a>4、解决方案（道）</h4><ol>
<li>更多的<strong>页面静态化处理</strong></li>
<li><strong>构建多级缓存架构</strong><ul>
<li>Nginx缓存+redis缓存+ehcache缓存</li>
</ul>
</li>
<li><strong>检测Mysql严重耗时业务进行优化</strong><ul>
<li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
</ul>
</li>
<li><strong>灾难预警机制</strong><ul>
<li>监控redis服务器性能指标<ul>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
</ul>
</li>
<li><strong>限流、降级</strong><ul>
<li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ul>
</li>
</ol>
<h4 id="5、解决方案（术）"><a href="#5、解决方案（术）" class="headerlink" title="5、解决方案（术）"></a>5、解决方案（术）</h4><ol>
<li><p><strong>LRU与LFU切换</strong></p>
</li>
<li><p><strong>数据有效期策略调整</strong></p>
<ul>
<li><p>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/90.png" alt="img"></p>
</li>
<li><p><strong>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/91.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>超热数据使用永久key</strong></p>
</li>
<li><p><strong>定期维护</strong>（自动+人工）</p>
<ul>
<li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
</ul>
</li>
<li><p><strong>加锁</strong></p>
<ul>
<li>慎用！</li>
</ul>
</li>
</ol>
<h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><p><strong>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力</strong>。如<strong>能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</strong>。</p>
<p>原本情况：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907151332317.png" alt="image-20210907151332317"></p>
<p>服务雪崩的情况：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907151254348.png" alt="image-20210907151254348"></p>
<h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><h4 id="1、数据库服务器崩溃（2）"><a href="#1、数据库服务器崩溃（2）" class="headerlink" title="1、数据库服务器崩溃（2）"></a>1、数据库服务器崩溃（2）</h4><ol>
<li>系统平稳运行过程中</li>
<li><strong>数据库连接量瞬间激增</strong></li>
<li><strong>Redis服务器无大量key过期</strong></li>
<li><strong>Redis内存平稳，无波动</strong></li>
<li><strong>Redis服务器CPU正常</strong></li>
<li><strong>数据库崩溃</strong></li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908131731307.png" alt="image-20210908131731307"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/87.png" alt="img"></p>
<h4 id="2、问题排查-2"><a href="#2、问题排查-2" class="headerlink" title="2、问题排查"></a>2、问题排查</h4><ol>
<li><strong>Redis中某个key过期，该key访问量巨大</strong></li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li><strong>Redis在短时间内发起了大量对数据库中同一数据的访问</strong></li>
</ol>
<h4 id="3、问题分析-1"><a href="#3、问题分析-1" class="headerlink" title="3、问题分析"></a>3、问题分析</h4><ul>
<li><strong>单个key高热数据</strong></li>
<li><strong>key过期</strong></li>
</ul>
<h4 id="4、解决方案（术）"><a href="#4、解决方案（术）" class="headerlink" title="4、解决方案（术）"></a>4、解决方案（术）</h4><ol>
<li><p><strong>预先设定</strong></p>
<ul>
<li>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长</li>
<li>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li>
</ul>
</li>
<li><p><strong>现场调整</strong></p>
<ul>
<li><strong>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</strong></li>
</ul>
</li>
<li><p><strong>后台刷新数据</strong></p>
<ul>
<li>启动定时任务，高峰期来临之前，<strong>刷新数据有效期，确保不丢失</strong></li>
</ul>
</li>
<li><p><strong>二级缓存</strong></p>
<ul>
<li><strong>设置不同的失效时间，保障不会被同时淘汰就行</strong></li>
</ul>
</li>
<li><p><strong>加锁（但是要注意也是性能瓶颈，慎重！）</strong></p>
<ul>
<li><p><strong>分布式锁，防止被击穿，</strong></p>
</li>
<li><p><strong>利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据</strong>，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库；</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/88.png" alt="img"></p>
<p>在使用互斥锁的时候需要避免出现<strong>死锁</strong>或者<strong>锁过期</strong>的情况：</p>
<ul>
<li>使用lua脚本或事务将获取锁和设置过期时间作为一个原子性操作(如：set kk vv nx px 30000)，以避免出现某个客户端获取锁之后宕机导致的锁不被释放造成死锁现象；</li>
<li>另起一个线程监控获取锁的线程的查询状态，快到锁过期时间时还没查询结束则延长锁的过期时间，避免多次查询多次锁过期造成计算资源的浪费；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p><strong>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力</strong>。应对策略应该<strong>在业务数据分析与预防方面进行</strong>，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</p>
<h3 id="4、缓存穿透"><a href="#4、缓存穿透" class="headerlink" title="4、缓存穿透"></a>4、缓存穿透</h3><h4 id="1、数据库服务器崩溃（3）"><a href="#1、数据库服务器崩溃（3）" class="headerlink" title="1、数据库服务器崩溃（3）"></a>1、数据库服务器崩溃（3）</h4><ol>
<li>系统平稳运行过程中</li>
<li><strong>应用服务器流量随时间增量较大</strong></li>
<li><strong>Redis服务器命中率随时间逐步降低</strong></li>
<li><strong>Redis内存平稳，内存无压力</strong></li>
<li><strong>Redis服务器CPU占用激增</strong></li>
<li><strong>数据库服务器压力激增</strong></li>
<li><strong>数据库崩溃</strong></li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908131718336.png" alt="image-20210908131718336"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/85.png" alt="img"></p>
<h4 id="2、问题排查-3"><a href="#2、问题排查-3" class="headerlink" title="2、问题排查"></a>2、问题排查</h4><ul>
<li><strong>Redis中大面积出现未命中</strong></li>
<li><strong>出现非正常URL访问</strong></li>
</ul>
<h4 id="3、问题分析-2"><a href="#3、问题分析-2" class="headerlink" title="3、问题分析"></a>3、问题分析</h4><ul>
<li><strong>获取的数据在数据库中也不存在，数据库查询未得到对应数据</strong></li>
<li><strong>Redis获取到null数据未进行持久化，直接返回</strong></li>
<li><strong>下次此类数据到达重复上述过程</strong></li>
<li><strong>==出现黑客攻击服务器==</strong></li>
</ul>
<h4 id="4、解决方案（术）-1"><a href="#4、解决方案（术）-1" class="headerlink" title="4、解决方案（术）"></a>4、解决方案（术）</h4><ol>
<li><p><strong>缓存null</strong></p>
<ul>
<li>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li>
</ul>
</li>
<li><p><strong>白名单策略</strong></p>
<ul>
<li><p>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</p>
</li>
<li><p>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p>
<ul>
<li>(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个<strong>很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</strong></li>
<li>布隆过滤器可以用于<strong>检索一个元素是否在一个集合中</strong>。</li>
<li>它的优点是<strong>空间效率和查询时间都远远超过一般的算法</strong>，缺点是<strong>有一定的误识别率和删除困难</strong>。</li>
<li>将所有可能存在的数据哈希到一个足够大的<code>bitmaps</code>中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/86.png" alt="img"></p>
<blockquote>
<p>布隆过滤器有误判率，虽然不能完全避免数据穿透的现象，但已经可以将99.99%的穿透查询给屏蔽在Redis层了，极大的降低了底层数据库的压力，减少了资源浪费。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>实施监控</strong></p>
<ul>
<li><strong>实时监控redis命中率</strong>（业务正常范围时，通常会有一个波动值）与null数据的占比<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>key加密</strong></p>
<ul>
<li>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</li>
<li>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li>
</ul>
</li>
</ol>
<h4 id="5、总结-1"><a href="#5、总结-1" class="headerlink" title="5、总结"></a>5、总结</h4><p><strong>缓存穿透访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力</strong>。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，==并及时报警==。应对策略应该在临时预案防范方面多做文章。</p>
<p><strong>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</strong></p>
<h3 id="5、缓存更新"><a href="#5、缓存更新" class="headerlink" title="5、缓存更新"></a>5、缓存更新</h3><p>缓存服务（Redis）和数据服务（底层数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。如何解决并发场景下更新操作的双写一致是缓存系统的一个重要知识点。</p>
<blockquote>
<p><strong>第二步操作异常</strong>：缓存和数据的操作顺序中，第二个动作报错。如数据库被更新， 此时失效缓存的时候出错，缓存内数据仍是旧版本；</p>
</blockquote>
<p>缓存更新的设计模式有四种：</p>
<ul>
<li><p><strong>Cache aside</strong>：</p>
<ul>
<li><p><strong>查询</strong>：先查缓存，缓存没有就查数据库，然后加载至缓存内；</p>
</li>
<li><p><strong>更新</strong>：先更新数据库，然后让缓存失效；或者先失效缓存然后更新数据库； </p>
</li>
<li><p>为了避免在并发场景下，多个请求同时更新同一个缓存导致脏数据，因此<strong>不能直接更新缓存而是另缓存失效</strong>。(看Redis 的缓存一致性)</p>
</li>
<li><p>推荐使用先失效缓存，后更新数据库，配合延迟失效来更新缓存的模式；</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/92.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>Read through</strong>：在查询操作中更新缓存，即当缓存失效时，<strong>Cache Aside 模式是由调用方负责把数据加载入缓存</strong>，<strong>而 Read Through 则用缓存服务自己来加载</strong>；</p>
</li>
<li><p><strong>Write through</strong>：在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后<strong>由缓存自己更新数据库</strong>； </p>
</li>
<li><p><strong>Write behind caching</strong>：俗称write back，<strong>在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地定时批量更新数据库</strong>；</p>
</li>
</ul>
<p><strong>四种缓存更新模式的优缺点</strong>：</p>
<ul>
<li>Cache Aside：实现起来较简单，但需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）；</li>
<li>Read/Write Through：只需要维护一个数据存储（缓存），但是实现起来要复杂一些；</li>
<li>Write Behind Caching：与Read/Write Through 类似，区别是Write Behind Caching的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。<ul>
<li>优点是直接操作内存速度快，多次操作可以合并持久化到数据库。</li>
<li>缺点是数据可能会丢失，例如系统断电等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>缓存本身就是通过牺牲强一致性来提高性能，因此使用缓存提升性能，就会有数据更新的延迟性。这就需要我们在评估需求和设计阶段根据实际场景去做权衡了。</p>
</blockquote>
<h3 id="6、缓存降级"><a href="#6、缓存降级" class="headerlink" title="6、缓存降级"></a>6、缓存降级</h3><p>缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损部分其他服务，仍然需要保证主服务可用。可以将其他次要服务的数据进行缓存降级，从而提升主服务的稳定性。</p>
<p>降级的目的是<strong>保证核心服务可用，即使是有损的</strong>。如去年双十一的时候淘宝购物车无法修改地址只能使用默认地址，这个服务就是被降级了，这里阿里保证了订单可以正常提交和付款，但修改地址的服务可以在服务器压力降低，并发量相对减少的时候再恢复。</p>
<p><strong>降级可以根据实时的监控数据进行自动降级也可以配置开关人工降级</strong>。是否需要降级，哪些服务需要降级，在什么情况下再降级，取决于大家对于系统功能的取舍。</p>
<h3 id="7、性能指标监控"><a href="#7、性能指标监控" class="headerlink" title="7、性能指标监控"></a>7、性能指标监控</h3><h4 id="1、监控指标"><a href="#1、监控指标" class="headerlink" title="1、监控指标"></a>1、监控指标</h4><ul>
<li>性能指标：<code>Performance</code></li>
<li>内存指标：<code>Memory</code></li>
<li>基本活动指标：<code>Basic activity</code></li>
<li>持久性指标：<code>Persistence</code></li>
<li>错误指标：<code>Error</code></li>
</ul>
<h5 id="1、性能指标：Performance"><a href="#1、性能指标：Performance" class="headerlink" title="1、性能指标：Performance"></a>1、性能指标：Performance</h5><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>latency</td>
<td>Redis响应一个请求的时间</td>
</tr>
<tr>
<td>instantaneous_ops_per_sec</td>
<td>平均每秒处理请求总数</td>
</tr>
<tr>
<td>hit rate(calculated)</td>
<td>缓存命中率（计算出来的）</td>
</tr>
</tbody></table>
<h5 id="2、内存指标：Memory"><a href="#2、内存指标：Memory" class="headerlink" title="2、内存指标：Memory"></a>2、内存指标：Memory</h5><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>used_menory</td>
<td>已使用内存</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>内存碎片率</td>
</tr>
<tr>
<td>evicted_keys</td>
<td>由于最大内存限制被移除的key的数量</td>
</tr>
<tr>
<td>blocked_clients</td>
<td>由于BLPOP,BRPOP,or BRPOPlPUSH而备阻塞的客户端</td>
</tr>
</tbody></table>
<h5 id="3、基本活动指标：Basic-activity"><a href="#3、基本活动指标：Basic-activity" class="headerlink" title="3、基本活动指标：Basic activity"></a>3、基本活动指标：Basic activity</h5><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>connected_clients</td>
<td>客户端连接数</td>
</tr>
<tr>
<td>connected_slaves</td>
<td>Slave数量</td>
</tr>
<tr>
<td>master_last_io_seconds_ago</td>
<td>最近一次主从交互之后的秒数</td>
</tr>
<tr>
<td>keyspace</td>
<td>数据库中的key值总数</td>
</tr>
</tbody></table>
<h5 id="4、持久性指标：Persistence"><a href="#4、持久性指标：Persistence" class="headerlink" title="4、持久性指标：Persistence"></a>4、持久性指标：Persistence</h5><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rdb_last_save_time</td>
<td>最后一次持久化保存到磁盘的时间戳</td>
</tr>
<tr>
<td>rdb_changes_since_last_save</td>
<td>自最后一次持久化以来数据库的更改数</td>
</tr>
</tbody></table>
<h5 id="5、错误指标：Error"><a href="#5、错误指标：Error" class="headerlink" title="5、错误指标：Error"></a>5、错误指标：Error</h5><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rejected_connections</td>
<td>由于达到maxclient限制而被拒绝的连接数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>Key值查找失败（没有命中）次数</td>
</tr>
<tr>
<td>master_link_down_since_seconds</td>
<td>主从断开的持续时间</td>
</tr>
</tbody></table>
<h4 id="2、redis相关的工具与监控命令"><a href="#2、redis相关的工具与监控命令" class="headerlink" title="2、redis相关的工具与监控命令"></a>2、redis相关的工具与监控命令</h4><ul>
<li>工具<ul>
<li>Cloud Insight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
</li>
<li>命令<ul>
<li>benchmark</li>
<li>redis cli</li>
<li>monitor</li>
<li>showlog</li>
</ul>
</li>
</ul>
<h5 id="1、命令——benchmark"><a href="#1、命令——benchmark" class="headerlink" title="1、命令——benchmark"></a>1、命令——benchmark</h5><p>注意：</p>
<ul>
<li><p>benchmark是一个指令，而不是一个redis命令</p>
</li>
<li><p>所以不是在redis的客户端上启动的，而是像启动redis的服务端或客户端那样直接执行的</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>范例1</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark</span><br></pre></td></tr></table></figure>
</li>
<li><p>范例2</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure>

<p>说明：100个连接，5000次请求对应的性能</p>
</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907163642955.png" alt="image-20210907163642955"></p>
<h5 id="2、命令——monitor"><a href="#2、命令——monitor" class="headerlink" title="2、命令——monitor"></a>2、命令——monitor</h5><p>注意：</p>
<ul>
<li><p>monitor它是一个redis命令，而不是一个指令</p>
</li>
<li><p>所以需要在redis的客户端上启动的</p>
</li>
<li><p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure>

<p>打印服务器调试信息</p>
</li>
</ul>
<h5 id="3、命令——showlong"><a href="#3、命令——showlong" class="headerlink" title="3、命令——showlong"></a>3、命令——showlong</h5><ul>
<li><p>命令</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showlong [<span class="keyword">operator</span>]</span><br></pre></td></tr></table></figure>

<p>operator：</p>
<ul>
<li>get ：获取慢查询日志</li>
<li>len ：获取慢查询日志条目数</li>
<li>reset ：重置慢查询日志</li>
</ul>
</li>
<li><p>相关配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 <span class="comment">#设置慢查询的时间下线，单位：微妙</span></span><br><span class="line">slowlog-max-len 100 <span class="comment">#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="3、Redis-6"><a href="#3、Redis-6" class="headerlink" title="3、Redis 6"></a>3、Redis 6</h1><h2 id="1、NoSQL数据库简介"><a href="#1、NoSQL数据库简介" class="headerlink" title="1、NoSQL数据库简介"></a>1、NoSQL数据库简介</h2><h3 id="1、技术发展"><a href="#1、技术发展" class="headerlink" title="1、技术发展"></a>1、技术发展</h3><p>技术的分类</p>
<ol>
<li>解决<strong>功能性</strong>的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li>
<li>解决<strong>扩展性</strong>的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li>
<li>解决<strong>性能</strong>的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li>
</ol>
<h4 id="1、Web-1-0时代"><a href="#1、Web-1-0时代" class="headerlink" title="1、Web 1.0时代"></a>1、Web 1.0时代</h4><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907203723504.png" alt="image-20210907203723504"></p>
<h4 id="2、Web-2-0时代"><a href="#2、Web-2-0时代" class="headerlink" title="2、Web 2.0时代"></a>2、Web 2.0时代</h4><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907203751485.png" alt="image-20210907203751485"></p>
<h4 id="3、解决CPU及内存压力"><a href="#3、解决CPU及内存压力" class="headerlink" title="3、解决CPU及内存压力"></a>3、解决CPU及内存压力</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907214051175.png" alt="image-20210907214051175"></p>
<h4 id="4、解决IO压力"><a href="#4、解决IO压力" class="headerlink" title="4、解决IO压力"></a>4、解决IO压力</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907214058698.png" alt="image-20210907214058698"></p>
<h3 id="2、NoSQL数据库"><a href="#2、NoSQL数据库" class="headerlink" title="2、NoSQL数据库"></a>2、NoSQL数据库</h3><h4 id="1、NoSQL数据库概述"><a href="#1、NoSQL数据库概述" class="headerlink" title="1、NoSQL数据库概述"></a>1、NoSQL数据库概述</h4><p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 </p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>不遵循SQL标准。</li>
<li>不支持ACID。（事务的四大特性）</li>
<li>远超于SQL的性能。</li>
</ul>
<h4 id="2、NoSQL适用场景"><a href="#2、NoSQL适用场景" class="headerlink" title="2、NoSQL适用场景"></a>2、NoSQL适用场景</h4><ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<h4 id="3、NoSQL不适用场景"><a href="#3、NoSQL不适用场景" class="headerlink" title="3、NoSQL不适用场景"></a>3、NoSQL不适用场景</h4><ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储，处理复杂的关系，需要<strong>即席查询</strong>。<ul>
<li><strong>即席查询是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表</strong></li>
</ul>
</li>
<li><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong></li>
</ul>
<h4 id="4、常用的NoSQL数据库"><a href="#4、常用的NoSQL数据库" class="headerlink" title="4、常用的NoSQL数据库"></a>4、常用的NoSQL数据库</h4><h5 id="1、Memcache"><a href="#1、Memcache" class="headerlink" title="1、Memcache"></a>1、Memcache</h5><ul>
<li><strong>很早</strong>出现的NoSql数据库</li>
<li>数据都在内存中，<strong>一般不持久化</strong></li>
<li>支持简单的key-value模式，<strong>支持类型单一</strong></li>
<li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li>
</ul>
<h5 id="2、Redis"><a href="#2、Redis" class="headerlink" title="2、Redis"></a>2、Redis</h5><p>几乎覆盖了Memcached的绝大部分功能</p>
<p>数据都在内存中，<strong>支持持久化</strong>，主要用作备份恢复</p>
<p>除了支持简单的key-value模式，还<strong>支持多种数据结构的存储</strong>，比如 list、set、hash、zset等。</p>
<p>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</p>
<h5 id="3、MongoDb"><a href="#3、MongoDb" class="headerlink" title="3、MongoDb"></a>3、MongoDb</h5><ul>
<li>高性能、开源、模式自由(schema free)的<strong>文档型数据库</strong></li>
<li>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</li>
<li>虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能</li>
<li>支持二进制数据及大型对象</li>
<li>可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</li>
</ul>
<h3 id="3、行式存储数据库（大数据时代）"><a href="#3、行式存储数据库（大数据时代）" class="headerlink" title="3、行式存储数据库（大数据时代）"></a>3、行式存储数据库（大数据时代）</h3><h4 id="1、行式数据库"><a href="#1、行式数据库" class="headerlink" title="1、行式数据库"></a>1、行式数据库</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907215836602.png" alt="image-20210907215836602"></p>
<h4 id="2、列式数据库"><a href="#2、列式数据库" class="headerlink" title="2、列式数据库"></a>2、列式数据库</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907215842362.png" alt="image-20210907215842362"></p>
<h5 id="1、Hbase"><a href="#1、Hbase" class="headerlink" title="1、Hbase"></a>1、Hbase</h5><p>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行==随机==、==实时==的读写操作的场景中。</p>
<p>HBase的目标就是处理数据量<strong>非常庞大</strong>的表，可以用<strong>普通的计算机</strong>处理<strong>超过10亿行数据</strong>，还可处理有数百万<strong>列</strong>元素的数据表。</p>
<h5 id="2、Cassandra-kəˈsaendrə"><a href="#2、Cassandra-kəˈsaendrə" class="headerlink" title="2、Cassandra[kəˈsændrə]"></a>2、Cassandra[kəˈsændrə]</h5><p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的**海量数据集(数据量通常达到PB级别)**。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<blockquote>
<p>计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</p>
<p>字节 byte：8个二进制位为一个字节(B)，最常用的单位。</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Megabyte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<p>1PB（Petabyte 千万亿字节 拍字节）=1024TB，</p>
<p>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</p>
<p>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</p>
<p>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</p>
<p>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
</blockquote>
<h3 id="4、图关系型数据库"><a href="#4、图关系型数据库" class="headerlink" title="4、图关系型数据库"></a>4、图关系型数据库</h3><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907220207887.png" alt="image-20210907220207887"></p>
<h3 id="5、DB-Engines-数据库排名"><a href="#5、DB-Engines-数据库排名" class="headerlink" title="5、DB-Engines 数据库排名"></a>5、DB-Engines 数据库排名</h3><p><a target="_blank" rel="noopener" href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210907220243094.png" alt="image-20210907220243094"></p>
<hr>
<h2 id="2、Redis配置文件介绍"><a href="#2、Redis配置文件介绍" class="headerlink" title="2、Redis配置文件介绍"></a>2、Redis配置文件介绍</h2><p>自定义目录：/myredis/redis.conf</p>
<h3 id="1、-Units单位"><a href="#1、-Units单位" class="headerlink" title="1、###Units单位###"></a>1、###Units单位###</h3><p><strong>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</strong></p>
<p>大小写不敏感</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000334131.png" alt="image-20210908000334131"></p>
<h3 id="2、-INCLUDES包含"><a href="#2、-INCLUDES包含" class="headerlink" title="2、###INCLUDES包含###"></a>2、###INCLUDES包含###</h3><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000425633.png" alt="image-20210908000425633"></p>
<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h3 id="3、-网络相关配置"><a href="#3、-网络相关配置" class="headerlink" title="3、###网络相关配置"></a>3、###网络相关配置</h3><h4 id="1、bind"><a href="#1、bind" class="headerlink" title="1、bind"></a>1、bind</h4><p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p><strong>不写的情况下，无限制接受任何ip地址的访问</strong></p>
<p><strong>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</strong></p>
<p><strong>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</strong></p>
<p>如果配置了<code>bind * -::*</code>：表示无限制接受任何ip地址的访问</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000556177.png" alt="image-20210908000556177"></p>
<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000618247.png" alt="image-20210908000618247"></p>
<h4 id="2、protected-mode"><a href="#2、protected-mode" class="headerlink" title="2、protected-mode"></a>2、protected-mode</h4><p>将本机访问保护模式设置no</p>
<p>默认为yes，表示只能进行本机访问</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000707970.png" alt="image-20210908000707970"></p>
<h4 id="3、port"><a href="#3、port" class="headerlink" title="3、port"></a>3、port</h4><p>端口号，默认 6379</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000750174.png" alt="image-20210908000750174"></p>
<h4 id="4、tcp-backlog"><a href="#4、tcp-backlog" class="headerlink" title="4、tcp-backlog"></a>4、tcp-backlog</h4><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。默认是511</p>
<p>注意Linux内核会将这个值减小到<code>/proc/sys/net/core/somaxconn</code>的值（128），所以需要确认增大<code>/proc/sys/net/core/somaxconn</code>和<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>（128）两个值来达到想要的效果</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908000853907.png" alt="image-20210908000853907"></p>
<h4 id="5、timeout"><a href="#5、timeout" class="headerlink" title="5、timeout"></a>5、timeout</h4><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即<strong>永不关闭</strong>。</p>
<p>默认为0，单位：秒/s</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908001813330.png" alt="image-20210908001813330"></p>
<h4 id="6、tcp-keepalive"><a href="#6、tcp-keepalive" class="headerlink" title="6、tcp-keepalive"></a>6、tcp-keepalive</h4><p>对访问客户端的一种<strong>心跳检测</strong>，每个n秒检测一次。默认是300s</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002103758.png" alt="image-20210908002103758"></p>
<h3 id="4、-GENERAL通用"><a href="#4、-GENERAL通用" class="headerlink" title="4、###GENERAL通用###"></a>4、###GENERAL通用###</h3><h4 id="1、daemonize"><a href="#1、daemonize" class="headerlink" title="1、daemonize"></a>1、daemonize</h4><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002228723.png" alt="image-20210908002228723"></p>
<h4 id="2、pidfile"><a href="#2、pidfile" class="headerlink" title="2、pidfile"></a>2、pidfile</h4><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002305616.png" alt="image-20210908002305616"></p>
<h4 id="3、loglevel"><a href="#3、loglevel" class="headerlink" title="3、loglevel"></a>3、loglevel</h4><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong></p>
<p>四个级别根据使用阶段来选择，<strong>生产环境选择notice 或者warning</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002345229.png" alt="image-20210908002345229"></p>
<h4 id="4、logfile"><a href="#4、logfile" class="headerlink" title="4、logfile"></a>4、logfile</h4><p>日志文件名称，<strong>默认为空</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002458862.png" alt="image-20210908002458862"></p>
<h4 id="5、databases-16"><a href="#5、databases-16" class="headerlink" title="5、databases 16"></a>5、databases 16</h4><p>设定库的数量 <strong>默认16</strong>，<strong>默认数据库为0</strong>，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002536352.png" alt="image-20210908002536352"></p>
<h3 id="5、-SECURITY安全"><a href="#5、-SECURITY安全" class="headerlink" title="5、###SECURITY安全###"></a>5、###SECURITY安全###</h3><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002619005.png" alt="image-20210908002619005"></p>
<p>访问密码的查看、设置和取消。<strong>默认是没有密码的</strong></p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002648683.png" alt="image-20210908002648683"></p>
<h3 id="6、-LIMITS限制"><a href="#6、-LIMITS限制" class="headerlink" title="6、####LIMITS限制###"></a>6、####LIMITS限制###</h3><h4 id="1、maxclients"><a href="#1、maxclients" class="headerlink" title="1、maxclients"></a>1、maxclients</h4><ul>
<li>设置redis同时可以与多少个客户端进行连接。</li>
<li><strong>默认情况下为10000个客户端。</strong></li>
<li>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908002803930.png" alt="image-20210908002803930"></p>
<h4 id="2、maxmemory"><a href="#2、maxmemory" class="headerlink" title="2、maxmemory"></a>2、maxmemory</h4><ul>
<li>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li>
<li>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过<code>maxmemory-policy</code>来指定。（逐出算法）</li>
<li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li>
<li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908003003737.png" alt="image-20210908003003737"></p>
<h4 id="3、maxmemory-policy"><a href="#3、maxmemory-policy" class="headerlink" title="3、maxmemory-policy"></a>3、maxmemory-policy</h4><ul>
<li>volatile-lru：使用LRU算法移除key，只对设置了<strong>过期时间</strong>的键；（最近最少使用）</li>
<li>allkeys-lfu：在所有集合key中，使用LFU算法移除key（最近使用次数最少）</li>
<li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li>allkeys-random：在所有集合key中，移除随机的key</li>
<li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908004811841.png" alt="image-20210908004811841"></p>
<h4 id="4、maxmemory-samples"><a href="#4、maxmemory-samples" class="headerlink" title="4、maxmemory-samples"></a>4、maxmemory-samples</h4><ul>
<li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li>
<li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908004839416.png" alt="image-20210908004839416"></p>
<hr>
<h2 id="3、Redis的发布和订阅"><a href="#3、Redis的发布和订阅" class="headerlink" title="3、Redis的发布和订阅"></a>3、Redis的发布和订阅</h2><h3 id="1、什么是发布和订阅"><a href="#1、什么是发布和订阅" class="headerlink" title="1、什么是发布和订阅"></a>1、什么是发布和订阅</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h3 id="2、Redis的发布和订阅"><a href="#2、Redis的发布和订阅" class="headerlink" title="2、Redis的发布和订阅"></a>2、Redis的发布和订阅</h3><p>Redis中的订阅、发布实现了发布/订阅消息范式，<strong>发布者不是计划发送消息给特定的订阅者，而是发布消息到不同的频道，发布者不需要知道是哪些订阅者订阅了消息</strong>。<strong>订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道是什么样的发布者发布的消息</strong>。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。</p>
<p>在Redis的发布订阅模式中，有三个部分：</p>
<ul>
<li><code>Publisher（发布者）</code>：发送消息到频道中，每次只能往一个频道发送一条消息；</li>
<li><code>Subscriber（订阅者）</code>：订阅频道，订阅者可以同时订阅多个频道；</li>
<li><code>Channel（频道）</code>：将发布者发布的消息转发给当前订阅此频道的订阅者</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/44.png" alt="img"></p>
<ol>
<li><p>客户端可以订阅频道如下图</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908014220373.png" alt="image-20210908014220373">     </p>
</li>
<li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908014312523.png" alt="image-20210908014312523"></p>
</li>
</ol>
<h3 id="3、发布订阅命令行实现"><a href="#3、发布订阅命令行实现" class="headerlink" title="3、发布订阅命令行实现"></a>3、发布订阅命令行实现</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布消息到指定的频道</span></span><br><span class="line">PUBLISH channel message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅给定的一个或多个频道的信息</span></span><br><span class="line">SUBSCRIBE channel [channel ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅一个或多个符合给定模式的频道</span></span><br><span class="line">PSUBSCRIBE pattern [pattern ...] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指退订给定的频道</span></span><br><span class="line">UNSUBSCRIBE [channel [channel ...]] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 退订所有给定模式的频道</span></span><br><span class="line">PUNSUBSCRIBE [pattern [pattern ...]] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看订阅与发布系统状态</span></span><br><span class="line">PUBSUB subcommand [argument [argument ...]] </span><br></pre></td></tr></table></figure>



<h3 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h3><p>使用搭建的集群来测试Redis的订阅发布模式，A节点作为发布者，A,B,C节点作为订阅者消费A节点发布的消息：</p>
<ul>
<li>订阅者6381：与发布者在同一节点，订阅www,csdn,wyk三个频道；</li>
<li>订阅者6382：订阅符合csdn和wyk模式的所有频道；</li>
<li>订阅者6383：订阅csdn频道；</li>
<li>发布者6381：分别往csdn1,csdn2,csdn,wyk四个频道发送消息，验证三个订阅者接收消息的情况以及发布者发布消息后的返回值；</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/45.png" alt="img"></p>
<p>断开后的订阅者重新订阅后会丢失断开期间发布者发布的消息：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/46.png" alt="img"></p>
<blockquote>
<p>在集群模式中，发布者发布消息后的返回值取决于<strong>订阅者与发布者在不在同一个节点上</strong>：</p>
<ul>
<li>发布者发布消息后返回值为<strong>与发布者相同节点当前订阅了该频道的客户端数量</strong>。</li>
</ul>
</blockquote>
<h3 id="5、对比"><a href="#5、对比" class="headerlink" title="5、对比"></a>5、对比</h3><p>在上面的示例中，大家也可以看到，Redis中的发布订阅非常像消息队列，但还是有不同，我们就来对比一下Redis的List实现消息队列以及传统消息队列Kafka看看有哪些不同：</p>
<h4 id="1、对比List"><a href="#1、对比List" class="headerlink" title="1、对比List"></a>1、对比List</h4><p>与Redis中的List对比，基于List实现的消息队列需要结合<code>lpush + brpop</code>来实现。</p>
<ul>
<li>胜<strong>（多消费组）</strong>：<ul>
<li>当多个客户端同时消费同一个List消息队列时，消费者A使用brpop消费的数据就从list中弹出了，消费者B就再也读不到该数据；</li>
<li>而在发布订阅中，多个订阅者可以订阅相同的频道，频道内的数据会分发到各个订阅者，不会出现某一个订阅者消费了之后，另一个订阅者读不到该数据的情况。</li>
</ul>
</li>
<li>负<strong>（断点消费）</strong>：<ul>
<li>但对于List的消息队列来说，当消费者断开后重连，仍然可以从List中断点消费还没消费的数据；</li>
<li>而发布订阅中，如果订阅者断开重连，会丢失断开期间发布者发布的数据，无法恢复。</li>
</ul>
</li>
</ul>
<h4 id="2、对比Kafka"><a href="#2、对比Kafka" class="headerlink" title="2、对比Kafka"></a>2、对比Kafka</h4><p>Redis的发布订阅以及List并不是要和专业的消息队列对标，而是可以实现类似的功能，真正在消息队列领域做的好的有很多，RabbitMQ、ActiveMQ、RocketMQ、Kafka、Pulsar等等，发布订阅相比于它们有什么异同呢？</p>
<ul>
<li><strong>不同点</strong>：<ul>
<li><strong>持久化</strong>：Kafka会将数据持久化到磁盘内，而Redis的发布订阅做不到；</li>
<li><strong>断点消费</strong>：上面也提到，当订阅者断开重连会丢失断开期间发布者发布的消息，而kafka中会记录每个消费者消费的topic的offset，因此kafka可以从断开的offset继续消费；</li>
<li><strong>偏移量</strong>：基于上一条，同样的kafka的消费者可以指定从某个offset开始重新消费，而Redis发布订阅根本不会记录订阅者消费的偏移量；</li>
<li><strong>消费方式</strong>： <strong>在Redis发布订阅中，数据消费情况是由发布者控制的</strong>，当发布者发布到频道中后，只有当前连接了频道的订阅者才能消费到数据，断开重连的会失去那部分数据。而<strong>kafka中消费进度是由消费者控制的</strong>，消费者从topic中拉取数据并记录消费的offset。</li>
</ul>
</li>
<li><strong>相同点</strong>：<ul>
<li><strong>消息模型</strong>：在JMS消息模型中有点对点和订阅发布两种<strong>，Kafka和Redis发布订阅都是采用发布订阅的模型。</strong></li>
<li><strong>消费者组</strong>：Kafka里在不同的消费者组中的消费者消费相同的topic时会各自维护一个offset，因此不会出现A消费之后的数据，B就消费不到的情况。Redis中订阅者订阅相同的频道也不会出现类似的情况。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4、解决库存遗留问题——LUA脚本"><a href="#4、解决库存遗留问题——LUA脚本" class="headerlink" title="4、解决库存遗留问题——LUA脚本"></a>4、解决库存遗留问题——LUA脚本</h2><h3 id="1、LUA脚本"><a href="#1、LUA脚本" class="headerlink" title="1、LUA脚本"></a>1、LUA脚本</h3><p>Lua 是一个小巧的<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以<strong>Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</strong></p>
<p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p>
<p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p>
<p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p>
<h3 id="2、LUA脚本在Redis中的优势"><a href="#2、LUA脚本在Redis中的优势" class="headerlink" title="2、LUA脚本在Redis中的优势"></a>2、LUA脚本在Redis中的优势</h3><p><strong>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。</strong>提升性能。</p>
<p><strong>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</strong></p>
<p>但是注意<strong>redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用</strong>。</p>
<p><strong>利用lua脚本淘汰用户，解决超卖问题。</strong></p>
<p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908024325395.png" alt="image-20210908024325395"></p>
<h3 id="3、在Redis中使用LUA脚本示例"><a href="#3、在Redis中使用LUA脚本示例" class="headerlink" title="3、在Redis中使用LUA脚本示例"></a>3、在Redis中使用LUA脚本示例</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure>



<h2 id="5、Redis-6新功能"><a href="#5、Redis-6新功能" class="headerlink" title="5、Redis 6新功能"></a>5、Redis 6新功能</h2><h3 id="1、ACL"><a href="#1、ACL" class="headerlink" title="1、ACL"></a>1、ACL</h3><h4 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h4><p><strong>Redis ACL是 Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</strong></p>
<p>在Redis 5版本之前，Redis 安全规则只有密码控制，还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p>
<ol>
<li>接入权限：用户名和密码 </li>
<li>可以执行的命令 </li>
<li>可以操作的 KEY</li>
</ol>
<p>参考<a target="_blank" rel="noopener" href="https://redis.io/topics/acl">官网</a></p>
<h4 id="2、命令"><a href="#2、命令" class="headerlink" title="2、命令"></a>2、命令</h4><ul>
<li><p>展现用户权限列表</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl list</span><br></pre></td></tr></table></figure>

<p>数据说明：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132433758.png" alt="image-20210908132433758"></p>
</li>
<li><p>查看添加权限指令类别</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加参数类型名可以查看类型下具体命令</span></span><br><span class="line">acl cat &lt;参数类型名&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看添加权限指令类别</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132718079.png" alt="image-20210908132718079"></p>
</li>
<li><p>加参数类型名可以查看类型下具体命令</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908132730836.png" alt="image-20210908132730836"></p>
</li>
</ol>
</li>
<li><p>查看当前用户</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl whoami</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建和编辑用户ACL</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclsetuser</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3、ACL规则"><a href="#3、ACL规则" class="headerlink" title="3、ACL规则"></a>3、ACL规则</h4><h5 id="1、有效ACL规则的列表"><a href="#1、有效ACL规则的列表" class="headerlink" title="1、有效ACL规则的列表"></a>1、有效ACL规则的列表</h5><p>某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>启动用户</td>
<td>on</td>
<td>激活某用户账号</td>
</tr>
<tr>
<td>禁用用户</td>
<td>off</td>
<td>禁用某用户账号。注意：已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td>
</tr>
<tr>
<td>权限的添加删除</td>
<td>+<command></td>
<td>将指令添加到用户可以调用的指令列表中</td>
</tr>
<tr>
<td></td>
<td>-<command></td>
<td>从用户可执行指令列表移除指令</td>
</tr>
<tr>
<td></td>
<td>+@<category></category></td>
<td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td>
</tr>
<tr>
<td></td>
<td>-@<category></category></td>
<td>从用户可调用指令中移除类别</td>
</tr>
<tr>
<td></td>
<td>allcommands</td>
<td>+@all的别名</td>
</tr>
<tr>
<td></td>
<td>nocommand</td>
<td>-@all的别名</td>
</tr>
<tr>
<td>可操作键的添加或删除</td>
<td>~<pattern></pattern></td>
<td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td>
</tr>
</tbody></table>
<h5 id="2、查看ACL的有哪些命令"><a href="#2、查看ACL的有哪些命令" class="headerlink" title="2、查看ACL的有哪些命令"></a>2、查看ACL的有哪些命令</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @server</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/17.png" alt="img"></p>
<h5 id="3、通过命令创建新用户默认权限"><a href="#3、通过命令创建新用户默认权限" class="headerlink" title="3、通过命令创建新用户默认权限"></a>3、通过命令创建新用户默认权限</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser user1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133631954.png" alt="image-20210908133631954"></p>
<p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用<strong>just created的默认属性来创建用户</strong>。如果用户已经存在，则上面的命令将不执行任何操作。</p>
<h5 id="4、设置有用户名、密码、ACL权限、并启用的用户"><a href="#4、设置有用户名、密码、ACL权限、并启用的用户" class="headerlink" title="4、设置有用户名、密码、ACL权限、并启用的用户"></a>4、设置有用户名、密码、ACL权限、并启用的用户</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser user2 on &gt;password ~cached:* +get</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133725918-16310794468831.png" alt="image-20210908133725918"></p>
<h5 id="5、切换用户，验证权限"><a href="#5、切换用户，验证权限" class="headerlink" title="5、切换用户，验证权限"></a>5、切换用户，验证权限</h5><p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908133748625.png" alt="image-20210908133748625"></p>
<h3 id="2、IO-多线程"><a href="#2、IO-多线程" class="headerlink" title="2、IO 多线程"></a>2、IO 多线程</h3><h4 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h4><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。</p>
<p>**Redis6执行命令依然是==单线程==**。</p>
<h4 id="2、原理架构"><a href="#2、原理架构" class="headerlink" title="2、原理架构"></a>2、原理架构</h4><p>Redis 6 加入多线程，但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。</p>
<p><strong>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程</strong>。</p>
<p>之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。</p>
<p>整体的设计大体如下:</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908134006188.png" alt="image-20210908134006188"></p>
<p>另外，<strong>多线程IO默认也是不开启的</strong>，需要再配置文件中配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads yes </span><br><span class="line"></span><br><span class="line">io-threads 4</span><br></pre></td></tr></table></figure>



<h3 id="3、工具支持-Cluster"><a href="#3、工具支持-Cluster" class="headerlink" title="3、工具支持 Cluster"></a>3、工具支持 Cluster</h3><p>之前老版Redis想要搭集群<strong>需要单独安装ruby环境</strong>，<strong>Redis 5 将 redis-trib.rb 的功能集成到 redis-cli</strong> 。</p>
<p><strong>另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/image-20210908134140316.png" alt="image-20210908134140316"></p>
<h3 id="4、Redis新功能持续关注"><a href="#4、Redis新功能持续关注" class="headerlink" title="4、Redis新功能持续关注"></a>4、Redis新功能持续关注</h3><p>Redis6新功能还有：</p>
<ol>
<li>RESP3新的 Redis 通信协议：<strong>优化服务端与客户端之间通信</strong></li>
<li><strong>Client side caching客户端缓存</strong>：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</li>
<li><strong>Proxy集群代理模式</strong>：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是<strong>代理不改变 Cluster 的功能限制</strong>，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</li>
<li>Modules API<ul>
<li>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。</li>
<li>Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。</li>
<li>Redis一开始就是一个向编写各种系统开放的平台。</li>
</ul>
</li>
</ol>
<h2 id="6、Redis-的缓存一致性"><a href="#6、Redis-的缓存一致性" class="headerlink" title="6、Redis 的缓存一致性"></a>6、Redis 的缓存一致性</h2><h4 id="1、Redis-数据一致性简介"><a href="#1、Redis-数据一致性简介" class="headerlink" title="1、Redis 数据一致性简介"></a>1、Redis 数据一致性简介</h4><p>在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。</p>
<p>基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级：</p>
<ul>
<li>第1级：订单数据和支付流水数据；这两块数据<strong>对实时性和精确性要求很高</strong>，所以不添加任何缓存，<strong>读写操作将直接操作数据库</strong>。</li>
<li>第2级：用户相关数据；这些数据和用户相关，<strong>具有读多写少的特征</strong>，所以我们<strong>使用redis进行缓存</strong>。</li>
<li>第3级：支付配置信息；这些数据和用户无关，<strong>具有数据量小，频繁读，几乎不修改的特征</strong>，所以我们<strong>使用本地内存进行缓存</strong>。</li>
</ul>
<p>但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，<strong>因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改</strong>。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p>
<p>接下来就讨论一下关于<strong>保证缓存和数据库双写时的数据一致性</strong>。</p>
<h4 id="2、解决方案-2"><a href="#2、解决方案-2" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><p>那么我们这里列出来所有策略，并且讨论他们优劣性。</p>
<ol>
<li>先更新数据库，后更新缓存</li>
<li>先更新数据库，后删除缓存</li>
<li>先删除缓存，后更新数据库</li>
<li>先更新缓存，后更新数据库</li>
<li>数据异步同步（最佳实现）</li>
</ol>
<h4 id="3、详解"><a href="#3、详解" class="headerlink" title="3、详解"></a>3、详解</h4><h5 id="1、先更新数据库，后更新缓存（不推荐）"><a href="#1、先更新数据库，后更新缓存（不推荐）" class="headerlink" title="1、先更新数据库，后更新缓存（不推荐）"></a>1、先更新数据库，后更新缓存（不推荐）</h5><p>这种场景一般是没有人使用的，主要原因是在==更新缓存==那一步，为什么呢？</p>
<ol>
<li>其一：因为有的业务需求缓存中存在的值并不是直接从数据库中查出来的，有的是<strong>需要经过一系列计算来的缓存值</strong>，那么这时候后你要更新缓存的话其实代价是很高的。如果此时有大量的对数据库进行写数据的请求，但是读请求并不多，那么此时如果每次写请求都更新一下缓存，那么性能损耗是非常大的。<ul>
<li>例子：比如在数据库中有一个值为 1 的值，此时我们有 10 个请求对其每次加一的操作，但是这期间并没有读操作进来，如果用了先更新数据库的办法，那么此时就会有十个请求对缓存进行更新，会有大量的冷数据产生，如果我们不更新缓存而是删除缓存，那么在有读请求来的时候那么就会只更新缓存一次。</li>
</ul>
</li>
<li>其二：存在缓存数据和数据库数据不一致情况<ul>
<li>例子：当有两个线程A、B，同时对一条数据进行操作，一开始数据库和redis的数据都为tony，当线程A去修改数据库，将tong改为allen，然后线程A在修改缓存中的数据，可能因为网络原因出现延迟，这个时候线程B，将数据库中的数据修改成了Mike、然后将redis中的tony，也改成了Mike，然后线程A恢复正常，将redis中的缓存改成了allen，此时就出现了缓存数据和数据库数据不一致情况。</li>
<li>这种情况是很致命的，因为在这个值被重新修改或过期之前，A和B读取的都是错误数据。</li>
</ul>
</li>
</ol>
<h5 id="2、先更新缓存，后更新数据库（不推荐）"><a href="#2、先更新缓存，后更新数据库（不推荐）" class="headerlink" title="2、先更新缓存，后更新数据库（不推荐）"></a>2、先更新缓存，后更新数据库（不推荐）</h5><p>这一种情况和第一种情况是一样的，主要原因是在==更新缓存==那一步：</p>
<ol>
<li>其一：缓存的数据可能需要经过计算，如果每次写请求都更新一下缓存，那么性能损耗是非常大的。</li>
<li>其二：存在缓存数据和数据库数据不一致情况<ul>
<li>当有两个线程A、B，同时对一条数据进行操作，线程A先将redis中 的数据修改为了allen，然后CPU切换到了线程B，将redis中的数据修改为了mike，然后将数据库中的信息也修改了mike，然后线程A获得CPU执行，将数据库中的信息改为了allen，此时出现缓存和数据库数据不一致情况。</li>
</ul>
</li>
</ol>
<h5 id="3、先删除缓存，后更新数据库（存在问题）-推荐"><a href="#3、先删除缓存，后更新数据库（存在问题）-推荐" class="headerlink" title="3、先删除缓存，后更新数据库（存在问题）(推荐)"></a>3、先删除缓存，后更新数据库（存在问题）(推荐)</h5><p>该方案也会出问题，具体出现的原因如下：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/1.png" alt="先删除缓存，后更新数据库"></p>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 会先删除 Redis 中的数据，然后去数据库进行更新操作</li>
<li>此时请求 B 看到 Redis 中的数据时空的，会去数据库中查询该值，补录到 Redis 中</li>
<li>但是此时请求 A 并没有更新成功，或者事务还未提交，那么这时候就会产生数据库和 Redis 数据不一致的问题</li>
</ol>
<p>如何解决呢？</p>
<ul>
<li>其实最简单的解决办法就是==延时双删==的策略。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/2.png" alt="延时双删"></p>
<p>但是上述的保证事务提交完以后再进行删除缓存还有一个问题：</p>
<ul>
<li>就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/3.png" alt="主从同步时间差"></p>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 更新操作，删除了 Redis</li>
<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>
<li>请 B 查询操作，发现 Redis 中没有数据</li>
<li>去从库中拿去数据</li>
<li>此时同步数据还未完成，拿到的数据是旧数据</li>
</ol>
<p>此时的解决办法：<strong>如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询</strong>。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/4.png" alt="从主库中拿数据"></p>
<h5 id="4、先更新数据库，后删除缓存（推荐）"><a href="#4、先更新数据库，后删除缓存（推荐）" class="headerlink" title="4、先更新数据库，后删除缓存（推荐）"></a>4、先更新数据库，后删除缓存（推荐）</h5><p>问题：这一种情况也会出现问题：</p>
<ol>
<li><strong>可能会短暂出现数据不一致情况，但最终都会一致</strong>。<ul>
<li>当有两个线程A、B，线程A先去将数据库的值修改为allen，然后需要去删除redis中的缓存，当线程B去读取缓存时，线程A已经完成delete操作时，缓存不命中，需要去查询数据库，然后在更新缓存，数据一致性；如果线程A没有完成delete操作，线程B直接命中，返回的数据与数据库中的数据不一致，可能会短暂出现数据不一致情况，但最终都会一致。</li>
<li>当有两个线程A、B，线程A去修改数据库中的值改为allen，然后出现网络波动，线程B将数库中的值修改为了Mike，然后两个线程都会删除缓存，保证数据一致性</li>
</ul>
</li>
<li><strong>当数据过期或者初始化时，会出现数据不一致情况</strong>，也就是线程B从数据库中，查询到数据为tony，然后线程A将tony修改为了allen，然后去删除redis中的数据，然后线程B将读到的tony，更新到了数据库中，出现了数据不一致问题<ul>
<li>解决方案：对于不过期的数据我们要在上线的时候做好数据的预热，保证缓存命中。对于存在过期的数据，因为有过期时间，只会在特定的时间段内数据不一致，下次数据过期后，可以恢复，对于实时性要求不高时，可以接受。</li>
</ul>
</li>
<li>更新数据库成功了，但是<strong>在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</strong></li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/5.png" alt="先更新数据库，后删除缓存"></p>
<p>此时解决方案就是<strong>利用消息队列进行删除的补偿</strong>。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
<p>但是这个方案会有一个缺点就是<strong>会对业务代码造成大量的侵入，深深的耦合在一起</strong>，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<p>这也是第5种解决方法：数据异步同步</p>
<h5 id="5、数据异步同步（最佳实现）"><a href="#5、数据异步同步（最佳实现）" class="headerlink" title="5、数据异步同步（最佳实现）"></a>5、数据异步同步（最佳实现）</h5><p>对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<p>Canal：基于数据库增量日志解析，提供增量数据订阅和消费<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>mysql会将操作记录在Binary log日志中，通过canal去监听数据库日志二进制文件，解析log日志，同步到redis中进行增删改操作。</p>
<p>canal的工作原理：canal 模拟 MySQL slave 的交互协议，<strong>伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</strong>；MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )；canal 解析 binary log 对象(原始为 byte 流)。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/6.png" alt="利用订阅 binlog 删除缓存"></p>
<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p>每种方案各有利弊，比如在第二种先删除缓存，后更新数据库这个方案我们最后讨论了要更新 Redis 的时候强制走主库查询就能解决问题，那么这样的操作会对业务代码进行大量的侵入，但是不需要增加的系统，不需要增加整体的服务的复杂度。</p>
<p>最后一种方案我们最后讨论了利用订阅 binlog 日志进行搭建独立系统操作 Redis，这样的缺点其实就是增加了系统复杂度。其实每一次的选择都需要我们对于我们的业务进行评估来选择，没有一种技术是对于所有业务都通用的。没有最好的，只有最适合我们的。</p>
<h2 id="7、LUA脚本"><a href="#7、LUA脚本" class="headerlink" title="7、LUA脚本"></a>7、LUA脚本</h2><h3 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>Redis2.6之后新增的功能，我们可以在redis中通过lua脚本操作redis。与事务不同的是事务是将多个命令添加到一个执行的集合，执行的时候仍然是多个命令，会受到其他客户端的影响，而<strong>脚本会将多个命令和操作当成一个命令在redis中执行，也就是说该脚本在执行的过程中，不会被任何其他脚本或命令打断干扰</strong>。正是因此这种原子性，<strong>lua脚本才可以代替multi和exec的事务功能</strong>。同时也是因此，<strong>在lua脚本中不宜进行过大的开销操作，避免影响后续的其他请求的正常执行。</strong></p>
<h3 id="2、使用lua脚本的好处"><a href="#2、使用lua脚本的好处" class="headerlink" title="2、使用lua脚本的好处"></a>2、使用lua脚本的好处</h3><ul>
<li>lua脚本是作为一个整体执行的，所以中间不会被其他命令插入</li>
<li>可以把多条命令一次性打包，所以可以有效减少网络开销;</li>
<li>lua脚本可以常驻在redis内存中，所以在使用的时候，可以直接拿来复用。也减少了代码量</li>
</ul>
<h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><p>redis脚本使用eval命令执行lua脚本，其中numkeys表示lua script里有多少个key参数，redis脚本根据该数字从后面的key和arg中取前n个作为key参数，之后的都作为arg参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval script numkeys key [key ...] <span class="built_in">arg</span> [<span class="built_in">arg</span> ...]</span><br></pre></td></tr></table></figure>

<h4 id="1、例1：记录IP登录次数"><a href="#1、例1：记录IP登录次数" class="headerlink" title="1、例1：记录IP登录次数"></a>1、例1：记录IP登录次数</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 利用hash记录所有登录的IP次数</span><br><span class="line"># key参数的数量必须和numkey一致，使用key或者argv可以实现一样的效果。如下面第一个命令里用了三个key，代表后面的三个参数分别对应脚本里的key1 key2 key3.第二个命令里用了一个key，代表了后面第一个参数对应脚本里的key1，后面第二和第三个参数对应脚本里的argv1和argv2</span><br><span class="line">eval <span class="string">&quot;return redis.call(&#x27;hincrby&#x27;, KEYS[1], KEYS[2], KEYS[3])&quot;</span> <span class="number">3</span> h_host host_192<span class="number">.168</span><span class="number">.145</span><span class="number">.1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">eval <span class="string">&quot;return redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], ARGV[2])&quot;</span> <span class="number">1</span> h_host host_192<span class="number">.168</span><span class="number">.145</span><span class="number">.1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/18.png" alt="img"></p>
<h4 id="2、例2：当10秒内请求3次后拒绝访问"><a href="#2、例2：当10秒内请求3次后拒绝访问" class="headerlink" title="2、例2：当10秒内请求3次后拒绝访问"></a>2、例2：当10秒内请求3次后拒绝访问</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>给访问ip的key递增</span><br><span class="line"># <span class="number">2.</span>判断该访问次数若为首次登录则设置过期时间<span class="number">10</span>秒</span><br><span class="line"># <span class="number">3.</span>若不是首次登录则判断是否大于<span class="number">3</span>次，若大于则返回<span class="number">0</span>，否则返回<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">eval <span class="string">&quot;local request_times = redis.call(&#x27;incr&#x27;,KEYS[1]);if request_times == 1 then redis.call(&#x27;expire&#x27;,KEYS[1], ARGV[1]) end;if request_times &gt; tonumber(ARGV[2]) then return 0 end return 1;&quot;</span> <span class="number">1</span> test_127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/19.png" alt="img"></p>
<p>通过上面的例子也可以看出，我们可以在redis里使用eval命令调用lua脚本，且该脚本在redis里作为单条命令去执行不会受到其余命令的影响，非常适用于<strong>高并发场景下</strong>的事务处理。同样我们可以在lua脚本里实现任何想要实现的功能，迭代，循环，判断，赋值 都是可以的。</p>
<h3 id="4、lua脚本缓存"><a href="#4、lua脚本缓存" class="headerlink" title="4、lua脚本缓存"></a>4、lua脚本缓存</h3><p><strong>redis脚本也支持将脚本进行持久化</strong>，这样的话，下次再使用就不用输入那么长的lua脚本了。<strong>事实上使用eval执行的时候也会缓存，eval与load不同的是eval会将lua脚本执行并缓存，而load只会将脚本缓存</strong>。</p>
<p><strong>相同点是它们都使用sha算法进行缓存</strong>，因此只要lua脚本内容相同，eval与load缓存的sha码就是一样的。而缓存后的脚本，我们可以使用<code>evalsha</code>命令直接调用，极大的简化了我们的代码量，不用重复的将lua脚本写出来。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eval 执行脚本并缓存</span></span><br><span class="line"><span class="built_in">eval</span> script numkeys key [key ...] arg [arg ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#load 缓存lua脚本</span></span><br><span class="line">SCRIPT LOAD script</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用缓存的脚本sha码调用脚本</span></span><br><span class="line">EVALSHA sha1 numkeys key [key ...] arg [arg ...] </span><br><span class="line"></span><br><span class="line"><span class="comment">#使用sha码判断脚本是否已缓存</span></span><br><span class="line">SCRIPT EXISTS sha1 [sha1 ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#清空所有缓存的脚本</span></span><br><span class="line">SCRIPT FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment">#杀死当前正在执行的所有lua脚本</span></span><br><span class="line">SCRIPT KILL</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/20.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/21.png" alt="img"></p>
<h2 id="8、Redis6新特性之ACL安全策略（用户权限管理）"><a href="#8、Redis6新特性之ACL安全策略（用户权限管理）" class="headerlink" title="8、Redis6新特性之ACL安全策略（用户权限管理）"></a>8、Redis6新特性之ACL安全策略（用户权限管理）</h2><p>自从Redis6.0以来，大家呼吁了很久的权限管理功能**(ACL[access control list 访问控制列表])<strong>终于发布了，通过此功能，我们可以</strong>设置不同的用户并对他们授权命令或数据权限<strong>。这样我们可以</strong>避免有些用户的误操作导致数据丢失或避免数据泄露**的安全风险。</p>
<h3 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>在Redis6之前的版本，我们只能使用requirepass参数给default用户配置登录密码，<strong>同一个redis集群的所有开发都共享default用户，难免会出现误操作把别人的key删掉或者数据泄露的情况</strong>，那之前我们也可以使用rename command的方式给一些危险函数重命名或禁用，但是这样也<strong>防止不了自己的key被其他人访问</strong>。</p>
<p>因此Redis6版本推出了ACL(Access Control List)访问控制权限的功能，基于此功能，<strong>我们可以设置多个用户，并且给每个用户单独设置命令权限和数据权限</strong>。 为了保证向下兼容，<strong>Redis6保留了default用户和使用requirepass的方式给default用户设置密码，默认情况下default用户拥有Redis最大权限，我们使用redis-cli连接时如果没有指定用户名，用户也是默认default。</strong></p>
<p>我们可以在<strong>配置文件</strong>中或者<strong>命令行</strong>中设置ACL，如果<strong>使用配置config文件的话需要重启服务</strong>，<strong>使用配置aclfile文件或者命令行授权的话无需重启Redis服务但需要及时将权限持久化到磁盘，否则下次重启的时候无法恢复该权限。</strong> </p>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p>
<h3 id="2、配置文件模式"><a href="#2、配置文件模式" class="headerlink" title="2、配置文件模式"></a>2、配置文件模式</h3><p>配置ACL的方式有两种，一种是<strong>在config文件中直接配置</strong>，另一种是<strong>在外部aclfile中配置</strong>。配置的命令是一样的，但是两种方式只能选择其中一种，我们之前使用requirepass给default用户设置密码，默认就是使用config的方式，<strong>执行config rewrite重写配置后会自动在config文件最下面新增一行记录配置default的密码和权限</strong>。</p>
<h4 id="1、conf文件模式"><a href="#1、conf文件模式" class="headerlink" title="1、conf文件模式"></a>1、conf文件模式</h4><p><strong>使用redis.conf文件配置default和其他用户的ACL权限</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.在config文件中配置default用户的密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.在config文件中添加DSL命令配置用户ACL权限</span></span><br><span class="line">【使用方式在下文】</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.在config文件中注释aclfile的路径配置(默认是注释的)</span></span><br><span class="line"><span class="comment">#aclfile /opt/app/redis6/users.acl</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4.重启redis服务</span></span><br><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/24.png" alt="img"></p>
<p>因此我们可以直接在config配置文件中使用上面default用户ACL这行DSL命令设置用户权限，或者我们也可以配置外部aclfile配置权限。</p>
<p>配置aclfile需要先将config中配置的DSL注释或删除，因为Redis不允许两种ACL管理方式同时使用，否则在启动redis的时候会报下面的错误：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Configuring Redis with users defined in redis.conf and at the same setting an ACL file path is invalid. This setup is very likely to lead to configuration errors and security holes, please define either an ACL file or declare users directly in your redis.conf, but not both.</span></span><br></pre></td></tr></table></figure>



<h4 id="2、外部ACLFILE模式"><a href="#2、外部ACLFILE模式" class="headerlink" title="2、外部ACLFILE模式"></a>2、外部ACLFILE模式</h4><p><strong>使用外部aclfile文件配置Default和其他用户的ACL权限</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.注释redis.conf中所有已授权的ACL命令，如：</span></span><br><span class="line"><span class="comment">#user default on #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* +@all</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.在config文件中注释default用户的密码，因为开启aclfile之后，requirepass的密码就失效了：</span></span><br><span class="line">redis.conf</span><br><span class="line"><span class="comment">#requirepass 123456</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># users.acl</span></span><br><span class="line">user default on <span class="comment">#8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* +@all</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.在config文件中配置aclfile的路径，然后创建该文件，否则重启redis服务会报错找不到该文件</span></span><br><span class="line">aclfile /opt/app/redis6/users.acl</span><br><span class="line">touch /opt/app/redis6/users.acl</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4.在外部aclfile文件中添加DSL命令配置用户ACL权限</span></span><br><span class="line">【使用方式在下文】</span><br><span class="line"> </span><br><span class="line"><span class="comment">## 5.重启redis服务或使用aclfile load命令加载权限</span></span><br><span class="line">systemctl restart redis</span><br><span class="line">或</span><br><span class="line">在redis命令行中执行：</span><br><span class="line">aclfile load</span><br></pre></td></tr></table></figure>

<p>开启aclfile之后不再推荐在redis.conf文件中通过requirepass配置default的密码，因为它不再生效，同时开启aclfile之后也不能使用redis-cli -a xxx登陆，必须使用redis-cli –user xxx  –pass yyy来登陆： </p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/25.png" alt="img"></p>
<h3 id="3、对比conf和aclfile模式"><a href="#3、对比conf和aclfile模式" class="headerlink" title="3、对比conf和aclfile模式"></a>3、对比conf和aclfile模式</h3><p>在redis.conf和aclfile模式中配置DSL <strong>官方更推荐使用aclfile</strong>，因为如果在redis.conf中配置了权限之后需要重启redis服务才能将配置的权限加载至redis服务中来，但如果使用aclfile模式，可以调用acl load命令将aclfile中配置的ACL权限热加载进环境中，类似于Mysql中的flush privileges。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">redis.conf</th>
<th>users.acl</th>
</tr>
</thead>
<tbody><tr>
<td align="left">配置方式</td>
<td align="left">DSL</td>
<td>DSL</td>
</tr>
<tr>
<td align="left">加载ACL配置</td>
<td align="left">重启Redis服务</td>
<td>ACL LOAD命令</td>
</tr>
<tr>
<td align="left">持久化ACL配置</td>
<td align="left">CONFIG REWRITE命令</td>
<td>ACL SAVE命令</td>
</tr>
</tbody></table>
<h3 id="4、命令行模式"><a href="#4、命令行模式" class="headerlink" title="4、命令行模式"></a>4、命令行模式</h3><h4 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>上面可以看到，我们在配置文件中配置的ACL权限，需要执行ACL LOAD或者重启Redis服务才能生效，事实上我们可以直接在命令行下配置ACL，在命令行模式下配置的权限无需重启服务即可生效。我们也可以在命令行模式下配置ACL并将其持久化到aclfile或者config文件中(这取决于配置文件中选择的是config模式还是外部aclfile模式)，一旦将权限持久化到aclfile或cofig文件中，下次重启就会自动加载该权限，如果忘记持久化，一旦服务宕机或重启，该权限就会丢失。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用config模式，将ACL权限持久化到redis.conf文件中使用下面的命令：</span></span><br><span class="line">config rewrite</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果使用aclfile模式，将ACL权限持久化到users.acl文件中使用下面的命令：</span></span><br><span class="line">acl save</span><br></pre></td></tr></table></figure>



<h4 id="2、ACL规则"><a href="#2、ACL规则" class="headerlink" title="2、ACL规则"></a>2、ACL规则</h4><p>ACL是使用DSL（Domain specific language）定义的，该DSL描述了用户能够执行的操作。<strong>该规则始终从上到下，从左到右应用</strong>，因为规则的顺序对于理解用户的实际权限很重要。ACL规则可以在redis.conf文件以及users.acl文件中配置DSL，也可以在命令行中通过ACL命令配置。</p>
<p>某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>启动用户</td>
<td>on</td>
<td>激活某用户账号</td>
</tr>
<tr>
<td>禁用用户</td>
<td>off</td>
<td>禁用某用户账号。注意：已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td>
</tr>
<tr>
<td>权限的添加删除</td>
<td>+<command></td>
<td>将指令添加到用户可以调用的指令列表中</td>
</tr>
<tr>
<td></td>
<td>-<command></td>
<td>从用户可执行指令列表移除指令</td>
</tr>
<tr>
<td></td>
<td>+<command> | subcommand</td>
<td>允许使用已禁用命令的特定子命令</td>
</tr>
<tr>
<td></td>
<td>+@<category></category></td>
<td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td>
</tr>
<tr>
<td></td>
<td>-@<category></category></td>
<td>从用户可调用指令中移除类别</td>
</tr>
<tr>
<td></td>
<td>allcommands</td>
<td>+@all的别名</td>
</tr>
<tr>
<td></td>
<td>nocommand</td>
<td>-@all的别名</td>
</tr>
<tr>
<td>可操作键的添加或删除</td>
<td>~<pattern></pattern></td>
<td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td>
</tr>
<tr>
<td>禁止访问某些Key</td>
<td>* resetkeys</td>
<td>使用当前模式覆盖所有允许的模式。如： ~foo:* ~bar:* resetkeys ~objects:* ，客户端只能访问匹配 object:* 模式的 KEY。</td>
</tr>
</tbody></table>
<p><strong>为用户配置有效密码</strong>：</p>
<ul>
<li><code>&gt;&lt;password&gt;</code>：将此密码添加到用户的有效密码列表中。例如，<code>&gt;mypass</code>将“mypass”添加到有效密码列表中。该命令会清除用户的<em>nopass</em>标记。每个用户可以有任意数量的有效密码。</li>
<li><code>&lt;&lt;password&gt;</code>：从有效密码列表中删除此密码。若该用户的有效密码列表中没有此密码则会返回错误信息。</li>
<li><code>#&lt;hash&gt;</code>：将此SHA-256哈希值添加到用户的有效密码列表中。该哈希值将与为ACL用户输入的密码的哈希值进行比较。允许用户将哈希存储在users.acl文件中，而不是存储明文密码。仅接受SHA-256哈希值，因为密码哈希必须为64个字符且小写的十六进制字符。</li>
<li><code>!&lt;hash&gt;</code>：从有效密码列表中删除该哈希值。当不知道哈希值对应的明文是什么时很有用。</li>
<li><code>nopass</code>：移除该用户已设置的所有密码，并将该用户标记为nopass无密码状态：任何密码都可以登录。<em>resetpass</em>命令可以清除nopass这种状态。</li>
<li><code>resetpass</code>：清空该用户的所有密码列表。而且移除<em>nopass</em>状态。<em>resetpass</em>之后用户没有关联的密码同时也无法使用无密码登录，因此<em>resetpass</em>之后必须添加密码或改为<em>nopass</em>状态才能正常登录。</li>
<li><code>reset</code>：重置用户状态为初始状态。执行以下操作resetpass，resetkeys，off，-@all。</li>
</ul>
<h3 id="5、ACL-HELP"><a href="#5、ACL-HELP" class="headerlink" title="5、ACL HELP"></a>5、ACL HELP</h3><p>使用下面的命令查看help文档：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/26.png" alt="img"></p>
<h3 id="6、ACL-LIST"><a href="#6、ACL-LIST" class="headerlink" title="6、ACL LIST"></a>6、ACL LIST</h3><p>我们可以使用ACL LIST命令来查看当前活动的ACL，默认情况下，有一个“<em>default</em>”用户：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; acl list</span><br><span class="line">1) <span class="string">&quot;user default on nopass ~* +@all&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中user为关键词，default为用户名，后面的内容为ACL规则描述，on表示活跃的，nopass表示无密码， ~* 表示所有key，+@all表示所有命令。所以上面的命令表示活跃用户default无密码且可以访问所有命令以及所有数据。</p>
<h3 id="7、ACL-USERS"><a href="#7、ACL-USERS" class="headerlink" title="7、ACL USERS"></a>7、ACL USERS</h3><p>返回所有用户名：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; acl users</span><br><span class="line">1) <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="8、ACL-WHOAMI"><a href="#8、ACL-WHOAMI" class="headerlink" title="8、ACL WHOAMI"></a>8、ACL WHOAMI</h3><p>返回当前用户名：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; acl whoami</span><br><span class="line">1) <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="9、ACL-CAT"><a href="#9、ACL-CAT" class="headerlink" title="9、ACL CAT"></a>9、ACL CAT</h3><p>查看命令类别，用于授权：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACL CAT:显示所有的命令类别 。</span><br><span class="line">ACL CAT &lt;category&gt;:显示所有指定类别下的所有命令。 </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200617164523228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZGMwNTIx,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="10、ACL-SETUSER"><a href="#10、ACL-SETUSER" class="headerlink" title="10、ACL SETUSER"></a>10、ACL SETUSER</h3><p>使用下面的命令创建或修改用户属性，<strong>username区分大小写</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># username区分大小写</span></span><br><span class="line"><span class="comment"># 若用户不存在则按默认规则创建用户，若存在则修改用户属性</span></span><br><span class="line">SETUSER &lt;username&gt; [attribs ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若用户不存在，则按默认规则创建用户。若用户存在则该命令不做任何操作。</span></span><br><span class="line">ACL SETUSER &lt;username&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 若用户不存在，则按默认规则创建用户，并为其增加&lt;rules&gt;。</span></span><br><span class="line"><span class="comment"># 若用户存在则在已有规则上增加 &lt;rules&gt;。</span></span><br><span class="line">ACL SETUSER &lt;username&gt; &lt;rules&gt; </span><br></pre></td></tr></table></figure>

<p>默认规则下新增的用户处于非活跃状态，且没有密码，同时也没有任何命令和key的权限： </p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/27.png" alt="img"></p>
<p>例：使用下面的命令<strong>新增用户/修改用户</strong>的权限：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#on为活跃状态，密码为wyk123456，允许对所有csdn开头的key使用get和set命令</span></span><br><span class="line">ACL SETUSER wyk on &gt;wyk123456 ~csdn* +get +<span class="built_in">set</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#为wyk用户新增一个可用密码csdn8888</span></span><br><span class="line">ACL SETUSER wyk on &gt;csdn8888</span><br><span class="line"> </span><br><span class="line"><span class="comment">#为wyk用户新增list类别下所有命令的权限</span></span><br><span class="line">ACL SETUSER wyk on +@list</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/28.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/29.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/30.png" alt="img"></p>
<h3 id="11、ACL-GETUSER"><a href="#11、ACL-GETUSER" class="headerlink" title="11、ACL GETUSER"></a>11、ACL GETUSER</h3><p>使用下面的命令查看用户的ACL权限：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看用户的ACL权限</span></span><br><span class="line">acl getuser &lt;username&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/31.png" alt="img"></p>
<h3 id="12、ACL-DELUSER"><a href="#12、ACL-DELUSER" class="headerlink" title="12、ACL DELUSER"></a>12、ACL DELUSER</h3><p>删除指定的用户：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除指定的用户</span></span><br><span class="line">acl deluser &lt;username&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/32.png" alt="img"></p>
<h3 id="13、ACL-SAVE"><a href="#13、ACL-SAVE" class="headerlink" title="13、ACL SAVE"></a>13、ACL SAVE</h3><p>前面提到过，我们可以使用acl save命令将当前服务器中的ACL权限持久化到aclfile中，如果没持久化就关闭redis服务，那些ACL权限就会丢失，因此我们每次授权之后一定要记得ACL SAVE将ACL权限持久化到aclfile中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将acl权限持久化到磁盘的aclfile中</span></span><br><span class="line">acl save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用redis.conf配置ACL，则使用config rewrite命令将ACL持久化到redis.conf中</span></span><br><span class="line">config rewrite</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/33.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/34.png" alt="img"></p>
<h3 id="14、ACL-LOAD"><a href="#14、ACL-LOAD" class="headerlink" title="14、ACL LOAD"></a>14、ACL LOAD</h3><p>我们也可以直接在aclfile中修改或新增ACL权限，修改之后不会立刻生效，我们可以在redis命令行中执行acl load将该aclfile中的权限加载至redis服务中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将aclfile中的权限加载至redis服务中</span></span><br><span class="line">acl load</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/35.png" alt="img"></p>
<h3 id="15、ACL-GENPASS"><a href="#15、ACL-GENPASS" class="headerlink" title="15、ACL GENPASS"></a>15、ACL GENPASS</h3><p>随机返回sha256密码，我们可以直接使用该密文配置ACL密码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机返回一个256bit的32字节的伪随机字符串，并将其转换为64字节的字母+数字组合字符串</span></span><br><span class="line">acl genpass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可指定位数</span></span><br><span class="line">acl genpass 32</span><br><span class="line">acl genpass 64</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/36.png" alt="img"></p>
<h3 id="16、ACL-LOG"><a href="#16、ACL-LOG" class="headerlink" title="16、ACL LOG"></a>16、ACL LOG</h3><p>查看ACL安全日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">log</span></span><br></pre></td></tr></table></figure>



<h3 id="17、AUTH"><a href="#17、AUTH" class="headerlink" title="17、AUTH"></a>17、AUTH</h3><p>使用auth命令切换用户：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH &lt;username&gt; &lt;password&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/37.png" alt="img"></p>
<h3 id="18、总结"><a href="#18、总结" class="headerlink" title="18、总结"></a>18、总结</h3><p>由于Redis是高性能的数据库，正常情况下每秒可以接收百万级别的请求，因此我们的用户密码一定要是非常复杂的组合，否则很容易就会被暴力跑字典给破解了，不管怎么说，这次Redis6版本带来的新特性ACL权限控制也是解决了我们很大的痛点，终于可以权限隔离了！</p>
<h2 id="9、Redis6新特性之RESP3与客户端缓存-Client-side-caching"><a href="#9、Redis6新特性之RESP3与客户端缓存-Client-side-caching" class="headerlink" title="9、Redis6新特性之RESP3与客户端缓存(Client side caching)"></a>9、Redis6新特性之RESP3与客户端缓存(Client side caching)</h2><p>Redis6引入新的RESP3协议，并以此为基础加入了客户端缓存的新特性，在此特性下，大大提高了应用程序的响应速度，并降低了数据库的压力。</p>
<h3 id="1、什么是客户端缓存"><a href="#1、什么是客户端缓存" class="headerlink" title="1、什么是客户端缓存"></a>1、什么是客户端缓存</h3><h4 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>客户端缓存是一种用于<strong>创建高性能服务</strong>的技术，在此技术下，应用程序端将数据库中的数据缓存在应用端的内存中，<strong>当应用程序访问数据时直接从本机内存中读取</strong>，而无需连接数据库端，减少了网络IO，提升了应用程序的响应速度，同时也减少了数据库端的压力。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/topics/client-side-caching">https://redis.io/topics/client-side-caching</a></p>
<p>Why RESP3：<a target="_blank" rel="noopener" href="http://antirez.com/news/125">http://antirez.com/news/125</a></p>
<p>没有客户端缓存： </p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/47.png" alt="img"></p>
<blockquote>
<p>应用端先查询Redis端，如果没有Redis缓存则到源数据库端查询，如果有则直接从Redis端查询数据，更新数据时直接更新MySQL端并同步至Redis内；</p>
</blockquote>
<p>有客户端缓存：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/48.png" alt="img"></p>
<blockquote>
<p>应用端先查询本地缓存如Guava、Caffeine，若没有本地缓存则访问Redis缓存，如果Redis缓存中也没有则查询源数据库；</p>
</blockquote>
<h4 id="2、客户端缓存的优点"><a href="#2、客户端缓存的优点" class="headerlink" title="2、客户端缓存的优点"></a>2、客户端缓存的优点</h4><ul>
<li>降低了客户端的数据延迟，提升客户端的响应速度；</li>
<li>数据库端接收的查询减少，降低了数据库端的压力，因此在相同的数据集下可以使用更少的节点提供服务；</li>
</ul>
<p>疑问：</p>
<p>为了实现客户端缓存，我们面临这样的问题，当进程中缓存了数据，而数据库端数据发生变更，该如何通知到进程，避免客户端显示失效的数据呢？(缓存一致性)</p>
<p>在Redis中可以使用发布订阅机制，向客户端发布数据失效的通知，但该模式下<strong>即使某些客户端中没有包含过期数据也会向所有客户端发送无效的消息，非常影响数据库的性能</strong>。</p>
<blockquote>
<p>在之前的版本中，客户端缓存采用<strong>缓存槽(caching slot)**的方式记录每个客户端内的key是否发生变化以及时同步，最新版中已弃用该方式，而是采用</strong>记录key的名称或前缀**。 </p>
</blockquote>
<h3 id="2、什么是RESP3"><a href="#2、什么是RESP3" class="headerlink" title="2、什么是RESP3"></a>2、什么是RESP3</h3><p>RESP 全称 <code>REdisSerializationProtocol</code>，是 <strong>Redis 服务端与客户端之间通信的协议</strong>。在Reds6之前的版本，使用的是<strong>RESP2协议</strong>，数据都是<strong>以<code>字符串数组</code>的形式返回给客户端</strong>，不管是 list 还是 sorted set。因此客户端需要自行去根据类型进行解析，这样会增加了客户端实现的复杂性。</p>
<p>为了照顾老用户，Redis6在兼容 RESP2 的基础上，开始支持 RESP3，但未来会全面切换到RESP3之上。今天的客户端缓存在基于RESP3才能有更好的实现，可以在同一个连接中运行数据的查询和接收失效消息。而目前在RESP2上实现的客户端缓存，<strong>需要两个客户端连接以转发重定向的形式实现。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用RESP2协议</span></span><br><span class="line">HELLO 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用RESP3协议</span></span><br><span class="line">HELLO 3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/49.png" alt="img"></p>
<h3 id="3、客户端缓存的实现方式"><a href="#3、客户端缓存的实现方式" class="headerlink" title="3、客户端缓存的实现方式"></a>3、客户端缓存的实现方式</h3><p>Redis客户端缓存被称为Tracking，在RESP3协议下，有两种模式：</p>
<ul>
<li><strong>默认模式</strong>：服务器记录客户端访问了哪些key，当其中的key发生变更时给客户端发送失效信息，消耗服务器端内存；</li>
<li><strong>广播模式</strong>：客户端订阅访问过的key的前缀，当符合模式的key发生变更就会被通知（即使变更的key没有被客户端缓存），服务器端不记录客户端访问的key，因此不会消耗服务器端的内存；</li>
</ul>
<h3 id="4、默认模式"><a href="#4、默认模式" class="headerlink" title="4、默认模式"></a>4、默认模式</h3><h4 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h4><p><strong>服务器端会记录访问key的客户端列表并维护一个表，这个表被称为==失效表==(Invalidation Table)，如果插入一个新的key，服务器端会给客户端发送失效信息并从客户端踢除该key，避免提供过时数据。</strong></p>
<p><strong>在失效表中</strong>不会记录key和客户端内对应指针的映射关系，<strong>只会记录key的指针和各客户端ID（每个Redis客户端都有一个唯一ID)的映射关系</strong>，当发送完失效信息后，<strong>客户端剔除key</strong>，<strong>服务端从失效表中删除key的指针和客户端ID的映射关系</strong>。</p>
<p><strong>在失效表中key的命名空间只有一个</strong>，即是说，在db0~db15中相同的key名，在失效表中会记录在同一个命名空间内，即使客户端缓存的是db0内的key，如果db1内的同名key被更新，也会通知客户端剔除db0内的同名key。</p>
<p><strong>客户端缓存的操作就是对key的内存地址进行操作</strong>： </p>
<ol>
<li>当开启客户端缓存的客户端从Redis获取数据时，Redis服务端会调用 <code>enableTracking</code> 方法在上面的失效表中记录key和客户端ID的映射关系；</li>
<li>若key被修改，则Redis服务端会调用 <code>trackingInvalidateKey</code> 函数根据该key被缓存的客户端列表ID调用 <code>sendTrackingMessage</code> 函数向它们发送失效消息。(发送失效消息前会检查客户端的<code>Client_Tracking</code>和<code>NOLOOP</code>状态)</li>
<li>服务端发送完失效消息后会从失效表中将该key与客户端ID的映射关系删除；</li>
<li>由于客户端可能会在开启之后关闭了缓存功能，在失效表中删除key和该客户端ID之间的映射关系比较消耗性能，因此<strong>服务端采用懒删除的方式</strong>，<strong>只是将该客户端的Client_Tracking相关标志位删除</strong>；</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/50.png" alt="img"></p>
<h4 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h4><p>上面提到我们可以使用HELLO命令切换RESP3协议，在此协议下我们使用tracking命令开启track追踪，此时服务端会记录客户端在连接的生命周期内的只读的key，当客户端开启track追踪后，key的数据会被缓存在客户端内存中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启RESP3协议</span></span><br><span class="line">HELLO 3</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启tracking 客户端缓存</span></span><br><span class="line">client tracking on</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭tracking 客户端缓存</span></span><br><span class="line">client tracking off</span><br></pre></td></tr></table></figure>

<p>为了演示失效消息的通知，这里使用telnet测试客户端缓存，然后在另一个redis-cli对key做操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用telnet连接客户端</span></span><br><span class="line">telnet wykd 6379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># auth命令登录服务器(如果没有密码可以忽略)</span></span><br><span class="line">auth default wyk123456</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启RESP3</span></span><br><span class="line">hello 3</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启客户端缓存 tracking</span></span><br><span class="line">client tracking on</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询一个key 同时该key会被缓存</span></span><br><span class="line">get name</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在另一个redis客户端中 修改/删除/过期/淘汰 该key</span></span><br><span class="line"><span class="built_in">set</span> name new_values</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在telnet窗口会收到key失效的消息如下：</span></span><br><span class="line">get name   <span class="comment">#客户端缓存key</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">wyk</span><br><span class="line"> </span><br><span class="line">&gt;2         <span class="comment">#失效消息</span></span><br><span class="line"><span class="variable">$10</span></span><br><span class="line">invalidate</span><br><span class="line">*1</span><br><span class="line"><span class="variable">$4</span></span><br><span class="line">name</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭客户端缓存 tracking，关闭后不会再收到key的失效消息</span></span><br><span class="line">client tracking off</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/51.png" alt="img"></p>
<blockquote>
<p>当开启了tracking后，<strong>客户端缓存的key如果在别处被修改为与原值一样，也会收到失效消息</strong>；</p>
<p>当客户端缓存失效后，该key再被修改时，客户端不会再收到消息，也就是再查询该key之后 才会在客户端缓存key的值；</p>
</blockquote>
<p>当客户端缓存的key因<strong>过期策略</strong>或<strong>内存淘汰策略</strong>被驱逐时，服务端也会发送失效消息给开启了tracking的客户端：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/52.png" alt="img"></p>
<p>当开启了tracking的客户端获取的key不存在时，如果在另一个客户端新增/修改了该key，那个tracking的客户端也会收到失效消息，可见<strong>如果key不存在也会在客户端缓存中缓存空值</strong>，这种结果因人而异，个人认为这样不太好：</p>
<ol>
<li>一是客户端会徒增大量的无用缓存（空值）</li>
<li>二是服务端的失效表会维护更多的key-&gt;clientID的映射关系。</li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/53.png" alt="img"></p>
<h3 id="5、广播模式"><a href="#5、广播模式" class="headerlink" title="5、广播模式"></a>5、广播模式</h3><h4 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h4><p>另一个客户端缓存的实现方式是<strong>广播模式(broadcasting)**，广播不会消耗服务端的内存，而是</strong>向各客户端发送更多的失效消息<strong>。广播模式与默认模式类似，不同的是</strong>广播模式下维护的是前缀表，在前缀表中存储客户端订阅的key前缀与客户端ID之间的映射关系。**</p>
<p>在这种模式下，有以下的主要行为：</p>
<ol>
<li>客户端使用 <code>BCAST</code> 选项开启客户端缓存的广播模式，并使用 <code>PREFIX</code> 指定一个或多个前缀。<strong>如果不指定前缀则默认客户端接收所有的key的失效消息</strong>，如果指定则只会接收匹配该前缀的key的失效消息；</li>
<li>在广播模式下，服务端维护的不是失效表，而是<strong>前缀表(Prefix Table)，每个前缀映射一些客户端ID</strong>；</li>
<li><strong>每次修改跟任意前缀匹配的键时，所有订阅该前缀的客户端都将收到失效消息</strong>；</li>
<li>服务端的CPU消耗与订阅的key前缀数量成正比，<strong>订阅的key前缀数量越多服务器端压力越大</strong>；</li>
<li><strong>服务器可以为订阅特定前缀的客户端创建单个回复，并向所有的客户端发送相同的回复来进行优化，有助于降低CPU使用率。</strong></li>
</ol>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/54.png" alt="img"></p>
<h4 id="2、应用-1"><a href="#2、应用-1" class="headerlink" title="2、应用"></a>2、应用</h4><p>同样，在广播模式下也需要开启RESP3协议，这里我们仍然使用刚才的telnet会话进行演示。</p>
<p>使用下面的命令开启广播模式的客户端缓存，上面提到广播模式下服务端维护一个前缀表，记录key的前缀和客户端id的映射关系，因此我们也可以在客户端指定需要接收失效消息的key前缀：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet访问redis客户端(略)</span></span><br><span class="line"><span class="comment"># 开启RESP3</span></span><br><span class="line">hello 3</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启广播模式的客户端缓存tracking，默认会收到所有的key的失效信息</span></span><br><span class="line">client tracking on bcast</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开启广播模式的客户端缓存tracking，只接受指定前缀&#x27;wyk&#x27;的key的失效信息</span></span><br><span class="line">client tracking on bcast prefix wyk</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/55.png" alt="img"></p>
<blockquote>
<p>广播模式下，<strong>只要符合客户端设置的key前缀的key发生新增、修改、删除、过期、淘汰等动作，即使该key没有被该客户端缓存，也会收到key的失效消息</strong>；</p>
</blockquote>
<h3 id="6、重定向模式"><a href="#6、重定向模式" class="headerlink" title="6、重定向模式"></a>6、重定向模式</h3><p>为了兼容RESP2协议，<strong>在Redis6中客户端缓存可以以重定向(Redirect)的方式实现</strong>，不再使用 RESP3 原生支持的PUSH消息，而是<strong>将消息通过 Pub/Sub 通知给另外一个客户端连接</strong>：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/56.png" alt="img"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看客户端id</span></span><br><span class="line">client id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于接收失效消息的客户端订阅频道</span></span><br><span class="line">subscribe _redis_:invalidate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端开启Tracking客户端缓存 并指定需要接收失效消息的客户端ID</span></span><br><span class="line">client tracking on bcast redirect receive_client_id</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/57.png" alt="img"></p>
<h3 id="7、OPTIN-和-OPTOUT"><a href="#7、OPTIN-和-OPTOUT" class="headerlink" title="7、OPTIN 和 OPTOUT"></a>7、OPTIN 和 OPTOUT</h3><p><strong>在默认模式或重定向模式下，我们可以有选择的对需要的key进行缓存</strong>，而由于广播模式是匹配key前缀，因此不能使用此命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RESP3 默认模式</span></span><br><span class="line"><span class="comment"># 切换RESP3协议</span></span><br><span class="line">hello 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启客户端缓存optin选项</span></span><br><span class="line">client tracking on optin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令后面第一个只读key会被缓存</span></span><br><span class="line">client caching yes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># RESP2 重定向模式</span></span><br><span class="line">hello 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启客户端缓存optin选项，1234是接收失效消息的客户端id</span></span><br><span class="line">client tracking on REDIRECT 1234 OPTIN  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令后面第一个只读key会被缓存</span></span><br><span class="line">client caching yes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>OPTIN</strong>：只有执行<em>client caching yes</em>之后的第一个key才会被缓存；</li>
<li><strong>OPTOUT</strong>：与OPTIN相反，执行<em>client caching no</em>之后的第一个只读key不会被缓存；</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/58.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/59.png" alt="img"></p>
<blockquote>
<p>注意：在redis6.0.3版本中outin和optout选项时灵时不灵，可能还有BUG；</p>
</blockquote>
<h3 id="8、NOLOOP选项"><a href="#8、NOLOOP选项" class="headerlink" title="8、NOLOOP选项"></a>8、NOLOOP选项</h3><p>我们的客户端修改自己已缓存的key的时候也会收到这个key的过期信息，事实上这个客户端是不需要收到该消息的，这造成了浪费，因此我们可以使用<strong>NOLOOP</strong>选项将该客户端设置为：本客户端修改的key不会收到相关的失效信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启客户端缓存的NOLOOP选项</span></span><br><span class="line">client tracking on noloop</span><br></pre></td></tr></table></figure>

<p>开启noloop选项的客户端，如果在该客户端上修改它已经缓存的key，自己不会收到该key的失效消息：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/60.png" alt="img"></p>
<p>没开启noloop选项的客户端，如果在该客户端上修改它已经缓存的key，自己也会收到该key的失效消息：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/61.png" alt="img"></p>
<h3 id="9、失效表key上限"><a href="#9、失效表key上限" class="headerlink" title="9、失效表key上限"></a>9、失效表key上限</h3><p>可以使用 <em>tracking_table_max_keys</em> 参数修改服务端失效表内记录的缓存的key的数量，当失效表内记录的缓存key达到配置的数量时会随机从失效表内移除缓存：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询最大缓存的数量</span></span><br><span class="line">config get tracking-table-max-keys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置最大缓存数量为300</span></span><br><span class="line">config <span class="built_in">set</span> tracking-table-max-keys 300</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/62.png" alt="img"></p>
<h2 id="10、Redis6新特性之集群代理-Cluster-Proxy"><a href="#10、Redis6新特性之集群代理-Cluster-Proxy" class="headerlink" title="10、Redis6新特性之集群代理(Cluster Proxy)"></a>10、Redis6新特性之集群代理(Cluster Proxy)</h2><p>在之前的文章中介绍了Redis6的集群搭建和原理，我们可以使用dummy和smart客户端连接集群，本篇介绍Redis6新增的一个功能：集群代理。<strong>客户端不需要知道集群中的具体节点个数和主从身份，可以直接通过代理访问集群，对于客户端来说通过集群代理访问的集群就和单机的Redis一样，因此也能解决很多集群的使用限制。</strong></p>
<h3 id="1、介绍-7"><a href="#1、介绍-7" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>在Redis6的release note中可以看到新功能中的ACL，RESP3，客户端缓存我们在前面的文章中已经介绍过，本篇就看一下集群代理。集群代理与Redis在Github上是不同的项目，地址如下：</p>
<p>Github：<a target="_blank" rel="noopener" href="https://github.com/RedisLabs/redis-cluster-proxy">https://github.com/RedisLabs/redis-cluster-proxy</a></p>
<p>集群代理（Redis Cluster Proxy）： <strong>将集群抽象为单实例，客户端不需要知道集群中的具体节点个数和主从身份，通过代理访问集群，就像访问单机Redis一样。同时集群代理也能解决在集群模式下multiple操作的限制及跨slot操作限制(如mget,mset…)。</strong></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/63.png" alt="img"></p>
<p>Redis集群代理的特点：</p>
<ul>
<li><strong>自动化路由</strong>：每个查询被自动路由到集群的正确节点；</li>
<li><strong>多线程</strong>：多路复用通信模型，每个线程都有自己的集群连接；</li>
<li><strong>顺序性</strong>：在多路复用上下文中，保证查询的执行和应答顺序；</li>
<li><strong>无感知更新集群信息</strong>：当请求/重定向错误时会自动更新集群信息，客户端提交的查询会在集群信息更新完成后重新执行，对于客户端来说这一切是无感的，客户端不会收到请求/重定向的错误信息，而是直接收到查询的结果；</li>
<li><strong>跨槽/节点查询</strong>：支持跨slot或node的mutiple操作key，如mget,mset,del等。但由于mset,del会破坏原子性，因此该配置默认关闭；</li>
<li><strong>ACL</strong>：支持连接开启了ACL的Redis集群；</li>
<li><strong>DBSIZE</strong>：对于没有指定节点的命令，将会合并所有的信息的总和并返回；</li>
</ul>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/64.png" alt="img"></p>
<h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><h4 id="1、下载解压"><a href="#1、下载解压" class="headerlink" title="1、下载解压"></a>1、下载解压</h4><p>从github上下载解压源码（2020-06-30：目前最新版是unstable版本）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git命令</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/artix75/redis-cluster-proxy</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 手动下载zip解压</span></span><br><span class="line">unzip redis-cluster-proxy-unstable.zip </span><br></pre></td></tr></table></figure>



<h4 id="2、安装gcc4-9-版本"><a href="#2、安装gcc4-9-版本" class="headerlink" title="2、安装gcc4.9+版本"></a>2、安装gcc4.9+版本</h4><p>在之前<a target="_blank" rel="noopener" href="https://blog.csdn.net/wsdc0521/article/details/106316972">安装Redis6</a>的文章中有介绍，此处略过安装gcc9.1：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启gcc9.1</span></span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看gcc版本</span></span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/65.png" alt="img"></p>
<h4 id="3、编译"><a href="#3、编译" class="headerlink" title="3、编译"></a>3、编译</h4><p>执行下面的命令编译源码，出现下图表示安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入目录并编译</span></span><br><span class="line"><span class="built_in">cd</span> redis-cluster-proxy-unstable</span><br><span class="line">make</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果编译出错之后再编译可以先执行命令删除之前的编译文件</span></span><br><span class="line">make distclean</span><br></pre></td></tr></table></figure>

<p>如果遇到错误 <em>unknown type name ‘_Atomic’</em> ，请检查gcc版本重新安装；</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/66.png" alt="img"></p>
<h4 id="4、安装"><a href="#4、安装" class="headerlink" title="4、安装"></a>4、安装</h4><p>编译成功后使用下面的命令安装Redis集群代理服务，出现下图表示安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Redis集群代理，可指定安装目录</span></span><br><span class="line">make install PREFIX=/opt/app/redis-cluster-proxy</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/67.png" alt="img"></p>
<h4 id="5、使用"><a href="#5、使用" class="headerlink" title="5、使用"></a>5、使用</h4><h5 id="1、配置启动"><a href="#1、配置启动" class="headerlink" title="1、配置启动"></a>1、配置启动</h5><p>从源码中将配置文件copy到安装目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/wyk/redis-cluster-proxy-unstable/proxy.conf /opt/app/redis-cluster-proxy/</span><br></pre></td></tr></table></figure>

<p>修改配置文件：vim /opt/app/redis-cluster-proxy/proxy.conf</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置Redis集群,这里我使用前几篇文章中配置的Redis6集群，三主三从</span></span><br><span class="line">cluster 127.0.0.1:6381  <span class="comment">#主1</span></span><br><span class="line">cluster 127.0.0.1:6382  <span class="comment">#主2</span></span><br><span class="line">cluster 127.0.0.1:6383  <span class="comment">#主3</span></span><br><span class="line">cluster 127.0.0.1:6391  <span class="comment">#从1</span></span><br><span class="line">cluster 127.0.0.1:6392  <span class="comment">#从2</span></span><br><span class="line">cluster 127.0.0.1:6393  <span class="comment">#从3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#默认端口</span></span><br><span class="line">port 7777</span><br><span class="line"> </span><br><span class="line"><span class="comment">#线程数</span></span><br><span class="line">threads 8</span><br><span class="line"> </span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"> </span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line">logfile <span class="string">&quot;/opt/app/redis-cluster-proxy/redis-cluster-proxy.log&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#允许跨slot查询</span></span><br><span class="line">enable-cross-slot yes</span><br><span class="line"> </span><br><span class="line"><span class="comment">#最大客户端连接数</span></span><br><span class="line">max-clients 10000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#ACL用户密码(也可以在启动服务时指定)</span></span><br><span class="line">auth-user myuser <span class="comment">#ACL用户</span></span><br><span class="line">auth mypassw    <span class="comment">#ACL密码</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#连接池</span></span><br><span class="line">connections-pool-size 10</span><br><span class="line">connections-pool-min-size 10</span><br><span class="line">connections-pool-spawn-every 50</span><br><span class="line">connections-pool-spawn-rate 50</span><br></pre></td></tr></table></figure>

<p>创建日志文件并使用下面的命令指定配置文件启动集群代理：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建日志文件</span></span><br><span class="line">touch /opt/app/redis-cluster-proxy/redis-cluster-proxy.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Redis集群代理服务</span></span><br><span class="line">/opt/app/redis-cluster-proxy/bin/redis-cluster-proxy -c /opt/app/redis-cluster-proxy/proxy.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/68.png" alt="img"></p>
<p><strong>连接集群代理客户端</strong>：</p>
<p>Redis集群代理服务监听7777端口，我们可以使用Redis命令行指定7777端口启动集群代理客户端：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接Redis集群代理客户端</span></span><br><span class="line">/opt/app/redis6/bin/redis-cli -p 7777</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/69.png" alt="img"></p>
<h5 id="2、跨节点slot操作"><a href="#2、跨节点slot操作" class="headerlink" title="2、跨节点slot操作"></a>2、跨节点slot操作</h5><p>上面提到在集群代理中，会将集群抽象成一个Redis实例，对用户来说跨slot/node操作是无感的，而在默认集群中会重定向到对应slot所在的节点进行操作。</p>
<p>默认集群模式： </p>
<p>在之前的Redis集群文章中演示了在dummy客户端中操作集群内的key时会重定向到该key存储的slot所在的节点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-c进入集群命令行模式</span></span><br><span class="line">redis-cli -c -p 6381</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用命令查看key所在的槽</span></span><br><span class="line">cluster keyslot key1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/70.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/71.png" alt="img"></p>
<p><strong>集群代理模式：</strong></p>
<p>在集群代理模式下，可以跨slot甚至跨节点操作key，而在集群模式下链接客户端是做不到的。下图演示了如果在集群代理中使用mset和mget跨slot跨node设置或查询key，对于用户来说仿佛是在使用一个单实例的Redis：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/72.png" alt="img"></p>
<h4 id="6、故障转移"><a href="#6、故障转移" class="headerlink" title="6、故障转移"></a>6、故障转移</h4><p>手动的使集群中一个主节点宕机，测试集群代理能否感知到集群的故障转移：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在6381主节点执行命令，手动的让其宕机</span></span><br><span class="line"><span class="comment"># 命令执行一个非法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 调试，执行后需要重启服务</span></span><br><span class="line">debug segfault</span><br></pre></td></tr></table></figure>

<p>情况一、主节点6381宕机，6391节点升级为主节点，集群恢复正常，但6381节点还没启动，此时集群代理无法使用，需要启动6381节点之后集群代理才能恢复使用：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/73.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/74.png" alt="img"></p>
<p>情况二、手动将6381主节点宕机，当从节点6391升级为主节点后，重启6381节点作为6391的从节点，此时集群的主从机器全部正常启动，查询集群代理，不会收到影响：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/75.png" alt="img"></p>
<h3 id="3、结尾"><a href="#3、结尾" class="headerlink" title="3、结尾"></a>3、结尾</h3><p>目前在Github上最新的版本仍是unstable版，毕竟是新功能，还是有很多BUG的，像集群的故障转移在集群代理中就没有做的很好，其次就是如果集群代理服务本身没有解决单点故障(可以尝试配合HAProxy等代理服务做负载均衡)。</p>
<p>官方最后声明中也提到【当前处于α版本，不推荐在生产环境使用]】：</p>
<blockquote>
<p>This project is currently alpha code that is indented to be evaluated by the community in order to get suggestions and contributions. We discourage its usage in any production environment.</p>
</blockquote>
<p>但不可否认的是集群代理给redis集群提供了轻量的代理层，也解决了很多在集群模式中的使用限制，未来的潜力还很大，让我们拭目以待吧！</p>
<h2 id="11、Redis6新特性之IO多线程"><a href="#11、Redis6新特性之IO多线程" class="headerlink" title="11、Redis6新特性之IO多线程"></a>11、Redis6新特性之IO多线程</h2><p>终于，Redis的多线程版本横空出世，大大提高了并发，本篇就带大家来看看什么是IO多线程，和我们理解的多线程有什么区别，与Memcached的多线程又有什么区别。</p>
<h3 id="1、介绍-8"><a href="#1、介绍-8" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>作为Redis6版本中的其中一大新特性，IO多线程大大提升了Redis的并发性能。该功能也是在社区内被反复提起，而之前Antirez在自己的博客中也曾经做过简单的介绍：<a target="_blank" rel="noopener" href="http://antirez.com/news/126">http://antirez.com/news/126</a></p>
<h3 id="2、为什么Redis6-0之前是单线程模型"><a href="#2、为什么Redis6-0之前是单线程模型" class="headerlink" title="2、为什么Redis6.0之前是单线程模型"></a>2、为什么Redis6.0之前是单线程模型</h3><p>首先我们要明确一个共识，我们通常所说的<strong>Redis单线程是指获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这个主线程就是我们平时说的”单线程”**，而</strong>其他的清理脏数据、无用连接的释放、LRU淘汰策略等等也是有其他线程在处理的，因此其实在Redis6之前的Redis本质上也是多线程的。**</p>
<p>为什么这些操作要放在同一个主线程中，官方给出的解释：<a target="_blank" rel="noopener" href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores">传送门</a> </p>
<ul>
<li>通常瓶颈不在 CPU，而是在内存和网络IO；</li>
<li>多线程会带来线程不安全的情况；</li>
<li>多线程可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗；</li>
<li>单线程降低了Redis内部实现复杂度；</li>
<li>hash的惰性rehash，lpush等线程不安全的命令可以无锁执行；</li>
</ul>
<h3 id="3、什么是IO多线程"><a href="#3、什么是IO多线程" class="headerlink" title="3、什么是IO多线程"></a>3、什么是IO多线程</h3><p>既然上面说单线程那么好，为什么Redis6.0又要引入多线程呢？ </p>
<p>Redis 抽象了一套 <strong>AE 事件</strong>模型，将 IO 事件和时间事件融入一起，同时借助多路复用机制(linux上用epoll) 的回调特性，使得 IO 读写都是非阻塞的，实现高性能的网络处理能力。加上 Redis 基于内存的数据处理，这就是 “单线程，但却高性能” 的核心原因。</p>
<p>但 IO 数据的读写依然是阻塞的，这也是 Redis 目前的主要性能瓶颈之一，特别是在数据吞吐量特别大的时候，具体情况如下：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/76.png" alt="img"></p>
<p>上图的下半部分，当 socket 中有数据时，Redis 会通过系统调用将数据从内核态拷贝到用户态，供 Redis 解析用。这个拷贝过程是阻塞的，术语称作 “同步 IO”，数据量越大拷贝的延迟越高，时间消耗也越大，糟糕的是这些操作都是单线程处理的。（写 reponse 时也是一样）</p>
<p>这是 Redis 目前的瓶颈之一，Redis6.0 引入的 “多线程” 机制就是对于该瓶颈的优化。核心思路是，将主线程的 IO 读写任务拆分出来给一组独立的线程执行，使得多个 socket 的读写可以并行化。</p>
<blockquote>
<p>与 Memcached 从 IO 处理到数据访问多线程的实现模式有些差异。<strong>Redis 的IO多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程</strong>。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。</p>
</blockquote>
<h3 id="4、开启IO多线程"><a href="#4、开启IO多线程" class="headerlink" title="4、开启IO多线程"></a>4、开启IO多线程</h3><p>默认情况下，Redis多线程是禁用的，我们可以在配置文件选择开启：vim redis.conf</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启IO多线程</span></span><br><span class="line">io-threads-do-reads yes</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置线程数量，如果设为1就是主线程模式。</span></span><br><span class="line">io-threads 4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方建议：<strong>至少4核的机器才开启IO多线程</strong>，并且除非真的遇到了性能瓶颈，否则不建议开启此配置 ，且配置的线程数少于机器总线程数，<strong>如果有4核建议开启2,3个线程，如果有8核建议开6线程</strong>。 线程并不是越多越好，多于8个线程意义不大。</p>
</blockquote>
<h3 id="5、性能对比"><a href="#5、性能对比" class="headerlink" title="5、性能对比"></a>5、性能对比</h3><p>因资源有限，我手边的机器渣渣配置如下，开启3个线程对比单线程：</p>
<p><strong>配置：</strong> </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@BD-T-uatredis9 ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            15G        1.0G         13G         64M        1.2G         14G</span><br><span class="line">Swap:          4.0G          0B        4.0G</span><br><span class="line">[root@BD-T-uatredis9 ~]<span class="comment"># lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    1</span><br><span class="line">Socket(s):             4</span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 79</span><br><span class="line">Model name:            Intel(R) Xeon(R) CPU E7-4809 v4 @ 2.10GHz</span><br><span class="line">Stepping:              1</span><br><span class="line">CPU MHz:               2094.952</span><br><span class="line">BogoMIPS:              4189.90</span><br><span class="line">Hypervisor vendor:     VMware</span><br><span class="line">Virtualization <span class="built_in">type</span>:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              20480K</span><br><span class="line">NUMA node0 CPU(s):     0-3</span><br></pre></td></tr></table></figure>

<p><strong>测试命令：</strong> </p>
<p>使用<em>redis-benchmark</em>进行压测，这里模拟在4核4线程的机器上分别测试3线程和单线程在100W请求，数据大小在128b,512b,1024b，200个客户端，执行SET和GET的QPS性能对比</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三线程</span></span><br><span class="line">./redis-benchmark -h localhost -p 6380 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000 --threads 3 -d 128 -c 200 -q</span><br><span class="line"> </span><br><span class="line">./redis-benchmark -h localhost -p 6380 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000 --threads 3 -d 512 -c 200 -q</span><br><span class="line"> </span><br><span class="line">./redis-benchmark -h localhost -p 6380 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000 --threads 3 -d 1024 -c 200 -q</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单线程</span></span><br><span class="line">./redis-benchmark -h localhost -p 6381 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000  -d 128 -c 200 -q</span><br><span class="line"> </span><br><span class="line">./redis-benchmark -h localhost -p 6381 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000  -d 512 -c 200 -q</span><br><span class="line"> </span><br><span class="line">./redis-benchmark -h localhost -p 6381 --user default -a wyk123456 -t <span class="built_in">set</span>,get -n 1000000 -r 1000000  -d 1024 -c 200 -q</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>可能是我机器太渣了，3线程比单线程的QPS提升有120%~140%，网友测试的在4线程下QPS提升了100%。</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/77.png" alt="img"></p>
<p>网友的测试结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis Server: 阿里云 Ubuntu 18.04，8 CPU 2.5 GHZ, 8G 内存，主机型号 ecs.ic5.2xlarge</span><br><span class="line">Redis Benchmark Client: 阿里云 Ubuntu 18.04，8 2.5 GHZ CPU, 8G 内存，主机型号 ecs.ic5.2xlarge</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/78.png" alt="img"></p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/79.png" alt="img"></p>
<blockquote>
<p>注意，数据仅供验证参考，不能作为线上指标：</p>
<ul>
<li>本测试只是使用早期的 <code>unstble</code> 分支的性能，不排除稳定版的性能会更好。 </li>
<li>本测试并没有针对严谨的延时控制和不同并发的场景进行压测。</li>
</ul>
</blockquote>
<h3 id="6、源码解析"><a href="#6、源码解析" class="headerlink" title="6、源码解析"></a>6、源码解析</h3><p>刚才提到IO多线程只是在网络数据的读写上是多线程了，具体流程如下：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/80.png" alt="img"></p>
<p>流程：</p>
<ol>
<li>主线程获取 socket 放入等待列表</li>
<li>将 socket 分配给各个 IO 线程（并不会等列表满）</li>
<li>主线程阻塞等待 IO 线程读取 socket 完毕</li>
<li>主线程以单线程执行命令 （如果命令没有接收完毕，会等 IO 下次继续）</li>
<li>主线程阻塞等待 IO 线程将数据回写 socket 完毕（一次没写完，会等下次再写）</li>
<li>解除绑定，清空等待队列</li>
</ol>
<blockquote>
<ul>
<li>IO 线程要么同时在读 socket，要么同时在写，不会同时读或写；</li>
<li>IO 线程只负责读写 socket 解析命令，不负责执行命令，由主线程串行执行命令；</li>
<li>IO 线程数可配置，默认为 1；</li>
<li>上面的过程是完全无锁的，因为在 IO 线程处理的时主线程会等待全部的 IO 线程完成，所以不会出现 data race 的场景。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/redis-io/redis/blob/6.0/src/networking.c">源码</a>：</p>
<p>redis-server 逻辑首先执行 initThreadedIO()函数对 线程进行初始化，当然，也包括 根据配置 server.io_threads_num 控制线程个数，其中主线程的处理逻辑为 IOThreadMain() 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* networking.c: line 2666 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IOThreadMain</span><span class="params">(<span class="keyword">void</span> *myid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* The ID is the thread number (from 0 to server.iothreads_num-1), and is used by the thread to just manipulate a single sub-array of clients. */</span></span><br><span class="line">    <span class="comment">// 线程 ID，跟普通线程池的操作方式一样，都是通过 线程ID 进行操作</span></span><br><span class="line">    <span class="keyword">long</span> id = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)myid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Wait for start */</span></span><br><span class="line">        <span class="comment">// 这里的等待操作比较特殊，没有使用简单的 sleep，避免了 sleep 时间设置不当可能导致糟糕的性能，但是也有个问题就是频繁 loop 可能一定程度上造成 cpu 占用较长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (io_threads_pending[id] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Give the main thread a chance to stop this thread. */</span></span><br><span class="line">        <span class="keyword">if</span> (io_threads_pending[id] == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">            pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(io_threads_pending[id] != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// debug 模式</span></span><br><span class="line">        <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;[%ld] %d to handle\n&quot;</span>, id, (<span class="keyword">int</span>)listLength(io_threads_list[id]));</span><br><span class="line">        <span class="comment">/* Process: note that the main thread will never touch our list</span></span><br><span class="line"><span class="comment">         * before we drop the pending count to 0. */</span></span><br><span class="line">        <span class="comment">// 根据线程 id 以及待分配列表进行 任务分配</span></span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listRewind(io_threads_list[id],&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="comment">// 判断读写类型</span></span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                <span class="comment">// 这里需要注意重复调用了 readQueryFromClient，不过不用担心，有 CLIENT_PENDING_READ 标识可以进行识别</span></span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;io_threads_op value is unknown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        io_threads_pending[id] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;[%ld] Done\n&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleClientsWithPendingReadsUsingThreads()</code> 待处理任务分配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* networking.c: line 2871 */</span></span><br><span class="line"><span class="comment">/* When threaded I/O is also enabled for the reading + parsing side, the readable handler will just put normal clients into a queue of clients to process (instead of serving them synchronously). This function runs the queue using the I/O threads, and process them in order to accumulate the reads in the buffers, and also parse the first command available rendering it in the client structures. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否开启 线程读</span></span><br><span class="line">    <span class="keyword">if</span> (!io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL READ pending clients\n&quot;</span>, processed);</span><br><span class="line">    <span class="comment">/* Distribute the clients across N different lists. */</span></span><br><span class="line">    <span class="comment">// 将待处理任务进行分配，分配方式为 RR (round robin) 即基于任务到达时间片进行分配</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Give the start condition to the waiting threads, by setting the start condition atomic var. */</span></span><br><span class="line">    <span class="comment">// 设定任务个数参数</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait for all threads to end their work. */</span></span><br><span class="line">    <span class="comment">// 等待所有线程任务都处理完毕</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O READ All threads finshed\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* Run the list of clients again to process the new buffers. */</span></span><br><span class="line">    <span class="comment">// 继续运行，等待新的处理任务</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">            c-&gt;flags &amp;= ~ CLIENT_PENDING_COMMAND;</span><br><span class="line">            processCommandAndResetClient(c);</span><br><span class="line">        &#125;</span><br><span class="line">        processInputBufferAndReplicate(c);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readQueryFromClient()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* networking.c: line 1791 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line">    <span class="comment">/* Check if we want to read from the client later when exiting from the event loop. This is the case if threaded I/O is enabled. */</span></span><br><span class="line">    <span class="comment">// 加入多线程模型已经启用</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果没有启用多线程模型，则走下面继续处理读逻辑</span></span><br><span class="line">    <span class="comment">// ....还有后续老逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>postponeClientRead()</code> 将任务放入处理队列，而根据上面 <code>IOThreadMain()</code> 和 <code>handleClientsWithPendingReadsUsingThreads()</code> 的任务处理逻辑进行处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* networking.c: line 2852 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">postponeClientRead</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果启用多线程模型，并且判断全局配置中是否支持多线程读</span></span><br><span class="line">    <span class="keyword">if</span> (io_threads_active &amp;&amp;</span><br><span class="line">        server.io_threads_do_reads &amp;&amp;</span><br><span class="line">        <span class="comment">// 这里有个点需要注意，如果是 master-slave 同步也有可能被认为是普通 读任务，所以需要标识</span></span><br><span class="line">        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_READ;</span><br><span class="line">        <span class="comment">// 将任务放入处理队列</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_read,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、对比Memcached"><a href="#7、对比Memcached" class="headerlink" title="7、对比Memcached"></a>7、对比Memcached</h3><p>前些年memcached 是各大互联网公司常用的缓存方案，因此redis 和 memcached 的区别基本成了面试官缓存方面必问的面试题，最近几年memcached用的少了，基本都是 redis。不过随着Redis6.0加入了多线程特性，类似的问题可能还会出现，接下来我们只针对多线程模型来简单比较一下它们。</p>
<p>首先看一下Memcached的线程模型：</p>
<p><img src="/2021/09/04/redis%E9%AB%98%E7%BA%A7/81.png" alt="img"></p>
<p>如上图所示：Memcached 服务器采用 master-woker 模式进行工作，服务端采用 socket 与客户端通讯。主线程、工作线程 采用 pipe管道进行通讯。主线程采用 libevent 监听 listen、accept 的读事件，事件响应后将连接信息的数据结构封装起来，根据算法选择合适的工作线程，将连接任务携带连接信息分发出去，相应的线程利用连接描述符建立与客户端的socket连接 并进行后续的存取数据操作。</p>
<p>Redis6.0与Memcached多线程模型对比：</p>
<ul>
<li>相同点：<strong>都采用了 master线程-worker 线程的模型</strong></li>
<li>不同点：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</li>
</ul>
<h3 id="8、结尾"><a href="#8、结尾" class="headerlink" title="8、结尾"></a>8、结尾</h3><p>大家都会拿Redis和memcached对比，但Redis不是memcached，它只是做到like memcached的多线程，而不是跟memcached一样的完全隔离的多线程模型。Redis中因为有lua脚本，事务，Lpush等等复杂性，需要考虑的问题很多，不管怎么样，最新版的Redis6带给我们的IO多线程着实是个惊喜，互联网大厂们应该很快就会纷纷上线此功能了！</p>
<hr>
<h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马程序员Redis入门到精通，Java企业级解决方案必看</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rv41177Af?p=2&spm_id_from=pageDriver">【尚硅谷】2021 最新 Redis 6 入门到精通 超详细 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wsdc0521/article/details/106907436">Redis系列</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrwhite2020/p/14727548.html">Redis6使用指导（完整版）</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039078249">如何保证 Redis 缓存与数据库双写一致性？</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/09/04/redis%E9%AB%98%E7%BA%A7/" title="redis高级">http://xgh-user.github.io/2021/09/04/redis高级/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/30/mysql%E9%AB%98%E7%BA%A7/" rel="prev" title="mysql高级">
      <i class="fa fa-chevron-left"></i> mysql高级
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E3%80%81Redis%E5%88%9D%E7%BA%A7%EF%BC%88Windows%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">1、Redis初级（Windows）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Redis%E5%85%A5%E9%97%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1、Redis入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Redis-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、Redis 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Nosql%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、Nosql的出现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Nosql-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2、Nosql 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%85%B7%E4%BD%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E2%80%94%E2%80%94%EF%BC%88%E7%94%B5%E5%95%86%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3、具体解决方案 ——（电商场景）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Redis"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">4、Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Redis-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">5、Redis 的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Redis-%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、Redis 的下载与安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Redis-%E7%9A%84%E4%B8%8B%E8%BD%BD"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1、Redis 的下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85-Redis"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2、安装 Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%90%AF%E5%8A%A8-Redis"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">3、启动 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">1、前台启动（不推荐）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">2、后台启动（推荐）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Redis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、Redis 的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1、命令行模式工具使用思考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BF%A1%E6%81%AF%E6%B7%BB%E5%8A%A0"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">2、信息添加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">3、信息查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%B8%85%E9%99%A4%E5%B1%8F%E5%B9%95%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">4、清除屏幕信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%80%80%E5%87%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">5、退出客户端命令行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">6、帮助</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2、Redis 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、数据存储类型介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1、业务数据的特殊性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">1、作为缓存使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">2、附加功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%885%E7%A7%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2、Redis 数据类型（5种常用）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81String"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81redis-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1、redis 数据存储格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81string-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2、string 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81String%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3、String类型的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81string-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">4、string 类型数据的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81string-%E4%BD%9C%E4%B8%BA%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">5、string 作为数值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81string-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">6、string 类型数据操作的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81string-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">7、string 类型应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.7.1.</span> <span class="nav-text">1、业务场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.2.7.2.</span> <span class="nav-text">2、解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81key-%E7%9A%84%E8%AE%BE%E7%BD%AE%E7%BA%A6%E5%AE%9A"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">8、key 的设置约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81string-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">9、string 类型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81hash"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81hash-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1、hash 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E5%9B%B0%E6%83%91"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">存储的困惑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Hash-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2、Hash 的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81hash-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3、hash 类型数据的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81hash-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">4、hash 类型数据操作的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81string%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%EF%BC%88json%EF%BC%89%E4%B8%8Ehash%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">5、string存储对象（json）与hash存储对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81hash-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">6、hash 类型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81list"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81list-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">1、list 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81list-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2、list 的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81list-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">3、list 类型数据基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81list-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">4、list 类型数据操作注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81list-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">5、list 类型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81set"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81set-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">1、set 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Set-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2、Set 的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81set-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">3、set 类型数据的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81set-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">4、set 类型数据操作的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81set-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">5、set 类型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81sorted-set"><span class="nav-number">1.2.6.</span> <span class="nav-text">6、sorted_set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81sorted-set-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">1、sorted_set 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Sorted-set-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2、Sorted_set 的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%88%E8%B7%B3%E8%A1%A8%EF%BC%89"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">跳跃表（跳表）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.6.2.1.1.</span> <span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.6.2.1.2.</span> <span class="nav-text">2、实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81sorted-set-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">3、sorted_set 类型数据的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81sorted-set-%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">4、sorted_set 类型数据操作的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81sorted-set-%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">5、sorted_set 类型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B"><span class="nav-number">1.2.7.</span> <span class="nav-text">7、数据类型实践案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF1"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">1、业务场景1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2、解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%94%B9%E8%89%AF"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">3、解决方案改良</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF2"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">4、业务场景2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">5、业务分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.7.6.</span> <span class="nav-text">6、解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.8.</span> <span class="nav-text">8、解决方案列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Redis-%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">3、Redis 通用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81key%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、key通用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81key-%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1、key 特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81key-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2、key 基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81key-%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3、key 扩展操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81key-%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%97%B6%E6%95%88%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">1、key 扩展操作——时效性控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81key-%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">2、key 扩展操作——查询模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81key-%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">4、key 其他操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、数据库通用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1、数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81db-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2、db 基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3、常用服务器命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Jedis"><span class="nav-number">1.4.</span> <span class="nav-text">4、Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Jedis%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、Jedis简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81HelloWorld%EF%BC%88Jedis%E7%89%88%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、HelloWorld（Jedis版）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1、准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5redis"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2、客户端连接redis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Jedis%E7%AE%80%E6%98%93%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BC%80%E5%8F%91"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、Jedis简易工具类开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E4%BA%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">1、基于连接池获取连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%B0%81%E8%A3%85%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">2、封装连接参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">3、加载配置信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4、加载配置信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.4.4.</span> <span class="nav-text">4、可视化客户端</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%E3%80%81Redis%E9%AB%98%E7%BA%A7%EF%BC%88Linux%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">2、Redis高级（Linux）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E4%BA%8ELinux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85Redis"><span class="nav-number">2.1.</span> <span class="nav-text">1、基于Linux环境安装Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Redis%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、Redis在Linux环境下的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Redis%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、Redis基础环境设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Redis%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、Redis服务启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.1.4.</span> <span class="nav-text">4、Redis客户端连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">2.1.5.</span> <span class="nav-text">5、Redis服务端配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">2、Redis 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、持久化简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1、什么是持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2、为什么要进行持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B%E4%BF%9D%E5%AD%98%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3、持久化过程保存什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81RDB"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81RDB%E6%99%AE%E9%80%9A%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">1、RDB普通启动方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-save%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">1、RDB启动方式 —— save指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.1.1.1.</span> <span class="nav-text">1、RDB启动方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-save%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.1.1.2.</span> <span class="nav-text">2、RDB启动方式 —— save指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-save%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.1.1.3.</span> <span class="nav-text">3、RDB启动方式 —— save指令相关配置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-save%E6%8C%87%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.1.1.4.</span> <span class="nav-text">4、RDB启动方式 —— save指令工作原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-bgsave%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">2、RDB启动方式 —— bgsave指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-1"><span class="nav-number">2.2.2.1.2.1.</span> <span class="nav-text">1、RDB启动方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-bgsave%E6%8C%87%E4%BB%A4-1"><span class="nav-number">2.2.2.1.2.2.</span> <span class="nav-text">2、RDB启动方式 —— bgsave指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-bgsave%E6%8C%87%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.1.2.3.</span> <span class="nav-text">3、RDB启动方式 —— bgsave指令工作原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94-bgsave%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.1.2.4.</span> <span class="nav-text">4、RDB启动方式 —— bgsave指令相关配置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E2%80%94%E2%80%94save%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.1.2.5.</span> <span class="nav-text">3、RDB启动方式 ——save配置原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81save%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.1.2.6.</span> <span class="nav-text">4、save配置相关配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81RDB%E7%9A%84%E5%A4%87%E4%BB%BD"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2、RDB的备份</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81RDB%E7%9A%84%E5%81%9C%E6%AD%A2"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">3、RDB的停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81RDB%E4%B8%89%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">4、RDB三种启动方式对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81RDB%E7%89%B9%E6%AE%8A%E5%90%AF%E5%8A%A8%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">5、RDB特殊启动形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81RDB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">6、RDB优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81RDB%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.2.6.1.</span> <span class="nav-text">1、RDB优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81RDB%E7%BC%BA%E7%82%B9"><span class="nav-number">2.2.2.6.2.</span> <span class="nav-text">2、RDB缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81AOF"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81RDB%E5%AD%98%E5%82%A8%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">1、RDB存储的弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81AOF%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">2、AOF概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81AOF%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3、AOF写数据过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AOF%E5%86%99%E6%95%B0%E6%8D%AE%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5-appendfsync"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">4、AOF写数据三种策略(appendfsync)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81AOF%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">5、AOF功能开启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81AOF%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">6、AOF相关配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81AOF%E5%86%99%E6%95%B0%E6%8D%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.3.7.</span> <span class="nav-text">7、AOF写数据遇到的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81AOF%E9%87%8D%E5%86%99"><span class="nav-number">2.2.3.8.</span> <span class="nav-text">8、AOF重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81AOF%E9%87%8D%E5%86%99%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.3.9.</span> <span class="nav-text">9、AOF重写作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81AOF%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">2.2.3.10.</span> <span class="nav-text">10、AOF重写规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81AOF%E9%87%8D%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.3.11.</span> <span class="nav-text">11、AOF重写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12%E3%80%81AOF%E6%89%8B%E5%8A%A8%E9%87%8D%E5%86%99-%E2%80%94%E2%80%94-bgrewriteaof%E6%8C%87%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.3.12.</span> <span class="nav-text">12、AOF手动重写 —— bgrewriteaof指令工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13%E3%80%81AOF%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.3.13.</span> <span class="nav-text">13、AOF自动重写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14%E3%80%81AOF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.3.14.</span> <span class="nav-text">14、AOF工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15%E3%80%81AOF%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.3.15.</span> <span class="nav-text">15、AOF重写流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8write%E5%92%8Cfsync%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.3.16.</span> <span class="nav-text">16、系统调用write和fsync说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17%E3%80%81AOF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.2.3.17.</span> <span class="nav-text">17、AOF的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.3.17.1.</span> <span class="nav-text">1、优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BC%BA%E7%82%B9"><span class="nav-number">2.2.3.17.2.</span> <span class="nav-text">2、缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81RDB%E4%B8%8EAOF%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.4.</span> <span class="nav-text">4、RDB与AOF区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81RDB-VS-AOF"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">1、RDB VS AOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81RDB%E4%B8%8EAOF%E7%9A%84%E9%80%89%E6%8B%A9%E4%B9%8B%E6%83%91"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">2、RDB与AOF的选择之惑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81AOF-RDB%E6%B7%B7%E5%90%88-%E6%8E%A8%E8%8D%90"><span class="nav-number">2.2.5.</span> <span class="nav-text">5、AOF+RDB混合[推荐]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">2、配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">3、使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.6.</span> <span class="nav-text">6、持久化应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Redis-%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.</span> <span class="nav-text">3、Redis 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、事务简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">1、什么是事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.</span> <span class="nav-text">2、事务基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">1、事务的边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">2、事务的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">3、事务的工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">4、事务的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%85%A5%E9%94%99%E8%AF%AF%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.3.2.4.1.</span> <span class="nav-text">1、定义事务的过程中，命令格式输入错误怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%9A%E4%B9%89%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.3.2.4.2.</span> <span class="nav-text">2、定义事务的过程中，命令执行出现错误怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%89%8B%E5%8A%A8%E8%BF%9B%E8%A1%8C%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A"><span class="nav-number">2.3.2.4.3.</span> <span class="nav-text">3、手动进行事务回滚</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Redis-%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">5、Redis 事务三特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%94%81"><span class="nav-number">2.3.3.</span> <span class="nav-text">3、锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E2%80%94%E2%80%94%E9%94%81"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">1、基于特定条件的事务执行——锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">2、锁的应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81redssion"><span class="nav-number">2.3.4.</span> <span class="nav-text">4、redssion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-Redisson"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">1、如何安装 Redisson</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-Redisson"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">2、如何编译运行 Redisson</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9Redisson-API%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">3、对Redisson API的相关使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Redis-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">2.4.</span> <span class="nav-text">4、Redis 删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、过期数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">1、Redis中的数据特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">2、数据删除策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、数据删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%97%B6%E6%95%88%E6%80%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">1、时效性数据的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">2、数据删除策略的目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">3、数据删除策略——定时删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">4、数据删除策略——惰性删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">5、数据删除策略——定期删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%AF%94%E5%AF%B9"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">6、删除策略比对</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、逐出算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E6%A3%80%E6%B5%8B"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">1、新数据进入检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">2、影响数据逐出的相关配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81LRU%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">3、LRU算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">2.4.3.3.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.3.3.2.</span> <span class="nav-text">2、底层实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81LFU%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">4、LFU算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">2.4.3.4.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">2.4.3.4.2.</span> <span class="nav-text">2、底层实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%BE%9D%E6%8D%AE"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">5、数据逐出策略配置依据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Redis-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="nav-number">2.5.</span> <span class="nav-text">5、Redis 核心配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="nav-number">2.5.1.</span> <span class="nav-text">服务器基础配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AE%BE%E5%AE%9A"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">1、服务器端设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">2、日志配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">3、客户端配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE"><span class="nav-number">2.5.1.4.</span> <span class="nav-text">4、多服务器快捷配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.6.</span> <span class="nav-text">6、高级数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Bitmaps"><span class="nav-number">2.6.1.</span> <span class="nav-text">1、Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E9%9C%80%E6%B1%82"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">1、存储需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Bitmaps%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">2、Bitmaps类型的基础操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Bitmaps%E4%B8%8Eset%E5%AF%B9%E6%AF%94"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">3、Bitmaps与set对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Bitmaps%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">4、Bitmaps的应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81HyperLogLog"><span class="nav-number">2.6.2.</span> <span class="nav-text">2、HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%95%B0"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">1、基数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81LogLog%E7%AE%97%E6%B3%95%EF%BC%88%E8%B7%B3%E8%BF%87%EF%BC%89"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">2、LogLog算法（跳过）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81HyperLogLog%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">3、HyperLogLog类型的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81HyperLogLog%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="nav-number">2.6.2.4.</span> <span class="nav-text">4、HyperLogLog的相关说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81HyperLogLog%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.6.2.5.</span> <span class="nav-text">5、HyperLogLog的应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81GEO"><span class="nav-number">2.6.3.</span> <span class="nav-text">3、GEO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81GEO%E7%AE%80%E4%BB%8B"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">1、GEO简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81GEO%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">2、GEO类型的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81GEO%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">3、GEO的应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">7、主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">2.7.1.</span> <span class="nav-text">1、主从复制简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%92%E8%81%94%E7%BD%91%E2%80%9C%E4%B8%89%E9%AB%98%E2%80%9D%E6%9E%B6%E6%9E%84"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">1、互联网“三高”架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E2%80%9CRedis%E2%80%9D%E6%98%AF%E5%90%A6%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">2、“Redis”是否高可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E6%A1%88"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">3、多台服务器连接方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">4、主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4"><span class="nav-number">2.7.1.5.</span> <span class="nav-text">5、高可用集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AAslave%E7%BB%93%E7%82%B9%E5%AE%95%E6%9C%BA%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B9%B6%E4%B8%8D%E5%BD%B1%E5%93%8Dredis%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">2.7.1.5.1.</span> <span class="nav-text">1、在一个slave结点宕机之后，并不影响redis可用性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AAmaster%E7%BB%93%E7%82%B9%E5%AE%95%E6%9C%BA%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%80%E4%B8%AAslave%E5%8D%87%E7%BA%A7%E4%B8%BAmaster%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%B8%8D%E5%BD%B1%E5%93%8Dredis%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">2.7.1.5.2.</span> <span class="nav-text">2、在一个master结点宕机之后，可以有一个slave升级为master继续使用，并不影响redis可用性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AAmaster%E7%BB%93%E7%82%B9%E5%8E%8B%E5%8A%9B%E8%BF%87%E5%A4%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%80%E9%83%A8%E5%88%86%E5%B7%A5%E4%BD%9C%E4%BA%A4%E7%BB%99%E4%B8%80%E4%B8%AAslave%E7%BB%93%E7%82%B9%E5%8E%BB%E5%81%9A%EF%BC%8C%E8%AE%A9%E8%BF%99%E4%B8%AAslave%E4%BD%9C%E4%B8%BAmaster%E5%8E%BB%E7%AE%A1%E7%90%86%E5%AE%83%E7%9A%84%E4%BB%8E%E7%BB%93%E7%82%B9%EF%BC%88master%E4%B8%8Eslave%E5%8F%AA%E6%98%AF%E7%9B%B8%E5%AF%B9%E6%9D%A5%E8%AF%B4%E7%9A%84%EF%BC%89"><span class="nav-number">2.7.1.5.3.</span> <span class="nav-text">3、在一个master结点压力过大，可以将一部分工作交给一个slave结点去做，让这个slave作为master去管理它的从结点（master与slave只是相对来说的）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AAmaster%E6%9D%A5%E6%8E%A5%E6%94%B6%E5%A4%96%E7%95%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%A4%AA%E5%AE%89%E5%85%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%9A%E4%B8%AAmaster%E5%81%9A%E6%88%90%E9%9B%86%E7%BE%A4"><span class="nav-number">2.7.1.5.4.</span> <span class="nav-text">4、如果一个master来接收外界数据不太安全的话，也可以将多个master做成集群</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.7.1.6.</span> <span class="nav-text">6、主从复制的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.2.</span> <span class="nav-text">2、主从复制工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%80%BB%E8%BF%B0"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">1、总述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">2、阶段一：建立连接阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.2.2.1.</span> <span class="nav-text">1、建立连接阶段工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%BB%E4%BB%8E%E8%BF%9E%E6%8E%A5%EF%BC%88slave%E8%BF%9E%E6%8E%A5master%EF%BC%89"><span class="nav-number">2.7.2.2.2.</span> <span class="nav-text">2、主从连接（slave连接master）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%BB%E4%BB%8E%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.7.2.2.3.</span> <span class="nav-text">3、主从断开连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE"><span class="nav-number">2.7.2.2.4.</span> <span class="nav-text">4、授权访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">2、阶段二：数据同步阶段工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.2.3.1.</span> <span class="nav-text">1、数据同步阶段工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5master%E8%AF%B4%E6%98%8E"><span class="nav-number">2.7.2.3.2.</span> <span class="nav-text">2、数据同步阶段master说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5slave%E8%AF%B4%E6%98%8E"><span class="nav-number">2.7.2.3.3.</span> <span class="nav-text">3、数据同步阶段slave说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">3、阶段三：命令传播阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6"><span class="nav-number">2.7.2.4.1.</span> <span class="nav-text">1、命令传播阶段的部分复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8CID%EF%BC%88runid%EF%BC%89"><span class="nav-number">2.7.2.4.2.</span> <span class="nav-text">2、服务器运行ID（runid）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.7.2.4.3.</span> <span class="nav-text">3、复制缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%8D%E5%88%B6%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%88offset%EF%BC%89"><span class="nav-number">2.7.2.4.4.</span> <span class="nav-text">4、主从服务器复制偏移量（offset）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.2.5.</span> <span class="nav-text">4、数据同步+命令传播阶段工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.2.6.</span> <span class="nav-text">5、心跳机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%BF%83%E8%B7%B3%E9%98%B6%E6%AE%B5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.7.2.7.</span> <span class="nav-text">6、心跳阶段注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E5%AE%8C%E6%95%B4%EF%BC%89"><span class="nav-number">2.7.2.8.</span> <span class="nav-text">7、主从复制工作流程（完整）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.3.</span> <span class="nav-text">3、主从复制常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%881%EF%BC%89"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">1、频繁的全量复制（1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%882%EF%BC%89"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">2、频繁的全量复制（2）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%881%EF%BC%89"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">3、频繁的网络中断（1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%882%EF%BC%89"><span class="nav-number">2.7.3.4.</span> <span class="nav-text">4、频繁的网络中断（2）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">2.7.3.5.</span> <span class="nav-text">5、数据不一致</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.8.</span> <span class="nav-text">8、哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%93%A8%E5%85%B5%E7%AE%80%E4%BB%8B"><span class="nav-number">2.8.1.</span> <span class="nav-text">1、哨兵简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E6%9C%BA%E2%80%9C%E5%AE%95%E6%9C%BA%E2%80%9D"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">1、主机“宕机”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%93%A8%E5%85%B5"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">2、哨兵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">3、哨兵的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E7%94%A8%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.8.2.</span> <span class="nav-text">2、启用哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">1、配置哨兵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">2、配置哨兵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%93%A8%E5%85%B5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.8.3.</span> <span class="nav-text">3、哨兵工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">1、主从切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">2、阶段一：监控阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%80%9A%E7%9F%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">3、阶段二：通知阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5"><span class="nav-number">2.8.3.4.</span> <span class="nav-text">4、阶段三：故障转移阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81sentinel1%E5%8F%91%E7%8E%B0master%E5%AE%95%E6%9C%BA"><span class="nav-number">2.8.3.4.1.</span> <span class="nav-text">1、sentinel1发现master宕机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%80%89%E4%B8%BE%E4%B8%80%E4%B8%AAsentinel%E5%8E%BB%E8%A7%A3%E5%86%B3%E5%BD%93%E5%89%8Dmaster%E5%AE%95%E6%9C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">2.8.3.4.2.</span> <span class="nav-text">2、选举一个sentinel去解决当前master宕机问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E6%8C%91%E9%80%89%E5%A4%87%E9%80%89master"><span class="nav-number">2.8.3.4.3.</span> <span class="nav-text">3、服务器列表中挑选备选master</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.3.4.4.</span> <span class="nav-text">4、故障转移阶段总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B"><span class="nav-number">2.8.4.</span> <span class="nav-text">4、日志查看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E9%9B%86%E7%BE%A4"><span class="nav-number">2.9.</span> <span class="nav-text">9、集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="nav-number">2.9.1.</span> <span class="nav-text">1、集群简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%8E%B0%E7%8A%B6%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">1、现状问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">2、集群架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%9B%86%E7%BE%A4%E4%BD%9C%E7%94%A8"><span class="nav-number">2.9.1.3.</span> <span class="nav-text">3、集群作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">2.9.1.4.</span> <span class="nav-text">4、Redis 集群的限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash-Tag"><span class="nav-number">2.9.1.4.1.</span> <span class="nav-text">Hash Tag</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Redis%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.9.2.</span> <span class="nav-text">2、Redis集群结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.9.2.1.</span> <span class="nav-text">1、数据存储设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%9B%86%E7%BE%A4%E5%86%85%E9%83%A8%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="nav-number">2.9.2.2.</span> <span class="nav-text">2、集群内部通讯设计（迭代查询）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8E%9F%E7%90%86"><span class="nav-number">2.9.2.3.</span> <span class="nav-text">3、原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%99"><span class="nav-number">2.9.2.3.1.</span> <span class="nav-text">1、数据分区规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA"><span class="nav-number">2.9.2.3.2.</span> <span class="nav-text">2、常见的哈希分区</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%EF%BC%9A"><span class="nav-number">2.9.2.3.2.1.</span> <span class="nav-text">1、哈希取余：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">2.9.2.3.2.2.</span> <span class="nav-text">2、一致性哈希</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%B8%A6%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-Redis%E9%9B%86%E7%BE%A4"><span class="nav-number">2.9.2.3.2.3.</span> <span class="nav-text">3、带虚拟节点的一致性哈希 (Redis集群)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">2.9.2.3.3.</span> <span class="nav-text">3、通信机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E8%AE%BF%E9%97%AE%E9%9B%86%E7%BE%A4"><span class="nav-number">2.9.2.3.4.</span> <span class="nav-text">4、访问集群</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81Dummy%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">2.9.2.3.4.1.</span> <span class="nav-text">1、Dummy客户端</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Smart%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">2.9.2.3.4.2.</span> <span class="nav-text">2、Smart客户端</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81cluster%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E6%90%AD%E5%BB%BA"><span class="nav-number">2.9.3.</span> <span class="nav-text">3、cluster集群结构搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">1、搭建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Cluster%E9%85%8D%E7%BD%AE"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">2、Cluster配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.9.3.3.</span> <span class="nav-text">3、启动redis服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8master%E7%BB%93%E7%82%B9"><span class="nav-number">2.9.3.3.1.</span> <span class="nav-text">1、启动master结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8Dredis%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.9.3.3.2.</span> <span class="nav-text">2、查看当前redis服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%B0%86%E5%BD%93%E5%89%8D%E7%9A%84%E5%85%AD%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9B%B8%E8%BF%9E"><span class="nav-number">2.9.3.3.3.</span> <span class="nav-text">3、将当前的六个结点相连</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%AD%A4%E6%97%B6redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%97%A5%E5%BF%97"><span class="nav-number">2.9.3.3.4.</span> <span class="nav-text">4、此时redis服务端的日志</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8cluster%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">2.9.3.4.</span> <span class="nav-text">4、使用cluster设置与获取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%9C%A8Cluster%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.9.3.5.</span> <span class="nav-text">5、在Cluster集群下出现相关问题的解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BD%93slave%E7%BB%93%E7%82%B9%E5%AE%95%E6%9C%BA%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.9.3.5.1.</span> <span class="nav-text">1、当slave结点宕机会出现什么问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BD%93master%E7%BB%93%E7%82%B9%E5%AE%95%E6%9C%BA%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.9.3.5.2.</span> <span class="nav-text">2、当master结点宕机会出现什么问题？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81Cluster%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">2.9.3.6.</span> <span class="nav-text">6、Cluster节点操作命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81redis-trib%E5%91%BD%E4%BB%A4"><span class="nav-number">2.9.3.7.</span> <span class="nav-text">7、redis-trib命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="nav-number">2.9.4.</span> <span class="nav-text">4、集群参数优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.10.</span> <span class="nav-text">10、企业级解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">2.10.1.</span> <span class="nav-text">1、缓存预热</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E2%80%9C%E5%AE%95%E6%9C%BA%E2%80%9D"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">1、“宕机”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">2、问题排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.10.1.3.</span> <span class="nav-text">3、解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BB%93%E8%AE%BA"><span class="nav-number">2.10.1.4.</span> <span class="nav-text">4、结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.10.2.</span> <span class="nav-text">2、缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%EF%BC%881%EF%BC%89"><span class="nav-number">2.10.2.1.</span> <span class="nav-text">1、数据库服务器崩溃（1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-1"><span class="nav-number">2.10.2.2.</span> <span class="nav-text">2、问题排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">2.10.2.3.</span> <span class="nav-text">3、问题分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E9%81%93%EF%BC%89"><span class="nav-number">2.10.2.4.</span> <span class="nav-text">4、解决方案（道）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E6%9C%AF%EF%BC%89"><span class="nav-number">2.10.2.5.</span> <span class="nav-text">5、解决方案（术）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">2.10.2.6.</span> <span class="nav-text">6、总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">2.10.3.</span> <span class="nav-text">3、缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%EF%BC%882%EF%BC%89"><span class="nav-number">2.10.3.1.</span> <span class="nav-text">1、数据库服务器崩溃（2）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-2"><span class="nav-number">2.10.3.2.</span> <span class="nav-text">2、问题排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="nav-number">2.10.3.3.</span> <span class="nav-text">3、问题分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E6%9C%AF%EF%BC%89"><span class="nav-number">2.10.3.4.</span> <span class="nav-text">4、解决方案（术）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">2.10.3.5.</span> <span class="nav-text">5、总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">2.10.4.</span> <span class="nav-text">4、缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%EF%BC%883%EF%BC%89"><span class="nav-number">2.10.4.1.</span> <span class="nav-text">1、数据库服务器崩溃（3）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-3"><span class="nav-number">2.10.4.2.</span> <span class="nav-text">2、问题排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="nav-number">2.10.4.3.</span> <span class="nav-text">3、问题分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E6%9C%AF%EF%BC%89-1"><span class="nav-number">2.10.4.4.</span> <span class="nav-text">4、解决方案（术）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.10.4.5.</span> <span class="nav-text">5、总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0"><span class="nav-number">2.10.5.</span> <span class="nav-text">5、缓存更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="nav-number">2.10.6.</span> <span class="nav-text">6、缓存降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="nav-number">2.10.7.</span> <span class="nav-text">7、性能指标监控</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="nav-number">2.10.7.1.</span> <span class="nav-text">1、监控指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9APerformance"><span class="nav-number">2.10.7.1.1.</span> <span class="nav-text">1、性能指标：Performance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87%EF%BC%9AMemory"><span class="nav-number">2.10.7.1.2.</span> <span class="nav-text">2、内存指标：Memory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%9F%BA%E6%9C%AC%E6%B4%BB%E5%8A%A8%E6%8C%87%E6%A0%87%EF%BC%9ABasic-activity"><span class="nav-number">2.10.7.1.3.</span> <span class="nav-text">3、基本活动指标：Basic activity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%E6%8C%87%E6%A0%87%EF%BC%9APersistence"><span class="nav-number">2.10.7.1.4.</span> <span class="nav-text">4、持久性指标：Persistence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87%EF%BC%9AError"><span class="nav-number">2.10.7.1.5.</span> <span class="nav-text">5、错误指标：Error</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81redis%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4"><span class="nav-number">2.10.7.2.</span> <span class="nav-text">2、redis相关的工具与监控命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94benchmark"><span class="nav-number">2.10.7.2.1.</span> <span class="nav-text">1、命令——benchmark</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94monitor"><span class="nav-number">2.10.7.2.2.</span> <span class="nav-text">2、命令——monitor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94showlong"><span class="nav-number">2.10.7.2.3.</span> <span class="nav-text">3、命令——showlong</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3%E3%80%81Redis-6"><span class="nav-number">3.</span> <span class="nav-text">3、Redis 6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">1、NoSQL数据库简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、技术发展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Web-1-0%E6%97%B6%E4%BB%A3"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">1、Web 1.0时代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Web-2-0%E6%97%B6%E4%BB%A3"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">2、Web 2.0时代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3CPU%E5%8F%8A%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">3、解决CPU及内存压力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3IO%E5%8E%8B%E5%8A%9B"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">4、解决IO压力</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、NoSQL数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">1、NoSQL数据库概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81NoSQL%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">2、NoSQL适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81NoSQL%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">3、NoSQL不适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">4、常用的NoSQL数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Memcache"><span class="nav-number">3.1.2.4.1.</span> <span class="nav-text">1、Memcache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Redis"><span class="nav-number">3.1.2.4.2.</span> <span class="nav-text">2、Redis</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81MongoDb"><span class="nav-number">3.1.2.4.3.</span> <span class="nav-text">3、MongoDb</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%89"><span class="nav-number">3.1.3.</span> <span class="nav-text">3、行式存储数据库（大数据时代）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%A1%8C%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">1、行式数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">2、列式数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Hbase"><span class="nav-number">3.1.3.2.1.</span> <span class="nav-text">1、Hbase</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Cassandra-k%C9%99%CB%88saendr%C9%99"><span class="nav-number">3.1.3.2.2.</span> <span class="nav-text">2、Cassandra[kəˈsændrə]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%9B%BE%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.4.</span> <span class="nav-text">4、图关系型数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81DB-Engines-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%90%8D"><span class="nav-number">3.1.5.</span> <span class="nav-text">5、DB-Engines 数据库排名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.2.</span> <span class="nav-text">2、Redis配置文件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81-Units%E5%8D%95%E4%BD%8D"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、###Units单位###</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81-INCLUDES%E5%8C%85%E5%90%AB"><span class="nav-number">3.2.2.</span> <span class="nav-text">2、###INCLUDES包含###</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.3.</span> <span class="nav-text">3、###网络相关配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81bind"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">1、bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81protected-mode"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">2、protected-mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81port"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">3、port</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81tcp-backlog"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">4、tcp-backlog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81timeout"><span class="nav-number">3.2.3.5.</span> <span class="nav-text">5、timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81tcp-keepalive"><span class="nav-number">3.2.3.6.</span> <span class="nav-text">6、tcp-keepalive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81-GENERAL%E9%80%9A%E7%94%A8"><span class="nav-number">3.2.4.</span> <span class="nav-text">4、###GENERAL通用###</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81daemonize"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">1、daemonize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81pidfile"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">2、pidfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81loglevel"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">3、loglevel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81logfile"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">4、logfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81databases-16"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">5、databases 16</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81-SECURITY%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">5、###SECURITY安全###</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">设置密码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81-LIMITS%E9%99%90%E5%88%B6"><span class="nav-number">3.2.6.</span> <span class="nav-text">6、####LIMITS限制###</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81maxclients"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">1、maxclients</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81maxmemory"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">2、maxmemory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81maxmemory-policy"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">3、maxmemory-policy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81maxmemory-samples"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">4、maxmemory-samples</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="nav-number">3.3.</span> <span class="nav-text">3、Redis的发布和订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="nav-number">3.3.1.</span> <span class="nav-text">1、什么是发布和订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="nav-number">3.3.2.</span> <span class="nav-text">2、Redis的发布和订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">3、发布订阅命令行实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.4.</span> <span class="nav-text">4、使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%AF%B9%E6%AF%94"><span class="nav-number">3.3.5.</span> <span class="nav-text">5、对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AF%B9%E6%AF%94List"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">1、对比List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E6%AF%94Kafka"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">2、对比Kafka</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3%E5%BA%93%E5%AD%98%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94LUA%E8%84%9A%E6%9C%AC"><span class="nav-number">3.4.</span> <span class="nav-text">4、解决库存遗留问题——LUA脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81LUA%E8%84%9A%E6%9C%AC"><span class="nav-number">3.4.1.</span> <span class="nav-text">1、LUA脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81LUA%E8%84%9A%E6%9C%AC%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">3.4.2.</span> <span class="nav-text">2、LUA脚本在Redis中的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%9C%A8Redis%E4%B8%AD%E4%BD%BF%E7%94%A8LUA%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.3.</span> <span class="nav-text">3、在Redis中使用LUA脚本示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Redis-6%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="nav-number">3.5.</span> <span class="nav-text">5、Redis 6新功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81ACL"><span class="nav-number">3.5.1.</span> <span class="nav-text">1、ACL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%91%BD%E4%BB%A4"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">2、命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ACL%E8%A7%84%E5%88%99"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">3、ACL规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9C%89%E6%95%88ACL%E8%A7%84%E5%88%99%E7%9A%84%E5%88%97%E8%A1%A8"><span class="nav-number">3.5.1.3.1.</span> <span class="nav-text">1、有效ACL规则的列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8BACL%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4"><span class="nav-number">3.5.1.3.2.</span> <span class="nav-text">2、查看ACL的有哪些命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90"><span class="nav-number">3.5.1.3.3.</span> <span class="nav-text">3、通过命令创建新用户默认权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E8%AE%BE%E7%BD%AE%E6%9C%89%E7%94%A8%E6%88%B7%E5%90%8D%E3%80%81%E5%AF%86%E7%A0%81%E3%80%81ACL%E6%9D%83%E9%99%90%E3%80%81%E5%B9%B6%E5%90%AF%E7%94%A8%E7%9A%84%E7%94%A8%E6%88%B7"><span class="nav-number">3.5.1.3.4.</span> <span class="nav-text">4、设置有用户名、密码、ACL权限、并启用的用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%9D%83%E9%99%90"><span class="nav-number">3.5.1.3.5.</span> <span class="nav-text">5、切换用户，验证权限</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81IO-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">2、IO 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B-2"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">2、原理架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81-Cluster"><span class="nav-number">3.5.3.</span> <span class="nav-text">3、工具支持 Cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Redis%E6%96%B0%E5%8A%9F%E8%83%BD%E6%8C%81%E7%BB%AD%E5%85%B3%E6%B3%A8"><span class="nav-number">3.5.4.</span> <span class="nav-text">4、Redis新功能持续关注</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Redis-%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.6.</span> <span class="nav-text">6、Redis 的缓存一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="nav-number">3.6.0.1.</span> <span class="nav-text">1、Redis 数据一致性简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">3.6.0.2.</span> <span class="nav-text">2、解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.6.0.3.</span> <span class="nav-text">3、详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">3.6.0.3.1.</span> <span class="nav-text">1、先更新数据库，后更新缓存（不推荐）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">3.6.0.3.2.</span> <span class="nav-text">2、先更新缓存，后更新数据库（不推荐）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%EF%BC%89-%E6%8E%A8%E8%8D%90"><span class="nav-number">3.6.0.3.3.</span> <span class="nav-text">3、先删除缓存，后更新数据库（存在问题）(推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">3.6.0.3.4.</span> <span class="nav-text">4、先更新数据库，后删除缓存（推荐）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5%EF%BC%88%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-number">3.6.0.3.5.</span> <span class="nav-text">5、数据异步同步（最佳实现）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">3.6.0.4.</span> <span class="nav-text">4、总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81LUA%E8%84%9A%E6%9C%AC"><span class="nav-number">3.7.</span> <span class="nav-text">7、LUA脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">3.7.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">3.7.2.</span> <span class="nav-text">2、使用lua脚本的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8"><span class="nav-number">3.7.3.</span> <span class="nav-text">3、应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BE%8B1%EF%BC%9A%E8%AE%B0%E5%BD%95IP%E7%99%BB%E5%BD%95%E6%AC%A1%E6%95%B0"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">1、例1：记录IP登录次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BE%8B2%EF%BC%9A%E5%BD%9310%E7%A7%92%E5%86%85%E8%AF%B7%E6%B1%823%E6%AC%A1%E5%90%8E%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE"><span class="nav-number">3.7.3.2.</span> <span class="nav-text">2、例2：当10秒内请求3次后拒绝访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81lua%E8%84%9A%E6%9C%AC%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.4.</span> <span class="nav-text">4、lua脚本缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81Redis6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BACL%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%88%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">8、Redis6新特性之ACL安全策略（用户权限管理）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-4"><span class="nav-number">3.8.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.2.</span> <span class="nav-text">2、配置文件模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81conf%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">1、conf文件模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%A4%96%E9%83%A8ACLFILE%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.2.2.</span> <span class="nav-text">2、外部ACLFILE模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E6%AF%94conf%E5%92%8Caclfile%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.3.</span> <span class="nav-text">3、对比conf和aclfile模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.4.</span> <span class="nav-text">4、命令行模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-5"><span class="nav-number">3.8.4.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ACL%E8%A7%84%E5%88%99"><span class="nav-number">3.8.4.2.</span> <span class="nav-text">2、ACL规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81ACL-HELP"><span class="nav-number">3.8.5.</span> <span class="nav-text">5、ACL HELP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81ACL-LIST"><span class="nav-number">3.8.6.</span> <span class="nav-text">6、ACL LIST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81ACL-USERS"><span class="nav-number">3.8.7.</span> <span class="nav-text">7、ACL USERS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81ACL-WHOAMI"><span class="nav-number">3.8.8.</span> <span class="nav-text">8、ACL WHOAMI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81ACL-CAT"><span class="nav-number">3.8.9.</span> <span class="nav-text">9、ACL CAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81ACL-SETUSER"><span class="nav-number">3.8.10.</span> <span class="nav-text">10、ACL SETUSER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81ACL-GETUSER"><span class="nav-number">3.8.11.</span> <span class="nav-text">11、ACL GETUSER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81ACL-DELUSER"><span class="nav-number">3.8.12.</span> <span class="nav-text">12、ACL DELUSER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81ACL-SAVE"><span class="nav-number">3.8.13.</span> <span class="nav-text">13、ACL SAVE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81ACL-LOAD"><span class="nav-number">3.8.14.</span> <span class="nav-text">14、ACL LOAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81ACL-GENPASS"><span class="nav-number">3.8.15.</span> <span class="nav-text">15、ACL GENPASS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81ACL-LOG"><span class="nav-number">3.8.16.</span> <span class="nav-text">16、ACL LOG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81AUTH"><span class="nav-number">3.8.17.</span> <span class="nav-text">17、AUTH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">3.8.18.</span> <span class="nav-text">18、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81Redis6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BRESP3%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98-Client-side-caching"><span class="nav-number">3.9.</span> <span class="nav-text">9、Redis6新特性之RESP3与客户端缓存(Client side caching)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="nav-number">3.9.1.</span> <span class="nav-text">1、什么是客户端缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-6"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">3.9.1.2.</span> <span class="nav-text">2、客户端缓存的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRESP3"><span class="nav-number">3.9.2.</span> <span class="nav-text">2、什么是RESP3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.9.3.</span> <span class="nav-text">3、客户端缓存的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.9.4.</span> <span class="nav-text">4、默认模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86"><span class="nav-number">3.9.4.1.</span> <span class="nav-text">1、原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8"><span class="nav-number">3.9.4.2.</span> <span class="nav-text">2、应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.9.5.</span> <span class="nav-text">5、广播模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86-1"><span class="nav-number">3.9.5.1.</span> <span class="nav-text">1、原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8-1"><span class="nav-number">3.9.5.2.</span> <span class="nav-text">2、应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.9.6.</span> <span class="nav-text">6、重定向模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81OPTIN-%E5%92%8C-OPTOUT"><span class="nav-number">3.9.7.</span> <span class="nav-text">7、OPTIN 和 OPTOUT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81NOLOOP%E9%80%89%E9%A1%B9"><span class="nav-number">3.9.8.</span> <span class="nav-text">8、NOLOOP选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E5%A4%B1%E6%95%88%E8%A1%A8key%E4%B8%8A%E9%99%90"><span class="nav-number">3.9.9.</span> <span class="nav-text">9、失效表key上限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81Redis6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%90%86-Cluster-Proxy"><span class="nav-number">3.10.</span> <span class="nav-text">10、Redis6新特性之集群代理(Cluster Proxy)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-7"><span class="nav-number">3.10.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85"><span class="nav-number">3.10.2.</span> <span class="nav-text">2、安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%8E%8B"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">1、下载解压</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85gcc4-9-%E7%89%88%E6%9C%AC"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">2、安装gcc4.9+版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BC%96%E8%AF%91"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">3、编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%AE%89%E8%A3%85"><span class="nav-number">3.10.2.4.</span> <span class="nav-text">4、安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%BD%BF%E7%94%A8"><span class="nav-number">3.10.2.5.</span> <span class="nav-text">5、使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="nav-number">3.10.2.5.1.</span> <span class="nav-text">1、配置启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%B7%A8%E8%8A%82%E7%82%B9slot%E6%93%8D%E4%BD%9C"><span class="nav-number">3.10.2.5.2.</span> <span class="nav-text">2、跨节点slot操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">3.10.2.6.</span> <span class="nav-text">6、故障转移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BB%93%E5%B0%BE"><span class="nav-number">3.10.3.</span> <span class="nav-text">3、结尾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81Redis6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BIO%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.11.</span> <span class="nav-text">11、Redis6新特性之IO多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-8"><span class="nav-number">3.11.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis6-0%E4%B9%8B%E5%89%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.11.2.</span> <span class="nav-text">2、为什么Redis6.0之前是单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.11.3.</span> <span class="nav-text">3、什么是IO多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%BC%80%E5%90%AFIO%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.11.4.</span> <span class="nav-text">4、开启IO多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">3.11.5.</span> <span class="nav-text">5、性能对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">3.11.6.</span> <span class="nav-text">6、源码解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%AF%B9%E6%AF%94Memcached"><span class="nav-number">3.11.7.</span> <span class="nav-text">7、对比Memcached</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E7%BB%93%E5%B0%BE"><span class="nav-number">3.11.8.</span> <span class="nav-text">8、结尾</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%84%E6%96%99%E6%9D%A5%E6%BA%90"><span class="nav-number">4.</span> <span class="nav-text">资料来源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
