<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] 面试JAVA SE1、自增变量面试面试代码： 123456789public static void main(String[] args) &amp;#123;    int i &#x3D; 1;    i &#x3D; i++;    int j &#x3D; i++;    int k &#x3D; i + ++i * i++;    System.out.println(&quot;i&#x3D;&quot; + i);    Sy">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] 面试JAVA SE1、自增变量面试面试代码： 123456789public static void main(String[] args) &amp;#123;    int i &#x3D; 1;    i &#x3D; i++;    int j &#x3D; i++;    int k &#x3D; i + ++i * i++;    System.out.println(&quot;i&#x3D;&quot; + i);    Sy">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204445223.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204626492.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204658561.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924205010565.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924212654176.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924230643727.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925002308721.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925002343782.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a93a466-09cf-4488-80f5-23b04dfbb0b1/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/833922c3-3cff-457a-a99f-87f624dcce89/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8467835b-0df8-4a44-8c84-feea5b3ed23f/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af5ce5f4-3102-4a3d-a3f1-1056d883a5ad/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be1565ca-54da-492d-9360-fd5855d34a0d/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de3af23f-d369-41ce-bd7c-70c1ec14cdeb/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fa54eac-c696-4548-8652-fa93364d718e/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925014930971.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925014831510.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925015219816.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925023912627.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/Snipaste_2021-09-24_20-33-17.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925032612325.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925141914079.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925142532325.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7d87cda-138a-4db9-b79a-a37e8ac00f37/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76cd0000-3df2-4ca9-88f6-5112017a19cc/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2dfe083c-ffbe-4b79-981f-0b47f274e71f/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01eb16fb-53a7-4eb4-81fc-bb3764ebf610/Untitled.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ca5467f3ea20c7c0697146376f4c3d47.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bb4d946a40e607b8147e6deac8b02ade.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007004349302.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c07f348f468d4090bb39b07baf4f377e.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3c328ee84a41d90aa960e5857fc78ddf.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007005057732.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d381ecf29e4f454195a84b4b654b56b9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fc14ffa11f07f0cbf735b99cf8fa96df.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007165015054.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-ffecb93c8bf571890c0bc518f1762d44_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007011505668.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ea31ed933323897e3380cdb77ed0e0c7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ae2dd47e47d9481e8e32b0cdc098bce0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/afb4740ac2e70e7365b9927033c24ac9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2b8db2d76a9bb8da9192712ac15761af.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/21daaaa9ae688d7ee417c954a9f3bd4f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4d72208071e80b07f7b9707861420ab0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/08c8543bf7424f4d1b34f41ece0f7eb8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/81285879cc70cbd4b7dff97312bade78.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7030af09224d7acb8e6f7dbb63ed85f2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/85d5ddcb783d854668b2a2622336d68f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/69241ba42f45fb2a94c9b9fb8b8ccbf1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4a1637a018c3a77634eee01a899ab31d.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8290a9483ec124dadabe3929e6a2d979.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9a9efeb3c98d2c9a536d39cf9f1b6f35.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0e97745c55bbd9dcd3a6b4d2619798e7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/843b23b517e0348601c8f9bea5a39371.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/692f53b08decc2f8c273126505d31ebf.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0406b72e8fd11c1c29171c14562de754.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/49f16f165454a2a06ab0fa1c05d13b71.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d0af2849daffa060a77a680311449064.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d61cbb3f465a1faeee808dbf83b2f55a.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/cf1fd627a5f95866a19524d10e10580b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b3d8d8e59730bdf6b36bde1072ac1e36.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/638387916cf2559906201754d698b820.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b85ea37494142bb53c48f7ffa0b68313.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6a2bb392c384f4d4db863c5b4ba45650.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c736fa961c08f2a62b0455a167f6fc3d.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e9e6040168ec3daa5a0233017f70fd74.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/10593da4c5751b30fd8b21a12150c20b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d20d180e9c5d7591093b43581731f923.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/09a722184363e1018e9f2676f56f69a5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2e11011dbccd693bcfd53d9b810622aa.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/edac7b49ece5cb1e491b63f9067082a6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bac8654b3f9e491823f2bc172cf1169f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4b217710f3f2214b7de1cee5d1494e01.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/de8cb0631d168ee788992dbf07d8b608.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/71fa0e9d7441fb7d39e922f02797c58c.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ed73ccc4c1dda8e7cb74c34c6215fe28.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6f7e7f0cee224ad4d17cbbe937abdc2c.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/cc1624181da4c9f8ab26ffaeb9a0d6b7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/074046757a0d38eb0aa96d0d617951c3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/097d8cfe27bda2e8f4aa428c7db26651.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/57377a4668b631579e7da081288c5297.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/40fb3e07ab7b85d744f88e254914188a.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbf2a2f9e9ffbc55033b3f8b0c14c293.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d4232b6200fc5e47f83b231675554b80.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f2fdc13f836deabe04b5b213b1cf08c9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a8a737995cbb141e407e21f5fda16659.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/47f77ce56fee037c28626cd90c70a06c.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/96b8a1f29283395bed85c3c11a9004dd.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ec1eeee5dcd5b46e0714c8240e83e9e8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/edf7e6f1a15c350fabb40661e89e6e82.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/96b5ce842d4e2ede0ecfe08089cd44cd.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2d1dee19311720836ba4b361ee3fb5cb.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bd40fa37def2022fcd8cef8204cbb745.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4cd9ae95a1f79096393aca3af634f8ff.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ca6308338b8bca795d5f10450fa54999.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbccea27f03efcbb1c7ab91fab2c2b4f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f085b60071f613339c8aa209cb2d675f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fd9b00d510df522faf57fa89a10f8619.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8dc2691050faf5a5abe888b89bec0fae.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3698dcaed7ee457601f48962ed30a666.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1ae8fd7ac4e5f14f0353b729d8e0b0c2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/139b5fdf9f83621c3f80754164b2bd8d.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/480c68a3dfd3f33631d398314f8237b7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/465a2a5275f1dba7755f9936740d71bf.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/dbb64257a3175bbf4d6e2d92823c4afb.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a6d69aa082ab9cf610896f85349b0a4b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/327c7b670e87d9d835e649271404e6ea.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/34bd1bbb24e6b2ba69e77f10f25fcd43.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b80bd7bf1b90db7847babede039d4cc6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a179441e34c9e63c34edb8ab5bfa6d0e.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8795709327014d708daae8fa121d0c41.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c9431ae0d435f82fe8f838d8add7e395.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3b5dbe8329accd0ca257fda07c34eb38.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fde9778c2834ef09eb9dc212411a34f1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3ef8ac309383b13c98cb33ff8333cfde.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9a7adb821a06e815f0edad16ee18710a.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a4042699ebedd2fb23bce0823442fd94.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/18414acc299fb31b57bfcd81cb256fed.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f78cc7d7e1941ce37f7a2a5540a9f5a8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5e0adb5af58e58045b983c0ff9d3c2bf.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8f4c51139c9365b200f81f638f23b4d2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9869de7fcccd6ed7f07a9149a78146f4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1480c74cb206c12feaa1ed14a832a6f4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/115016d24a2b156fa0e7ddf022baf1b0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ea46f04b240bed4a2c32f429c848f22b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8610d80e902878d98ac9fcee980498ff.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ee74bbd1cf446a08194408f130589b28.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f0e21ace2afae1e741289d4656bf8498.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/02a772b5813a345127ee52340bf0386d.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/20941ced07602ce3a17bfd309715b458.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/722f782fa462b8c17ab58eb1bcca2b27.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbb029224904fcba0698279f4af33f66.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/103267fe6b29569ed1312d64d85273c5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/11cab9c119340bc9144c60cc2a6d2b6b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/156ab45d51dd92d7f5783264333e2926.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/16114ca319c7b01f8ac42775d0bc93b2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a258520846f7dfce8f42df74d42d9a50.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2aeaa5e6c07774f3e1b826c4ba16dc86.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/88bc9c2eb977576ab9c5e0a2ae727c59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/94d5d60bcfcc2f274c8d8e4525b5dfb9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e03d5af6ef3d6c81d41168f520059828.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5fd485ebd4e00c548f35073b61d11b15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b695223711f058c2fd97f5cfb2b3fc2c.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/52f8acd8be540393d58fb7266d698881.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6d8e2606e3e6130b18000cc0a21df51f-16335883873571.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f5895e44268bca718a64cd5290c544d3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1e265730ad0a573f91214f40242c20e3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2b4bc7f577dd911f3f97000aa6a4a5c9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fed2f335cb411063664af35d5a8ecd71.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ef78a2b56d5e998666ba7f25a0a4da98.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d340bf47b4d4d2be81811fa335167f0c.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f7ae144525efd87929acfcc8e55c444f.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204103456530-1440936422.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204140535741-161861384.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204143852185-1939651975.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204203656875-494940668.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204212449716-1301629510.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204220301492-1148761968.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204220513781-372928637.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204221638906-1777114336.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204223944889-116602678.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204224808505-1568778028.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204231345958-1279298854.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204232549511-1394750161.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204233648113-348674892.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206125000164-1211001618.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206125702165-1508386014.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206131800751-1704613279.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206140724428-31234925.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206142628581-1457152166.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206143755854-491082342-163359507294430.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206145823514-983408464.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206153259183-1350022613.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206160916118-290422058.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210202202515344-1730389536.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210203210248385-1775555013.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210202215113431-1000736063.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925145421487.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925150649625.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925152036088.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925152312959.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/24afba3710eecc8f2225fdec39063d40.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007230228198.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7779829b07787062d2fb57a8f91bb5ce.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f8dda21727ecd0a9163b9c4e216a6ea5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5bf8d9d12b20b9e4c27772b43e22a57a.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d8b324a3c021ae11e71dcc5da1ab8c0b.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/060a18caee395fae8796a48e5214202d.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5e551161caeb7f6eb7892e23d45c2a79.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/54e71cba443b2b5d8f49dad6450bee42.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f8c3f3b937fd77a48cb570188367f8d0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a0f037718cb8d2cbaee49f686dcf0e74.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/12c5526453ae59e64efda4a309510040-163369964360812.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/abc068f7d766a68862079499bfea6613.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/174430816d515a4f9070b7a7158dffa6.gif">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/61d11a2206812ac5cfb0ab75e0cbe6e4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e2135890194fbd120f88377c16d34b26.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b2d5a55df4837226e085710d78a0d8f6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ab423b570f2556aae42047dc30031fef.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2ca45a630c105106f1052e5fdf1a8aa2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3543591488da5c26a2dd6aa1abf82ae1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/151c954021cb888f15e299ddb20346df.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925231133733.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925232120695.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925232730948.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925235908134.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005539237.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005610144.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005930287.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926022649349.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141136813-16326367030621.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141201995.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141050834.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210927150822979.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210928224559619.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210928224539153.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929015055562.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929014307611.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929015024492.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929020401653.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7f749fc8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8afdf6f2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/90f4132ca8188e1af37bed13615a8b37.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d78b62f55bf63f6240b8e9be41494029.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/90f4132ca8188e1af37bed13615a8b37.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/dfb1ef1312d571b596bb378a20265d67.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c4cbe27c2615bbe033144019d3142dfb.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211006145617321.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/10a24b1847439613cd2a7215553142b1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5105058dbcfd3dc94f40d560f1070432.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b2cce18d2b747938c3ed826e35b88bfa.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0cc1c6dc17e11c0eb76c2f24b14a4683.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/df751e0935dd3a3dc18d447ea434c9a3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/92128bc9be81f4c38c52cb9a1a5390ac.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211006234534626.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007000856860.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007001005389.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007001033334.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929154440600.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929154740187.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929160007999.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929161910910.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929162641205.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929163807231-16329046893941.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164652331.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164702060.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164525230.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164531215.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929165529641.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929170211758.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930022132677.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930022952843.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930023036859.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930024037129.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003192451779.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193243584.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193407527.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193748985.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210429023609239.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003195511732.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003220332605.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003220751051.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221514373.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221017872.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221029445.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221035370.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004023839443.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024015511.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024112912.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024222685.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004034427789.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004035000114.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004035101683.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004040241718.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223828690.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223911772.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223950346.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925224505115.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225359975.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225423420.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225451607.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225658814.png">
<meta property="article:published_time" content="2021-09-23T13:50:31.000Z">
<meta property="article:modified_time" content="2021-10-08T14:09:58.321Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204445223.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题 | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-23 21:50:31" itemprop="dateCreated datePublished" datetime="2021-09-23T21:50:31+08:00">2021-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-08 22:09:58" itemprop="dateModified" datetime="2021-10-08T22:09:58+08:00">2021-10-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记 - 面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="JAVA-SE"><a href="#JAVA-SE" class="headerlink" title="JAVA SE"></a>JAVA SE</h2><h3 id="1、自增变量"><a href="#1、自增变量" class="headerlink" title="1、自增变量"></a>1、自增变量</h3><h4 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h4><p>面试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">    System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">    System.out.println(<span class="string">&quot;k=&quot;</span> + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure>



<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote>
<p>代码相关字节码</p>
</blockquote>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204445223.png" alt="image-20210924204445223"></p>
<p>对应的操作数栈与局部变量表执行顺序</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204626492.png" alt="image-20210924204626492"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924204658561.png" alt="image-20210924204658561"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924205010565.png" alt="image-20210924205010565"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>赋值=，最后计算</li>
<li>=右边的从左到右加载值依次压入操作数栈</li>
<li>实际先算哪个，看运算符优先级</li>
<li><strong>自增、自减操作都是直接修改局部变量表当中变量的值，不经过操作数栈</strong></li>
<li><strong>最后的赋值之前，临时结果也是存储在操作数栈中</strong></li>
</ul>
<h3 id="2、单例模式——Singleton"><a href="#2、单例模式——Singleton" class="headerlink" title="2、单例模式——Singleton"></a>2、单例模式——Singleton</h3><h4 id="面试-2"><a href="#面试-2" class="headerlink" title="面试"></a>面试</h4><p>编程题：写一个Singleton示例</p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><h5 id="1、什么是Singleton？"><a href="#1、什么是Singleton？" class="headerlink" title="1、什么是Singleton？"></a>1、什么是Singleton？</h5><ul>
<li>Singleton：在Java中即指单例设计模式，它是软件开发中最常用的设计模式之一。<ul>
<li>单：唯一</li>
<li>例：实例</li>
</ul>
</li>
<li>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。<ul>
<li>例如：代表JVM运行环境的Runtime类</li>
</ul>
</li>
</ul>
<h5 id="2、要点"><a href="#2、要点" class="headerlink" title="2、要点"></a>2、要点</h5><ol>
<li>一是某个类只能有一个实例；<ul>
<li>构造器私有化</li>
</ul>
</li>
<li>二是它必须自行创建这个实例；<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
</li>
<li>三是它必须自行向整个系统提供这个实例;<ul>
<li>对外提供获取该实例对象的方式：<ol>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="3、几种常见形式"><a href="#3、几种常见形式" class="headerlink" title="3、几种常见形式"></a>3、几种常见形式</h5><ul>
<li>饿汉式：直接创建对象，不存在线程安全问题<ul>
<li>直接实例化饿汉式（简洁直观）</li>
<li>枚举式（最简洁、最安全）</li>
<li>静态代码块饿汉式（适合复杂实例化）</li>
</ul>
</li>
<li>懒汉式：延迟创建对象<ul>
<li>线程不安全（适用于单线程）</li>
<li>线程安全（加锁，适用于多线程）</li>
<li>双重检查（适用于多线程，效率比加锁高）</li>
<li>静态内部类形式（适用于多线程）</li>
</ul>
</li>
</ul>
<h5 id="4、实现"><a href="#4、实现" class="headerlink" title="4、实现"></a>4、实现</h5><h6 id="1、饿汉式——直接实例化饿汉式（简洁直观）"><a href="#1、饿汉式——直接实例化饿汉式（简洁直观）" class="headerlink" title="1、饿汉式——直接实例化饿汉式（简洁直观）"></a>1、饿汉式——直接实例化饿汉式（简洁直观）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 饿汉式：</span></span><br><span class="line"><span class="comment"> * 	在类初始化时直接创建实例对象，不管你是否需要这个对象都会创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * （1）构造器私有化</span></span><br><span class="line"><span class="comment"> * （2）自行创建，并且用静态变量保存</span></span><br><span class="line"><span class="comment"> * （3）向外提供这个实例</span></span><br><span class="line"><span class="comment"> * （4）强调这是一个单例，我们可以用final修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    pubilc <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、饿汉式——枚举式（最简洁、最安全）"><a href="#2、饿汉式——枚举式（最简洁、最安全）" class="headerlink" title="2、饿汉式——枚举式（最简洁、最安全）"></a>2、饿汉式——枚举式（最简洁、最安全）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 枚举类型：表示该类型的对象是有限的几个</span></span><br><span class="line"><span class="comment"> * 我们可以限定为一个，就成了单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、饿汉式——静态代码块饿汉式（适合复杂实例化）（可以使用配置文件来解耦合）"><a href="#3、饿汉式——静态代码块饿汉式（适合复杂实例化）（可以使用配置文件来解耦合）" class="headerlink" title="3、饿汉式——静态代码块饿汉式（适合复杂实例化）（可以使用配置文件来解耦合）"></a>3、饿汉式——静态代码块饿汉式（适合复杂实例化）（可以使用配置文件来解耦合）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton IASTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(Singleton.class.getClassLoader().getResourceAsStream(<span class="string">&quot;single.properties&quot;</span>));</span><br><span class="line">	        INSTANCE = <span class="keyword">new</span> Singleton(pro.getProperty(<span class="string">&quot;info&quot;</span>));            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Singleton [info=&quot;</span> + info + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的配置文件single.properties：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：该配置文件要放在src目录下面，否则Properties加载不到</p>
</blockquote>
<h6 id="4、懒汉式——线程不安全（适用于单线程）"><a href="#4、懒汉式——线程不安全（适用于单线程）" class="headerlink" title="4、懒汉式——线程不安全（适用于单线程）"></a>4、懒汉式——线程不安全（适用于单线程）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式：</span></span><br><span class="line"><span class="comment"> * 	延迟创建这个实例对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (1)构造器私有化</span></span><br><span class="line"><span class="comment"> * (2)用一个静态变量保存这个唯一的实例</span></span><br><span class="line"><span class="comment"> * (3)提供一个静态方法，获取这个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">	        INSTANCE = <span class="keyword">new</span> Singleton();            </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5、懒汉式——线程安全（加锁，适用于多线程）"><a href="#5、懒汉式——线程安全（加锁，适用于多线程）" class="headerlink" title="5、懒汉式——线程安全（加锁，适用于多线程）"></a>5、懒汉式——线程安全（加锁，适用于多线程）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Synchronized(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">		        INSTANCE = <span class="keyword">new</span> Singleton();            </span><br><span class="line">    	    &#125;</span><br><span class="line">			<span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="6、懒汉式——双重检查（适用于多线程，效率比加锁高）"><a href="#6、懒汉式——双重检查（适用于多线程，效率比加锁高）" class="headerlink" title="6、懒汉式——双重检查（适用于多线程，效率比加锁高）"></a>6、懒汉式——双重检查（适用于多线程，效率比加锁高）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Synchronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();            </span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7、懒汉式——静态内部类形式（适用于多线程）"><a href="#7、懒汉式——静态内部类形式（适用于多线程）" class="headerlink" title="7、懒汉式——静态内部类形式（适用于多线程）"></a>7、懒汉式——静态内部类形式（适用于多线程）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在内部类被加载和初始化时，才创建INSTANCE实例对象</span></span><br><span class="line"><span class="comment"> * 静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的。</span></span><br><span class="line"><span class="comment"> * 因为是在内部类加载和初始化时，创建的，因此是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果是饿汉式，枚举形式最简单</li>
<li>如果是懒汉式，静态内部类形式最简单</li>
</ul>
<h3 id="3、类初始化与实例初始化"><a href="#3、类初始化与实例初始化" class="headerlink" title="3、类初始化与实例初始化"></a>3、类初始化与实例初始化</h3><h4 id="面试-3"><a href="#面试-3" class="headerlink" title="面试"></a>面试</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924212654176.png" alt="image-20210924212654176"></p>
<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)</span><br><span class="line">(9)(3)(2)(9)(8)(7)</span><br></pre></td></tr></table></figure>



<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><h5 id="1、类初始化过程"><a href="#1、类初始化过程" class="headerlink" title="1、类初始化过程"></a>1、类初始化过程</h5><ol>
<li>一个类要创建实例需要<strong>先加载并初始化该类</strong><ul>
<li>main方法所在的类需要先加载和初始化</li>
</ul>
</li>
<li>一个子类要初始化需要<strong>先初始化父类</strong></li>
<li><strong>一个类初始化就是执行<clinit>()方法</clinit></strong><ul>
<li><clinit>()方法由<strong>静态类变量</strong>显示赋值代码和<strong>静态代码块</strong>组成</clinit></li>
<li>类变量显示赋值代码和静态代码块代码<strong>从上到下顺序执行</strong></li>
<li><clinit>()方法<strong>只执行一次</strong></clinit></li>
</ul>
</li>
</ol>
<h5 id="2、实例初始化过程"><a href="#2、实例初始化过程" class="headerlink" title="2、实例初始化过程"></a>2、实例初始化过程</h5><p>实例初始化就是执行<init>()方法</init></p>
<ul>
<li><init>()方法可能重载有多个，<strong>有几个构造器就有几个<init>方法</init></strong></init></li>
<li><init>()方法由<strong>非静态实例变量</strong>显示赋值代码和<strong>非静态代码块</strong>、<strong>对应构造器</strong>代码组成</init></li>
<li>非静态实例变量显示赋值代码和非静态代码块代码<strong>从上到下顺序执行</strong>，而<strong>对应构造器的代码最后执行</strong></li>
<li><strong>每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法</init></strong></li>
<li><strong><init>方法的首行是super()或super(实参列表)，即对应父类的<init>方法</init></init></strong></li>
</ul>
<h5 id="3、方法的重写"><a href="#3、方法的重写" class="headerlink" title="3、方法的重写"></a>3、方法的重写</h5><ul>
<li>哪些方法不可以被重写<ul>
<li><strong>final方法</strong></li>
<li><strong>静态方法</strong></li>
<li><strong>private等子类中不可见方法</strong></li>
</ul>
</li>
<li>对象的多态性<ul>
<li>子类如果重写了父类的方法，<strong>通过子类对象调用的一定是子类重写过的代码</strong></li>
<li><strong>非静态方法默认的调用对象是this</strong></li>
<li>this对象在构造器或者说**<init>方法中就是正在创建的对象**</init></li>
</ul>
</li>
<li>方法的重写与重载的区别<ul>
<li>方法重写（Override）：<ul>
<li>是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></li>
<li>好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</li>
<li><strong>方法的重写规则</strong>：<ul>
<li>参数列表与被重写方法的参数列表必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个类，则不能重写该类的方法。</li>
</ul>
</li>
</ul>
</li>
<li>方法重载(Overload)：<ul>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>
<li>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li>
<li>最常用的地方就是构造器的重载。</li>
<li><strong>方法重载规则</strong>：<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4、方法参数传递机制"><a href="#4、方法参数传递机制" class="headerlink" title="4、方法参数传递机制"></a>4、方法参数传递机制</h3><h4 id="面试-4"><a href="#面试-4" class="headerlink" title="面试"></a>面试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		Integer num = <span class="number">200</span>;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line">		</span><br><span class="line">		change(i,str,num,arr,my);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">		System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">		System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">		System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">		System.out.println(<span class="string">&quot;my.a = &quot;</span> + my.a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a,MyData m)</span></span>&#123;</span><br><span class="line">		j += <span class="number">1</span>;</span><br><span class="line">		s += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">		n += <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">		m.a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">str = hello</span><br><span class="line">num = 200</span><br><span class="line">arr = [2,3,4,5,6]</span><br><span class="line">my.a = 11</span><br></pre></td></tr></table></figure>



<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>以上代码的方法参数传递机制</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210924230643727.png" alt="image-20210924230643727"></p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>方法的参数传递机制：</p>
<ul>
<li>形参是基本数据类型<ul>
<li>传递数据值</li>
</ul>
</li>
<li>实参是引用数据类型<ul>
<li>传递地址值</li>
</ul>
</li>
<li>特殊的类型：<strong>String</strong>、<strong>包装类</strong>等对象不可变性</li>
</ul>
<h3 id="5、递归与迭代"><a href="#5、递归与迭代" class="headerlink" title="5、递归与迭代"></a>5、递归与迭代</h3><h4 id="面试-5"><a href="#面试-5" class="headerlink" title="面试"></a>面试</h4><p>编程题：有n步台阶，一次只能上1步或2步，共有多少种走法？</p>
<ol>
<li>递归</li>
<li>迭代</li>
</ol>
<h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><h5 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h5><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925002308721.png" alt="image-20210925002308721"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStep</span></span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		System.out.println(f(<span class="number">100</span>));<span class="comment">//165580141</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(end-start);<span class="comment">//586ms</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实现f(n)：求n步台阶，一共有几种走法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(n + <span class="string">&quot;不能小于1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f(n-<span class="number">2</span>) + f(n-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、循环迭代"><a href="#2、循环迭代" class="headerlink" title="2、循环迭代"></a>2、循环迭代</h5><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925002343782.png" alt="image-20210925002343782"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStep2</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		System.out.println(loop(<span class="number">100</span>));<span class="comment">//165580141</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(end-start);<span class="comment">//&lt;1ms</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(n + <span class="string">&quot;不能小于1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> one = <span class="number">2</span>;<span class="comment">//初始化为走到第二级台阶的走法</span></span><br><span class="line">		<span class="keyword">int</span> two = <span class="number">1</span>;<span class="comment">//初始化为走到第一级台阶的走法</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			<span class="comment">//最后跨2步 + 最后跨1步的走法</span></span><br><span class="line">			sum = two + one;</span><br><span class="line">			two = one;</span><br><span class="line">			one = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>方法调用自身称为递归，利用变量的原值推出新值称为迭代。</li>
<li>递归<ul>
<li>优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好；</li>
<li>缺点：递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。</li>
</ul>
</li>
<li>迭代<ul>
<li>优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销；</li>
<li>缺点：代码不如递归简洁，可读性好</li>
</ul>
</li>
</ul>
<h3 id="6、成员变量与局部变量"><a href="#6、成员变量与局部变量" class="headerlink" title="6、成员变量与局部变量"></a>6、成员变量与局部变量</h3><h4 id="面试-6"><a href="#面试-6" class="headerlink" title="面试"></a>面试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam5</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s;<span class="comment">//成员变量，类变量</span></span><br><span class="line">	<span class="keyword">int</span> i;<span class="comment">//成员变量，实例变量</span></span><br><span class="line">	<span class="keyword">int</span> j;<span class="comment">//成员变量，实例变量</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//非静态代码块中的局部变量 i</span></span><br><span class="line">		i++;</span><br><span class="line">		j++;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;<span class="comment">//形参，局部变量,j</span></span><br><span class="line">		j++;</span><br><span class="line">		i++;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//形参，局部变量，args</span></span><br><span class="line">		Exam5 obj1 = <span class="keyword">new</span> Exam5();<span class="comment">//局部变量，obj1</span></span><br><span class="line">		Exam5 obj2 = <span class="keyword">new</span> Exam5();<span class="comment">//局部变量，obj1</span></span><br><span class="line">		obj1.test(<span class="number">10</span>);</span><br><span class="line">		obj1.test(<span class="number">20</span>);</span><br><span class="line">		obj2.test(<span class="number">30</span>);</span><br><span class="line">		System.out.println(obj1.i + <span class="string">&quot;,&quot;</span> + obj1.j + <span class="string">&quot;,&quot;</span> + obj1.s);</span><br><span class="line">		System.out.println(obj2.i + <span class="string">&quot;,&quot;</span> + obj2.j + <span class="string">&quot;,&quot;</span> + obj2.s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2,1,5</span><br><span class="line">1,1,5</span><br></pre></td></tr></table></figure>



<h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><ul>
<li>就近原则<ul>
<li>如果变量同名而且前面没有加this的话，采用的就是就近原则</li>
</ul>
</li>
<li>变量的分类<ul>
<li>成员变量：类变量、实例变量</li>
<li>局部变量</li>
</ul>
</li>
<li><strong>非静态代码块的执行：每次创建实例对象都会执行</strong></li>
<li><strong>方法的调用规则：调用一次执行一次</strong></li>
</ul>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>局部变量与成员变量的区别：</p>
<ol>
<li>声明的位置<ul>
<li>局部变量：方法体{}中，形参，代码块{}中</li>
<li>成员变量：类中方法外<ul>
<li>类变量：有static修饰</li>
<li>实例变量：没有static修饰</li>
</ul>
</li>
</ul>
</li>
<li>修饰符<ul>
<li>局部变量：final</li>
<li>成员变量：public、protected、private、final、static、volatile、transient</li>
</ul>
</li>
<li>值存储的位置<ul>
<li><strong>局部变量：栈</strong></li>
<li><strong>实例变量：堆</strong></li>
<li><strong>类变量：方法区</strong></li>
</ul>
</li>
<li>作用域<ul>
<li>局部变量：从声明处开始，到所属的<code>&#125;</code>结束</li>
<li>实例变量：在当前类中“this.”(有时this.可以缺省)，在其他类中“对象名.”访问</li>
<li>类变量：在当前类中“类名.”(有时类名.可以省略)，在其他类中“类名.”或“对象名.”访问</li>
</ul>
</li>
<li>生命周期<ul>
<li><strong>局部变量：每一个线程，每一次调用执行都是新的生命周期</strong></li>
<li><strong>实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量是独立的</strong></li>
<li><strong>类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的</strong></li>
</ul>
</li>
</ol>
<p>当局部变量与xx变量重名时，如何区分：</p>
<ol>
<li>局部变量与实例变量重名<ul>
<li>在实例变量前面加“this.”</li>
</ul>
</li>
<li>局部变量与类变量重名<ul>
<li>在类变量前面加“类名.”</li>
</ul>
</li>
</ol>
<h3 id="7、字符串常量java内部加载"><a href="#7、字符串常量java内部加载" class="headerlink" title="7、字符串常量java内部加载"></a>7、字符串常量java内部加载</h3><h4 id="面试——《深入理解Java虚拟机第三版》2-4-3"><a href="#面试——《深入理解Java虚拟机第三版》2-4-3" class="headerlink" title="面试——《深入理解Java虚拟机第三版》2.4.3"></a>面试——《深入理解Java虚拟机第三版》2.4.3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str1.intern());</span><br><span class="line">    System.out.println(str1 == str1.intern());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">    System.out.println(str2.intern());</span><br><span class="line">    System.out.println(str2 == str2.intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">58tongcheng</span><br><span class="line">58tongcheng</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">------------------</span><br><span class="line">java</span><br><span class="line">java</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h4 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h4><p>按照代码结果，java字符串答案为false 必然是两个不同的java，那另外一个java字符串如何加载进来的?</p>
<blockquote>
<p>因为有一个初始化的java字符串**(JDK加载时自带的)<strong>， 在加载<code>sun.misc.Version</code>这个类的时候进入</strong>常量池**。</p>
</blockquote>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a93a466-09cf-4488-80f5-23b04dfbb0b1/Untitled.png" alt="img"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/833922c3-3cff-457a-a99f-87f624dcce89/Untitled.png" alt="img"></p>
<h5 id="1、OpenJDK8底层源码说明问题"><a href="#1、OpenJDK8底层源码说明问题" class="headerlink" title="1、OpenJDK8底层源码说明问题"></a>1、OpenJDK8底层源码说明问题</h5><h6 id="1、System源码解析"><a href="#1、System源码解析" class="headerlink" title="1、System源码解析"></a>1、System源码解析</h6><p>System→ initializeSystemClass→Version：</p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8467835b-0df8-4a44-8c84-feea5b3ed23f/Untitled.png" alt="img"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af5ce5f4-3102-4a3d-a3f1-1056d883a5ad/Untitled.png" alt="img"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be1565ca-54da-492d-9360-fd5855d34a0d/Untitled.png" alt="img"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de3af23f-d369-41ce-bd7c-70c1ec14cdeb/Untitled.png" alt="img"></p>
<h6 id="2、类加载器和rt-jar"><a href="#2、类加载器和rt-jar" class="headerlink" title="2、类加载器和rt.jar"></a>2、类加载器和rt.jar</h6><p>根加载器提前部署加载rt.jar</p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fa54eac-c696-4548-8652-fa93364d718e/Untitled.png" alt="img"></p>
<h5 id="2、关于String-的-intern方法"><a href="#2、关于String-的-intern方法" class="headerlink" title="2、关于String 的 intern方法"></a>2、关于String 的 intern方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Returns a canonical representation for the string object.<br>A pool of strings, initially empty, is maintained privately by the class String.<br>When the intern method is invoked, <strong>if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned</strong>. <strong>Otherwise, this String object is added to the pool and a reference to this String object is returned</strong>.<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.<br>Returns:<br>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p>
</blockquote>
<p>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到字符串常量池中，并且返回次String对象的引用。</p>
<p><strong>方法区和运行时常量池的溢出</strong>：</p>
<p>由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放在一起进行。在JDK6或者更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX:PermSize和-XX:MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量。而在HotSpot虚拟机在JDK8中完全使用元空间来代替永久代，原本存放在永久代的字符串常量池被移至java堆当中，所以通过限制方法区容量已经没有了意义。如果我们在JDK7以及以上版本，通过限制java堆空间的大小，如：-Xmx。就能看到OOM：Java heap space。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>如果在JDK6当中，面试的代码返回的是两个false，因为在JD6当中，intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池当中存储，返回的也是永久代里面这个字符串实例的引用，与StringBuilder创建的字符串在java堆空间当中，所以必然不可能是同一个引用，结果返回false。</p>
<p>而在JDK7当中，intern()方法实现就不需要拷贝字符串实例到永久代了，因为字符串常量池已经从方法区移动到java堆空间当中，因此intern()方法只需要在字符串常量池里记录一下首次出现的字符串实例即可，因此intern()返回的引用和StringBuilder创建的字符串实例的引用就是同一个，结果返回true。</p>
<p>由于字符串”java”在类加载的时候就已经加载进字符串常量池当中了（不是首次创建），所以之后在java堆空间创建的字符串”java”的引用与在java堆空间的字符串常量池的字符串”java”的引用不是同一个，因此返回false。</p>
<blockquote>
<p>注：不只是字符串”java”，在JDK7以及之后的版本中，其他字符串如果有在java初始化类加载的时候进行过加载的话，也是已经加载进java堆的字符串常量池当中了，返回也是false。如zip等等。</p>
</blockquote>
<hr>
<h2 id="JAVA-EE"><a href="#JAVA-EE" class="headerlink" title="JAVA EE"></a>JAVA EE</h2><h3 id="1、Spring-Bean-的作用域之间有什么区别"><a href="#1、Spring-Bean-的作用域之间有什么区别" class="headerlink" title="1、Spring Bean 的作用域之间有什么区别"></a>1、Spring Bean 的作用域之间有什么区别</h3><p>解析：</p>
<p>在Spring中，可以在<bean>元素的scope属性你设置bean的作用域，以决定这个bean是单实例的还是多实例的。</bean></p>
<p><strong>默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例</strong>：所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，它是所有bean的默认作用域。</p>
<p>Spring Bean一共有四个作用域，可以通过scope属性来指定bean的作用域：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td><strong>默认值</strong>。<strong>当IOC容器一创建就会创建bean的实例（饿汉式）</strong>，而且是<strong>单例的</strong>，在SpringIOC容器中仅存在一个Bean实例</td>
</tr>
<tr>
<td>prototype</td>
<td><strong>原型的</strong>。<strong>当IOC容器一创建不再实例化该bean（懒汉式）</strong>，<strong>每次调用getBean方法时在实例化该bean</strong>，而且每调用一次getBean方法就<strong>创建一个新的实例对象</strong></td>
</tr>
<tr>
<td>request</td>
<td><strong>每次HTTP请求实例化一个新的bean</strong>，该作用域仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td>session</td>
<td><strong>在同一个HTTP Session会话中共享一个bean</strong>，不同的HTTP Session使用不同的Bean。该作用域仅适用于WebApplicationContext环境</td>
</tr>
</tbody></table>
<h3 id="2、Spring支持的常用数据库事务传播属性和事务隔离级别"><a href="#2、Spring支持的常用数据库事务传播属性和事务隔离级别" class="headerlink" title="2、Spring支持的常用数据库事务传播属性和事务隔离级别"></a>2、Spring支持的常用数据库事务传播属性和事务隔离级别</h3><p>解析：</p>
<h4 id="1、什么是事务的传播？"><a href="#1、什么是事务的传播？" class="headerlink" title="1、什么是事务的传播？"></a>1、什么是事务的传播？</h4><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<h4 id="2、事务的传播行为种类"><a href="#2、事务的传播行为种类" class="headerlink" title="2、事务的传播行为种类"></a>2、事务的传播行为种类</h4><p>事务的传播行为可以由传播属性指定。Spring定义了7种类传播行为</p>
<table>
<thead>
<tr>
<th>传播属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>当前的方法必须启动新事务，并在它自己的事务内运行。如果有事务正在运行，应该将它挂起</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行。否则它可以不运行在事务中</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>当前的方法不应该运行在事务中，如果有运行的事务，将它挂起</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>当前的方法必须运行在事务内部，如果没有运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NEVER</td>
<td>当前的方法不应该运行在事务内部，如果有运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行</td>
</tr>
</tbody></table>
<p>事务传播属性可以在 <code>@Transactional</code> 注解的 <code>propagation</code> 属性中定义。</p>
<p>现在重点来讲一下 <code>REQUIRED</code> 与 <code>REQUIRES_NEW</code> </p>
<h4 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h4><p>现有100现金，去购买价值60元、库存100件的《Spring》与价值50元、库存100件的《SpringMVC》</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925014930971.png" alt="image-20210925014930971"></p>
<p>有两种结果：</p>
<ol>
<li>两本书都买不成，现金依旧有100元，两本书的库存依旧是100件</li>
<li>买成了第一本书《Spring》，买不了第二本书《SpringMVC》，现金为40元，《Spring》的库存只剩下99件，而《SpringMVC》的库存依旧有100件</li>
</ol>
<p>导致以上两种结果的原因是事务的传播行为的不同。</p>
<h5 id="1、REQUIRED"><a href="#1、REQUIRED" class="headerlink" title="1、REQUIRED"></a>1、REQUIRED</h5><p>Propagation.REQUIRED：默认值，如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行。</p>
<p>结果：两本书都买不成，现金依旧有100元，两本书的库存依旧是100件</p>
<p>解析：</p>
<p>REQUIRED 传播行为：当bookService 的 purchase()方法被另外一个事务方法checkout()调用时，它默认会在现有的事务内运行。这个默认的传播行为就是REQUIRED 。因此在checkout()方法的开始和终止边界类内只有一个事务。这个事务只在checkout()方法结束的时候被提交，结果用户一本书都买不了</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925014831510.png" alt="image-20210925014831510"></p>
<h5 id="2、REQUIRES-NEW"><a href="#2、REQUIRES-NEW" class="headerlink" title="2、REQUIRES_NEW"></a>2、REQUIRES_NEW</h5><p>Propagation.REQUIRES_NEW：表示该方法必须启动一个新事务，并在自己的事务内运行。如果有事务在运行，就应该先挂起它。</p>
<p>结果：买成了第一本书《Spring》，买不了第二本书《SpringMVC》，现金为40元，《Spring》的库存只剩下99件，而《SpringMVC》的库存依旧有100件</p>
<p>解析：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925015219816.png" alt="image-20210925015219816"></p>
<h4 id="4、数据库的事务并发问题"><a href="#4、数据库的事务并发问题" class="headerlink" title="4、数据库的事务并发问题"></a>4、数据库的事务并发问题</h4><p>假设现在有两个事务：Transactional01 和 Transactional02 并发执行。</p>
<ol>
<li>脏读<ol>
<li>Transaction01将某条记录的AGE值从20修改为30。</li>
<li>Transaction02读取了Transaction01更新后的值：30。</li>
<li>Transaction01回滚，AGE值恢复到了20。</li>
<li>Transaction02读取到的30就是一个无效的值。</li>
</ol>
</li>
<li>不可重复读<ol>
<li>Transaction01读取了AGE值为20。</li>
<li>Transaction02将AGE值修改为30。</li>
<li>Transaction01再次读取AGE值为30，和第一次读取不一致。</li>
</ol>
</li>
<li>幻读<ol>
<li>Transaction01读取了STUDENT表中的一部分数据。</li>
<li>Transaction02向STUDENT表中插入了新的行。</li>
<li>Transaction01读取了STUDENT表时，多出了一些行。</li>
</ol>
</li>
</ol>
<h4 id="5、隔离级别"><a href="#5、隔离级别" class="headerlink" title="5、隔离级别"></a>5、隔离级别</h4><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。<strong>一个事务与其他事务隔离的程度称为隔离级别</strong>。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<ol>
<li><strong>读未提交：READ UNCOMMITTED</strong><ul>
<li>允许TranSaction01读取Transaction02未提交的修改。</li>
</ul>
</li>
<li><strong>读已提交：READ COMMITTED</strong><ul>
<li>要求Transaction01只能读取Transaction02已提交的修改。</li>
</ul>
</li>
<li><strong>可重复读：REPEATABLE READ</strong><ul>
<li>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</li>
</ul>
</li>
<li><strong>串行化：SERIALIZABLE</strong><ul>
<li>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</li>
</ul>
</li>
</ol>
<p>隔离级别属性可以在 <code>@Transactional</code> 注解的 <code>isolation</code> 属性中定义。如：</p>
<ul>
<li>Isolation.READ_UNCOMMITTED</li>
<li>Isolation.READ_COMMITTED</li>
</ul>
<h4 id="6、各个隔离级别解决并发问题的能力"><a href="#6、各个隔离级别解决并发问题的能力" class="headerlink" title="6、各个隔离级别解决并发问题的能力"></a>6、各个隔离级别解决并发问题的能力</h4><table>
<thead>
<tr>
<th></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ UNCOMMITTED</strong></td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong></td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<blockquote>
<p>表格当中的“有”“无”代表的是当前的左边隔离级别有没有上面的并发问题</p>
</blockquote>
<h4 id="7、各种数据库产品对事务隔离级别的支持程度"><a href="#7、各种数据库产品对事务隔离级别的支持程度" class="headerlink" title="7、各种数据库产品对事务隔离级别的支持程度"></a>7、各种数据库产品对事务隔离级别的支持程度</h4><table>
<thead>
<tr>
<th></th>
<th>Oracle</th>
<th>MySql</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ UNCOMMITTED</strong></td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong></td>
<td>√（默认）</td>
<td>√</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td>×</td>
<td>√（默认）</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="3、SpringMVC如何解决POST请求中文乱码问题"><a href="#3、SpringMVC如何解决POST请求中文乱码问题" class="headerlink" title="3、SpringMVC如何解决POST请求中文乱码问题"></a>3、SpringMVC如何解决POST请求中文乱码问题</h3><p>解析：</p>
<p>需要配置一个字符编码过滤器CharacterEncodingFilter来解决POST请求中文乱码问题</p>
<p>字符编码过滤器CharacterEncodingFilter源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置的字符集</span></span><br><span class="line">    <span class="keyword">private</span> String encoding;</span><br><span class="line">    <span class="comment">// 响应的时候是否需要使用上面设置的字符集</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> forceEncoding = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dpFilterInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果没有设置 encoding的话，默认就为null。如果设置了encoding的话就为true</span></span><br><span class="line"><span class="comment">        * forceEncoding如果设置为true的话，或者request.getCharacterEncoding()为null的话</span></span><br><span class="line"><span class="comment">        * 就能进入if语句块</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.forceEncoding || request.getCharacterEncoding()==<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 将设置的encoding字符集放进去</span></span><br><span class="line">            request.setCharacterEncoding(<span class="keyword">this</span>.encoding);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.forceEncoding) &#123;</span><br><span class="line">                <span class="comment">// 响应的时候使用上面设置的字符集</span></span><br><span class="line">				response.setCharacterEncoding(<span class="keyword">this</span>.encoding) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		filterChain.doFliter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决问题：</p>
<ol>
<li><p>在web.xml中配置CharacterEncodingFilter过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--解决POST请求的请求乱码问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：该过滤器要配置在web.xml的最上面</p>
</blockquote>
</li>
<li><p>在CharacterEncodingFilter过滤器的下面在配置一些过滤器的相关映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里的名字需要和上面配置的filter-name一致--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>以上方法只能解决的是POST请求的中文乱码问题</li>
<li>如果把请求修改为GET，依旧会出现中文乱码问题</li>
</ul>
</blockquote>
<p>那么，怎么解决GET请求的中文乱码问题?</p>
<p>最简单的一种方式：修改tomcat服务器的server.xml文件</p>
<ol>
<li><p>先找到tomcat服务器的server.xml文件</p>
</li>
<li><p>找到第一个Connector标签</p>
</li>
<li><p>在后面添加<code>URIEncoding=&quot;UTF-8&quot;</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925023912627.png" alt="image-20210925023912627"></p>
</li>
</ol>
<h3 id="4、简单谈一下SpringMVC的工作流程"><a href="#4、简单谈一下SpringMVC的工作流程" class="headerlink" title="4、简单谈一下SpringMVC的工作流程"></a>4、简单谈一下SpringMVC的工作流程</h3><p>解析：</p>
<p>SpringMVC的工作流程图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/Snipaste_2021-09-24_20-33-17.png" alt="Snipaste_2021-09-24_20-33-17"></p>
<p>代码执行流程：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925032612325.png" alt="image-20210925032612325"></p>
<h3 id="5、MyBatis中当实体类中的属性名和表中的字段名不一样的解决方法"><a href="#5、MyBatis中当实体类中的属性名和表中的字段名不一样的解决方法" class="headerlink" title="5、MyBatis中当实体类中的属性名和表中的字段名不一样的解决方法"></a>5、MyBatis中当实体类中的属性名和表中的字段名不一样的解决方法</h3><p>解析：</p>
<ol>
<li><p>在对应的mapper文件写sql语句时起别名</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925141914079.png" alt="image-20210925141914079"></p>
</li>
<li><p>在Mybatis的全局配置文件mybatis-config.xml中开启驼峰命名规则</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 开启驼峰命名规则，可以将数据库中的下划线映射为驼峰命名</span></span><br><span class="line"><span class="comment">		例如: last_name 可以映射为lastName</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>= <span class="string">&quot;mapUnderscoreToCameLCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Mapper映射文件中使用resultMap来自定义映射规则</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925142532325.png" alt="image-20210925142532325"></p>
</li>
</ol>
<hr>
<h2 id="Spring：主要考察IOC-AOP-TX（事务相关）"><a href="#Spring：主要考察IOC-AOP-TX（事务相关）" class="headerlink" title="Spring：主要考察IOC + AOP +TX（事务相关）"></a>Spring：主要考察IOC + AOP +TX（事务相关）</h2><h3 id="1、Aop的常用注解"><a href="#1、Aop的常用注解" class="headerlink" title="1、Aop的常用注解"></a>1、Aop的常用注解</h3><p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7d87cda-138a-4db9-b79a-a37e8ac00f37/Untitled.png" alt="img"></p>
<h3 id="2、有关于Spring-aop的面试题"><a href="#2、有关于Spring-aop的面试题" class="headerlink" title="2、有关于Spring aop的面试题"></a>2、有关于Spring aop的面试题</h3><h4 id="1、Srping-aop全部通知顺序问题"><a href="#1、Srping-aop全部通知顺序问题" class="headerlink" title="1、Srping aop全部通知顺序问题"></a>1、Srping aop全部通知顺序问题</h4><p>你肯定知道spring，那说说aop的全部通知顺序？springboot或springboot2对aop的执行顺序影响?</p>
<ul>
<li>SpringBoot1底层使用的是Spring4</li>
<li>SpringBoot2底层使用的是Spring5</li>
</ul>
<p>其实问的就是Spring4与Spring5的aop的全部通知顺序的区别？</p>
<h5 id="1、Spring4的aop的全部通知顺序"><a href="#1、Spring4的aop的全部通知顺序" class="headerlink" title="1、Spring4的aop的全部通知顺序"></a>1、Spring4的aop的全部通知顺序</h5><p>版本：Spring4.3.13 +springboot1.5.9</p>
<p><strong>spring4默认用的是JDK的动态代理</strong></p>
<p><strong>正常执行：@Before （前置通知）@After（后置通知）@AfterReturning (正常返回)</strong></p>
<p><strong>异常执行：@Before （前置通知）@After（后置通知）@AfterThrowing (方法异常)</strong></p>
<p>Spring4.3.13 +springboot1.5.9：正常aop顺序：</p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76cd0000-3df2-4ca9-88f6-5112017a19cc/Untitled.png" alt="img"></p>
<p>Spring4.3.13 +springboot1.5.9：异常aop顺序：</p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2dfe083c-ffbe-4b79-981f-0b47f274e71f/Untitled.png" alt="img"></p>
<p>总结：</p>
<p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01eb16fb-53a7-4eb4-81fc-bb3764ebf610/Untitled.png" alt="img"></p>
<h5 id="2、Spring5的aop的全部通知顺序"><a href="#2、Spring5的aop的全部通知顺序" class="headerlink" title="2、Spring5的aop的全部通知顺序"></a>2、Spring5的aop的全部通知顺序</h5><p>版本：Spring5.2.8 +springboot2.3.3</p>
<p><strong>spring5默认动态代理用的是cglib</strong>，不再是JDK的动态代理， 因为JDK必须要实现接口，但有些类它并没有实现接口，所以更加通用的话就是cglib</p>
<p><strong>正常执行：@Before（前置通知）@AfterReturning（正常返回）@After（后置通知)）</strong></p>
<p><strong>异常执行：@Before（前置通知）@AfterThrowing（方法异常）@After（后置通知)）</strong></p>
<p>Spring5+springboot2.3.3：aop正常顺序：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ca5467f3ea20c7c0697146376f4c3d47.png" alt="image-20210122160308629"></p>
<p>Spring5+springboot2.3.3：aop异常顺序：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bb4d946a40e607b8147e6deac8b02ade.png" alt="image-20210122160313858"></p>
<p>总结：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007004349302.png" alt="image-20211007004349302"></p>
<h5 id="3、Srping-aop全部通知顺序总结"><a href="#3、Srping-aop全部通知顺序总结" class="headerlink" title="3、Srping aop全部通知顺序总结"></a>3、Srping aop全部通知顺序总结</h5><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c07f348f468d4090bb39b07baf4f377e.png" alt="image-20210122160250883"></p>
<h4 id="2、Spring-的循环依赖问题"><a href="#2、Spring-的循环依赖问题" class="headerlink" title="2、Spring 的循环依赖问题"></a>2、Spring 的循环依赖问题</h4><h5 id="1、相关面试题"><a href="#1、相关面试题" class="headerlink" title="1、相关面试题"></a>1、相关面试题</h5><ol>
<li>你解释下spring中的三级缓存？</li>
<li>三级缓存分别是什么？三个Map有什么异同？</li>
<li>什么是循环依赖？请你谈谈？看过 Spring源码吗？一般我们说的 Spring容器是什么？</li>
<li>如何检测是否存在循环依赖？实际开发中见过循环依赖的异常吗？</li>
<li>多例的情况下，循环依赖问题为什么无法解决？</li>
</ol>
<h5 id="2、什么是循环依赖？"><a href="#2、什么是循环依赖？" class="headerlink" title="2、什么是循环依赖？"></a>2、什么是循环依赖？</h5><p><strong>多个 bean 之间相互依赖，形成了一个闭环</strong></p>
<p>比如：A 依赖于 B、B 依赖于 C、C 依赖于 A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependency</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        B b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        C c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        A a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，如果问 Spring 容器内部如何解决循环依赖， 一定是指默认的单例 Bean 中，属性互相引用的场景。也就是说，Spring 的循环依赖，是 Spring 容器注入时候出现的问题</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3c328ee84a41d90aa960e5857fc78ddf.png" alt="image-20210122181643319"></p>
<h5 id="3、两种注入方式对循环依赖的影响"><a href="#3、两种注入方式对循环依赖的影响" class="headerlink" title="3、两种注入方式对循环依赖的影响"></a>3、两种注入方式对循环依赖的影响</h5><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies">官网对循环依赖的说明</a></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007005057732.png" alt="image-20211007005057732"></p>
<p><strong>两种注入方式对循环依赖的影响</strong>：</p>
<ul>
<li>构造器注入：容易造成无法解决的循环依赖，不推荐使用（If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.）</li>
<li>Setter 注入：推荐使用 setter 方式注入单例 bean</li>
</ul>
<p>spring容器：</p>
<ul>
<li>默认的单例(singleton)的场景是支持循环依赖的，不报错。</li>
<li>原型(Prototype)的场景是不支持循环依赖的，会报错。默认单例，修改为原型scope=”prototype” 就导致了循环依赖错误</li>
</ul>
<p><strong>结论</strong>：<strong>我们 AB 循环依赖问题只要注入方式是 setter 且bean 的 scope 属性是 singleton，就不会有循环依赖问题</strong></p>
<h5 id="4、那么Spring底层是怎么解决循环依赖的呢"><a href="#4、那么Spring底层是怎么解决循环依赖的呢" class="headerlink" title="4、那么Spring底层是怎么解决循环依赖的呢"></a>4、那么Spring底层是怎么解决循环依赖的呢</h5><p><strong>Spring 内部通过 3 级缓存来解决循环依赖</strong></p>
<p>所谓的三级缓存其实就是 Spring 容器内部用来解决循环依赖问题的三个 Map，这三个 Map 在 <code>DefaultSingletonBeanRegistry</code> 类中</p>
<blockquote>
<p>只有单例的bean会通过三级缓存提前暴露来解决循环依赖问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中，因此也解决不了循环依赖问题。</p>
</blockquote>
<p><strong>那么三级缓存的这三个Map分别是什么？有什么异同？</strong></p>
<ol>
<li>第一级缓存〈也叫<strong>单例池</strong>）<code>Map&lt;String, Object&gt; singletonObjects</code>：常说的 Spring 容器就是指它，我们获取单例 bean 就是在这里面获取的，存放已经经历了完整生命周期的Bean对象</li>
<li>第二级缓存：<code>Map&lt;String, Object&gt; earlySingletonObjects</code>，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完整，可以认为是半成品的 bean）</li>
<li>第三级缓存： <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>，存放可以生成Bean的工厂，用于生产（创建）bean对象</li>
</ol>
<h5 id="5、源码-Deug-前置知识"><a href="#5、源码-Deug-前置知识" class="headerlink" title="5、源码 Deug 前置知识"></a>5、源码 Deug 前置知识</h5><h6 id="1、实例化-amp-初始化"><a href="#1、实例化-amp-初始化" class="headerlink" title="1、实例化 &amp; 初始化"></a>1、实例化 &amp; 初始化</h6><p><strong>实例化和初始化的区别</strong>：</p>
<ul>
<li><p>实例化：堆内存中申请一块内存空间</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d381ecf29e4f454195a84b4b654b56b9.png" alt="image-20210123101131093"></p>
</li>
<li><p>初始化：完成属性的填充</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fc14ffa11f07f0cbf735b99cf8fa96df.png" alt="image-20210123101143372"></p>
</li>
</ul>
<h6 id="2、3个Map-amp-5个方法"><a href="#2、3个Map-amp-5个方法" class="headerlink" title="2、3个Map &amp; 5个方法"></a>2、3个Map &amp; 5个方法</h6><p><strong>三级缓存 + 五大方法</strong>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007165015054.png" alt="image-20211007165015054"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-ffecb93c8bf571890c0bc518f1762d44_1440w.jpg" alt="img"></p>
<p><strong>三级缓存《==》3个Map</strong>：</p>
<ol>
<li>第一级缓存singletonObjects：存放的是已经初始化好了的Bean，bean名称与bean实例相对应，即所谓的单例池。表示已经经历了完整生命周期的Bean对象</li>
<li>第二级缓存earlySingletonObjects：存放的是实例化了，但是未初始化的Bean，bean名称与bean实例相对应。表示Bean的生命周期还没走完（Bean的属性还未填充）就把这个Bean存入该缓存中。也就是实例化但未初始化的bean放入该缓存里</li>
<li>第三级缓存singletonFactories：表示存放生成bean的工厂，存放的是FactoryBean，bean名称与bean工厂对应。假如A类实现了FactoryBean，那么依赖注入的时候不是A类，而是A类产生的Bean</li>
</ol>
<p><strong>五大方法</strong>：</p>
<ol>
<li><code>getSingleton()</code>：从容器里面获得单例的bean，没有的话则会创建 bean</li>
<li><code>doCreateBean()</code>：执行创建 bean 的操作（在 Spring 中以 do 开头的方法都是干实事的方法）</li>
<li><code>populateBean()</code>：创建完 bean 之后，对 bean 的属性进行填充</li>
<li><code>initializeBean()</code>：初始化bean对象，也是在这里完成AOP代理</li>
<li><code>addSingleton()</code>：bean 初始化完成之后，添加到单例容器池中，下次执行 getSingleton() 方法时就能获取到</li>
</ol>
<blockquote>
<p>注：关于第三级缓存 Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories的说明：singletonFactories 的 value 为 ObjectFactory 接口实现类的实例。ObjectFactory 为函数式接口，在该接口中定义了一个 getObject() 方法用于获取 bean，这也正是工厂思想的体现（工厂设计模式）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007011505668.png" alt="image-20211007011505668"></p>
</blockquote>
<h6 id="3、对象在三级缓存中的迁移"><a href="#3、对象在三级缓存中的迁移" class="headerlink" title="3、对象在三级缓存中的迁移"></a>3、对象在三级缓存中的迁移</h6><p><strong>A/B 两对象在三级缓存中的迁移说明</strong>：</p>
<ol>
<li>A创建过程中需要B，于是A将自己放到三级缓存里面，去实例化B</li>
<li>B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A，然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A</li>
<li>B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态），然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。</li>
</ol>
<h5 id="6、详细-Debug-流程"><a href="#6、详细-Debug-流程" class="headerlink" title="6、详细 Debug 流程"></a>6、详细 Debug 流程</h5><blockquote>
<p><strong>技巧：如何阅读框架源码？答：打断点 + 看日志</strong></p>
</blockquote>
<h6 id="1、beanA的实例化"><a href="#1、beanA的实例化" class="headerlink" title="1、beanA的实例化"></a>1、beanA的实例化</h6><p>在 <code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code> 代码处打上断点，逐步执行（Step Over），发现执行 <code>new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</code> 操作时，beanA 和 beanB 都已经被创建好了，因此我们需要进入 <code>new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</code> 中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ea31ed933323897e3380cdb77ed0e0c7.png" alt="image-20210122230104635"></p>
<p><strong>进入 <code>new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</code> 中</strong>：</p>
<p>点击 Step Into，首先进入了静态代码块中，不管我们的事，使用 Step Out 退出此方法</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ae2dd47e47d9481e8e32b0cdc098bce0.png" alt="image-20210122230423326"></p>
<p>再次 Step Into，进入 <code>ClassPathXmlApplicationContext</code> 类的构造函数，该构造函数使用 this 调用了另一个重载构造函数</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/afb4740ac2e70e7365b9927033c24ac9.png" alt="image-20210122230632877"></p>
<p>继续 Step Into，进入重载构造函数后单步 Step Over，发现执行完 <code>refresh()</code> 方法后输出如下日志，于是我们将断点打在 <code>refresh()</code> 那一行</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2b8db2d76a9bb8da9192712ac15761af.png" alt="image-20210122230823849"></p>
<p><strong>进入 <code>refresh()</code> 方法</strong>：</p>
<p>Step Into 进入 refresh() 方法，发现执行完 <code>finishBeanFactoryInitialization(beanFactory)</code> 方法后输出日志，于是我们将断点打在 <code>finishBeanFactoryInitialization(beanFactory)</code> 那一行</p>
<p>从注释也可以看出本方法完成了非懒加载单例 bean的初始化（Instantiate all remaining (non-lazy-init) singletons.）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/21daaaa9ae688d7ee417c954a9f3bd4f.png" alt="image-20210122231301414"></p>
<p><strong>进入 <code>finishBeanFactoryInitialization(beanFactory)</code> 方法</strong>：</p>
<p>Step Into 进入 <code>finishBeanFactoryInitialization(beanFactory)</code> 方法，发现执行完 <code>beanFactory.preInstantiateSingletons()</code> 方法后输出日志，于是我们将断点打在 <code>beanFactory.preInstantiateSingletons()</code> 那一行</p>
<p>从注释也可以看出本方法完成了非懒加载单例 bean的初始化（Instantiate all remaining (non-lazy-init) singletons.）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4d72208071e80b07f7b9707861420ab0.png" alt="image-20210122231617225"></p>
<p><strong>进入 <code>beanFactory.preInstantiateSingletons()</code> 方法</strong>：</p>
<p>Step Into 进入 <code>beanFactory.preInstantiateSingletons()</code> 方法，发现执行完 <code>getBean(beanName)</code> 方法后输出日志，于是我们将断点打在 <code>getBean(beanName)</code> 那一行</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/08c8543bf7424f4d1b34f41ece0f7eb8.png" alt="image-20210122231902178"></p>
<p><strong>进入 <code>getBean(beanName)</code> 方法</strong>：</p>
<p><code>getBean(beanName)</code> 调用了 <code>doGetBean(name, null, null, false)</code> 方法，即：<strong>在 Spring 里面，以do 开头的方法都是干实事的方法</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/81285879cc70cbd4b7dff97312bade78.png" alt="image-20210122232111871"></p>
<p><strong>进入 <code>doGetBean(name, null, null, false)</code> 方法</strong>：</p>
<p>我们可以给 bean 配置别名，这里的 <code>transformedBeanName(name)</code> 方法就是将用户别名转换为 bean 的真实名称</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7030af09224d7acb8e6f7dbb63ed85f2.png" alt="image-20210122232301105"></p>
<p><strong>进入 <code>getSingleton(beanName)</code> 方法</strong>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/85d5ddcb783d854668b2a2622336d68f.png" alt="image-20210122232610296"></p>
<p>调用了其重载的方法，<code>allowEarlyReference == true</code> 表示可以从三级缓存 <code>earlySingletonObjects</code> 中获取 bean，allowEarlyReference == false 表示不可以从三级缓存 earlySingletonObjects 中获取 bean</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/69241ba42f45fb2a94c9b9fb8b8ccbf1.png" alt="image-20210122232708127"></p>
<p><code>getSingleton(beanName, true)</code> 方法尝试从一级缓存 singletonObjects 中获取 beanA，beanA 现在还没有开始造，（isSingletonCurrentlyInCreation(beanName) 返回 false），获取不到返回 null</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4a1637a018c3a77634eee01a899ab31d.png" alt="image-20210122232923347"></p>
<p><strong>回到 <code>doGetBean(name, null, null, false)</code> 方法中</strong>：</p>
<p><strong>getSingleton(beanName)方法返回null</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8290a9483ec124dadabe3929e6a2d979.png" alt="image-20210122233201164"></p>
<p>我们所说的 bean 对于 Spring 来说就是一个个的 <code>RootBeanDefinition</code> 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9a9efeb3c98d2c9a536d39cf9f1b6f35.png" alt="image-20210122233255044"></p>
<p>这个 <code>dependsOn</code> 变量对应于 bean 的 <code>depends-on=&quot;&quot;</code> 属性，我们没有配置过，因此为 <code>null</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0e97745c55bbd9dcd3a6b4d2619798e7.png" alt="image-20210122233409563"></p>
<p>转了一圈发现并没有 beanA，终于要开始准备创建 beanA 啦</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/843b23b517e0348601c8f9bea5a39371.png" alt="image-20210122233943061"></p>
<p><strong>进入 <code>getSingleton(beanName, () -&gt; &#123;...&#125;</code> 方法</strong>：</p>
<p>首先尝试从一级缓存 <code>singletonObjects</code> 获取 beanA，那肯定是获取不到，因此 <strong>singletonObject == null</strong>，那么就需要创建 beanA，此时日志会输出：【Creating shared instance of singleton bean ‘a’】</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/692f53b08decc2f8c273126505d31ebf.png" alt="image-20210123112301014"></p>
<p>当执行完 <code>singletonObject = singletonFactory.getObject();</code> 时，会输出【A created success】，这说明<strong>执行 singletonFactory.getObject() 方法时将会实例化 beanA</strong>，并且根据代码变量名可得知单例工厂创建的，<strong>这个单例工厂就是我们传入的 Lambda 表达式</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0406b72e8fd11c1c29171c14562de754.png" alt="image-20210123112653528"></p>
<p><strong>进入 <code>createBean(beanName, mbd, args)</code> 方法</strong>:</p>
<p><code>mbdToUse</code> 将用于创建 beanA：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/49f16f165454a2a06ab0fa1c05d13b71.png" alt="image-20210123113109315"></p>
<p>来了，终于要执行 <code>doCreateBean(beanName, mbdToUse, args)</code> 实例化 beanA：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d0af2849daffa060a77a680311449064.png" alt="image-20210123113439196"></p>
<p><strong>进入 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法</strong>：</p>
<p>在 <code>factoryBeanInstanceCache</code> 中并不存在 beanA 对应的 Wrapper 缓存，<strong>instanceWrapper == null</strong>，因此我们要去创建 beanA 对应的 instanceWrapper，Wrapper 有包裹之意思，instanceWrapper 翻译过来为实例包裹器的意思，形象理解为：beanA 实例化需要经过 instanceWrapper 之手，beanA 实例被 instanceWrapper 包裹在其中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d61cbb3f465a1faeee808dbf83b2f55a.png" alt="image-20210123113721708"></p>
<p><strong>进入 <code>createBeanInstance(beanName, mbd, args)</code> 方法</strong>：</p>
<p>这一看就是<strong>反射</strong>的操作</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/cf1fd627a5f95866a19524d10e10580b.png" alt="image-20210123114509257"></p>
<p>这里有个 resolved 变量，写着注释：Shortcut when re-creating the same bean…，我个人理解是 resolved 标志该 bean 是否已经被实例化了，如果已经被实例化了，那么 resolved == true，这样就不用重复创建同一个 bean 了</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b3d8d8e59730bdf6b36bde1072ac1e36.png" alt="image-20210123114722004"></p>
<p>Candidate constructors for autowiring? 难道是构造器自动注入？在 return 的时候调用 <code>instantiateBean(beanName, mbd)</code> 方法实例化 beanA，并将其返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/638387916cf2559906201754d698b820.png" alt="image-20210123115049589"></p>
<p><strong>进入 <code>instantiateBean(beanName, mbd)</code> 方法</strong>：</p>
<p><code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 方法完成了 beanA 的实例化</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b85ea37494142bb53c48f7ffa0b68313.png" alt="image-20210123115807740"></p>
<p><strong>进入 <code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 方法</strong>：</p>
<p>首先获取已经解析好的构造器 <code>bd.resolvedConstructorOrFactoryMethod</code>，这是第一次创建，当然还没有啦，因此 <strong>constructorToUse == null</strong>。然后获取 A 的类型，如果发现是接口则直接抛异常。最后获取 A 的公开构造器，并将其赋值给 bd.resolvedConstructorOrFactoryMethod</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6a2bb392c384f4d4db863c5b4ba45650.png" alt="image-20210123120436544"></p>
<p>获取构造器的目的当然是为了实例化 beanA</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c736fa961c08f2a62b0455a167f6fc3d.png" alt="image-20210123120804415"></p>
<p><strong>进入 <code>BeanUtils.instantiateClass(constructorToUse)</code> 方法</strong>：</p>
<p>通过构造器创建 beanA 实例，Step Over 后会输出：【A created success】，并且会回到 <code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 方法中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e9e6040168ec3daa5a0233017f70fd74.png" alt="image-20210123120941726"></p>
<p><strong>回到 <code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 方法中</strong>：</p>
<p>在 <code>BeanUtils.instantiateClass(constructorToUse)</code> 方法中创建好了 beanA 实例，不过还没有进行初始化，可以看到属性 <code>b = null</code>，Step Over 后会回到 <code>instantiateBean(beanName, mbd)</code> 方法中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/10593da4c5751b30fd8b21a12150c20b.png" alt="image-20210123163945288"></p>
<p><strong>回到 <code>instantiateBean(beanName, mbd)</code> 方法中</strong>：</p>
<p>得到刚才创建的 beanA 实例，但其属性并未被初始化</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d20d180e9c5d7591093b43581731f923.png" alt="image-20210123164916170"></p>
<p>将实例化的 beanA 装进 BeanWrapper 中并返回 <code>bw</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/09a722184363e1018e9f2676f56f69a5.png" alt="image-20210123165203819"></p>
<p><strong>回到 <code>createBeanInstance(beanName, mbd, args)</code> 方法中</strong>：</p>
<p>得到刚才创建的 <code>beanWrapper</code> 实例，该 <code>beanWrapper</code> 包裹（封装）了刚才创建的 beanA 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2e11011dbccd693bcfd53d9b810622aa.png" alt="image-20210123165447074"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>在 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法获得 <code>BeanWrapper instanceWrapper</code>，用于封装 beanA 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/edac7b49ece5cb1e491b63f9067082a6.png" alt="image-20210123165629641"></p>
<p>获取并记录 A 的全类名：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bac8654b3f9e491823f2bc172cf1169f.png" alt="image-20210123170700410"></p>
<p>执行 <code>BeanPostProcessor</code>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4b217710f3f2214b7de1cee5d1494e01.png" alt="image-20210123170837080"></p>
<p>如果<strong>该 bean 是单例 bean</strong>（mbd.isSingleton()），并且<strong>允许循环依赖</strong>（this.allowCircularReferences），并且<strong>当前 bean 正在创建过程中</strong>（isSingletonCurrentlyInCreation(beanName)），那么就<strong>允许提前暴露该单例 bean</strong>（earlySingletonExposure = true），则会执行 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 方法<strong>将该 bean 放到三级缓存 <code>singletonFactories</code> 中</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/de8cb0631d168ee788992dbf07d8b608.png" alt="image-20210123170940500"></p>
<p><strong>进入 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 方法</strong>：</p>
<p>首先去一级缓存 singletonObjects 中找一下有没有 beanA，肯定没有啦~然后将 beanA 添加到三级缓存 <code>singletonFactories</code> 中，并将 beanA 从二级缓存 earlySingletonObjects 中移除（虽然此时的二级缓存当中没有beanA），最后将 beanName 添加至 registeredSingletons 中，表示该 bean 实例已经被注册</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/71fa0e9d7441fb7d39e922f02797c58c.png" alt="image-20210123171328459"></p>
<h6 id="2、beanA-的属性填充——初始化"><a href="#2、beanA-的属性填充——初始化" class="headerlink" title="2、beanA 的属性填充——初始化"></a>2、beanA 的属性填充——初始化</h6><p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>接着回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中，需要执行 <code>populateBean(beanName, mbd, instanceWrapper)</code> 方法对 beanA 中的属性进行填充</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ed73ccc4c1dda8e7cb74c34c6215fe28.png" alt="image-20210123171726753"></p>
<p><strong>进入 <code>populateBean(beanName, mbd, instanceWrapper)</code> 方法</strong>：</p>
<p>反射获取 beanA 的属性列表</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6f7e7f0cee224ad4d17cbbe937abdc2c.png" alt="image-20210123171917156"></p>
<p>执行 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法完成 beanA 属性的填充</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/cc1624181da4c9f8ab26ffaeb9a0d6b7.png" alt="image-20210123172048186"></p>
<p><strong>进入 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法</strong>：</p>
<p>取到 beanA 的属性列表，发现有个属性为 <code>b</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/074046757a0d38eb0aa96d0d617951c3.png" alt="image-20210123172426598"></p>
<p>遍历每一个属性，并对每一个属性进行注入，<code>valueResolver.resolveValueIfNecessary(pv, originalValue)</code> 的作用：Given a PropertyValue, return a value, resolving any references to other beans in the factory if necessary.</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/097d8cfe27bda2e8f4aa428c7db26651.png" alt="image-20210123172613391"></p>
<p><strong>进入 <code>valueResolver.resolveValueIfNecessary(pv, originalValue)</code> 方法</strong>：</p>
<p>通过 <code>resolveReference(argName, ref)</code> 解决依赖注入的问题：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/57377a4668b631579e7da081288c5297.png" alt="image-20210123173739270"></p>
<p><strong>进入 <code>resolveReference(argName, ref)</code> 方法</strong>：</p>
<p>先获得属性 <code>b</code> 的名称，再通过 <code>this.beanFactory.getBean(resolvedName)</code> 方法获取 beanB 的实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/40fb3e07ab7b85d744f88e254914188a.png" alt="image-20210123174227557"></p>
<h6 id="3、beanB-的实例化"><a href="#3、beanB-的实例化" class="headerlink" title="3、beanB 的实例化"></a>3、beanB 的实例化</h6><p><strong>进入 <code>this.beanFactory.getBean(resolvedName)</code> 方法</strong>：</p>
<p>哦，这熟悉的 <code>doGetBean(name, null, null, false)</code> 方法：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbf2a2f9e9ffbc55033b3f8b0c14c293.png" alt="image-20210123174510971"></p>
<p><strong>再次执行 <code>doGetBean(name, null, null, false)</code> 方法</strong>：</p>
<p>beanB 还没有实例化，因此 <code>getSingleton(beanName)</code> 方法返回 <code>null</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d4232b6200fc5e47f83b231675554b80.png" alt="image-20210123174631167"></p>
<p>又来到了这个熟悉的地方，先尝试获取 beanB 实例，获取不到就执行 <code>createBean()</code> 的操作</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f2fdc13f836deabe04b5b213b1cf08c9.png" alt="image-20210123181159951"></p>
<p><strong>进入 <code>getSingleton(beanName, () -&gt; &#123;... &#125;</code> 方法</strong>：</p>
<p>首先尝试从一级缓存 <code>singletonObjects</code> 中获取 beanB，那肯定是获取不到的呀</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a8a737995cbb141e407e21f5fda16659.png" alt="image-20210123181540128"></p>
<p>然后就调用 <code>singletonFactory.getObject()</code> 创建 beanB</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/47f77ce56fee037c28626cd90c70a06c.png" alt="image-20210123230319469"></p>
<p><strong>进入 <code>createBean(beanName, mbd, args)</code> 方法</strong>：</p>
<p>获取到 beanB 的类型为 <code>com.heygo.spring.circulardependency.B</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/96b8a1f29283395bed85c3c11a9004dd.png" alt="image-20210123230722139"></p>
<p>之前创建 beanA 的时候没有看到，现在看到挺有趣的：Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. 也就是说我们<strong>可以通过 BeanPostProcessors 返回 bean 的代理，而非 bean 本身</strong>。然后喜闻乐见，又来到了 <code>doCreateBean(beanName, mbdToUse, args)</code> 环节<img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ec1eeee5dcd5b46e0714c8240e83e9e8.png" alt="image-20210123231047179"></p>
<p><strong>进入 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法</strong>：</p>
<p>老样子，创建 beanB 对应的 <code>BeanWrapper instanceWrapper</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/edf7e6f1a15c350fabb40661e89e6e82.png" alt="image-20210123231513068"></p>
<p><strong>进入 <code>createBeanInstance(beanName, mbd, args)</code> 方法</strong>：</p>
<p>调用 <code>instantiateBean(beanName, mbd)</code> 创建 <code>beanWrapper</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/96b5ce842d4e2ede0ecfe08089cd44cd.png" alt="image-20210123231659756"></p>
<p><strong>进入 <code>instantiateBean(beanName, mbd)</code> 方法</strong>：</p>
<p>调用 <code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 创建 <code>beanWrapper</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2d1dee19311720836ba4b361ee3fb5cb.png" alt="image-20210123231815848"></p>
<p><strong>进入 <code>getInstantiationStrategy().instantiate(mbd, beanName, this)</code> 方法</strong>：</p>
<p>获取 <code>com.heygo.spring.circulardependency.B</code> 的构造器，并将构造器信息记录在 <code>bd.resolvedConstructorOrFactoryMethod</code> 字段中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bd40fa37def2022fcd8cef8204cbb745.png" alt="image-20210123232017300"></p>
<p>调用 <code>BeanUtils.instantiateClass(constructorToUse)</code> 方法创建 beanB 实例：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/4cd9ae95a1f79096393aca3af634f8ff.png" alt="image-20210123232156728"></p>
<p><strong>进入 <code>BeanUtils.instantiateClass(constructorToUse)</code> 方法</strong>：</p>
<p>通过调用 <code>B</code> 类的构造器创建 beanB 实例，此时控制台会输出：【B created success】</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ca6308338b8bca795d5f10450fa54999.png" alt="image-20210123232344101"></p>
<p><strong>回到 <code>instantiateBean(beanName, mbd)</code> 方法中</strong>：</p>
<p>在 <code>instantiateBean(beanName, mbd)</code> 方法中得到创建好的 beanB 实例，并将其丢进 <code>beanWrapper</code> 中，封装为 <code>BeanWrapper bw</code> 对象</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbccea27f03efcbb1c7ab91fab2c2b4f.png" alt="image-20210123232617698"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p><code>createBeanInstance(beanName, mbd, args)</code>方法将返回包装着 beanB 的<code>beanWrapper</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f085b60071f613339c8aa209cb2d675f.png" alt="image-20210123233026527"></p>
<p>执行 <code>BeanPostProcessor</code> 的处理过程：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fd9b00d510df522faf57fa89a10f8619.png" alt="image-20210123233404820"></p>
<p>beanB 由于<strong>满足单例</strong>并且<strong>正在被创建</strong>，因此 beanB <strong>可以被提前暴露出去</strong>（在属性还未初始化的时候可以提前暴露出去），于是执行 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 方法<strong>将其添加至三级缓存 <code>singletonFactory</code> 中</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8dc2691050faf5a5abe888b89bec0fae.png" alt="image-20210123233523439"></p>
<p><strong>进入 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 方法</strong>：</p>
<p>将 beanB 实例添加至三级缓存 <code>singletonFactory</code> 中，从二级缓存 <code>earlySingletonObjects</code> 中移除（虽然此时的第二级缓存当中也没有beanB），并注册其 beanName</p>
<blockquote>
<p>注：此时第三级缓存有两个值：</p>
<ul>
<li>K：beanA，V：beanAFactory的lambda表达式</li>
<li>K：beanB，V：beanBFactory的lambda表达式</li>
</ul>
</blockquote>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3698dcaed7ee457601f48962ed30a666.png" alt="image-20210123233916978"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>执行 <code>populateBean(beanName,mbd,instancewrapper)</code> 方法填充 beanB 的属性</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1ae8fd7ac4e5f14f0353b729d8e0b0c2.png" alt="image-20210123234133479"></p>
<h6 id="4、beanB-的属性填充——初始化"><a href="#4、beanB-的属性填充——初始化" class="headerlink" title="4、beanB 的属性填充——初始化"></a>4、beanB 的属性填充——初始化</h6><p><strong>进入 <code>populateBean(beanName, mbd, instanceWrapper)</code> 方法</strong>：</p>
<p>执行 <code>mbd.getPropertyValues()</code> 方法获取 beanB 的属性列表</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/139b5fdf9f83621c3f80754164b2bd8d.png" alt="image-20210123234301151"></p>
<p>执行 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法完成 beanB 属性的填充</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/480c68a3dfd3f33631d398314f8237b7.png" alt="image-20210123234518400"></p>
<p><strong>进入 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法</strong>：</p>
<p>执行 <code>mpvs.getPropertyValuelist()</code> 方法获取 beanB 的属性列表</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/465a2a5275f1dba7755f9936740d71bf.png" alt="image-20210123234654991"></p>
<p>遍历每一个属性，并对每一个属性进行注入，valueResolver.resolveValueIfNecessary(pv, originalValue) 的作用：Given a PropertyValue, return a value, resolving any references to other beans in the factory if necessary.</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/dbb64257a3175bbf4d6e2d92823c4afb.png" alt="image-20210123234750025"></p>
<p><strong>进入 <code>valueResolver.resolveValueIfNecessary(pv, originalValue)</code> 方法</strong>：</p>
<p>执行 <code>resolveReference(argName, ref)</code> 方法为 beanB 注入名为 <code>a</code> 属性</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a6d69aa082ab9cf610896f85349b0a4b.png" alt="image-20210123234916337"></p>
<p><strong>进入 <code>resolveReference(argName, ref)</code> 方法</strong>：</p>
<p>执行 <code>this.beanFactory.getBean(resolvedName)</code> 方法获取 beanA 实例，其实就是执行 <code>doGetBean(name, null, null, false)</code> 方法</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/327c7b670e87d9d835e649271404e6ea.png" alt="image-20210123235249422"></p>
<p><strong>进入 <code>doGetBean(name, null, null, false)</code> 方法</strong>：</p>
<p>关键来了，这里执行 <code>getSingleton(beanName)</code> 是够能够获取到 beanA 实例呢？答案是<strong>可以</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/34bd1bbb24e6b2ba69e77f10f25fcd43.png" alt="image-20210123235540413"></p>
<p><strong>进入 <code>getSingleton(beanName, true)</code> 方法</strong>：</p>
<p><code>getSingleton(beanName)</code> 调用了其重载方法 <code>getSingleton(beanName, true)</code>，接下来的逻辑很重要：</p>
<ol>
<li><p>beanA 并没有存放在一级缓存 <code>singletonObjects</code> 中，因此执行 <code>Object singletonObject = this.singletonObjects.get(beanName)</code> 后，<strong>singletonObject == null</strong>，再加上 beanA 正在满足创建的条件<strong>（isSingletonCurrentlyInCreation(beanName) == true）</strong>，因此可以进入第一层 if 判断</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b80bd7bf1b90db7847babede039d4cc6.png" alt="image-20210124000622676"></p>
</li>
<li><p>beanA 被存放在三级缓存 <code>singletonFactories</code> 中，从二级缓存 <code>earlySingletonObjects</code> 中获取也是 <code>null</code>，因此可以进入第二层 <code>if</code> 判断</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a179441e34c9e63c34edb8ab5bfa6d0e.png" alt="image-20210124000702685"></p>
</li>
<li><p>从三级缓存中获取 beanA 肯定不为空，因此可以进入第三层 <code>if</code> 判断</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8795709327014d708daae8fa121d0c41.png" alt="image-20210124000956873"></p>
</li>
<li><p>进入第三个if块之后：</p>
<ol>
<li>从单例工厂 <code>singletonFactory</code> 中获取 beanA；</li>
<li>将 beanA 添加至二级缓存 <code>earlySingletonObjects</code> 中；</li>
<li>将 beanA 从三级缓存 <code>singletonFactories</code> 中移除</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c9431ae0d435f82fe8f838d8add7e395.png" alt="image-20210124001103112"></p>
</li>
</ol>
<blockquote>
<p>注：</p>
<ul>
<li>此时的第三级缓存当中有K：beanB，V：beanBFactory的lambda表达式</li>
<li>此时的第二级缓存当中有K：属性A，V：beanA的实例（未完成初始化）</li>
</ul>
</blockquote>
<p><strong>回到 <code>doGetBean(name, null, null, false)</code> 方法中</strong>：</p>
<p>执行 <code>Object sharedInstance = getSingleton(beanName)</code> 将获得之前存入三级缓存 <code>singletonFactories</code> 中的 beanA</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3b5dbe8329accd0ca257fda07c34eb38.png" alt="image-20210124001710344"></p>
<p>好家伙，获取到 beanA 后就直接返回了</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fde9778c2834ef09eb9dc212411a34f1.png" alt="image-20210124001902295"></p>
<p><strong>回到 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法中</strong>：</p>
<p>执行 <code>valueResolver.resolveValueIfNecessary(pv, originalValue)</code> 方法获取到 beanA 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3ef8ac309383b13c98cb33ff8333cfde.png" alt="image-20210124002251839"></p>
<p>将属性 beanA 添加到 deepCopy 集合中（<code>List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size())</code>）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9a7adb821a06e815f0edad16ee18710a.png" alt="image-20210124003102723"></p>
<p>执行 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法将会填充 beanB 中的 <code>a</code> 属性</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a4042699ebedd2fb23bce0823442fd94.png" alt="image-20210124113724764"></p>
<p><strong>进入 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法</strong>：</p>
<p>调用了其重载方法 <code>setPropertyValues(pvs, false, false)</code>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/18414acc299fb31b57bfcd81cb256fed.png" alt="image-20210124113855809"></p>
<p><strong>进入 <code>setPropertyValues(pvs, false, false)</code> 方法</strong>：</p>
<p>在该方法中会对 bean 的每一个属性进行填充（通过 <code>setPropertyValues(pvs, false, false)</code> 方法对属性进行赋值）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f78cc7d7e1941ce37f7a2a5540a9f5a8.png" alt="image-20210124114022056"></p>
<p><strong>回到 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法中</strong>：</p>
<p>此时 <code>bw</code> 包裹着 beanB，执行 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法会将 <code>deepCopy</code> 中的元素依次赋值给 beanB 的各个属性，此时 beanB 中的 <code>a</code> 属性已经赋值为 beanA</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5e0adb5af58e58045b983c0ff9d3c2bf.png" alt="image-20210124003407181"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>因为 <code>instanceWrapper</code> 封装了 beanB，所以执行了 <code>populateBean(beanName, mbd, instanceWrapper)</code> 方法后，beanB 中的 a 属性就已经被填充啦，可以看到 <strong>beanB 中有 beanA，但 beanA 中没有 beanB</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8f4c51139c9365b200f81f638f23b4d2.png" alt="image-20210124102307241"></p>
<p>执行 <code>getSingleton(beanName, false)</code> 方法，传入的参数 <code>allowEarlyReference = false</code>，表示不允许从三级缓存 <code>singletonFactories</code> 中获取 beanB</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/9869de7fcccd6ed7f07a9149a78146f4.png" alt="image-20210124102706141"></p>
<p><strong>进入 <code>getSingleton(beanName, false)</code> 方法</strong>：</p>
<p>由于传入的参数 <code>allowEarlyReference = false</code>，因此第三层 <code>if</code> 判断铁定进不去，而 beanB 在三级缓存 <code>singletonFactories</code> 中存着，因此返回的 <code>singletonObject</code> 为 <code>null</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1480c74cb206c12feaa1ed14a832a6f4.png" alt="image-20210124102941902"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>这里应该是执行 bean 的 <code>destroy-method</code> ，应该只会在工厂销毁的时候并且 bean 为单例的条件下，其内部逻辑才会执行。<code>registerDisposableBeanIfNecessary(beanName, bean, mbd)</code> 方法的注释如下：Add the given bean to the list of disposable beans in this factory, registering its DisposableBean interface and/or the given destroy method to be called on factory shutdown (if applicable). Only applies to singletons. <strong>最后将 beanB 返回（属性 a 已经填充完毕）</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/115016d24a2b156fa0e7ddf022baf1b0.png" alt="image-20210124103604267"></p>
<p><strong>回到 <code>createBean(beanName, mbd, args)</code> 方法</strong>：</p>
<p>执行 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法得到包装 beanB 实例（属性 <code>a</code> 已经填充完毕），并将其返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ea46f04b240bed4a2c32f429c848f22b.png" alt="image-20210124104113201"></p>
<p><strong>回到 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法中</strong>：</p>
<p>执行 <code>singletonFactory.getObject()</code> 方法获取到 beanB 实例，这里的 <code>singletonFactory</code> 是之前调用 <strong>getSingleton(beanName, () -&gt; { … } 方法传入的 Lambda 表达式</strong>，然后将 newSingleton 设置为 true</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8610d80e902878d98ac9fcee980498ff.png" alt="image-20210124104331897"></p>
<p>执行 <code>addSingleton(beanName, singletonObject)</code> 方法<strong>将 beanB 实例添加到一级缓存 <code>singletonObjects</code> 中</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ee74bbd1cf446a08194408f130589b28.png" alt="image-20210124105036099"></p>
<p><strong>进入 <code>addSingleton(beanName, singletonObject)</code> 方法</strong>：</p>
<ol>
<li>将 beanB 放入一级缓存 <code>singletonObjects</code> 中</li>
<li>将 beanB 从三级缓存 <code>singletonFactories</code> 中删除（beanB 确实在三级缓存中）</li>
<li>将 beanB 从二级缓存 <code>earlySingletonObjects</code> 中删除（beanB 并不在二级缓存中）</li>
<li>将 beanB 的 beanName 注册到 <code>registeredSingletons</code> 中（之前添加至三级缓存的时候已经注册过啦~）</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f0e21ace2afae1e741289d4656bf8498.png" alt="image-20210124105602572"></p>
<blockquote>
<p>注：</p>
<ul>
<li>此时的第三级缓存当中已经没有东西了</li>
<li>第二级缓存当中有K：A，V：beanA的实例（半成品，未初始化）</li>
<li>第一级缓存当中有K：B，V：beanB的实例（成品）</li>
</ul>
</blockquote>
<p><strong>回到 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法中</strong>：</p>
<p>执行 <code>addSingleton(beanName, singletonObject)</code> 将 beanB 添加到一级缓存 <code>singletonObjects</code> 后，将 beanB 返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/02a772b5813a345127ee52340bf0386d.png" alt="image-20210124105914335"></p>
<p><strong>回到 <code>doGetBean(name, null, null, false)</code> 方法中</strong>：</p>
<p>执行完 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法后，得到属性已经填充好的 beanB，并且已经将其添加至一级缓存 <code>singletonObjects</code> 中</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/20941ced07602ce3a17bfd309715b458.png" alt="image-20210124110528798"></p>
<p>将 beanB 返回，想想返回到哪儿去了呢？当初时因为 beanA 要填充其属性 <code>b</code>，才执行了创建 beanB 的操作，现在返回肯定是将 beanB 返回给 beanA</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/722f782fa462b8c17ab58eb1bcca2b27.png" alt="image-20210124110743721"></p>
<h6 id="5、beanA-的属性填充"><a href="#5、beanA-的属性填充" class="headerlink" title="5、beanA 的属性填充"></a>5、beanA 的属性填充</h6><p><strong>回到 <code>resolveReference(argName, ref)</code> 方法中</strong>：</p>
<p>执行完 <code>this.beanFactory.getBean(resolvedName)</code> 方法后，获得了属性填充好的 beanB 实例，并将其实例返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/bbb029224904fcba0698279f4af33f66.png" alt="image-20210124112123075"></p>
<p><strong>回到 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法中</strong>：</p>
<p>执行完 <code>valueResolver.resolveValueIfNecessary(pv, originalValue)</code> 方法后，将获得属性填充好的 beanB 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/103267fe6b29569ed1312d64d85273c5.png" alt="image-20210124112327554"></p>
<p>将 <code>b</code> 属性添加至 <code>deepCopy</code> 集合中：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/11cab9c119340bc9144c60cc2a6d2b6b.png" alt="image-20210124112557933"></p>
<p>执行 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法对 beanA 的 <code>b</code> 属性进行填充</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/156ab45d51dd92d7f5783264333e2926.png" alt="image-20210124112719836"></p>
<p><strong>进入 <code>setPropertyValues(pvs, false, false)</code> 方法</strong>：</p>
<p>在 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法中调用了 <code>setPropertyValues(pvs, false, false)</code> 方法，在该方法中会对 bean 的每一个属性进行填充（通过 <code>setPropertyValues(pvs, false, false)</code> 方法对属性进行赋值）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/16114ca319c7b01f8ac42775d0bc93b2.png" alt="image-20210124113319078"></p>
<p><strong>回到 <code>applyPropertyValues(beanName, mbd, bw, pvs)</code> 方法中</strong>：</p>
<p>此时 <code>bw</code> 中包裹着 beanA，执行 <code>bw.setPropertyValues(new MutablePropertyValues(deepCopy))</code> 方法会将 deepCopy 中的元素依次赋值给 beanA 的各个属性，此时 beanA 中的 b 属性已经赋值为 beanA，又加上之前 beanB 中的 a 属性已经赋值为 beanA，此时可开启无限套娃模式</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a258520846f7dfce8f42df74d42d9a50.png" alt="image-20210124114401647"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>执行完 <code>populateBean(beanName, mbd, instanceWrapper)</code> 方法后，可以开启无限套娃模式</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2aeaa5e6c07774f3e1b826c4ba16dc86.png" alt="image-20210124115239983"></p>
<p>这次执行 <code>getSingleton(beanName, false)</code> 方法能获取到 beanA 吗？答：可以</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/88bc9c2eb977576ab9c5e0a2ae727c59.png" alt="image-20210124115314625"></p>
<p><strong>进入 <code>getSingleton(beanName, false)</code> 方法</strong>：</p>
<p>之前 beanB 中注入 <code>a</code> 属性时，将 beanA 从三级缓存 <code>singletonFactories</code> 移动到了二级缓存 <code>earlySingletonObjects</code> 中，因此可以从二级缓存 <code>earlySingletonObjects</code> 中获取到 beanA</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/94d5d60bcfcc2f274c8d8e4525b5dfb9.png" alt="image-20210124211309555"></p>
<p><strong>回到 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法中</strong>：</p>
<p>最终将获取到的 beanA 返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e03d5af6ef3d6c81d41168f520059828.png" alt="image-20210124211546214"></p>
<p><strong>回到 <code>createBean(beanName, mbd, args)</code> 方法中</strong>：</p>
<p>执行 <code>doCreateBean(beanName, mbdToUse, args)</code> 方法后得到 beanA 实例，并将此实例返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5fd485ebd4e00c548f35073b61d11b15.png" alt="image-20210124211750032"></p>
<p><strong>回到 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法</strong>：</p>
<p>执行 <code>singletonFactory.getObject()</code> 方法后将获得 beanA 实例，这里的 <code>singletonFactory</code> 是我们传入的 Lambda 表达式（专门用于创建 bean 实例）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b695223711f058c2fd97f5cfb2b3fc2c.png" alt="image-20210124212010249"></p>
<p>执行 <code>addSingleton(beanName, singletonObject)</code> 方法<strong>将 beanA 添加到一级缓存 <code>singletonObjects</code> 中</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/52f8acd8be540393d58fb7266d698881.png" alt="image-20210124212134609"></p>
<p><strong>进入 <code>addSingleton(beanName, singletonObject)</code> 方法</strong>：</p>
<ol>
<li>将 beanA 放入一级缓存 singletonObjects 中</li>
<li>将 beanA 从三级缓存 singletonFactories 中删除（beanA 并不在三级缓存中）</li>
<li>将 beanA 从二级缓存 earlySingletonObjects 中删除（beanA 确实在二级缓存中）</li>
<li>将 beanA 的 beanName 注册到 registeredSingletons 中（之前添加至三级缓存的时候已经注册过啦~）</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/6d8e2606e3e6130b18000cc0a21df51f-16335883873571.png" alt="image-20210124212338035"></p>
<blockquote>
<p> 注：</p>
<ul>
<li>此时的第三级、第二级缓存都没有东西了</li>
<li>在第一级缓存有两个已经实例化初始化好的成品：beanA与beanB</li>
</ul>
</blockquote>
<p><strong>回到 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法中</strong>：</p>
<p>将 beanA 添加至一级缓存 <code>singletonObjects</code> 后，将其返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f5895e44268bca718a64cd5290c544d3.png" alt="image-20210124212537559"></p>
<p><strong>回到 <code>doGetBean(name, null, null, false)</code> 方法中</strong>：</p>
<p>执行 <code>getSingleton(beanName, () -&gt; &#123; ... &#125;</code> 方法得到 beanA 实例后，将其返回</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1e265730ad0a573f91214f40242c20e3.png" alt="image-20210124212741165"></p>
<p><strong>回到 <code>preInstantiateSingletons()</code> 方法中</strong>：</p>
<p>终于要结束了。。。执行完 <code>getBean(beanName)</code> 方法后，将得到无限套娃版本的 beanA 和 beanB 实例</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2b4bc7f577dd911f3f97000aa6a4a5c9.png" alt="image-20210124213019608"></p>
<h6 id="6、循环依赖总结"><a href="#6、循环依赖总结" class="headerlink" title="6、循环依赖总结"></a>6、循环依赖总结</h6><p><strong>全部 Debug 断点</strong>：</p>
<p><strong>导出 Debug 所有断点</strong>：点击【View Breakpoints】</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/fed2f335cb411063664af35d5a8ecd71.png" alt="image-20210124214526041"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ef78a2b56d5e998666ba7f25a0a4da98.png" alt="image-20210124214624664"></p>
<p><strong>Debug 步骤总结</strong>：</p>
<ol>
<li>调用<code>doGetBean()</code>方法，想要获取beanA，于是调用<code>getSingleton()</code>方法从缓存中查找beanA</li>
<li>在<code>getSingleton()</code>方法中，<strong>从一级缓存中查找</strong>，没有，返回null</li>
<li><code>doGetBean()</code>方法中获取到的beanA为null，于是走对应的处理逻辑，调用<code>getSingleton()</code>的重载方法（参数为ObjectFactory的)去获取一个beanA单例</li>
<li>在<code>getSingleton()</code>方法中，<strong>先将beanA_name添加到一个集合中，用于标记该bean正在创建中</strong>。然后回调匿名内部类的<code>creatBean()</code>方法创建beanA对象</li>
<li>进入<code>AbstractAutowireCapableBeanFactory#doCreateBean()</code>，<strong>先反射调用构造器创建出beanA的实例</strong>，然后判断。<strong>是否为单例</strong>、<strong>是否允许提前暴露引用(对于单例一般为true)**、</strong>是否正在创建中〈即是否在第四步的集合中)<strong>。判断为true则</strong>将beanA添加到【三级缓存】中**</li>
<li>调用<code>populateBean()</code>对beanA进行属性填充，此时检测到beanA依赖于beanB，于是开始从一级缓存当中查找beanB</li>
<li>调用<code>doGetBean()</code>方法，和上面beanA的过程一样，到一级缓存中查找beanB，没有则创建，然后给beanB填充属性</li>
<li>此时beanB依赖于beanA，调用<code>getSingleton()</code>获取beanA，<strong>依次从一级、二级、三级缓存中找，此时从三级缓存中获取到beanA的创建工厂</strong>，通过创建工厂获取到singletonObject，此时这个singletonObject指向的就是上面在<code>doCreateBean()</code>方法中实例化的beanA</li>
<li>这样beanB就获取到了beanA的依赖，于是<strong>beanB顺利完成实例化</strong>，<strong>将beanB从第三级缓存放在第一级缓存当中</strong>，并<strong>将beanA从三级缓存移动到二级缓存中</strong></li>
<li>随后beanA继续他的属性填充工作，此时也获取到了beanB，beanA也随之完成了创建，回到<code>getsingleton()</code>方法中继续向下执行，<strong>将beanA从二级缓存移动到一级缓存中</strong></li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d340bf47b4d4d2be81811fa335167f0c.png" alt="image-20210124215934076"></p>
<h5 id="7、三级缓存总结"><a href="#7、三级缓存总结" class="headerlink" title="7、三级缓存总结"></a>7、三级缓存总结</h5><p><strong>Spring 创建 Bean 的两大步骤</strong>：</p>
<ol>
<li>创建原始bean对象</li>
<li>填充对象属性和初始化</li>
</ol>
<p>每次创建bean之前，我们都会从缓存中查下有没有该bean，因为是单例，只能有一个。当我们创建 beanA的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了beanB，接着就又去创建beanB，同样的流程，创建完 beanB填充属性时又发现它依赖了beanA又是同样的流程。</p>
<p>==不同的是==：这时候可以在三级缓存中查到刚放进去的原始对象beanA，所以不需要继续创建，用它注入beanB，完成beanB的创建。既然 beanB创建好了，所以beanA就可以完成填充属性的步骤了，接着执行剩下的逻辑，闭环完成。</p>
<p><strong>Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化但还没初始化的状态，也即半成品。</strong></p>
<p><strong>实例化的过程又是通过构造器创建的，如果A还没创建好出来怎么可能提前曝光，所以构造器的循环依赖无法解决。</strong></p>
<p>Spring为了解决单例的循环依赖问题，使用了三级缓存：</p>
<ol>
<li>其中一级缓存为单例池〈 singletonObjects)，我们的应用中使用的bean对象就是一级缓存中的</li>
<li>二级缓存为提前曝光对象( earlySingletonObjects)，用来解决对象创建过程中的循环依赖问题</li>
<li>三级缓存为提前曝光对象工厂( singletonFactories），用于处理存在 AOP 时的循环依赖问题</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f7ae144525efd87929acfcc8e55c444f.png" alt="image-20210124220433578"></p>
<p>假设A、B循环引用，实例化A的时候就将其放入三级缓存中，接着填充属性的时候，发现依赖了B，同样的流程也是实例化后放入三级缓存，接着去填充属性时又发现自己依赖A，这时候从缓存中查找到早期暴露的A，没有AOP代理的话，直接将A的原始对象注入B，完成B的初始化后，进行属性填充和初始化，这时候B完成后，就去完成剩下的A的步骤，<strong>如果有AOP代理，就进行AOP处理获取代理后的对象A，注入B，走剩下的流程</strong>。</p>
<h5 id="8、Spring循环依赖-AOP源码分析"><a href="#8、Spring循环依赖-AOP源码分析" class="headerlink" title="8、Spring循环依赖+AOP源码分析"></a>8、Spring循环依赖+AOP源码分析</h5><h6 id="1、情况一：没有依赖，有-AOP"><a href="#1、情况一：没有依赖，有-AOP" class="headerlink" title="1、情况一：没有依赖，有 AOP"></a>1、情况一：没有依赖，有 AOP</h6><p>此时， <code>SimpleBean</code> 对象在 Spring 中是如何创建的呢，我们一起来跟下源码</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204103456530-1440936422.gif" alt="img"></p>
<p>接下来，我们从 <code>DefaultListableBeanFactory</code> 的 <code>preInstantiateSingletons</code> 方法开始 debug </p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204140535741-161861384.gif" alt="img"></p>
<p>没有跟进去的方法，或者快速跳过的，我们可以先略过，重点关注跟进去了的方法和停留了的代码，此时有几个属性值中的内容值得我们留意下：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204143852185-1939651975.png" alt="img"></p>
<p>我们接着从 <code>createBean</code> 往下跟</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204203656875-494940668.gif" alt="img"></p>
<p>关键代码在 doCreateBean 中，其中有几个关键方法的调用值得大家去跟下：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204212449716-1301629510.png" alt="img"></p>
<p>此时：<strong>代理对象的创建是在对象实例化完成，并且初始化也完成之后进行的，是对一个成品对象创建代理对象</strong></p>
<p><strong>所以此种情况下：只用一级缓存就够了，其他两个缓存可以不要</strong></p>
<h6 id="2、情况二：循环依赖，没有AOP"><a href="#2、情况二：循环依赖，没有AOP" class="headerlink" title="2、情况二：循环依赖，没有AOP"></a>2、情况二：循环依赖，没有AOP</h6><p>此时循环依赖的两个类是： <code>Circle</code> 和 <code>Loop</code></p>
<p>对象的创建过程与前面的基本一致，<strong>只是多了循环依赖，少了 AOP</strong>，所以我们重点关注： <code>populateBean</code> 和 <code>initializeBean</code> 方法</p>
<p>先创建的是 Circle 对象，那么我们就从创建它的 <code>populateBean</code> 开始，再开始之前，我们先看看三级缓存中的数据情况</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204220301492-1148761968.gif" alt="img"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204220513781-372928637.png" alt="img"></p>
<p>我们开始跟 <code>populateBean</code> ，它完成属性的填充，与循环依赖有关，一定要仔细看，仔细跟</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204221638906-1777114336.gif" alt="img"></p>
<p>对 <code>circle</code> 对象的属性 <code>loop</code> 进行填充的时候，去 Spring 容器中找 <code>loop</code> 对象，发现没有则进行创建，又来到了熟悉的 <code>createBean</code> </p>
<p>此时三级缓存中的数据没有变化，但是 <code>Set&lt;String&gt; singletonsCurrentlyInCreation</code> 中多了个 <code>loop</code> </p>
<p>相信到这里大家都没有问题，我们继续往下看</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204223944889-116602678.gif" alt="img"></p>
<p><code>loop</code> 实例化完成之后，对其属性 <code>circle</code> 进行填充，去 Spring 中获取 <code>circle</code> 对象，又来到了熟悉的 <code>doGetBean</code> </p>
<p><strong>此时一、二级缓存中都没有 <code>circle</code>、<code>loop</code> ，而三级缓存中有这两个</strong>，我们接着往下看，重点来了，仔细看哦</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204224808505-1568778028.gif" alt="img"></p>
<p>通过 <code>getSingleton</code> 获取 circle 时，三级缓存调用了 <code>getEarlyBeanReference</code> ，但**由于没有 AOP，所以 <code>getEarlyBeanReference</code> 直接返回了普通的半成品 <code>circle</code>**，然后将 半成品 <code>circle</code> 放到了二级缓存，并将其返回，然后填充到了 <code>loop</code> 对象中</p>
<p><strong>此时的 loop 对象就是一个成品对象了；接着将 loop 对象返回，填充到 circle 对象中</strong>，如下如所示</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204231345958-1279298854.gif" alt="img"></p>
<p>我们发现直接将 成品 <code>loop</code> 放到了一级缓存中，二级缓存自始至终都没有过 loop ，三级缓存虽说存了 loop ，但没用到就直接 remove 了</p>
<p>此时缓存中的数据，相信大家都能想到了：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204232549511-1394750161.png" alt="img"></p>
<p>虽说 <code>loop</code> 对象已经填充到了 <code>circle</code> 对象中，但还有一丢丢流程没走完，我们接着往下看</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210204233648113-348674892.gif" alt="img"></p>
<p>将 成品 <code>circle</code> 放到了一级缓存中，二级缓存中的 circle 没有用到就直接 remove 了，最后各级缓存中的数据相信大家都清楚了，就不展示了</p>
<p>我们回顾下这种情况下各级缓存的存在感，<strong>一级缓存存在感十足，二级缓存可以说无存在感，三级缓存有存在感（向 loop 中填充 circle 的时候有用到）</strong></p>
<p><strong>所以此种情况下：可以减少某个缓存，只需要两级缓存就够了</strong></p>
<h6 id="3、情况三：循环依赖-AOP"><a href="#3、情况三：循环依赖-AOP" class="headerlink" title="3、情况三：循环依赖 + AOP"></a>3、情况三：循环依赖 + AOP</h6><p>比上一种情况多了 AOP，我们来看看对象的创建过程有什么不一样；同样是先创建 <code>Circle</code> ，在创建 <code>Loop</code> </p>
<p>创建过程与上一种情况大体一样，只是有小部分区别，跟源码的时候我会在这些区别上有所停顿，其他的会跳过，大家要仔细看</p>
<p>实例化 <code>Circle</code> ，然后填充 半成品 <code>circle</code> 的属性 <code>loop</code> ，去 Spring 容器中获取 <code>loop</code> 对象，发现没有</p>
<p>则实例化 <code>Loop</code> ，接着填充 半成品 <code>loop</code> 的属性 <code>circle</code> ，去 Spring 容器中获取 <code>circle</code> 对象</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206125000164-1211001618.png" alt="img"></p>
<p>这个过程与前一种情况是一致的，就直接跳过了，我们从上图中的红色步骤开始跟源码，此时三级缓存中的数据如下</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206125702165-1508386014.png" alt="img"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206131800751-1704613279.gif" alt="img"></p>
<p>我们发现从第三级缓存获取 <code>circle</code> 的时候，调用了 <code>getEarlyBeanReference</code> 创建了 半成品 <code>circle</code> 的代理对象</p>
<p><strong>将 半成品 <code>circle</code> 的代理对象放到了第二级缓存中，并将代理对象返回赋值给了 半成品 <code>loop</code> 的 <code>circle</code> 属性</strong> </p>
<p>注意：<strong>此时是在进行 loop 的初始化，但却把 半成品 circle 的代理对象提前创建出来了</strong></p>
<p>loop 的初始化还未完成，我们接着往下看，又是一个重点，仔细看</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206140724428-31234925.gif" alt="img"></p>
<p><strong>在 <code>initializeBean</code> 方法中完成了 半成品 <code>loop</code> 的初始化，并在最后创建了 loop 成品 的代理对象</strong></p>
<p><strong><code>loop</code> 代理对象创建完成之后会将其放入到第一级缓存中（移除第三级缓存中的 loop ，第二级缓存自始至终都没有 loop ）</strong></p>
<p>然后将 <code>loop</code> 代理对象返回并赋值给 半成品 <code>circle</code> 的属性 <code>loop</code> ，接着进行 半成品 <code>circle</code> 的 <code>initializeBean</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206142628581-1457152166.gif" alt="img"></p>
<p>因为 <code>circle</code> 的代理对象已经生成过了（在第二级缓存中），所以不用再生成代理对象了；</p>
<p><strong>将第二级缓存中的 <code>circle</code> 代理对象移到第一级缓存中，并返回该代理对象</strong></p>
<p>此时各级缓存中的数据情况如下（<strong>普通 circle 、 loop 对象在各自代理对象的 target 中</strong>）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206143755854-491082342-163359507294430.png" alt="img"></p>
<p>我们回顾下这种情况下各级缓存的存在感，一级缓存仍是存在感十足，二级缓存有存在感，三级缓存挺有存在感</p>
<p><strong>第三级缓存提前创建 <code>circle</code> 代理对象，不提前创建则只能给 <code>loop</code> 对象的属性 <code>circle</code> 赋值成 半成品 <code>circle</code> ，==那么 <code>loop</code> 对象中的 <code>circle</code> 对象就无 AOP 增强功能了==</strong></p>
<p><strong>第二级缓存用于存放 <code>circle</code> 代理，用于解决循环依赖</strong>；也许在这个示例体现的不够明显，因为依赖比较简单，依赖稍复杂一些，就能感受到了</p>
<p><strong>第一级缓存存放的是对外暴露的对象，可能是代理对象，也可能是普通对象</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206145823514-983408464.png" alt="img"></p>
<p><strong>所以此种情况下：三级缓存一个都不能少</strong></p>
<h6 id="4、情况四：循环依赖-AOP-删除第三级缓存"><a href="#4、情况四：循环依赖-AOP-删除第三级缓存" class="headerlink" title="4、情况四：循环依赖 + AOP + 删除第三级缓存"></a>4、情况四：循环依赖 + AOP + 删除第三级缓存</h6><p><strong>没有依赖，有AOP</strong> 这种情况中，我们知道 <strong>AOP 代理对象的生成是在成品对象创建完成之后创建的，这也是 Spring 的设计原则，代理对象尽量推迟创建</strong></p>
<p><strong>循环依赖 + AOP</strong> 这种情况中， <strong>circle 代理对象的生成提前了，因为必须要保证其 AOP 功能，但 loop 代理对象的生成还是遵循的 Spring 的原则</strong></p>
<p><strong>如果我们打破这个原则，将代理对象的创建逻辑提前，那是不是就可以不用三级缓存了，而只用两级缓存了呢？</strong></p>
<p>对 Spring 的源码做了非常小的改动，改动如下：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206153259183-1350022613.gif" alt="img"></p>
<p><strong>去除了第三级缓存，并将代理对象的创建逻辑提前，置于实例化之后，初始化之前</strong>；我们来看下执行结果：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210206160916118-290422058.png" alt="img"></p>
<p>并没有什么问题。</p>
<h6 id="5、情况五：循环依赖-AOP-注解"><a href="#5、情况五：循环依赖-AOP-注解" class="headerlink" title="5、情况五：循环依赖 + AOP + 注解"></a>5、情况五：循环依赖 + AOP + 注解</h6><p>目前基于 xml 的配置越来越少，而基于注解的配置越来越多，所以了也提供了一个注解的版本供大家去跟源码</p>
<p>代码还是很简单：<a target="_blank" rel="noopener" href="https://gitee.com/youzhibing/spring-circle/tree/master/spring-circle-annotation">spring-circle-annotation</a></p>
<p>跟踪流程与 循环依赖 + AOP 那种情况基本一致，只是属性的填充有了一些区别，具体可查看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youzhibing/p/11031216.html">Spring 的自动装配 → 骚话 @Autowired 的底层工作原理</a></p>
<h6 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h6><ol>
<li>三级缓存各自的作用<ol>
<li><strong>第一级缓存的是对外暴露的对象</strong>，也就是我们应用需要用到的</li>
<li><strong>第二级缓存的作用是==为了处理循环依赖的对象创建问题==，里面存的是半成品对象或半成品对象的代理对象</strong></li>
<li><strong>第三级缓存的作用==处理存在 AOP + 循环依赖的对象创建问题==，能将==代理对象提前创建==</strong></li>
</ol>
</li>
<li>Spring 为什么要引入第三级缓存<ol>
<li>严格来讲，<strong>第三级缓存并非缺它不可，因为可以提前创建代理对象</strong></li>
<li><strong>提前创建代理对象只是会节省那么一丢丢内存空间，并不会带来性能上的提升，但是会破环 Spring 的设计原则</strong></li>
<li>Spring 的设计原则是<strong>尽可能保证普通对象创建完成之后，再生成其 AOP 代理（尽可能延迟代理对象的生成）</strong></li>
<li><strong>所以 Spring 用了第三级缓存，既维持了设计原则，又处理了循环依赖；牺牲那么一丢丢内存空间是愿意接受的</strong></li>
</ol>
</li>
</ol>
<h5 id="9、循环依赖于三级缓存相关面试解答"><a href="#9、循环依赖于三级缓存相关面试解答" class="headerlink" title="9、循环依赖于三级缓存相关面试解答"></a>9、循环依赖于三级缓存相关面试解答</h5><h6 id="1、说下什么是循环依赖"><a href="#1、说下什么是循环依赖" class="headerlink" title="1、说下什么是循环依赖"></a>1、说下什么是循环依赖</h6><p>两个或则两个以上的bean对象互相依赖对方，最终形成 闭环 。例如 A 对象依赖 B 对象，B 对象也依赖 A 对象</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210202202515344-1730389536.png" alt="img"></p>
<h6 id="2、那循环依赖会有什么问题呢"><a href="#2、那循环依赖会有什么问题呢" class="headerlink" title="2、那循环依赖会有什么问题呢"></a>2、那循环依赖会有什么问题呢</h6><p>在bean对象的创建过程会产生死循环，类似如下</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210203210248385-1775555013.png" alt="img"></p>
<h6 id="3、那么Spring-是如何解决的呢？"><a href="#3、那么Spring-是如何解决的呢？" class="headerlink" title="3、那么Spring 是如何解决的呢？"></a>3、那么Spring 是如何解决的呢？</h6><p>通过<strong>三级缓存提前暴露bean对象</strong>来解决的</p>
<h6 id="4、三级缓存里面分别存的什么"><a href="#4、三级缓存里面分别存的什么" class="headerlink" title="4、三级缓存里面分别存的什么"></a>4、三级缓存里面分别存的什么</h6><p>三级缓存就是三个map对象</p>
<ol>
<li>一级缓存是一个ConcurrentHashMap，容量为256，里面存的是成品对象，实例化和初始化都完成了，我们的应用中使用的对象就是一级缓存中的</li>
<li>二级缓存是一个HashMap，容量为16，里面存的是半成品，用来解决对象创建过程中的循环依赖问题</li>
<li>三级缓存是一个HashMap，容量为16，里面存的是 ObjectFactory&lt;?&gt; 类型的 lambda 表达式，用于处理存在 AOP 时的循环依赖问题</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/747662-20210202215113431-1000736063.png" alt="img"></p>
<h6 id="5、Spring使用三级缓存解决循环依赖的前提是什么？"><a href="#5、Spring使用三级缓存解决循环依赖的前提是什么？" class="headerlink" title="5、Spring使用三级缓存解决循环依赖的前提是什么？"></a>5、Spring使用三级缓存解决循环依赖的前提是什么？</h6><p>有两个前提：</p>
<ol>
<li><p>bean是单例实例，即scope的属性为singleton</p>
<ul>
<li>因为如果是scope的属性为prototype原型，那么每一次创建的bean对象都是新对象，不会走三级缓存。</li>
</ul>
</li>
<li><p>bean对象的依赖注入方式不能全是构造器注入的方式</p>
<ul>
<li><p>Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化但还没初始化的状态，也即半成品。</p>
</li>
<li><p>实例化的过程又是通过构造器创建的，如果A还没创建好出来怎么可能提前曝光，所以构造器的循环依赖无法解决</p>
</li>
<li><p>也就是说：</p>
<ul>
<li>构造方法注入的方式，将实例化与初始化并在一起完成，能够快速创建一个可直接使用的对象</li>
<li>setter 方法注入的方式，是在对象实例化完成之后，再通过反射调用对象的 setter 方法完成属性的赋值。将对象的实例化与初始化分隔开了</li>
</ul>
</li>
<li><p>那又为什么说不能全是构造器注入的方式</p>
<table>
<thead>
<tr>
<th>依赖情况</th>
<th>依赖注入方式</th>
<th>循环依赖是否被解决</th>
</tr>
</thead>
<tbody><tr>
<td>AB相互依赖（循环依赖）</td>
<td>均采用setter方式注入</td>
<td>是</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>均采用构造器方式注入</td>
<td>否</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>A注入B的方式为setter，B注入A的方式为构造器</td>
<td>是</td>
</tr>
<tr>
<td>AB相互依赖（循环依赖）</td>
<td>B注入A的方式为setter，A注入B的方式为构造器</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>为什么在下表中的第三种情况的循环依赖能被解决，而第四种情况不能被解决呢？</p>
<p>Spring在创建Bean时<strong>默认会根据自然排序进行创建</strong>，所以A会先于B进行创建。</p>
</blockquote>
</li>
</ol>
<h6 id="6、为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）"><a href="#6、为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）" class="headerlink" title="6、为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）"></a>6、为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）</h6><p>只用一级缓存也是可以解决的，但是会复杂化整个逻辑</p>
<p>半成品对象是没法直接使用的（存在 NPE 问题），所以 Spring 需要保证在启动的过程中，所有中间产生的半成品对象最终都会变成成品对象。</p>
<p>如果将半成品对象和成品对象都混在一级缓存中，那么为了区分他们，势必会增加一些而外的标记和逻辑处理，这就会导致对象的创建过程变得复杂化了。</p>
<p>将半成品对象与成品对象分开存放，两级缓存各司其职，能够简化对象的创建过程，更简单、直观。</p>
<p>如果 Spring 不引入 AOP，那么两级缓存就够了，但是作为 Spring 的核心之一，AOP 怎能少得了呢？</p>
<p>所以为了处理 AOP代理时的循环依赖，Spring 引入第三级缓存来处理循环依赖时的代理对象的创建。</p>
<p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p>
<h6 id="7、如果将代理对象的创建过程提前，紧随于实例化之后，而在初始化之前，那是不是就可以只用两级缓存了？"><a href="#7、如果将代理对象的创建过程提前，紧随于实例化之后，而在初始化之前，那是不是就可以只用两级缓存了？" class="headerlink" title="7、如果将代理对象的创建过程提前，紧随于实例化之后，而在初始化之前，那是不是就可以只用两级缓存了？"></a>7、如果将代理对象的创建过程提前，紧随于实例化之后，而在初始化之前，那是不是就可以只用两级缓存了？</h6><p>可以，没有问题。但是会破坏Spring的设计原则：尽可能保证普通对象创建完成之后，再生成其 AOP 代理（尽可能延迟代理对象的生成）</p>
<hr>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="1、Linux常用服务类相关命令"><a href="#1、Linux常用服务类相关命令" class="headerlink" title="1、Linux常用服务类相关命令"></a>1、Linux常用服务类相关命令</h3><h4 id="1、service-Centos6"><a href="#1、service-Centos6" class="headerlink" title="1、service (Centos6)"></a>1、service (Centos6)</h4><ul>
<li><p>注册在系统中的标准化程序</p>
</li>
<li><p>有方便统一的管理方式(常用的方法)</p>
<ul>
<li>service 服务名 start：开启服务</li>
<li>service 服务名 stop：关闭服务</li>
<li>service 服务名 restart：重启服务</li>
<li>service 服务名 reload：重新加载服务</li>
<li>service 服务名 status：查看当前服务的状态</li>
</ul>
</li>
<li><p><strong>查看服务的方法</strong>：<code>/etc/init.d/服务名</code></p>
</li>
<li><p>通过chkconfig命令设置自启动</p>
<ul>
<li><p><strong>查看服务</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置服务是否开机自启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 5 服务名 off</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925145421487.png" alt="image-20210925145421487"></p>
<h4 id="2、systemctl-Centos7"><a href="#2、systemctl-Centos7" class="headerlink" title="2、systemctl (Centos7)"></a>2、systemctl (Centos7)</h4><ul>
<li><p>注册在系统中的标准化程序</p>
</li>
<li><p>有方便统一的管理方式(常用的方法)</p>
<ul>
<li>systemctl start 服务名(xxxx.service)：开启服务</li>
<li>systemctl restart 服务名(xxxx.service)：重启服务</li>
<li>systemctl stop 服务名(xxxx.service)：关闭服务</li>
<li>systemctl reload 服务名(xxxx.service)：重新加载服务</li>
<li>systemctl status 服务名(xxxx.service)：查看当前服务的状态</li>
</ul>
</li>
<li><p><strong>查看服务的方法</strong>：<code>/usr/lib/systemd/system</code></p>
</li>
<li><p><strong>查看服务的命令</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用grep进行过滤</span></span><br><span class="line">systemctl list-unit-files | grep xxx</span><br><span class="line"></span><br><span class="line">systemctl --<span class="built_in">type</span> service</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过systemctl命令设置自启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> service_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机不自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> service_name</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="1、git分支相关命令"><a href="#1、git分支相关命令" class="headerlink" title="1、git分支相关命令"></a>1、git分支相关命令</h3><ul>
<li><p>创建分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch -v &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一步完成：创建分支并切换到该分支（最常用）</span></span><br><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先切换到主分支</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先切换到主分支</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2、请讲一下Git的工作流"><a href="#2、请讲一下Git的工作流" class="headerlink" title="2、请讲一下Git的工作流"></a>2、请讲一下Git的工作流</h3><ul>
<li>在master主分支下分出develop开发分支进行开发工作<ul>
<li>master一般是项目经理或者运维人员才能操作的</li>
<li>开发人员接触的最多的就是develop分支</li>
<li>注意：master分支和develop要保持一致</li>
</ul>
</li>
<li>在develop分支下，根据项目的不同模块再分出对应的开发分支</li>
<li>如果在master主分支（上线）出现了bug，那么master会分出hotfix分支进行bug的修复工作<ul>
<li>bug修复过后在下线master分支，将hotfix分支合并到master之后在上线</li>
<li>同时要将hotfix分支合并到develop分支当中，保证master分支和develop要保持一致，防止将来把develop分支合并到master主分支出现重复的bug</li>
</ul>
</li>
<li>当模块的开发工作完成之后，将对应模块的开发分支提交到develop分支当中，并创建release分支查看是否有bug，如果有bug的话进行修复。最终合并到master主分支当中进行上线</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925150649625.png" alt="image-20210925150649625"></p>
<h3 id="3、GitHub的常用词"><a href="#3、GitHub的常用词" class="headerlink" title="3、GitHub的常用词"></a>3、GitHub的常用词</h3><ul>
<li><code>watch</code>：会持续收到该项目的动态</li>
<li><code>fork</code>：复制某个项目到自己的GitHub仓库</li>
<li><code>star</code>：点赞</li>
<li><code>clone</code>：将项目下载至本地</li>
<li><code>follow</code>：关注你感兴趣的作者，会收到他们的动态</li>
</ul>
<h3 id="4、in关键字限制搜索范围"><a href="#4、in关键字限制搜索范围" class="headerlink" title="4、in关键字限制搜索范围"></a>4、in关键字限制搜索范围</h3><p>公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[要搜索的关键字] in name 或description 或readme</span><br></pre></td></tr></table></figure>

<ul>
<li>xxx in:name——项目名包含xxx的</li>
<li>xxx in:description——项目描述包含xxx的</li>
<li>xxx in:readme——项目的readme文件中包含xxx的</li>
</ul>
<p>组合使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索项目名或者readme或者项目描述中包含秒杀的项目</span></span><br><span class="line">seckill <span class="keyword">in</span>:name,readmw,description</span><br></pre></td></tr></table></figure>



<h3 id="5、stars或fork数量关键词去查找"><a href="#5、stars或fork数量关键词去查找" class="headerlink" title="5、stars或fork数量关键词去查找"></a>5、stars或fork数量关键词去查找</h3><p>stars的公式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[要搜索的关键字] stars 通配符[:&gt; 或者 :&gt;=]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间范围数字</span></span><br><span class="line">[要搜索的关键字] stars:数字1..数字2</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg：查找stars数大于等于5000的springboot项目</span></span><br><span class="line">springboot stars:&gt;=5000</span><br></pre></td></tr></table></figure>

<p>forks的公式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[要搜索的关键字] forks 通配符[:&gt; 或者 :&gt;=]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间范围数字</span></span><br><span class="line">[要搜索的关键字] forks:数字1..数字2</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg：查找forks数大于500的springcloud项目</span></span><br><span class="line">springcloud forks:&gt;500</span><br></pre></td></tr></table></figure>

<p>组合使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找fork在100到200之间并且stars数在80到100之间的springboot项目</span></span><br><span class="line">springboot forks:100..200 stars:80..100</span><br></pre></td></tr></table></figure>



<h3 id="6、awesome加强搜索"><a href="#6、awesome加强搜索" class="headerlink" title="6、awesome加强搜索"></a>6、awesome加强搜索</h3><p>公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome 关键字</span><br></pre></td></tr></table></figure>

<blockquote>
<p>awesome系列一般是用来学习、工具、书籍类相关的项目</p>
</blockquote>
<p>使用：搜索优秀的redis相关的项目，包括框架、教程等</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome redis</span><br></pre></td></tr></table></figure>



<h3 id="7、高亮显示某一行代码"><a href="#7、高亮显示某一行代码" class="headerlink" title="7、高亮显示某一行代码"></a>7、高亮显示某一行代码</h3><p>公式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1行</span></span><br><span class="line">地址后面紧跟<span class="comment">#L数字</span></span><br><span class="line"><span class="comment"># eg:高亮显示在Dao层的SeckillDao.java的第13行</span></span><br><span class="line">https://github.com/codingXiaxw/seckill/blob/master/scr/main/java/cn/codingxiaxw/dao/SeckillDao.java<span class="comment">#L13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行</span></span><br><span class="line">地址后面紧跟<span class="comment">#L数字-L数字2</span></span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">https://github.com/codingXiaxw/seckill/blob/master/scr/main/java/cn/codingxiaxw/dao/SeckillDao.java<span class="comment">#L13-L23</span></span><br></pre></td></tr></table></figure>



<h3 id="8、项目内搜索"><a href="#8、项目内搜索" class="headerlink" title="8、项目内搜索"></a>8、项目内搜索</h3><p>在键盘输入<strong>英文t</strong>，此时路径会变成xxx/<strong>find/master</strong>。网页的代码呈现一个树状的结构，方便我们查看源码和相关框架。</p>
<p><a target="_blank" rel="noopener" href="https://help.github.com/en/articles/using-keyboard-shortcuts">github的其他快捷键</a></p>
<h3 id="9、搜索某个地区内的大佬"><a href="#9、搜索某个地区内的大佬" class="headerlink" title="9、搜索某个地区内的大佬"></a>9、搜索某个地区内的大佬</h3><p>公式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location:地区 language:语言</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索地区在北京的Java方向的大佬</span></span><br><span class="line">location:beijing language:java</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h3><p>Redis提供了2个不同形式的持久化方式。</p>
<ul>
<li>RDB (Redis DataBase)</li>
<li>AOF (Append Of File)</li>
</ul>
<h4 id="1、RDB"><a href="#1、RDB" class="headerlink" title="1、RDB"></a>1、RDB</h4><p>在指定的时间间隔内将内存中的<strong>数据集快照写入磁盘</strong>，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>备份是如何执行的？</p>
<ul>
<li>Redis会单独创建(fork) 一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。</li>
<li>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li>
<li>RDB的缺点是最后一次持久化后的数据可能丢失。</li>
</ul>
<p>RDB的优缺点：</p>
<ul>
<li>优点：<ul>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
</li>
<li>缺点：<ul>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能。</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925152036088.png" alt="image-20210925152036088"></p>
<h4 id="2、AOF"><a href="#2、AOF" class="headerlink" title="2、AOF"></a>2、AOF</h4><p><strong>以日志的形式来记录每个==写==操作</strong>，将Redis执行过的所有写指令记录下来(读操作不记录)，<strong>只许追加文件但不可以改写文件</strong>，Redis启动之初会读取该文件重新构建数据，换言之，<strong>Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</strong>。</p>
<p>备份是如何执行的？</p>
<p>AOF与RDB类似，都是依靠一个fork子进程和一个缓冲区进行写指令的备份的。而且AOF在进行写指令备份的时候，可以开启重写机制来提高性能</p>
<p>AOF的优缺点：</p>
<ul>
<li>优点：<ul>
<li>备份机制更稳健，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
</li>
<li>缺点：<ul>
<li>恢复备份速度要慢。</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>存在个别Bug，造成恢复不能。</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925152312959.png" alt="image-20210925152312959"></p>
<h3 id="2、Redis在项目中的使用场景"><a href="#2、Redis在项目中的使用场景" class="headerlink" title="2、Redis在项目中的使用场景"></a>2、Redis在项目中的使用场景</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>比如说，①我想知道什么时候<strong>封锁一个IP地址</strong>。<br>可以使用命令<code>Incrby</code>记录当前IP访问的次数，达到一定的次数就封锁该IP<br><strong>②设置分布式锁</strong>：set key value [Ex seconds] [PX milliseconds] [NX|XX]<br><strong>参数解释</strong>：<br>1.EX：key在多少秒之后过期<br>2.PX：key在多少毫秒之后过期<br>3.NX：当key不存在的时候，才创建key，效果等同于setnx key value<br>4.XX：当key存在的时候，覆盖key<br><strong>③商品编号、订单号采用 INCR 命令生成</strong><br><strong>④文章阅读量、点赞数和在看数</strong></td>
</tr>
<tr>
<td>Hash</td>
<td>redis 中的 hash 类似于 java 中的 <code>Map&lt;String,Map&lt;Object,object&gt;&gt;</code> 数据结构，即以字符串为 key，以 Map 对象为 value<br><strong>①存储用户信息</strong>【id，name，age】<br>hset(key,field,value)<br>hset(userKey,id,101)<br>hset(userKey,name,admin)<br>hset(userKey,age,23)<br>—-修改案例—-<br>hget(userKey,id)<br>hset(userKey,id,102)<br>为什么不使用String类型来存储<br>set(userKey,用信息的字符串)<br>get(userKey)<br><strong>不建议使用 String 类型存储用户信息</strong><br><strong>②购物车早期版本，可在小中厂项目中使用</strong><br>1.新增商品：<code>hset shopcut:uid1024 sid334488 1</code><br>2.新增商品：<code>hset shopcut:uid1024 sid337788 1</code><br>3.增加商品数量2：<code>hincrby shopcut:uid1024 sid337788 2</code><br>4.查看商品总数：<code>hlen shopcut:uid1024</code><br>5.全部选择：<code>hgetall shopcut:uid1024</code></td>
</tr>
<tr>
<td>List</td>
<td>与其说 list 是个集合，还不如说 list 是个双端队列。<br><strong>①实现最新消息的排行</strong>，还可以利用List的<code>push</code>命令，<strong>将任务存在list集合中</strong>，同时使用另一个命令<code>pop</code>，将任务从集合中取出。<br>Redis—list数据类型来<strong>模拟消息队列</strong>。【电商中的秒杀就可以采用这种方式来完成一个秒杀活动】<br><strong>②微信文章订阅公众号</strong><br>1.比如我订阅了如下两个公众号，他们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 <code>LPUSH likearticle:onebyId 666 888</code> 命令推送给我<br>2.查看我自己的号订阅的全部文章，类似分页，下面0~10就是一次显示10条：<code>LPUSH likearticle:onebyId 0 10</code></td>
</tr>
<tr>
<td>Set</td>
<td>特殊之处：<strong>可以自动排重</strong>。比如说微博中将每个人的好友存在集合(Set)中，这样<strong>①求两个人的共通好友</strong>的操作。我们只需要求交集即可<br><strong>②微信抽奖小程序</strong>：<br>1.如果某个用户点击了立即参与按钮，则执行 <code>sadd key useId</code> 命令将该用户 ID 添加至 set 中<br>2.显示已经有多少人参与了抽奖：<code>SCARD key</code><br>3.抽奖(从set中任意选取N个中奖人)<br>    3.1.随机抽奖2个人，元素不删除：<code>SRANDMEMBER key 2</code><br>    3.2.随机抽奖3个人，元素会删除：<code>SPOP key 3</code><br><strong>③微信朋友圈点赞</strong>：<br>1.新增点赞：<code>SADD pub:msgID 点赞用户ID1 点赞用户ID2</code><br>2.取消点赞：<code>SREM pub:msgID 点赞用户ID</code><br>3.展现所有点赞过的用户：<code>SMEMBERS pub:msgID</code><br>4.点赞用户数统计，就是常见的点赞红色数字：<code>SCARD pub.msgID</code><br>5.判断某个朋友是否对楼主点赞过：<code>SISMEMBER pub:msgID 用户ID</code><br><strong>④QQ内推可能认识的人</strong><br>QQ 内推可能认识的好友：<code>SDIFF 我的好友 Ta的好友</code></td>
</tr>
<tr>
<td>ZSet</td>
<td><strong>以某一个条件为权重，进行排序</strong>。<br>京东：<strong>①商品详情的时候，都会有一个综合排名，还可以按照商品销售量进行排名。</strong><br>思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。<br>1.商品编号1001的销量是9，商品编号1002的销量是15：<code>ZADD goods:sellsort 9 1001 15 1002</code><br>2.有一个客户又买了2件商品1001，商品编号1001销量加2：<code>ZINCRBY goods:sellsort 2 1001</code><br>3.求商品销量前10名：<code>ZRANGE goods:sellsort 0 10 WITHSCORES</code><br><strong>②抖音/微博热搜</strong><br>1.点击视频增加播放量：<code>ZINCRBY hotvcr:20200919 1八佰</code>，<code>ZINCRBY hotvcr:20200919 15 八佰 2 花木兰</code><br>2.展示当日排行前10条：<code>ZREVRANGE hotvcr:20200919 0 9 WITHSCORES</code></td>
</tr>
</tbody></table>
<h3 id="3、Redis-6-0-7的bug"><a href="#3、Redis-6-0-7的bug" class="headerlink" title="3、Redis 6.0.7的bug"></a>3、Redis 6.0.7的bug</h3><p>Redis突然发布了紧急版本 6.0.8 ，之前消息称 6.0.7 被称作最后一个 6.x 版本，但 Redis 团队表示 6.0.8 版本升级迫切性等级为高：<strong>任何将 Redis 6.0.7 与 Sentinel 或 CONFIG REWRITE 命令配合使用的人都会受到影响</strong>，应尽快升级。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/24afba3710eecc8f2225fdec39063d40.png" alt="image-20210126163514224"></p>
<p>从官方给出的信息来看，估计是出现了Bug，具体更新的内容如下：</p>
<ol>
<li><strong>Bug修复</strong><ol>
<li>CONFIG REWRITE在通过CONFIG设置oom-score-adj-values后，可以通过CONFIG设置或从配置文件中加载，会生成一个损坏的配置文件。将会导致Redis无法启动</li>
<li>修正MacOS上redis-cli –pipe的问题。</li>
<li>在不存在的密钥上，修复HKEYS/HVALS的RESP3响应。</li>
<li>各种小的错误修复</li>
</ol>
</li>
<li><strong>新功能</strong><ol>
<li>当设置为madvise时，移除THP警告。</li>
<li>允许在群集中只读副本上使用读命令进行EXEC。</li>
<li>在redis-cli-cluster调用命令中增加master/replicas选项。</li>
</ol>
</li>
<li><strong>模块化API</strong><ol>
<li>添加<code>RedisModule_ThreadSafeContextTryLock</code>。</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>官网地址</strong>：</p>
<ul>
<li>官网地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></li>
<li>中文官网地址：<a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></li>
</ul>
</blockquote>
<p><strong>查看当前Redis版本的方法</strong>：</p>
<ol>
<li>在 Linux 命令行下：在 redis 安装目录下执行 <code>redis-server -v</code> 命令</li>
<li>在 redis 客户端命令行下：执行 <code>info</code> 命令，第二行就是当前启动的Redis的版本</li>
</ol>
<h3 id="4、Redis-命令大全"><a href="#4、Redis-命令大全" class="headerlink" title="4、Redis 命令大全"></a>4、Redis 命令大全</h3><p><a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">官网命令大全</a></p>
<p>直接搜索即可</p>
<p>如果当前不能使用外网或者不能进行线上查看，可以使用Redis自带的help指令：help @关键字</p>
<p>eg：help @String</p>
<p>注意事项：执行 redis 指令可能会出现如下错误：(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.</p>
<p>原因分析：究其原因是因为强制把 redis 快照关闭了导致不能持久化的问题，在网上查了一些相关解决方案，通过 stop-writes-on-bgsave-error 值设置为 no 即可避免这种问题。</p>
<p>解决方案一：通过 redis 命令行修改，在 redis 命令行执行 config set stop-writes-on-bgsave-error no 指令</p>
<p>解决方案二：直接修改 redis.conf 配置文件，使用 vim 编辑器打开 redis-server 配置的 redis.conf 文件，然后使用快捷匹配模式：/stop-writes-on-bgsave-error 定位到 stop-writes-on-bgsave-error 字符串所在位置，接着把后面的 yes 设置为 no 即可。</p>
<h3 id="5、Redis的分布式锁"><a href="#5、Redis的分布式锁" class="headerlink" title="5、Redis的分布式锁"></a>5、Redis的分布式锁</h3><p>知道分布式锁吗？有哪些实现方案？ 你谈谈对redis分布式锁的理解， 删key的时候有什么问题？</p>
<p>单机版的锁与分布式锁：</p>
<ul>
<li>JVM层面的加锁，单机版的锁</li>
<li>分布式微服务架构，拆分后各个微服务组件为了避免冲突和数据故障而加入的一种锁，分布式的锁</li>
</ul>
<p>分布式锁的几种实现方式：</p>
<ol>
<li>mysql</li>
<li>zookeeper</li>
<li>redis</li>
</ol>
<blockquote>
<p>一般的互联网公司，大家都习惯用redis做分布式锁</p>
<p>redis ==》 redlock ==》 redisson</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007230228198.png" alt="image-20211007230228198"></p>
</blockquote>
<h4 id="1、分布式锁的常见面试题"><a href="#1、分布式锁的常见面试题" class="headerlink" title="1、分布式锁的常见面试题"></a>1、分布式锁的常见面试题</h4><ol>
<li>Redis除了拿来做缓存，你还见过基于Redis的什么用法?</li>
<li>Redis做分布式锁的时候有需要注意的问题?</li>
<li>如果是Redis是单点部署的，会带来什么问题? 那你准备怎么解决单点问题呢?</li>
<li>集群模式下，比如主从模式，有没有什么问题呢?</li>
<li>那你简单的介绍一下Redlock吧? 你简历上写redisson，你谈谈</li>
<li>Redis分布式锁如何续期?看门狗知道吗?</li>
</ol>
<h4 id="2、为什么需要分布式锁？分布式锁的最终形成"><a href="#2、为什么需要分布式锁？分布式锁的最终形成" class="headerlink" title="2、为什么需要分布式锁？分布式锁的最终形成"></a>2、为什么需要分布式锁？分布式锁的最终形成</h4><h5 id="1、版本1-0：单机版-amp-没加锁"><a href="#1、版本1-0：单机版-amp-没加锁" class="headerlink" title="1、版本1.0：单机版&amp;没加锁"></a>1、版本1.0：单机版&amp;没加锁</h5><p><strong>问题</strong>：单机版程序没有加锁，在并发测试下数字不对，会出现并发安全问题</p>
<p><strong>解决</strong>：加锁，那么问题又来了，加 <code>synchronized</code> 锁还是 <code>ReentrantLock</code> 锁呢？</p>
<ol>
<li><code>synchronized</code>：不见不散，等不到锁就会死等</li>
<li><code>ReentrantLock</code>：过时不候，<code>lock.tryLock()</code> 提供一个过时时间的参数，时间一到自动放弃锁</li>
</ol>
<p><strong>如何选择</strong>：根据业务需求来选，如果非要抢到锁不可，就使用 <code>synchronized</code> 锁；如果可以暂时放弃锁，等会再来强，就使用 <code>ReentrantLock</code> 锁</p>
<h5 id="2、版本2-0：单机版-amp-加锁"><a href="#2、版本2-0：单机版-amp-加锁" class="headerlink" title="2、版本2.0：单机版&amp;加锁"></a>2、版本2.0：单机版&amp;加锁</h5><p><strong>使用 <code>synchronized</code> 锁保证单机版程序在并发下的安全性</strong></p>
<p><strong>注意事项</strong>：</p>
<ol>
<li>在单机环境下，可以使用 <code>synchronized</code> 锁或 <code>Lock</code> 锁来实现。</li>
<li>但是在分布式系统中，因为竞争的线程可能不在同一个节点上（同一个 jvm 中）即不同线程抢夺的不是同一把锁，所以需要一个让所有进程都能访问到的锁来实现，比如 redis 或者 zookeeper 来构建；</li>
<li>不同进程 jvm 层面的锁就不管用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程</li>
</ol>
<h5 id="3、版本3-0：分布式版-amp-不加分布式锁"><a href="#3、版本3-0：分布式版-amp-不加分布式锁" class="headerlink" title="3、版本3.0：分布式版&amp;不加分布式锁"></a>3、版本3.0：分布式版&amp;不加分布式锁</h5><p><strong>分布式部署之后，单机版的锁失效</strong>，撤销单机版的锁，并且在微服务之上，挡了一个 nginx 服务器，用于实现负载均衡的功能</p>
<p>在jmeter的压测下出现并发问题</p>
<h5 id="4、版本4-0：分布式版-amp-用redis做分布式锁"><a href="#4、版本4-0：分布式版-amp-用redis做分布式锁" class="headerlink" title="4、版本4.0：分布式版&amp;用redis做分布式锁"></a>4、版本4.0：分布式版&amp;用redis做分布式锁</h5><p>Redis具有极高的性能，且其命令对分布式锁支持友好，借助 <strong>SET 命令</strong>即可实现加锁处理</p>
<p>设置分布式锁<strong>：set key value [Ex seconds] [PX milliseconds] [NX|XX]</strong></p>
<p>参数解释：</p>
<ol>
<li>EX：key在多少秒之后过期</li>
<li>PX：key在多少毫秒之后过期</li>
<li>NX：当key不存在的时候，才创建key，效果等同于setnx key value</li>
<li>XX：当key存在的时候，覆盖key</li>
</ol>
<p>代码层面：</p>
<p>使用当前请求的 UUID + 线程名作为分布式锁的 value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前请求的 UUID + 线程名</span></span><br><span class="line">String value = UUID.randomUUID().toString()+Thread.currentThread().getName();</span><br></pre></td></tr></table></figure>

<p>使用setnx命令的jedis来加分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分布式锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object REDIS_LOCK_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span></span><br><span class="line">Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢锁失败</span></span><br><span class="line"><span class="keyword">if</span>(lockFlag == <span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码</span></span><br></pre></td></tr></table></figure>

<p>进程抢占分布式锁，如果抢占失败，则返回值为 false；如果抢占成功，则返回值为 true。</p>
<p>最后记得解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放分布式锁</span></span><br><span class="line">stringRedisTemplate.delete(REDIS_LOCK_KEY);</span><br></pre></td></tr></table></figure>

<h5 id="5、版本5-0：finally版"><a href="#5、版本5-0：finally版" class="headerlink" title="5、版本5.0：finally版"></a>5、版本5.0：finally版</h5><p>上面代码存在的问题：<strong>如果代码在执行的过程中出现异常，那么就可能无法释放锁</strong>，因此必须要在代码层面加上 <code>finally</code> 代码块，保证锁的释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span></span><br><span class="line">    Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (lockFlag == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放分布式锁</span></span><br><span class="line">    stringRedisTemplate.delete(REDIS_LOCK_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、版本6-0：过期时间版"><a href="#6、版本6-0：过期时间版" class="headerlink" title="6、版本6.0：过期时间版"></a>6、版本6.0：过期时间版</h5><p>上面代码存在的问题：假设<strong>部署了微服务 jar 包的服务器挂了</strong>，代码层面根本没有走到 finally 这块，<strong>也没办法保证解锁</strong>。既使之后该服务器重新启动，这个 key 也没有被删除，其他微服务就一直抢不到锁，因此我们需要加入一个过期时间限定的 key</p>
<p>使用setex命令的jedis来加分布式锁的过期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span></span><br><span class="line">Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);</span><br><span class="line"><span class="comment">// 设置过期时间为 10s</span></span><br><span class="line">stringRedisTemplate.expire(REDIS_LOCK_KEY, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="7、版本7-0：加锁原子版"><a href="#7、版本7-0：加锁原子版" class="headerlink" title="7、版本7.0：加锁原子版"></a>7、版本7.0：加锁原子版</h5><p>上面代码存在的问题：加锁与设置过期时间的操作分开了，假设服务器刚刚执行了加锁操作，然后宕机了，也没办法保证解锁。——<strong>没能保证加锁与过期时间的原子性</strong></p>
<p>使用setIfAbsent的重载方法来保证原子性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁，同时加上过期时间保证原子性</span></span><br><span class="line">Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢锁失败</span></span><br><span class="line"><span class="keyword">if</span> (lockFlag == <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、版本8-0：加UUID防止张冠李戴"><a href="#8、版本8-0：加UUID防止张冠李戴" class="headerlink" title="8、版本8.0：加UUID防止张冠李戴"></a>8、版本8.0：加UUID防止张冠李戴</h5><p>上面代码存在的问题：张冠李戴，删除了别人的锁：我们无法保证一个业务的执行时间，有可能是 10s，有可能是 20s，也有可能更长。因为执行业务的时候可能会调用其他服务，我们并不能保证其他服务的调用时间。如果设置的锁过期了，当前业务还正在执行，那么就有可能出现并发问题，并且还有可能出现当前业务执行完成后，释放了其他业务的锁</p>
<p>如下图，假设进程 A 在 T2 时刻设置了一把过期时间为 30s 的锁，在 T5 时刻该锁过期被释放，在 T5 和 T6 期间，Test 这把锁已经失效了，并不能保证进程 A 业务的原子性了。于是进程 B 在 T6 时刻能够获取 Test 这把锁，但是进程 A 在 T7 时刻删除了进程 B 加的锁，进程 B 在 T8 时刻删除锁的时候就蒙蔽了，我 TM 锁呢？</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7779829b07787062d2fb57a8f91bb5ce.png" alt="image-20210204161115030"></p>
<p>因此可以在解锁之前使用UUID判断当前的锁是不是自己的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前请求的 UUID + 线程名</span></span><br><span class="line">String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁，同时加上过期时间保证原子性</span></span><br><span class="line">    Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (lockFlag == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否是自己加的锁</span></span><br><span class="line">    <span class="keyword">if</span>(value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY)))&#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY); <span class="comment">// 释放分布式锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、版本9-0：解锁原子性"><a href="#9、版本9-0：解锁原子性" class="headerlink" title="9、版本9.0：解锁原子性"></a>9、版本9.0：解锁原子性</h5><p>上面代码存在的问题：<strong>在 finally 代码块中的判断与删除并不是原子操作</strong>，假设执行 <code>if</code> 判断的时候，这把锁还是属于当前业务，但是有可能刚执行完 <code>if</code> 判断，这把锁就被其他业务给释放了，还是会出现误删锁的情况</p>
<h6 id="1、版本9-1：解锁原子性——lura脚本保证解锁原子性操作（常用）"><a href="#1、版本9-1：解锁原子性——lura脚本保证解锁原子性操作（常用）" class="headerlink" title="1、版本9.1：解锁原子性——lura脚本保证解锁原子性操作（常用）"></a>1、版本9.1：解锁原子性——lura脚本保证解锁原子性操作（常用）</h6><p><a target="_blank" rel="noopener" href="https://redis.io/commands/set">lua 脚本</a></p>
<p>redis 可以通过 <code>eval</code> 命令保证代码执行的原子性</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f8dda21727ecd0a9163b9c4e216a6ea5.png" alt="image-20210204173538862"></p>
<p>代码：</p>
<p>1、**<code>RedisUtils</code> 工具类**：</p>
<p><code>getJedis()</code> 方法用于从 <code>jedisPool</code> 中获取一个连接块对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis服务器的IP地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostAddr = <span class="string">&quot;192.168.152.233&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, hostAddr, <span class="number">6379</span>, <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedisPool) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Jedispool is not ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、使用 lua 脚本保证解锁操作的原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 获取连接对象</span></span><br><span class="line">    Jedis jedis = RedisUtils.getJedis();</span><br><span class="line">    <span class="comment">// lua 脚本，摘自官网</span></span><br><span class="line">    String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot;</span> + <span class="string">&quot;then &quot;</span></span><br><span class="line">        + <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1])&quot;</span> + <span class="string">&quot;else &quot;</span> + <span class="string">&quot;  return 0 &quot;</span> + <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 lua 脚本</span></span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(value));</span><br><span class="line">        <span class="comment">// 获取 lua 脚本的执行结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(result.toString())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭链接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、版本9-2：解锁原子性——Redis事务保证解锁原子性操作"><a href="#2、版本9-2：解锁原子性——Redis事务保证解锁原子性操作" class="headerlink" title="2、版本9.2：解锁原子性——Redis事务保证解锁原子性操作"></a>2、版本9.2：解锁原子性——Redis事务保证解锁原子性操作</h6><p>1、事务介绍</p>
<ul>
<li>Redis的事务是通过<code>MULTl</code>，<code>EXEC</code>，<code>DISCARD</code>和<code>WATCH</code>这四个命令来完成。</li>
<li><strong>Redis的单个命令都是原子性的</strong>，所以这里确保事务性的对象是<strong>命令集合</strong>。</li>
<li>Redis将命令集合序列化并确保处于同一事务的命令集合连续且不被打断的执行。</li>
<li>Redis不支持回滚的操作。</li>
</ul>
<p>2、相关命令</p>
<ol>
<li><code>MULTI</code><ol>
<li>用于标记事务块的开始。</li>
<li>Redis会将后续的命令逐个放入队列中，然后使用EXEC命令原子化地执行这个命令序列。</li>
<li>语法：<code>MULTI</code></li>
</ol>
</li>
<li><code>EXEC</code><ol>
<li>在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。</li>
<li>语法：<code>EXEC</code></li>
</ol>
</li>
<li><code>DISCARD</code><ol>
<li>清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</li>
<li>语法：<code>DISCARD</code></li>
</ol>
</li>
<li><code>WATCH</code><ol>
<li>当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的状态。</li>
<li>语法：<code>WATCH key[key..…]</code></li>
<li>注：该命令可以<strong>实现redis的乐观锁</strong>，不会有ABA问题</li>
</ol>
</li>
<li><code>UNWATCH</code><ol>
<li>清除所有先前为一个事务监控的键。</li>
<li>语法：<code>UNWATCH</code></li>
</ol>
</li>
</ol>
<p>代码：</p>
<p>开启事务不断监视 <code>REDIS_LOCK_KEY</code> 这把锁有没有被别人动过，如果已经被别人动过了，那么继续重新执行删除操作，否则就解除监视</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//加事务，乐观锁</span></span><br><span class="line">        stringRedisTemplate.watch(REDIS_LOCK_KEY);</span><br><span class="line">        <span class="comment">// 判断是否是自己加的锁</span></span><br><span class="line">        <span class="keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            stringRedisTemplate.setEnableTransactionSupport(<span class="keyword">true</span>);</span><br><span class="line">            stringRedisTemplate.multi();</span><br><span class="line">            stringRedisTemplate.delete(REDIS_LOCK_KEY);</span><br><span class="line">            <span class="comment">// 判断事务是否执行成功，如果等于 null，就是没有删掉，删除失败，再回去 while 循环那再重新执行删除</span></span><br><span class="line">            List&lt;Object&gt; list = stringRedisTemplate.exec();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除成功，释放监控器，并且 break 跳出当前循环</span></span><br><span class="line">        stringRedisTemplate.unwatch();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、版本10-0：自动续期版"><a href="#10、版本10-0：自动续期版" class="headerlink" title="10、版本10.0：自动续期版"></a>10、版本10.0：自动续期版</h5><p>上面代码存在的问题：我们无法保证一个业务的执行时间，有可能是 10s，有可能是 20s，也有可能更长。因为执行业务的时候可能会调用其他服务，我们并不能保证其他服务的调用时间。如果设置的锁过期了，当前业务还正在执行，那么之前设置的锁就失效了，就有可能出现并发问题。</p>
<p>因此我们需要确保 redisLock 过期时间大于业务执行时间的问题，即面临如何对 Redis 分布式锁进行续期的问题：</p>
<p><strong>redis 与 zookeeper 在 CAP 方面的对比</strong>：</p>
<ul>
<li><strong>redis</strong>：<ul>
<li>redis 异步复制造成的锁丢失， 比如：主节点没来的及把刚刚 set 进来这条数据给从节点，就挂了，那么主节点和从节点的数据就不一致。此时如果集群模式下，就得上 Redisson 来解决</li>
</ul>
</li>
<li><strong>zookeeper</strong>：<ul>
<li>zookeeper 保持强一致性原则，对于集群中所有节点来说，要么同时更新成功，要么失败，因此使用 zookeeper 集群并不存在主从节点数据丢失的问题，但丢失了速度方面的性能</li>
</ul>
</li>
</ul>
<p><strong>使用 Redisson 实现自动续期功能</strong>：</p>
<p>redis 集群环境下，我们自己写的也不OK，直接上 RedLock 之 Redisson 落地实现</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">redis 分布式锁</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">redisson GitHub 地址</a></li>
</ol>
<p>代码：</p>
<p><strong>注入 <code>Redisson</code> 对象</strong></p>
<p>在 <code>RedisConfig</code> 配置类中注入 <code>Redisson</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建 RedisTemplate 对象，key 为 String 对象，value 为 Serializable（可序列化的）对象</span></span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// key 值使用字符串序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">// value 值使用 json 序列化器</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        <span class="comment">// 传入连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 返回 redisTemplate 对象</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、业务逻辑</strong></p>
<p>直接 <code>redissonLock.lock()</code>、<code>redissonLock.unlock()</code> 完事儿，这尼玛就是 juc 版本的 redis 分布式锁啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GoodController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Oneby</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/2/2 18:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LOCK_KEY = <span class="string">&quot;lockOneby&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当前请求的 UUID + 线程名</span></span><br><span class="line">        String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        redissonLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 redis 中获取商品的剩余数量</span></span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            String retStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 商品数量大于零才能出售</span></span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                retStr = <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retStr = <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(retStr);</span><br><span class="line">            <span class="keyword">return</span> retStr;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完善代码，修改可能出现的bug</p>
<p>问题：在超高并发的情况下，可能会抛出如下异常，原因是解锁 lock 的线程并不是当前线程</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5bf8d9d12b20b9e4c27772b43e22a57a.png" alt="image-20210204182943599"></p>
<p>代码：在释放锁之前加一个判断：还在持有锁的状态，并且是当前线程持有的锁再解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LOCK_KEY = <span class="string">&quot;lockOneby&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当前请求的 UUID + 线程名</span></span><br><span class="line">        String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        redissonLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 redis 中获取商品的剩余数量</span></span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            String retStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 商品数量大于零才能出售</span></span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                retStr = <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retStr = <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(retStr);</span><br><span class="line">            <span class="keyword">return</span> retStr;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 还在持有锁的状态，并且是当前线程持有的锁再解锁</span></span><br><span class="line">            <span class="keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;</span><br><span class="line">                redissonLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、分布式锁总结"><a href="#11、分布式锁总结" class="headerlink" title="11、分布式锁总结"></a>11、分布式锁总结</h5><ol>
<li>synchronized 锁：单机版 OK，上 nginx分布式微服务，单机锁就不 OK,</li>
<li>分布式锁：取消单机锁，上 redis 分布式锁 SETNX</li>
<li>如果出异常的话，可能无法释放锁， 必须要在 finally 代码块中释放锁</li>
<li>如果宕机了，部署了微服务代码层面根本没有走到 finally 这块，也没办法保证解锁，因此需要有设置锁的过期时间</li>
<li>除了增加过期时间之外，还必须要 SETNX 操作和设置过期时间的操作必须为原子性操作</li>
<li>规定只能自己删除自己的锁，你不能把别人的锁删除了，防止张冠李戴，可使用 lua 脚本或者事务</li>
<li>判断锁所属业务与删除锁的操作也需要是原子性操作</li>
<li>redis 集群环境下，我们自己写的也不 OK，直接上 RedLock 之 Redisson 落地实现</li>
</ol>
<h4 id="3、Redis-删除策略与缓存淘汰策略"><a href="#3、Redis-删除策略与缓存淘汰策略" class="headerlink" title="3、Redis 删除策略与缓存淘汰策略"></a>3、Redis 删除策略与缓存淘汰策略</h4><h5 id="1、Redis-缓存淘汰策略相关的面试题"><a href="#1、Redis-缓存淘汰策略相关的面试题" class="headerlink" title="1、Redis 缓存淘汰策略相关的面试题"></a>1、Redis 缓存淘汰策略相关的面试题</h5><ol>
<li>生产上你们的redis内存设置多少？</li>
<li>如何配置、修改redis的内存大小？</li>
<li>如果内存满了你怎么办？</li>
<li>redis 清理内存的方式？定期删除和惰性删除了解过吗</li>
<li>redis 的缓存淘汰策略</li>
<li>redis 的 LRU 淘汰机制了解过吗？可否手写一个 LRU 算法</li>
</ol>
<h5 id="2、redis-内存满了怎么办"><a href="#2、redis-内存满了怎么办" class="headerlink" title="2、redis 内存满了怎么办"></a>2、redis 内存满了怎么办</h5><blockquote>
<p><strong>redis 默认内存多少？在哪里查看? 如何设置修改?</strong></p>
</blockquote>
<h6 id="1、如何查看-redis-最大占用内存"><a href="#1、如何查看-redis-最大占用内存" class="headerlink" title="1、如何查看 redis 最大占用内存"></a>1、如何查看 redis 最大占用内存</h6><p>在 redis.conf 配置文件中有一个，输入 <code>:set nu</code> 显示行号，大约在 859 多行有一个 <code>maxmemory</code> 字段，用预设值 redis 的最大占用内存</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d8b324a3c021ae11e71dcc5da1ab8c0b.png" alt="image-20210207172808438"></p>
<h6 id="2、redis-会占用物理机器多少内存？"><a href="#2、redis-会占用物理机器多少内存？" class="headerlink" title="2、redis 会占用物理机器多少内存？"></a>2、redis 会占用物理机器多少内存？</h6><p>如果<strong>不设置最大内存大小或者设置最大内存大小为 0</strong>，在 <strong>64 位操作系统下不限制内存大小</strong>，在<strong>32位操作系统下最多使用 3GB 内存</strong></p>
<h6 id="3、一般生产上如何配置-redis-的内存"><a href="#3、一般生产上如何配置-redis-的内存" class="headerlink" title="3、一般生产上如何配置 redis 的内存"></a>3、一般生产上如何配置 redis 的内存</h6><p>一般推荐Redis设置内存为最大物理内存的四分之三，也就是 0.75</p>
<h6 id="4、如何修改-redis-内存设置"><a href="#4、如何修改-redis-内存设置" class="headerlink" title="4、如何修改 redis 内存设置"></a>4、如何修改 redis 内存设置</h6><p>1、通过<strong>修改文件配置（永久生效）</strong>：修改 maxmemory 字段，单位为字节</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/060a18caee395fae8796a48e5214202d.png" alt="image-20210207173214138"></p>
<p>2、通过命令修改（<strong>重启失效</strong>）：<code>config set maxmemory 104857600</code> 设置 redis 最大占用内存为 100MB，<code>config get maxmemory</code> 获取 redis 最大占用内存</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5e551161caeb7f6eb7892e23d45c2a79.png" alt="image-20210207173506155"></p>
<h6 id="5、通过命令查看-redis-内存使用情况"><a href="#5、通过命令查看-redis-内存使用情况" class="headerlink" title="5、通过命令查看 redis 内存使用情况?"></a>5、通过命令查看 redis 内存使用情况?</h6><p>通过 info 指令info memory可以查看 redis 内存使用情况：<code>used_memory_human</code> 表示实际已经占用的内存，<code>maxmemory</code> 表示 redis 最大占用内存</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/54e71cba443b2b5d8f49dad6450bee42.png" alt="image-20210207173935763"></p>
<h6 id="6、如果把-redis-内存打满了会发生什么-如果-redis-内存使用超出了设置的最大值会怎样"><a href="#6、如果把-redis-内存打满了会发生什么-如果-redis-内存使用超出了设置的最大值会怎样" class="headerlink" title="6、如果把 redis 内存打满了会发生什么? 如果 redis 内存使用超出了设置的最大值会怎样?"></a>6、如果把 redis 内存打满了会发生什么? 如果 redis 内存使用超出了设置的最大值会怎样?</h6><p>redis 将会报错：(error) OOM command not allowed when used memory &gt; ‘maxmemory’</p>
<p>如果设置了 <code>maxmemory</code> 的选项，假如 redis 内存使用达到上限，并且 key 都没有加上过期时间，就会导致数据写爆 redis 内存。为了避免类似情况，于是引出下一部分的内存淘汰策略</p>
<h5 id="3、redis-删除策略"><a href="#3、redis-删除策略" class="headerlink" title="3、redis 删除策略"></a>3、redis 删除策略</h5><p><strong>redis 如何删除设置了过期时间的 key</strong></p>
<h6 id="1、redis过期键的删除策略"><a href="#1、redis过期键的删除策略" class="headerlink" title="1、redis过期键的删除策略"></a>1、redis过期键的删除策略</h6><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？那么过期后到底什么时候被删除呢？redis 如何操作的呢</p>
<p>通过查看 redis 配置文件可知，默认淘汰策略是【<code>noeviction</code>（Don’t evict anything, just return an error on write operations.）】，如果 redis 内存被写爆了，直接返回 error</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/f8c3f3b937fd77a48cb570188367f8d0.png" alt="image-20210207174720294"></p>
<p><strong>redis 对于过期 key 的三种不同删除策略</strong>：</p>
<ol>
<li><strong>立即删除</strong><ul>
<li>立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对 CPU 是最不友好的。因为删除操作会占用 CPU 的时间，如果刚好碰上了 CPU 很忙的时候，比如正在做交集或排序等计算的时候，就会给 CPU 造成额外的压力，让 CPU 心累，时时需要删除，忙死</li>
<li>这会产生大量的性能消耗，同时也会影响数据的读取操作。</li>
<li>总结：定时删除对 CPU 不友好，但对 memory 友好，用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
</li>
<li><strong>惰性删除</strong><ul>
<li>惰性删除的策略刚好和定时删除相反，惰性删除在数据到达过期时间后不做处理，等下次访问该数据时：如果发现未过期，则返回该数据；如果发现已过期，则将其删除，并返回不存在。</li>
<li>如果一个键已经过期并且未被访问到，那么这个键仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。因此惰性删除策略的缺点是：它对内存是最不友好的。</li>
<li>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行 FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的 redis 服务器来说，肯定不是一个好消息</li>
<li>总结：惰性删除对 memory 不友好，但对 CPU 友好，用存储空间换取处理器性能（拿空间换时间）</li>
</ul>
</li>
<li><strong>定期删除</strong>：（折中方案）<ul>
<li>上面两种删除策略都走极端，因此引出我们的定期删除策略。</li>
<li>定期删除策略是前两种策略的折中：定期删除策略<strong>每隔一段时间执行一次删除过期键操作</strong>，并通过限制<strong>删除操作执行的时长和频率</strong>来减少删除操作对 CPU 时间的影响。</li>
<li>其做法为：**==周期性轮询== redis 库中的时效性数据，采用==随机抽取==的策略，利用==过期数据占比==的方式控制删除频度。**</li>
<li><strong>定期删除的特点</strong>：<ul>
<li>CPU 性能占用设置有峰值，检测频度可自定义设置</li>
<li>内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
</ul>
</li>
<li>总结：周期性抽查存储空间（随机抽查，重点抽查)</li>
<li><strong>定期删除的举例</strong>：<ul>
<li>redis 默认每间隔 100ms 检查是否有过期的 key，如果有过期 key 则删除。</li>
<li>注意：redis 不是每隔100ms 将所有的 key 检查一次而是随机抽取进行检查（如果每隔 100ms，全部 key 进行检查，redis 直接进去ICU）。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。</li>
</ul>
</li>
<li><strong>定期删除的难点</strong>：<ul>
<li>定期删除策略的难点是<strong>确定删除操作执行的时长和频率</strong>：redis 不可能时时刻刻遍历所有被设置了生存时间的 key，来检测数据是否已经到达过期时间，然后对它进行删除。</li>
<li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。</li>
<li>因此，<strong>如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<p>惰性删除和定期删除都存在数据没有被抽到的情况，如果这些数据已经到了过期时间，没有任何作用，这会导致大量过期的 key 堆积在内存中，导致 redis 内存空间紧张或者很快耗尽</p>
<p>因此必须要有一个更好的兜底方案，接下来引出 redis 内存淘汰策略</p>
<h5 id="4、Redis的缓存淘汰策略"><a href="#4、Redis的缓存淘汰策略" class="headerlink" title="4、Redis的缓存淘汰策略"></a>4、Redis的缓存淘汰策略</h5><p><strong>redis 6.0.8 版本的内存淘汰策略有哪些？</strong>：</p>
<p>8 种内存淘汰策略</p>
<ul>
<li><code>noeviction</code>：不会驱逐任何key</li>
<li><code>allkeys-lru</code>：对所有key使用LRU算法进行删除</li>
<li><code>volatile-lru</code>：对所有设置了过期时间的key使用LRU算法进行删除</li>
<li><code>allkeys-random</code>：对所有key随机删除</li>
<li><code>volatile-random</code>：对所有设置了过期时间的key随机删除</li>
<li><code>volatile-ttl</code>：删除马上要过期的key</li>
<li><code>allkeys-lfu</code>：对所有key使用LFU算法进行删除</li>
<li><code>volatile-lfu</code>：对所有设置了过期时间的key使用LFU算法进行删除</li>
</ul>
<p><strong>总结</strong>:</p>
<ul>
<li>2个维度<ol>
<li>过期键中筛选</li>
<li>所有键中筛选</li>
</ol>
</li>
<li>4个方面<ol>
<li>lru</li>
<li>lfu</li>
<li>random</li>
<li>ttl、noeviction</li>
</ol>
</li>
</ul>
<p><strong>如何配置 redis 的内存淘汰策略</strong>：</p>
<p>1、通过<strong>修改文件配置</strong>（<strong>永久生效</strong>）：配置 <code>maxmemory-policy</code> 字段：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/a0f037718cb8d2cbaee49f686dcf0e74.png" alt="image-20210207181430526"></p>
<p>通过<strong>命令</strong>修改（<strong>重启失效</strong>）：<code>config set maxmemory-policy allkeys-lru</code> 命令设置内存淘汰策略，<code>config get maxmemory-policy</code> 命令获取当前采用的内存淘汰策略</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/12c5526453ae59e64efda4a309510040-163369964360812.png" alt="image-20210207182204402"></p>
<h5 id="5、redis-LRU-算法"><a href="#5、redis-LRU-算法" class="headerlink" title="5、redis LRU 算法"></a>5、redis LRU 算法</h5><h6 id="1、LRU-算法简介"><a href="#1、LRU-算法简介" class="headerlink" title="1、LRU 算法简介"></a>1、LRU 算法简介</h6><p>LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，每次选择最近最久未使用的页面予以淘汰</p>
<h6 id="2、LRU-算法题来源"><a href="#2、LRU-算法题来源" class="headerlink" title="2、LRU 算法题来源"></a>2、LRU 算法题来源</h6><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
<p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。</p>
<p>实现 LRUCache 类：</p>
<ol>
<li>LRUCache(int capacity)：以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key)：如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value)：如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间.</li>
</ol>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p><strong>示例：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;LRUCache&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;get&quot;</span>]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<h6 id="3、LRU-算法设计思想"><a href="#3、LRU-算法设计思想" class="headerlink" title="3、LRU 算法设计思想"></a>3、LRU 算法设计思想</h6><p>查找和插入的时间复杂度为 <code>O(1)</code>，HashMap 没得跑了，但是 HashMap 是无序的集合，怎么样将其改造为有序集合呢？答案就是在各个 Node 节点之间增加 <code>prev</code> 指针和 <code>next</code> 指针，构成双向链表。即：<strong>HashMap + 双向链表</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/abc068f7d766a68862079499bfea6613.png" alt="image-20210207184327176"></p>
<p>LRU 的算法核心是哈希链表，本质就是 HashMap+DoubleLinkedList 时间复杂度是O(1)，哈希表+双向链表的结合体，下面这幅动图完美诠释了 HashMap+DoubleLinkedList 的工作原理：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/174430816d515a4f9070b7a7158dffa6.gif" alt="image-20210206182454498"></p>
<h6 id="4、LRU-算法编码实现"><a href="#4、LRU-算法编码实现" class="headerlink" title="4、LRU 算法编码实现"></a>4、LRU 算法编码实现</h6><p>1、**借助 JDK 自带的 <code>LinkedHashMap</code>**：</p>
<p><code>LinkedHashMap</code> 的注释中写明了： <code>LinkedHashMap</code> 非常适合用来构建 LRU 缓存</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/61d11a2206812ac5cfb0ab75e0cbe6e4.png" alt="image-20210207185047179"></p>
<p><strong>LRU 代码</strong>：</p>
<p>通过继承 <code>LinkedHashMap</code>，重写 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheDemo</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheDemo</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// accessOrder：the ordering mode. true for access-order；false for insertion-order</span></span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于判断是否需要删除最近最久未使用的节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCacheDemo lruCacheDemo = <span class="keyword">new</span> LRUCacheDemo(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        lruCacheDemo.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">5</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何要重写 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法</strong>：</p>
<p>先来看看 <code>LinkedHashMap</code> 中的 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法，直接 <code>return false</code>，缓存爆就爆，反正就是不会删除 <code>EldestEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment"> * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after</span></span><br><span class="line"><span class="comment"> * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment"> * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment"> * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment"> * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法在 <code>void afterNodeInsertion(boolean evict)</code> 方法中被调用，只有当 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法返回 true 时，才能够删除 <code>EldestEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们重写之后的判断条件为：如果 <code>LinkedHashMap</code> 中存储的元素个数已经大于缓存容量 <code>capacity</code>，则返回 <code>true</code>，表示允许删除 <code>EldestEntry</code>；否则返回 <code>false</code>，表示无需删除 <code>EldestEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于判断是否需要删除最近最久未使用的节点</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt; capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举例说明构造函数中的 <code>accessOrder</code> 的含义</strong>：</p>
<p><strong>构造函数中的 <code>accessOrder</code> 字段</strong></p>
<p>在 <code>LRUCacheDemo</code> 的构造方法中，我们调用了 <code>LinkedHashMap</code> 的构造方法，其中有一个字段为 <code>accessOrder</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/e2135890194fbd120f88377c16d34b26.png" alt="image-20210207193458904"></p>
<p><code>accessOrder = true</code> 和 <code>accessOrder = false</code> 的情况：</p>
<ul>
<li>当 <code>accessOrder = true</code> 时，每次使用 key 时（put 或者 get 时），都将 key 对应的数据移动到队尾（右边），表示最近经常使用；</li>
<li>当 <code>accessOrder = false</code> 时，key 的顺序为插入双向链表时的顺序</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b2d5a55df4837226e085710d78a0d8f6.png" alt="image-20210207194714608"></p>
<blockquote>
<p>注：false可以说是一种优化，没有去移动相关节点，性能会更好一点</p>
</blockquote>
<p><strong><code>LinkedHashMap</code> 的 <code>put()</code> 方法</strong>：</p>
<p><code>LinkedHashMap</code> 其实没有 <code>put()</code> 方法，<code>LinkedHashMap</code>的<code>put()</code>方法其实就是 <code>HashMap</code> 的 <code>put()</code> 方法，我就奇了怪了，<code>LinkedHashMap</code> 就是 <code>HashMap</code>？？？其实并不是。。。一起来看一下HashMap的putVal()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>putval()</code> 方法的调用了两个方法：<code>afterNodeAccess(e)</code> 方法和 <code>afterNodeInsertion(evict)</code> 方法，这两个方法就是专门针对于 <code>LinkedHashMap</code> 写的方法：在 HashMap 中这些方法均为空实现的方法，没有任何代码逻辑，需要推迟到子类 <code>LinkedHashMap</code> 中去实现，就是<strong>模板方法设计模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>注释也写了：Callbacks to allow <code>LinkedHashMap</code> post-actions</p>
<p>在 <code>LinkedHashMap</code> 的 <code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 方法中：如果设置了 <code>accessOrder = true</code> 时，则每次使用 key 时（put 或者 get 时），都将 key 对应的数据移动到队尾（右边），表示这是最近经常使用的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">//  accessOrder如果设置为true，进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>LinkedHashMap</code> 的 <code>void afterNodeInsertion(boolean evict)</code> 方法中：<strong>如果头指针不为空并且当前需要删除老节点</strong>，则执行 <code>removeNode(hash(key), key, null, false, true)</code> 方法删除 EldestEntry（若 accessOrder = true 时，EldestEntry 表示最近最少使用的数据，若 accessOrder = false 时，EldestEntry 表示最先插入链表的节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>LinkedHashMap</code> 的 <code>get()</code> 方法</strong>：</p>
<p>在 <code>LinkedHashMap</code> 的 <code>get()</code> 方法中：若 <code>accessOrder = true</code> 时，则每次 <code>get(key)</code> 之后都会将 key 对应的数据移动至双向链表的尾部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedHashMap 中如何构造双向链表？</strong></p>
<p><code>Entry&lt;K,V&gt;</code> 继承了 <code>HashMap.Node&lt;K,V&gt;</code>，并且有 <code>Entry&lt;K,V&gt; before, after;</code> 两个字段，这不就是双线链表的标配嘛</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>LinkedHashMap</code> 中定义了 <code>head</code> 和 <code>tail</code> ，<strong>分别指向双向链表的头部和尾部</strong>，人家注释中也说了，**<code>head</code> 用于指向双向链表中最老的节点，<code>tail</code> 用于指向最年轻的节点<strong>，至于最老和最年轻的定义，就得看 <code>accessOrder</code> 字段的值了：如果 <code>accessOrder = false</code>，那么</strong>最老的节点就是最久没有被使用过的节点，最年轻的节点就是最近被刚被使用过的节点<strong>；如果 <code>accessOrder = true</code>，那么</strong>最老的节点就是链表头部的节点，最年轻的节点就是链表尾部的节点**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>2、<strong>完全自己手写</strong></p>
<ol>
<li><p>依葫芦画瓢，先定义 Node 类作为数据的承载体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造一个node节点作为数据载体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; prev;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义双向链表，里面存放的就是 Node 对象，Node 节点之间通过 <code>prev</code> 和 <code>next</code> 指针连接起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.构建一个虚拟的双向链表,,里面存放的就是我们的Node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; head;</span><br><span class="line">    Node&lt;K, V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.添加到头（头插法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.获得最后一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>HashMap</code> 和 <code>DoubleLinkedList</code> 构建 <code>LinkedHashMap</code>，我们这里可是将最近最常使用的节点放在了双向链表的头部（和 <code>LinkedHashMap</code> 不同哦）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">Map&lt;Integer, Node&lt;Integer, Integer&gt;&gt; map;</span><br><span class="line">DoubleLinkedList&lt;Integer, Integer&gt; doubleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCacheDemo</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheSize = cacheSize;<span class="comment">//坑位</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//查找</span></span><br><span class="line">    doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">    doubleLinkedList.removeNode(node);</span><br><span class="line">    doubleLinkedList.addHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;  <span class="comment">//update</span></span><br><span class="line">        Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">        node.value = value;</span><br><span class="line">        map.put(key, node);</span><br><span class="line">        </span><br><span class="line">        doubleLinkedList.removeNode(node);</span><br><span class="line">        doubleLinkedList.addHead(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == cacheSize)  <span class="comment">//坑位满了</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;Integer, Integer&gt; lastNode = doubleLinkedList.getLast();</span><br><span class="line">            map.remove(lastNode.key);</span><br><span class="line">            doubleLinkedList.removeNode(lastNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增一个</span></span><br><span class="line">        Node&lt;Integer, Integer&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">        map.put(key, newNode);</span><br><span class="line">        doubleLinkedList.addHead(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试 <code>LRUCacheDemo</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LRUCacheDemo lruCacheDemo = <span class="keyword">new</span> LRUCacheDemo(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lruCacheDemo.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    lruCacheDemo.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    lruCacheDemo.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">    lruCacheDemo.put(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">    lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">    lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">    lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">    lruCacheDemo.put(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果：我们实现的是<code>accessOrder = false</code>最近最少使用的数据已经被删除了</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/ab423b570f2556aae42047dc30031fef.png" alt="image-20210207220552698"></p>
</li>
</ol>
<p><strong>全部代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map 负责查找，构建一个虚拟的双向链表，它里面装的就是一个个 Node 节点，作为数据载体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.构造一个node节点作为数据载体</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K, V&gt; prev;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构建一个虚拟的双向链表,,里面安放的就是我们的Node</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; head;</span><br><span class="line">        Node&lt;K, V&gt; tail;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            tail = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.添加到头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            node.prev = head;</span><br><span class="line">            head.next.prev = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.删除节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.prev = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获得最后一个节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tail.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    Map&lt;Integer, Node&lt;Integer, Integer&gt;&gt; map;</span><br><span class="line">    DoubleLinkedList&lt;Integer, Integer&gt; doubleLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheDemo</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;<span class="comment">//坑位</span></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//查找</span></span><br><span class="line">        doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">        doubleLinkedList.removeNode(node);</span><br><span class="line">        doubleLinkedList.addHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;  <span class="comment">//update</span></span><br><span class="line">            Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            map.put(key, node);</span><br><span class="line"></span><br><span class="line">            doubleLinkedList.removeNode(node);</span><br><span class="line">            doubleLinkedList.addHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == cacheSize)  <span class="comment">//坑位满了</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node&lt;Integer, Integer&gt; lastNode = doubleLinkedList.getLast();</span><br><span class="line">                map.remove(lastNode.key);</span><br><span class="line">                doubleLinkedList.removeNode(lastNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新增一个</span></span><br><span class="line">            Node&lt;Integer, Integer&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            doubleLinkedList.addHead(newNode);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LRUCacheDemo lruCacheDemo = <span class="keyword">new</span> LRUCacheDemo(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lruCacheDemo.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line">        lruCacheDemo.put(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(lruCacheDemo.map.keySet());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>图解双向队列</strong>：</p>
<ol>
<li><p><code>DoubleLinkedList</code> 双向链表的初始化</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2ca45a630c105106f1052e5fdf1a8aa2.png" alt="image-20210207220712585"></p>
</li>
<li><p>双向链表插入节点</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/3543591488da5c26a2dd6aa1abf82ae1.png" alt="image-20210207220859295"></p>
</li>
<li><p>双向链表删除节点</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/151c954021cb888f15e299ddb20346df.png" alt="image-20210207221116712"></p>
</li>
</ol>
<hr>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h3 id="1、Mysql什么时候建索引，什么时候不能建索引"><a href="#1、Mysql什么时候建索引，什么时候不能建索引" class="headerlink" title="1、Mysql什么时候建索引，什么时候不能建索引"></a>1、Mysql什么时候建索引，什么时候不能建索引</h3><h4 id="1、索引是什么？"><a href="#1、索引是什么？" class="headerlink" title="1、索引是什么？"></a>1、索引是什么？</h4><p>MySQL官方对索引的定义为：索引(Index)是希切MySQL高效获取数据的数据结构。</p>
<p>可以得到索引的本质：<strong>索引是数据结构</strong>（大部分索引是B+树）</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此<strong>索引往往以索引文件的形式存储的磁盘上</strong></p>
<h4 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h4><p>优点：</p>
<ul>
<li>类似大学图书馆建书目索引，<strong>提高数据检索的效率，降低数据库的IO成本</strong></li>
<li>通过索引列对数据进行排序，<strong>降低数据排序的成本，降低了CPU的消耗</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li>
</ul>
<h4 id="3、什么时候建索引，什么时候不能建索引"><a href="#3、什么时候建索引，什么时候不能建索引" class="headerlink" title="3、什么时候建索引，什么时候不能建索引"></a>3、什么时候建索引，什么时候不能建索引</h4><p>哪些情况需要创建索引：（从索引的优点去考虑）</p>
<ul>
<li><strong>主键自动建立唯一索引</strong></li>
<li><strong>频繁作为查询条件的字段</strong>应该创建索引</li>
<li>查询中<strong>与其它表关联的字段，外键关系建立索引</strong></li>
<li>单键/组合索引的选择问题，<strong>组合索引性价比更高</strong></li>
<li><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li>
<li><strong>查询中统计或者分组字段</strong><ul>
<li>分组字段创建索引会比排序字段创建索引的效率更高，因为分组本身就包含了排序，分组是先排序后分组</li>
</ul>
</li>
</ul>
<p>哪些情况不要创建索引：（从索引的缺点去考虑）</p>
<ul>
<li>表记录太少<ul>
<li>因为还需要维护一张索引表</li>
</ul>
</li>
<li>经常增删改的表或者字段<ul>
<li>因为索引会降低更新表的速度</li>
</ul>
</li>
<li>Where条件里用不到的字段不创建索引<ul>
<li>索引是为了更好更快的查询数据，如果该字段不用来查询数据，就没有必要创建索引</li>
</ul>
</li>
<li>过滤性不好的不适合建索引<ul>
<li>过滤性不好，如：性别</li>
<li>过滤性好，如：身份证号</li>
</ul>
</li>
</ul>
<hr>
<h2 id="JUC多线程及高并发"><a href="#JUC多线程及高并发" class="headerlink" title="JUC多线程及高并发"></a>JUC多线程及高并发</h2><h3 id="1、谈谈你对volatile的理解"><a href="#1、谈谈你对volatile的理解" class="headerlink" title="1、谈谈你对volatile的理解"></a>1、谈谈你对volatile的理解</h3><h4 id="1、解答"><a href="#1、解答" class="headerlink" title="1、解答"></a>1、解答</h4><p>volatile是Java虚拟机提供的<strong>轻量级</strong>的<strong>同步机制</strong></p>
<ul>
<li>保证可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ul>
<h4 id="2、谈谈JMM（Java内存模型）"><a href="#2、谈谈JMM（Java内存模型）" class="headerlink" title="2、谈谈JMM（Java内存模型）"></a>2、谈谈JMM（Java内存模型）</h4><p>JMM（<strong>Java内存模型</strong>，简称JMM）本身是一种抽象的概念<strong>并不真实存在</strong>，它描述的是一组规则或规范，<strong>通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</strong></p>
<p>JMM关于同步的规定：</p>
<ol>
<li><strong>线程解锁前，必须把共享变量的值刷新回主内存</strong>。</li>
<li><strong>线程加锁前，必须读取主内存的最新值到自己的工作内存</strong>。</li>
<li><strong>加锁解锁是同一把锁</strong>。</li>
</ol>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），==工作内存是每个线程的私有数据区域==，而Java内存模型中规定所有变量都存储到<strong>主内存，</strong>==主内存是共享内存区域==，所有线程都可以访问，<strong>但线程对变量的操作（读取、复制等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<strong>变量副本拷贝</strong>，因此==不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成==，其简要访问过程如下图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925231133733.png" alt="image-20210925231133733"></p>
<h4 id="3、解析"><a href="#3、解析" class="headerlink" title="3、解析"></a>3、解析</h4><h5 id="1、volatile解决可见性问题"><a href="#1、volatile解决可见性问题" class="headerlink" title="1、volatile解决可见性问题"></a>1、volatile解决可见性问题</h5><p>通过前面对JMM的介绍，我们知道：</p>
<ul>
<li>各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回主内存中的。</li>
<li>这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另一个线程B又对准内存中同一个共享变量X进行操作，</li>
<li>但此时A线程工作内存中共享变量X对线程B来说并不是可见，这种工作内存与主内存同步存在延迟现象就造成了可见性问题。</li>
</ul>
<p>可见性问题：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925232120695.png" alt="image-20210925232120695"> </p>
<hr>
<p>volatile解决可见性问题：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925232730948.png" alt="image-20210925232730948"></p>
<h5 id="2、volatile不能解决原子性问题"><a href="#2、volatile不能解决原子性问题" class="headerlink" title="2、volatile不能解决原子性问题"></a>2、volatile不能解决原子性问题</h5><p>编程代码：20个线程对int类型的变量num进行1000次的自增操作num++，最终得到的num结果小于等于20000</p>
<p>尝试解决：在num前面使用volatile进行修饰，运行发现num结果的依旧小于等于20000</p>
<ul>
<li>volatile不能解决原子性问题</li>
</ul>
<p>为什么volatile不能解决原子性问题？</p>
<ul>
<li>volatile解决的是可见性的问题，当一个线程修改自己工作流程的num时，要将num写回主内存当中并对其他线程可见，但是它不能保证<ol>
<li>从主存获取num数据</li>
<li>在自己的工作内存当中将num的值加1</li>
<li>在把修改过后的num的值写回主内存</li>
</ol>
</li>
<li>以上三个操作是原子性的，所以就有可能出现丢失写值的情况：多个线程把自己修改的num值同时写回主内存，而num只增加了1。就会出现最终num的结果小于等于20000的情况了。</li>
</ul>
<blockquote>
<p>注：num++并不是一个原子操作，它是三个操作。相关的JVM字节码：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925235908134.png" alt="image-20210925235908134"></p>
</blockquote>
<p>那么怎么解决num++的原子性问题</p>
<ol>
<li>方法1：synchronized加锁<ul>
<li>不推荐，锁的粒度太大</li>
</ul>
</li>
<li>方法2：使用原子整形类AutomicInteger的getAndIncrement方法进行自增<ul>
<li>底层：使用了CAS轻量级锁</li>
</ul>
</li>
</ol>
<h5 id="3、volatile禁止指令重排序——保证有序性"><a href="#3、volatile禁止指令重排序——保证有序性" class="headerlink" title="3、volatile禁止指令重排序——保证有序性"></a>3、volatile禁止指令重排序——保证有序性</h5><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对<strong>指令做重排，</strong>一般分以下3种<strong>：</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005539237.png" alt="image-20210926005539237"></p>
<p><strong>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致</strong>。</p>
<p>处理器在进行重排序时必须考虑指令之间的<strong>数据依赖性</strong>。</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005610144.png" alt="image-20210926005610144"></p>
<h5 id="4、volatile底层原理"><a href="#4、volatile底层原理" class="headerlink" title="4、volatile底层原理"></a>4、volatile底层原理</h5><p>为什么volatile可以实现可见性与有序性？</p>
<p>先了解一个概念，内存屏障又称内存栅栏（Memory Barrier），是一个CPU指令，它的作用有两个：</p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li>
</ol>
<p>内存屏障（Memory Barrier）的分类：</p>
<ul>
<li><p>关于Volatile写的内存屏障指令</p>
<ul>
<li><p>StoreStore屏障：禁止上面的普通写和下面的volatile写重排序——保证了使用volatile修饰的变量的写是在普通写之后执行的</p>
</li>
<li><p>StoreLoad屏障：防止上面的volatile写和下面可能有的volatile读/写重排序——保证了使用volatile修饰的变量的写是在其他在该volatile变量之后的使用volatile修饰的变量之前执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">30</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> d = <span class="number">40</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2的volatile可以保证1在2之前执行，2在3/4之前执行</li>
<li>4的volatile可以保证1/2/3在4之前执行</li>
</ul>
</li>
</ul>
</li>
<li><p>关于Volatile读的内存屏障指令</p>
<ul>
<li><p>LoadLoad屏障：禁止下面所有普通读操作和上面的volatile读重排序——保证了使用volatile修饰的变量的读是在其他普通变量读的之前执行</p>
</li>
<li><p>LoadStore屏障：禁止下面所有的写操作和上面的volatile读重排序——保证了使用volatile修饰的变量的读是在其他普通变量写的之前执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">System.out.println(b); <span class="comment">// 2</span></span><br><span class="line">c = <span class="number">80</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a的volatile保证了1在2/3之前执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重新排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。——保证有序性</p>
<p>内存屏障另外一个作用是<strong>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</strong>——保证可见性</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926005930287.png" alt="image-20210926005930287"></p>
<h5 id="4、保证线程的安全"><a href="#4、保证线程的安全" class="headerlink" title="4、保证线程的安全"></a>4、保证线程的安全</h5><ol>
<li>工作内存和主内存<strong>同步延迟现象导致的可见性问题</strong>：<ul>
<li>可以使用<code>synchronized</code>或<code>volatile</code>关键字解决，他们都可以使一个线程<strong>修改后的变量立即对其他线程可见</strong>。</li>
</ul>
</li>
<li>对于<strong>指令重排导致的可见性问题和有序性问题</strong>：<ul>
<li>可以利用<strong>volatile</strong>关键字解决，因为volatile的另外一个作用就是禁止重排序优化。</li>
</ul>
</li>
</ol>
<h4 id="4、你在哪些地方用过volatile？"><a href="#4、你在哪些地方用过volatile？" class="headerlink" title="4、你在哪些地方用过volatile？"></a>4、你在哪些地方用过volatile？</h4><p>解答：</p>
<ol>
<li>在单例模式Singleton的DCL写法（Double Check Lock双端检索机制）使用过volatile来反正指令的重排序</li>
<li>在手写读写锁的缓存的时候</li>
<li>在翻阅CAS的底层的JUC源码时经常能看到volatile</li>
</ol>
<p>为什么单例模式Singleton的DCL写法会出现指令的重排序问题导的线程安全问题？</p>
<p>原因在于<strong>对象的创建并不是一个原子操作</strong>，对象的操作分为3个步骤，<strong>而且步骤之间不存在数据依赖</strong>，可以进行指令重排序。</p>
<p>导致某一个线程执行到第一次检测，读取到的instance不为null时，可能会出现两种情况：</p>
<ol>
<li>instance的引用对象真的创建成功了（绝大部分都是）</li>
<li>instance的引用对象可能没有完成初始化（还是可能出现的，出现了就是线程安全问题了）</li>
</ol>
<p>instance = new SingletonDemo();——创建对象可以分为以下3步完成(伪代码)</p>
<ol>
<li><strong>分配对象内存空间</strong><ul>
<li>memory = allocate();</li>
</ul>
</li>
<li><strong>初始化对象</strong><ul>
<li>instance(memory); </li>
</ul>
</li>
<li><strong>设置instance指向刚分配的内存地址</strong>，此时instance! =null<ul>
<li>instance = memory;</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果JVM依靠的以上的指令进行对象的创建的话，就不会出现线程安全问题了——第一种情况</p>
<p>但是<strong>步骤2和步骤3不存在数据依赖关系</strong>，而且无论重排前还是重排后程序的执行结果<strong>在单线程中并没有改变</strong>，因此这种重排优化是允许的。</p>
</blockquote>
<ol>
<li><strong>分配对象内存空间</strong><ul>
<li>memory = allocate();</li>
</ul>
</li>
<li><strong>设置instance指向刚分配的内存地址</strong>，此时instance! =null，但是对象还没有初始化完成！对象里面的实例变量可能还没有赋值等等<ul>
<li>instance = memory;</li>
</ul>
</li>
<li><strong>初始化对象</strong><ul>
<li>instance(memory); </li>
</ul>
</li>
</ol>
<blockquote>
<p>因此此时线程得到的instance实例就是有问题的，就出现了线程安全问题——第二种情况</p>
</blockquote>
<h3 id="2、CAS你知道吗"><a href="#2、CAS你知道吗" class="headerlink" title="2、CAS你知道吗"></a>2、CAS你知道吗</h3><h4 id="1、什么是CAS"><a href="#1、什么是CAS" class="headerlink" title="1、什么是CAS"></a>1、什么是CAS</h4><p>CAS的全称是Compare-And-Swap（比较并交换），<strong>它是一条CPU并发原语</strong>。</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p>
<blockquote>
<p>CAS就是一个线程如果想要将当前修改值放进主内存之前需要进行一次比较操作：拿一开始从主内存获取的变量副本与当前主内存当中的该变量的值进行比较。如果一样，则表示在该线程修改该变量的值的这段时间内，没有其他线程动过主内存当中该变量的值（除了出现ABA问题），则可以进行写回操作，并且返回true。否则返回false并且写回失败。</p>
</blockquote>
<p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中CAS方法，JVM会帮我们实现<strong>CAS汇编指令</strong>。这是一种完全依赖于<strong>硬件</strong>的功能，通过它实现原子性。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干指令组成的，用语完成某个功能的一个过程，<strong>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致性问题。</strong></p>
<p>CAS应用：CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>为什么说CAS的粒度要比Synchronized低呢？——这就需要从CAS的底层说起</p>
<ul>
<li>因为Synchronized使用了锁，线程的并发性下降了</li>
<li>而CAS没有使用锁，底层是使用了自旋锁（自旋锁不是锁，而是一个循环），因此线程的并发性并没有下降</li>
</ul>
<h4 id="2、CAS的底层"><a href="#2、CAS的底层" class="headerlink" title="2、CAS的底层"></a>2、CAS的底层</h4><p>CAS的底层：Unsafe + 自旋锁</p>
<ul>
<li>Unsafe保证CAS操作的原子性</li>
<li>自旋锁保证CAS操作的成功性</li>
</ul>
<p>以atomicInteger.getAndIncrement();为例：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926022649349.png" alt="image-20210926022649349"></p>
<p>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别在不同CPU上）</p>
<ol>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。</li>
<li>线程A通过getAndIncrement(var1，var2)拿到value值3，这时线程A被挂起。</li>
<li>线程B也通过getAndIncrement(var1，var2)方法获得value值3，此时刚好线程B没有被挂起并执行compareAndSwap方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。</li>
<li>这是线程A恢复运行，执行compareAndSwapInt方法比较，发现手里的值3与内存值4不一致，说明该值已经被其他线程抢先异步修改过了，那A线程本次修改失败，只能重新读取重新来一遍了。</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li>
</ol>
<p>底层汇编：</p>
<p>Unsafe类中的compareAndSwaplnt，是一个本地方法，该方法的实现位于unsafe.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">	UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">	oop p = JNIHandles::resolve(obj);</span><br><span class="line">	jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">	<span class="keyword">return</span> (jint)(Atomic::cmpxchg(x,addr,e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(Atomic::cmpxchg(x,addr,e)) == e</p>
<ul>
<li>先想办法拿到变量value在内存中的地址。</li>
<li>通过Atomic::cmpxchg实现比较替换，其中参数x是即将更新的值，参数e是原内存的值。</li>
</ul>
</blockquote>
<h4 id="3、Unsafe"><a href="#3、Unsafe" class="headerlink" title="3、Unsafe"></a>3、Unsafe</h4><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<strong>Unsafe类存在于sun.misc包中</strong>，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。</p>
<p>其中：</p>
<ul>
<li>变量valueOffset，表示该变量在内存中的<strong>偏移地址</strong>，因为Unsafe就是根据内存偏移地址获取数据的。</li>
<li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li>
</ul>
<h4 id="4、CAS的缺点是什么？原子类Atomiclnteger的ABA问题谈谈？原子更新引用知道吗？"><a href="#4、CAS的缺点是什么？原子类Atomiclnteger的ABA问题谈谈？原子更新引用知道吗？" class="headerlink" title="4、CAS的缺点是什么？原子类Atomiclnteger的ABA问题谈谈？原子更新引用知道吗？"></a>4、CAS的缺点是什么？原子类Atomiclnteger的ABA问题谈谈？原子更新引用知道吗？</h4><ul>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA问题</li>
</ul>
<h5 id="1、ABA问题"><a href="#1、ABA问题" class="headerlink" title="1、ABA问题"></a>1、ABA问题</h5><p>因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是<strong>使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个类的compareAndSet方法的作用是<strong>首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</strong>。</p>
<h5 id="2、循环时间长开销大"><a href="#2、循环时间长开销大" class="headerlink" title="2、循环时间长开销大"></a>2、循环时间长开销大</h5><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。</p>
<p>pause指令有两个作用：</p>
<ol>
<li>第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li>
<li>第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。</li>
</ol>
<h5 id="3、只能保证一个共享变量的原子操作"><a href="#3、只能保证一个共享变量的原子操作" class="headerlink" title="3、只能保证一个共享变量的原子操作"></a>3、只能保证一个共享变量的原子操作</h5><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，<strong>这个时候就可以用锁</strong>。</p>
<p>还有一个取巧的办法，就是<strong>把多个共享变量合并成一个共享变量来操作</strong>。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。</p>
<p>从Java 1.5开始，JDK提供了<code>AtomicReference</code>类来<strong>保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作</strong>。</p>
<h3 id="3、我们知道ArrayList是线程不安全，请编写一个不安全的案例并给出解决方案"><a href="#3、我们知道ArrayList是线程不安全，请编写一个不安全的案例并给出解决方案" class="headerlink" title="3、我们知道ArrayList是线程不安全，请编写一个不安全的案例并给出解决方案"></a>3、我们知道ArrayList是线程不安全，请编写一个不安全的案例并给出解决方案</h3><p>ArrayList的add操作在多线程下是不安全的，会出现<code>ConcurrentModificationException</code>异常——并发修改异常</p>
<p>解决方法：</p>
<ul>
<li>使用Vector集合代替ArrayList集合<ul>
<li>Vector的底层方法，如add方法加了synchronized锁，粒度大，并发性低，不推荐</li>
</ul>
</li>
<li>使用Collections.synchronizedList集合包装ArrayList集合<ul>
<li>底层也是加了synchronized锁，粒度大，并发性低，不推荐</li>
</ul>
</li>
<li>使用JUC的CopyOnWriteArrayList集合代替ArrayList集合<ul>
<li>推荐</li>
</ul>
</li>
</ul>
<p>JUC的CopyOnWriteArrayList集合：——解决ArrayList多线程不安全问题</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141136813-16326367030621.png" alt="image-20210926141136813"></p>
<p>CopyOnWriteArrayList集合的add方法实现：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141201995.png" alt="image-20210926141201995"></p>
<blockquote>
<p>写时复制技术：</p>
<ul>
<li>CopyOnWrite容器即写时复制的容器。</li>
<li>往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前object[]进行Copy，复制出一个新的容器Object[] newElements，然后新的容器Object[] newElements里添加元素，</li>
<li>添加完元素之后，再将原容器的引用指向新的容器：setArray(newElements);</li>
<li>这样做的好处是可以<strong>对copyonwrite容器进行并发的读，而不需要加锁</strong>，因为当前容器不会添加任何元素。</li>
<li>所以<strong>copyonwrite容器也是一种读写分离的思想，读和写不同的容器</strong>。</li>
</ul>
</blockquote>
<p>JUC的CopyOnWriteArraySet集合：——解决HashSet多线程不安全问题</p>
<ul>
<li>底层使用了上面的CopyOnWriteArrayList集合</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210926141050834.png" alt="image-20210926141050834"></p>
<blockquote>
<p>注：</p>
<ul>
<li>HashSet的底层是一个容量为18，负载因子为0.75的HashMap<ul>
<li>HashSet集合add的值是底层HashMap的key（不可重复）</li>
<li>底层HashMap的value是PRESENT——一个Object类型的常量</li>
</ul>
</li>
<li>CopyOnWriteArraySet的底层是一个CopyOnWriteArrayList</li>
</ul>
</blockquote>
<p>JUC的ConcurrentHashMap集合：——解决HashMap多线程不安全问题</p>
<p>注意：</p>
<ul>
<li>ConcurrentHashMap集合在JDK1.7与JDK1.8的底层实现不一样<ul>
<li><code>ConcurrentHashMap JDK1.7</code>：使用<code>分段锁机制</code>实现；</li>
<li><code>ConcurrentHashMap JDK1.8</code>：则使用<code>数组+链表+红黑树数据结构和CAS原子操作</code>实现；</li>
</ul>
</li>
<li>HashMap集合在JDK1.7与JDK1.8的底层实现也略微有一点差别<ul>
<li>JDK1.7的HashMap在多线程的环境下，扩容的过程中可能会出现并发死链问题<ul>
<li>出现原因：JDK1.7的HashMap在添加元素是使用的是头插法</li>
</ul>
</li>
<li>JDK1.8的HashMap使用尾插法解决了并发死链问题</li>
<li>但是两种HashMap都不能解决在多线程的环境下出现ConCurrentModificationException问题</li>
</ul>
</li>
</ul>
<h3 id="4、公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解？请手写一个自旋锁"><a href="#4、公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解？请手写一个自旋锁" class="headerlink" title="4、公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解？请手写一个自旋锁"></a>4、公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解？请手写一个自旋锁</h3><h4 id="1、公平锁和非公平锁"><a href="#1、公平锁和非公平锁" class="headerlink" title="1、公平锁和非公平锁"></a>1、公平锁和非公平锁</h4><h5 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h5><ul>
<li>公平锁：是指多个线程按照申请锁的<strong>顺序</strong>来获取锁，类似排队打饭，先来后到。</li>
<li>非公平锁：是指多个线程获取锁的顺序<strong>并不是按照申请锁的顺序</strong>，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，<strong>有可能会造成优先级反转或者饥饿现象</strong>。</li>
</ul>
<h5 id="2、两者区别"><a href="#2、两者区别" class="headerlink" title="2、两者区别"></a>2、两者区别</h5><p>公平锁/非公平锁：并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，<strong>默认是非公平锁</strong>。</p>
<p>关于两者区别：</p>
<ul>
<li>公平锁：Threads acquire a fair lock in the order in which they requested it.<ul>
<li>公平锁，就是很公平，在并发情况下，每个线程在获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</li>
</ul>
</li>
<li>非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采取类似公平锁那种方式。</li>
</ul>
<h5 id="3、ReentrantLock-与-Synchronized"><a href="#3、ReentrantLock-与-Synchronized" class="headerlink" title="3、ReentrantLock 与  Synchronized"></a>3、ReentrantLock 与  Synchronized</h5><p>Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，<strong>默认是非公平锁</strong>。<strong>非公平锁的优点在于吞吐量比公平锁大</strong>。</p>
<p><strong>对于Synchronized而言，也是一种非公平锁</strong>。</p>
<h4 id="2、可重入锁（又名递归锁）"><a href="#2、可重入锁（又名递归锁）" class="headerlink" title="2、可重入锁（又名递归锁）"></a>2、可重入锁（又名递归锁）</h4><p>可重入锁（也就是递归锁）：指的是<strong>同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</strong></p>
<p>也就是说：<strong>线程可以进入任何一个它已经拥有的锁所有同步着的代码块。</strong></p>
<ul>
<li>ReentrantLock/Synchronized就是一个典型的可重入锁</li>
<li>可重入锁最大的作用是避免死锁</li>
<li>ReentrantLock可以获取多把的锁，但是需要配对进行解锁，否则会出现死锁问题</li>
</ul>
<h4 id="3、独占锁-共享锁"><a href="#3、独占锁-共享锁" class="headerlink" title="3、独占锁/共享锁"></a>3、独占锁/共享锁</h4><ul>
<li><p>独占锁：<strong>指该锁一次只能被一个线程所持有</strong>。</p>
<ul>
<li>对<code>ReentrantLock</code>和<code>Synchronized</code>而言都是独占锁。</li>
</ul>
</li>
<li><p>共享锁：<strong>指该锁可被多个线程所持有。</strong></p>
<ul>
<li>对<code>ReentrantReadWriteLock</code>，<strong>其读锁是共享锁，其写锁是独占锁</strong>。读锁的共享锁可保证并发读是非常高效的，<ul>
<li>读写，写读，写写的过程是互斥的。</li>
<li>读读是共享的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、自旋锁"><a href="#4、自旋锁" class="headerlink" title="4、自旋锁"></a>4、自旋锁</h4><p>自旋锁：是指尝试获取锁的线程不会立即阻塞，而是<strong>采用循环的方式去尝试获取锁</strong>。</p>
<p>这样的<strong>好处是减少线程上下切换的消耗</strong>，<strong>缺点是循环会消耗CPU</strong>。</p>
<p>自己实现自旋锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试写好的自旋锁</span></span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手写自旋锁</span></span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; come in ...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; unlock ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、synchronized和lock有什么区别？用新的lock有什么好处？你举例说说"><a href="#5、synchronized和lock有什么区别？用新的lock有什么好处？你举例说说" class="headerlink" title="5、synchronized和lock有什么区别？用新的lock有什么好处？你举例说说"></a>5、synchronized和lock有什么区别？用新的lock有什么好处？你举例说说</h4><ol>
<li><strong>原始构成</strong><ul>
<li><strong>synchronized是关键字，属于JVM层面</strong>，monitorenter（<strong>底层是通过monitor对象来完成</strong>，其实wait/notify等方法也依赖于monitor对象，只有在同步块或者方法中才能调用wait/notify等方法）</li>
<li><strong>Lock是具体类</strong>（java.util.concurrent.locks.lock）<strong>是api层面的锁。</strong></li>
</ul>
</li>
<li><strong>使用方法</strong><ul>
<li><strong>synchronized不需要用户去手动释放锁</strong>，当synchronized代码执行完后<strong>系统会自动让线程释放对锁的占用</strong>。</li>
<li><strong>ReentrantLock则需要用户去手动释放锁</strong>，若没有主动释放锁，就有可能导致出现死锁现象。<ul>
<li>需要lock()和unlock()方法配合try/finally语句块来完成。</li>
</ul>
</li>
</ul>
</li>
<li><strong>等待是否可中断</strong><ul>
<li><strong>synchronized不可中断，除非抛出异常或者正常运行完成</strong>。</li>
<li><strong>ReentrantLock可中断</strong><ol>
<li>设置超时方法：tryLock(long timeout,TimeUnit unit)；</li>
<li>lockInterruptibly()放代码块中，调用interrupt()方法可中断。</li>
</ol>
</li>
</ul>
</li>
<li><strong>加锁是否公平</strong><ul>
<li><strong>synchronized非公平锁</strong></li>
<li><strong>ReentrantLock两者都可以，默认非公平锁</strong>，构造方法可以传入boolean值，true为公平锁，false为非公平锁。</li>
</ul>
</li>
<li><strong>锁绑定多个条件Condition</strong><ul>
<li>synchronized没有Condition，进行唤醒时要不就是随机唤醒一个沉睡的线程，要不就是唤醒全部沉睡的线程</li>
<li>ReentrantLock用来实现分组唤醒需要唤醒的线程，可以<strong>精确唤醒</strong>，而不是像synchronized要么随机唤醒一个要么唤醒全部线程。</li>
</ul>
</li>
</ol>
<h3 id="5、CountDownLatch-CyclicBarrier-Semaphore"><a href="#5、CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="5、CountDownLatch/CyclicBarrier/Semaphore"></a>5、CountDownLatch/CyclicBarrier/Semaphore</h3><h4 id="1、CountDownLatch——做减法"><a href="#1、CountDownLatch——做减法" class="headerlink" title="1、CountDownLatch——做减法"></a>1、CountDownLatch——做减法</h4><ul>
<li>让一些线程阻塞直到另一个线程完成一系列操作后才被唤醒</li>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞。其他线程调用countDown方法会<strong>将计数器减1</strong>（调用CountDown方法的线程不会阻塞），<strong>当计数器的值变为0时，因调用await方法被阻塞的线程会被唤醒，继续执行</strong>。</li>
<li>鲜明的例子：秦灭六国，统一中原（减法）</li>
</ul>
<p>枚举与CountDownLatch实现对应线程的调用</p>
<p>CountDownLatch例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		county();	</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">county</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 通过枚举将数字i与国家进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 国被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.list(i).getRetMsg()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ******秦国一统华夏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>国家枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">    ONE(<span class="number">1</span>, <span class="string">&quot;齐&quot;</span>), TWO(<span class="number">2</span>, <span class="string">&quot;楚&quot;</span>), THREE(<span class="number">3</span>, <span class="string">&quot;燕&quot;</span>), FOUR(<span class="number">4</span>, <span class="string">&quot;赵&quot;</span>), FIVE(<span class="number">5</span>, <span class="string">&quot;魏&quot;</span>), SIX(<span class="number">6</span>, <span class="string">&quot;韩&quot;</span>);</span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> Integer retCode;</span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> String retMsg;</span><br><span class="line"></span><br><span class="line">    CountryEnum(Integer retCode, String retMsg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">        <span class="keyword">this</span>.retMsg = retMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">list</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        CountryEnum[] countryEnums = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum countryEnum : countryEnums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx==countryEnum.getRetCode())</span><br><span class="line">                <span class="keyword">return</span> countryEnum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、CyclicBarrier——做加法"><a href="#2、CyclicBarrier——做加法" class="headerlink" title="2、CyclicBarrier——做加法"></a>2、CyclicBarrier——做加法</h4><ul>
<li>CyslicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。</li>
<li>它要做的事情是，让一组线程到达屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会打开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。</li>
<li>鲜明的例子：集七颗龙珠召唤神龙（加法）</li>
</ul>
<h4 id="3、Semaphore——伸缩（加减法）"><a href="#3、Semaphore——伸缩（加减法）" class="headerlink" title="3、Semaphore——伸缩（加减法）"></a>3、Semaphore——伸缩（加减法）</h4><ul>
<li>信号量主要用于两个目的，一个是用于<strong>多个共享资源的互斥使用</strong>，另一个用于<strong>并发线程数的控制</strong>。</li>
<li>主要的方法：acquire()方法做减法，release()做加法，放在try/finally块当中执行</li>
<li>鲜明的例子：争抢车位</li>
</ul>
<h3 id="6、阻塞队列知道吗"><a href="#6、阻塞队列知道吗" class="headerlink" title="6、阻塞队列知道吗"></a>6、阻塞队列知道吗</h3><h4 id="1、队列-阻塞队列"><a href="#1、队列-阻塞队列" class="headerlink" title="1、队列+阻塞队列"></a>1、队列+阻塞队列</h4><p>阻塞队列，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致是：<strong>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</strong>。</p>
<ol>
<li>当阻塞队列是<strong>空</strong>时，从队列中<strong>获取</strong>元素的操作将<strong>被阻塞</strong>。</li>
<li>当阻塞队列是<strong>满</strong>时，往队列里<strong>添加</strong>元素的操作将<strong>被阻塞</strong>。</li>
<li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素</li>
<li>同样，试图从已满的阻塞队列中添加元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210927150822979.png" alt="image-20210927150822979"> </p>
<h4 id="2、为什么用？有什么好处？"><a href="#2、为什么用？有什么好处？" class="headerlink" title="2、为什么用？有什么好处？"></a>2、为什么用？有什么好处？</h4><p>在多线程领域：所谓阻塞，在某些情况下会<strong>挂起</strong>线程（即阻塞），一旦满足条件，被挂起的线程又会自动<strong>被唤醒</strong>。</p>
<p>为什么需要BlockingQueue？<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你包办了。</p>
<p>在<strong>concurrent</strong>包发布之前，在多线程环境下，<strong>我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全</strong>，而这会给程序带来不小的复杂度。</p>
<h4 id="3、架构梳理-种类分析"><a href="#3、架构梳理-种类分析" class="headerlink" title="3、架构梳理+种类分析"></a>3、架构梳理+种类分析</h4><p>BlockingQueue和list都是Collections的接口。常用的BlockingQueue的实现类有</p>
<ul>
<li><strong><code>ArrayBlockingQueue</code>**：由</strong>数组<strong>结构组成的</strong>有界**阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序</li>
<li><strong><code>LinkedBlockingQueue</code>**：由</strong>链表<strong>结构组成的</strong>有界**（但大小默认值为Integer.MAX_VALUE）阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序，吞吐量通常要高于ArrayBlockingQueue。但是它要慎用，LinkedBlockingQueue虽然说是一个有界的阻塞队列，但是它的默认容量是Integer.MAX_VALUE——2147483647（21亿多，与无界差不了多少）</li>
<li><strong><code>SynchronousQueue</code>**：一个不存储元素的阻塞队列，也即</strong>单个元素的队列**。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。<ul>
<li>SynchronousQueue没有容量。</li>
<li>与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。</li>
<li>吞吐量通常要高于LinkedBlockingQueue</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code>：支持<strong>优先级排序</strong>的<strong>无界</strong>阻塞队列。</li>
<li><code>DelayQueue</code>：使用<strong>优先级队列</strong>实现的<strong>延迟无界</strong>阻塞队列。</li>
<li><code>LinkedTransferQueue</code>：由<strong>链表</strong>结构组成的<strong>无界</strong>阻塞队列。</li>
<li><code>LinkedBlockingDeque</code>：由<strong>链表</strong>结构组成的<strong>双向阻塞</strong>队列。</li>
</ul>
<h4 id="4、BlockingQueue的核心方法"><a href="#4、BlockingQueue的核心方法" class="headerlink" title="4、BlockingQueue的核心方法"></a>4、BlockingQueue的核心方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常<ul>
<li>当阻塞队列满时，再往队列里add插入元素会抛<code>IllegalStateException Queue Full</code></li>
<li>当阻塞队列空时，再往队列里remove移除元素会抛<code>NoSuchElementException</code></li>
</ul>
</li>
<li>特殊值<ul>
<li>插入方法，成功true失败false</li>
<li>移除方法，成功返回出队列的元素，队列里面没有就返回null</li>
</ul>
</li>
<li>一直阻塞<ul>
<li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</li>
</ul>
</li>
<li>超时退出<ul>
<li>当阻塞队列满时，队列会阻塞线程一定的时间，超过限时后生产者线程会退出，返回false</li>
</ul>
</li>
</ul>
<h4 id="5、阻塞队列用在哪里"><a href="#5、阻塞队列用在哪里" class="headerlink" title="5、阻塞队列用在哪里"></a>5、阻塞队列用在哪里</h4><ol>
<li>生产者消费者模式<ul>
<li>传统版<ul>
<li>使用的是RentranLock与Condition的await与signalAll返回</li>
<li>注意虚假唤醒问题</li>
</ul>
</li>
<li>阻塞队列版<ul>
<li>在资源类当中添加阻塞队列和相关和生产与消费的方法，通过offer与poll的进行超时调用</li>
</ul>
</li>
</ul>
</li>
<li>线程池</li>
<li>消息中间件的底层使用的就是阻塞队列</li>
</ol>
<h3 id="7、使用FutureTask-与-Callable的几个注意事项"><a href="#7、使用FutureTask-与-Callable的几个注意事项" class="headerlink" title="7、使用FutureTask 与 Callable的几个注意事项"></a>7、使用FutureTask 与 Callable的几个注意事项</h3><h4 id="1、使用FutureTask的注意事项"><a href="#1、使用FutureTask的注意事项" class="headerlink" title="1、使用FutureTask的注意事项"></a>1、使用FutureTask的注意事项</h4><ol>
<li>多个线程抢FutureTask，FutureTask只会执行一次</li>
<li>如果想要执行多次FutureTask，需要新建新的FutureTask对象给线程使用</li>
<li>futureTask的get的方法可以获取运行futureTask的线程的运行结果，建议将该方法放在最后使用。<ul>
<li>因为该方法需要得到Callable结果的计算结果，放在前面可能会导致当前线程出现阻塞等待Callable的结果的获取之后才能往下运行</li>
<li>如果不得不先获取futureTask的结果，可以使用idDone方法，以自旋锁的方式获取</li>
</ul>
</li>
</ol>
<h4 id="2、Java有了Runnable接口，为什么还需要Callable接口？"><a href="#2、Java有了Runnable接口，为什么还需要Callable接口？" class="headerlink" title="2、Java有了Runnable接口，为什么还需要Callable接口？"></a>2、Java有了Runnable接口，为什么还需要Callable接口？</h4><p>先看看两者的源码：</p>
<p>Runnable.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.0开始</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.5开始</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由他们本身的接口定义我们就能够看出它们的区别：</p>
<ol>
<li>callable的核心是call方法，允许返回值，runnable的核心是run方法，没有返回值</li>
<li>call方法可以抛出异常，但是run方法不行<ul>
<li>因为runnable是java1.0就有了，所以他不存在返回值，后期在java1.5进行了优化，就出现了callable，就有了返回值和抛异常</li>
<li>因此Callable接口实现类中run()方法允许将异常向上抛出，也可以直接在内部处理(try…catch)</li>
<li>而Runnable接口实现类中run()方法的异常必须在内部处理掉，不能向上抛出</li>
</ul>
</li>
<li>callable和runnable都可以应用于executors。<strong>而thread类只支持runnable</strong></li>
<li>runnable对象实例可以作为线程池方法<code>execute()</code>的入口参数来执行任务；</li>
<li>callable对象实例可以作为线程池的<code>submit()</code>方法入口参数来执行任务；</li>
<li>运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。 通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。<ul>
<li>Callable接口支持通过FutureTask异步返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞线程直到获取“将来”的结果，当不调用此方法时，主线程不会阻塞。</li>
</ul>
</li>
</ol>
<h3 id="8、线程池用过吗？ThreadPoolExecutor谈谈你的理解？"><a href="#8、线程池用过吗？ThreadPoolExecutor谈谈你的理解？" class="headerlink" title="8、线程池用过吗？ThreadPoolExecutor谈谈你的理解？"></a>8、线程池用过吗？ThreadPoolExecutor谈谈你的理解？</h3><h4 id="1、为什么用线程池？——线程池的优势"><a href="#1、为什么用线程池？——线程池的优势" class="headerlink" title="1、为什么用线程池？——线程池的优势"></a>1、为什么用线程池？——线程池的优势</h4><p>线程池主要是控制运行线程的数量，<strong>处理过程中将任务放入队列</strong>，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>主要特点是：<strong>线程复用、控制最大并发数、管理线程</strong>。</p>
<ol>
<li>第一：<strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：<strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：<strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h4 id="2、线程池如何使用？"><a href="#2、线程池如何使用？" class="headerlink" title="2、线程池如何使用？"></a>2、线程池如何使用？</h4><h5 id="1、架构说明"><a href="#1、架构说明" class="headerlink" title="1、架构说明"></a>1、架构说明</h5><p>Java中的线程池是通过<strong>Executor框架</strong>实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</p>
<h5 id="2、编码实现"><a href="#2、编码实现" class="headerlink" title="2、编码实现"></a>2、编码实现</h5><ul>
<li>Executors.newScheduledThreadPool()</li>
<li>java8新出：Executors.newWorkStealingPool(int)——使用所有可用处理器作为目标并行度，创建一个窃取线程的池。<ul>
<li>使用目前机器上可用的处理器作为它的并行级别</li>
</ul>
</li>
<li>**Executors.newFixedThreadPool(int)**：一池固定线程数，执行长期的任务，性能好很多</li>
<li>**Executors.newSingleThreadExecutor()**：一池一线程，一个任务一个任务执行的场景</li>
<li>**Executors.newCachedThreadPool()**：一池多线程（可扩容），适用与执行很多短期异步的小程序或者负载较轻的服务器</li>
</ul>
<h6 id="1、Executors-newFixedThreadPool-int"><a href="#1、Executors-newFixedThreadPool-int" class="headerlink" title="1、Executors.newFixedThreadPool(int)"></a>1、Executors.newFixedThreadPool(int)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread pool that reuses a fixed number of threads</span></span><br><span class="line"><span class="comment"> * operating off a shared unbounded queue, using the provided</span></span><br><span class="line"><span class="comment"> * ThreadFactory to create new threads when needed.  At any point,</span></span><br><span class="line"><span class="comment"> * at most &#123;<span class="doctag">@code</span> nThreads&#125; threads will be active processing</span></span><br><span class="line"><span class="comment"> * tasks.  If additional tasks are submitted when all threads are</span></span><br><span class="line"><span class="comment"> * active, they will wait in the queue until a thread is</span></span><br><span class="line"><span class="comment"> * available.  If any thread terminates due to a failure during</span></span><br><span class="line"><span class="comment"> * execution prior to shutdown, a new one will take its place if</span></span><br><span class="line"><span class="comment"> * needed to execute subsequent tasks.  The threads in the pool will</span></span><br><span class="line"><span class="comment"> * exist until it is explicitly &#123;<span class="doctag">@link</span> ExecutorService#shutdown</span></span><br><span class="line"><span class="comment"> * shutdown&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when creating new threads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点：</p>
<ol>
<li>创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的<strong>LinkedBlockingQueue</strong>。</li>
</ol>
<h6 id="2、Executors-newSingleThreadExecutor"><a href="#2、Executors-newSingleThreadExecutor" class="headerlink" title="2、Executors.newSingleThreadExecutor()"></a>2、Executors.newSingleThreadExecutor()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment"> * off an unbounded queue. (Note however that if this single</span></span><br><span class="line"><span class="comment"> * thread terminates due to a failure during execution prior to</span></span><br><span class="line"><span class="comment"> * shutdown, a new one will take its place if needed to execute</span></span><br><span class="line"><span class="comment"> * subsequent tasks.)  Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment"> * sequentially, and no more than one task will be active at any</span></span><br><span class="line"><span class="comment"> * given time. Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned executor is</span></span><br><span class="line"><span class="comment"> * guaranteed not to be reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点：</p>
<ol>
<li>创建<strong>一个单线程化</strong>的线程池，它只会唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
<li>newSingleThread将corePoolSize和maximumPoolSize都设置为1，<strong>它使用的是LinkedBlockingQueue</strong>。</li>
</ol>
<h6 id="3、Executors-newCachedThreadPool"><a href="#3、Executors-newCachedThreadPool" class="headerlink" title="3、Executors.newCachedThreadPool()"></a>3、Executors.newCachedThreadPool()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread pool that creates new threads as needed, but</span></span><br><span class="line"><span class="comment"> * will reuse previously constructed threads when they are</span></span><br><span class="line"><span class="comment"> * available.  These pools will typically improve the performance</span></span><br><span class="line"><span class="comment"> * of programs that execute many short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment"> * Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously constructed</span></span><br><span class="line"><span class="comment"> * threads if available. If no existing thread is available, a new</span></span><br><span class="line"><span class="comment"> * thread will be created and added to the pool. Threads that have</span></span><br><span class="line"><span class="comment"> * not been used for sixty seconds are terminated and removed from</span></span><br><span class="line"><span class="comment"> * the cache. Thus, a pool that remains idle for long enough will</span></span><br><span class="line"><span class="comment"> * not consume any resources. Note that pools with similar</span></span><br><span class="line"><span class="comment"> * properties but different details (for example, timeout parameters)</span></span><br><span class="line"><span class="comment"> * may be created using &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点：</p>
<ol>
<li>创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</li>
</ol>
<h5 id="3、ThreadPoolExcutor"><a href="#3、ThreadPoolExcutor" class="headerlink" title="3、ThreadPoolExcutor"></a>3、ThreadPoolExcutor</h5><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210928224559619.png" alt="image-20210928224559619"></p>
<blockquote>
<p>以上线程池的底层都是使用了ThreadPoolExcutor的构造方法，只是传入的参数有差别。这也是我们自定义线程池的方法</p>
</blockquote>
<h4 id="3、线程池的几个重要参数介绍"><a href="#3、线程池的几个重要参数介绍" class="headerlink" title="3、线程池的几个重要参数介绍"></a>3、线程池的几个重要参数介绍</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210928224539153.png" alt="image-20210928224539153"></p>
<ul>
<li><code>corePoolSize</code>：线程池中的常驻核心线程数<ul>
<li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程。</li>
<li>当线程池中的线程数目到达corePoolSize后，就会把到达的任务放到缓存队列当中。</li>
</ul>
</li>
<li><code>maximumPoolSize</code>：线程池能够容纳同时执行的最大线程数，此值必须大于等于1.</li>
<li><code>keepAliveTime</code>：多余的空闲线程的存活时间。<ul>
<li>当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。</li>
<li>默认情况下：只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize。</li>
</ul>
</li>
<li><code>unit</code>：keepAliveTime的单位</li>
<li><code>workQueue</code>：任务队列，被提交但尚未被执行的任务。</li>
<li><code>threadFactory</code>：表示生成线程池中工作线程的线程工厂，用于<strong>创建线程一般用默认的即可</strong>。<ul>
<li>也可以直接cv默认的，然后定义一下线程名字，出问题了好排错</li>
</ul>
</li>
<li><code>handler</code>：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数，当有新的任务到来时采用的策略。</li>
</ul>
<h5 id="为什么在ThreadPoolExecutor的底层构造函数有七种参数，而线程池的创建却只有5个？剩下的那两个参数是什么？有什么作用？"><a href="#为什么在ThreadPoolExecutor的底层构造函数有七种参数，而线程池的创建却只有5个？剩下的那两个参数是什么？有什么作用？" class="headerlink" title="为什么在ThreadPoolExecutor的底层构造函数有七种参数，而线程池的创建却只有5个？剩下的那两个参数是什么？有什么作用？"></a>为什么在ThreadPoolExecutor的底层构造函数有七种参数，而线程池的创建却只有5个？剩下的那两个参数是什么？有什么作用？</h5><p>答：</p>
<ul>
<li><p>在线程池的创建当中使用的参数是前五个，剩下的那两个参数：</p>
</li>
<li><p>一个是生成线程池当中的线程的线程工厂，一般用默认的线程工厂进行工作线程的创建，因此提取出来在底层进行赋值，</p>
</li>
<li><p>最后一个参数是拒绝策略，作用是当队列满了并且工作线程大于等于线程池的最大线程数，当有新的任务到来时采用的策略。以上三个线程池的拒绝策略都是一样的——丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息（线程池默认的拒绝策略）。因此也提取出来在底层进行赋值。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929015055562.png" alt="image-20210929015055562"></p>
</li>
</ul>
<h4 id="4、说说线程池的底层工作原理？"><a href="#4、说说线程池的底层工作原理？" class="headerlink" title="4、说说线程池的底层工作原理？"></a>4、说说线程池的底层工作原理？</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929014307611.png" alt="image-20210929014307611"></p>
<ol>
<li><p>在创建了线程池后，线程池中的线程数为零，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p>
</li>
<li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断：</p>
<ol>
<li> 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li> 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入workQueue 队列； </li>
<li> 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务（救急）； </li>
<li> 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
<ol>
<li> 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</li>
<li> 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
</li>
</ol>
<h3 id="9、线程池用过吗？生产上你是如何设置合理参数？"><a href="#9、线程池用过吗？生产上你是如何设置合理参数？" class="headerlink" title="9、线程池用过吗？生产上你是如何设置合理参数？"></a>9、线程池用过吗？生产上你是如何设置合理参数？</h3><h4 id="1、线程池的拒绝策略你谈谈？JDK内置的拒绝策略有哪些？"><a href="#1、线程池的拒绝策略你谈谈？JDK内置的拒绝策略有哪些？" class="headerlink" title="1、线程池的拒绝策略你谈谈？JDK内置的拒绝策略有哪些？"></a>1、线程池的拒绝策略你谈谈？JDK内置的拒绝策略有哪些？</h4><p>答：</p>
<p>线程池中，有三个重要的参数，决定影响了拒绝策略：<code>corePoolSize</code> - 核心线程数，也即最小的线程数。<code>workQueue</code> - 阻塞队列 。 <code>maximumPoolSize</code> -最大线程数。</p>
<p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>
<p>总结起来，也就是一句话，当提交的任务数大于（workQueue.size() + maximumPoolSize ），就会触发线程池的拒绝策略。</p>
<p>四种拒绝策略：</p>
<ul>
<li><code>CallerRunsPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大；</li>
<li><code>AbortPolicy</code>：丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。<strong>线程池默认的拒绝策略</strong>。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</li>
<li><code>DiscardPolicy</code>：直接丢弃，其他啥都没有；</li>
<li><code>DiscardOldestPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入 </li>
</ul>
<p>除了线程池给的四种拒绝策略的实现，其他著名框架也提供了拒绝策略实现：</p>
<ul>
<li><code>Dubbo</code> 的实现：在抛出 <code>RejectedExecutionException</code> 异常之前<strong>会记录日志</strong>，并 <strong>dump 线程栈信息</strong>，<strong>方便定位问题</strong></li>
<li><code>Netty</code> 的实现：<strong>创建一个新线程来执行任务</strong></li>
<li><code>ActiveMQ</code> 的实现：<strong>带超时等待（60s）尝试放入队列</strong>，类似我们之前自定义的拒绝策略</li>
<li><code>PinPoint</code> 的实现：它使用了一个<strong>拒绝策略链</strong>，会<strong>逐一尝试策略链中每种拒绝策略</strong></li>
</ul>
<blockquote>
<p>以上内置拒绝策略<strong>均实现了RejectedExecutionHandler接口（函数式接口）</strong>。</p>
</blockquote>
<h4 id="2、你在工作中单一的-固定数的-可变的单重创建线程池的方法，你用哪个多？"><a href="#2、你在工作中单一的-固定数的-可变的单重创建线程池的方法，你用哪个多？" class="headerlink" title="2、你在工作中单一的/固定数的/可变的单重创建线程池的方法，你用哪个多？"></a>2、你在工作中单一的/固定数的/可变的单重创建线程池的方法，你用哪个多？</h4><p>答：一个都不用，我们生产上只能使用自定义的</p>
<p>Executors中JDK已经给你提供了，为什么不用？</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929015024492.png" alt="image-20210929015024492"></p>
<h4 id="3、合理配置线程池你是如何考虑的？"><a href="#3、合理配置线程池你是如何考虑的？" class="headerlink" title="3、合理配置线程池你是如何考虑的？"></a>3、合理配置线程池你是如何考虑的？</h4><ul>
<li>CPU密集型<ul>
<li>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。</li>
<li>CPU密集型任务配置尽可能少的线程数量：一般公式为：<strong>CPU核数+1个线程的线程的线程池</strong>。</li>
</ul>
</li>
<li>IO密集型<ol>
<li>第一种：由于IO密集型任务线程并不是一直执行任务，则应配置尽可能多的线程，如*<em>CPU核数 * 2*</em></li>
<li>第二种：IO密集型，即该任务需要大量的IO，即大量的阻塞。<ul>
<li>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。</li>
<li>所以IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</li>
<li>IO密集型时，大部分线程都阻塞，故需要多配置线程数：<strong>参考公式：CPU核数/1-阻塞系数 阻塞系数在0.8-0.9之间。</strong>(一般乐观就设置为0.9)</li>
</ul>
</li>
</ol>
</li>
<li>混合型<ul>
<li>CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li>
</ul>
</li>
</ul>
<h3 id="10、死锁编程及定位分析"><a href="#10、死锁编程及定位分析" class="headerlink" title="10、死锁编程及定位分析"></a>10、死锁编程及定位分析</h3><p>答：</p>
<ul>
<li>死锁是指两个或者两个以上的进程在执行过程中，因抢夺资源而造成的一种<strong>互相等待的现象</strong>，若无外力干涉它们将都无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性也就很低，否则就会因争夺有限的资源而陷入死锁。</li>
<li>产生死锁的主要原因：<ol>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ol>
</li>
<li>解决<ul>
<li>jps命令定位进程号</li>
<li>jstack找到死锁查看</li>
<li>在服务器上可以用jatack 拉取出项目的内存日志 看线程的情况 可以看出死锁</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929020401653.png" alt="image-20210929020401653"></p>
<h3 id="11、Java里面锁请谈谈你的理解，能说多少说多少"><a href="#11、Java里面锁请谈谈你的理解，能说多少说多少" class="headerlink" title="11、Java里面锁请谈谈你的理解，能说多少说多少"></a>11、Java里面锁请谈谈你的理解，能说多少说多少</h3><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/7f749fc8.png" alt="img"></p>
<ul>
<li><p>公平锁与非公平锁</p>
<ul>
<li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。<ul>
<li>优点：所有的线程都能得到资源，不会饿死在队列中。</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
</li>
<li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
</li>
</ul>
</li>
<li><p>可重入锁与不可重入锁</p>
<ul>
<li><strong>可重入锁</strong>：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<ul>
<li><strong>synchronized的重入的实现机理：</strong><ul>
<li>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</li>
<li>当执行monitorenter时，如果目标对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</li>
<li>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</li>
<li>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li>
</ul>
</li>
</ul>
</li>
<li><strong>不可重入锁</strong>：如果是不可重入锁的话，第一个锁没有解锁就不能操作第二个锁的内容</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>两个或多个进程在运行过程中，因争夺资源而造成的一种相互等待的现象，当进程处于这种相互等待的状态时，若无外力作用，它们都将无法再向前推进。</li>
</ul>
</li>
<li><p>活锁</p>
<ul>
<li>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束</li>
</ul>
</li>
<li><p>乐观锁与悲观锁</p>
<ul>
<li><strong>悲观锁</strong>：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</li>
<li>悲观锁主要分为<strong>共享锁</strong>和<strong>排他锁</strong>：<ul>
<li><strong>共享锁</strong>【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li><strong>排他锁</strong>【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。</li>
</ul>
</li>
<li><strong>乐观锁</strong>：不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现有CAS与版本号控制这两种方式</li>
</ul>
</li>
<li><p>自旋锁与自适应自旋锁</p>
<ul>
<li>自旋锁：<strong>在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但==不放弃CPU的执行时间==。等待持有锁的线程是否很快就会释放锁</strong>。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</li>
<li><strong>自适应自旋锁：自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</strong>。</li>
</ul>
</li>
<li><p>无锁、偏向锁、轻量级锁与重量级锁</p>
<ul>
<li><strong>无锁</strong><ul>
<li>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</li>
<li>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</li>
</ul>
</li>
<li><strong>偏向锁</strong><ul>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</li>
<li>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</li>
<li>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</li>
<li>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</li>
<li>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</li>
</ul>
</li>
<li><strong>轻量级锁</strong><ul>
<li>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</li>
<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</li>
<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</li>
<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</li>
<li>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</li>
<li>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</li>
</ul>
</li>
<li><strong>重量级锁</strong><ul>
<li>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>饥饿问题</p>
<ul>
<li>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</li>
</ul>
</li>
<li><p>表锁与行锁</p>
<ul>
<li><p>表锁：当一个线程在给一张表进行数据操作的时候，会将整一张表都锁起来。在它操作完成之前，其他线程不能对这张表的所有数据进行操作。</p>
<ul>
<li><p>表锁：意向锁</p>
<ul>
<li><p>表锁，其实也可以叫意向锁，表明“某个事务正在某些行持有了锁、或该事务准备去持有锁”。</p>
</li>
<li><p>意向锁产生的主要目的是<strong>为了处理行锁和表锁之间的冲突</strong>：</p>
<ul>
<li>事务在请求S锁和X锁前，需要先获得对应的IS、IX锁，</li>
<li>在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</li>
<li>意向共享锁（IS锁）：事务在请求S锁前，要先获得IS锁</li>
<li>意向排他锁（IX锁）：事务在请求X锁前，要先获得IX锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁：一个线程在对一张表的某一行数据进行操作的时候，会将那一行数据锁起来，在它操作完成之前，其他线程不能对这一行数据进行操作，但是对原这张表的其他行数据进行操作是允许的。</p>
<ul>
<li>行锁：记录锁(Record Locks)<ul>
<li>mysql的行锁是<strong>通过索引加载的</strong>，即<strong>行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描</strong>.</li>
</ul>
</li>
<li>行锁：间隙锁(Gap Locks)<ul>
<li><strong>区间锁，仅仅锁住一个索引区间（开区间，不包括双端端点）</strong>。</li>
<li><strong>在索引记录之间的间隙中加锁</strong>，或者是<strong>在某一条索引记录之前或者之后加锁，==并不包括该索引记录本==身</strong>。比如在 1、2、3中，间隙锁的可能值有 (∞, 1)，(1, 2)，(2, ∞)，</li>
<li><strong>间隙锁可用于防止幻读，保证索引间的不会被插入数据</strong></li>
</ul>
</li>
<li>行锁：临键锁(Next-Key Locks)<ul>
<li><strong>record lock + gap lock，左开右闭区间。</strong></li>
<li><strong>默认情况下，innodb使用next-key locks来锁定记录。</strong></li>
<li><strong>但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</strong></li>
<li>Next-Key Lock在不同的场景中会退化成记录锁或间隙锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>关于锁的优化：</p>
<ul>
<li>锁消除<ul>
<li>锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。<strong>锁消除的主要判定依据来源于逃逸分析的数据支持</strong>。</li>
<li>意思就是：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</li>
<li>当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。(eg：StringBuffer到StringBulider的转换)</li>
</ul>
</li>
<li>锁粗化<ul>
<li>如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展(粗化)到整个一系列操作的外部，使整个一连串地append()操作只需要加锁一次就可以了。</li>
</ul>
</li>
<li>锁升级/锁膨胀<ul>
<li>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</li>
<li><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/8afdf6f2.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="12、关于LockSupport的面试题"><a href="#12、关于LockSupport的面试题" class="headerlink" title="12、关于LockSupport的面试题"></a>12、关于LockSupport的面试题</h3><h4 id="1、为什么可以先唤醒线程后阻塞线程？"><a href="#1、为什么可以先唤醒线程后阻塞线程？" class="headerlink" title="1、为什么可以先唤醒线程后阻塞线程？"></a>1、为什么可以先唤醒线程后阻塞线程？</h4><p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞</p>
<h4 id="2、为什么唤醒两个后阻塞两次。但是最终结果还会阻塞线程？"><a href="#2、为什么唤醒两个后阻塞两次。但是最终结果还会阻塞线程？" class="headerlink" title="2、为什么唤醒两个后阻塞两次。但是最终结果还会阻塞线程？"></a>2、为什么唤醒两个后阻塞两次。但是最终结果还会阻塞线程？</h4><p>因为凭证的数量最多为1，连续调用两个unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，凭证不够，故会阻塞。</p>
<h3 id="13、关于AQS"><a href="#13、关于AQS" class="headerlink" title="13、关于AQS"></a>13、关于AQS</h3><h4 id="1、AQS-是什么"><a href="#1、AQS-是什么" class="headerlink" title="1、AQS 是什么"></a>1、AQS 是什么</h4><p><strong>字面意思</strong>：AQS（AbstractQueuedSynchronizer）：抽象的队列同步器</p>
<blockquote>
<p>一般我们说的 AQS 指的是 java.util.concurrent.locks 包下的 AbstractQueuedSynchronizer，但其实还有另外三种抽象队列同步器：AbstractOwnableSynchronizer、AbstractQueuedLongSynchronizer 和 AbstractQueuedSynchronizer</p>
</blockquote>
<p><strong>技术翻译</strong>：AQS 是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石， 通过<strong>内置的FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个<strong>int类变量（state）表示持有锁的状态</strong></p>
<blockquote>
<p>CLH：Craig、Landin and Hagersten 队列，是一个双向链表，AQS中的队列是CLH变体的虚拟FIFO双向队列</p>
</blockquote>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/90f4132ca8188e1af37bed13615a8b37.png" alt="image-20201227165645081"></p>
<h4 id="2、AQS-是-JUC-的基石"><a href="#2、AQS-是-JUC-的基石" class="headerlink" title="2、AQS 是 JUC 的基石"></a>2、AQS 是 JUC 的基石</h4><p><strong>和AQS有关的并发编程类</strong>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/d78b62f55bf63f6240b8e9be41494029.png" alt="image-20201227165833625"></p>
<p><strong>进一步理解锁和同步器的关系</strong>：</p>
<ul>
<li><code>锁</code>：<strong>面向锁的使用者</strong>。定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可，可以理解为用户层面的 API。</li>
<li><code>同步器</code>：<strong>面向锁的实现者</strong>。比如Java并发大神Douglee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等，Java 中有那么多的锁，就能简化锁的实现。</li>
</ul>
<h4 id="3、AQS-能干嘛"><a href="#3、AQS-能干嘛" class="headerlink" title="3、AQS 能干嘛"></a>3、AQS 能干嘛</h4><p><strong>AQS：加锁会导致阻塞</strong></p>
<p>有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理</p>
<p>抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种排队等候机制，抢占资源失败的线程继续去等待（类似办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候），仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p>
<p>既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？<strong>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的</strong>，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。<strong>它将请求共享资源的线程封装成队列的结点（Node） ，通过CAS、自旋以及LockSuport.park()的方式，维护state变量的状态，使并发达到同步的效果</strong>。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/90f4132ca8188e1af37bed13615a8b37.png" alt="image-20201227165645081"></p>
<h4 id="4、AQS-初步认识"><a href="#4、AQS-初步认识" class="headerlink" title="4、AQS 初步认识"></a>4、AQS 初步认识</h4><h5 id="1、AQS初识"><a href="#1、AQS初识" class="headerlink" title="1、AQS初识"></a>1、AQS初识</h5><p>官网解释：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/dfb1ef1312d571b596bb378a20265d67.png" alt="image-20201227171157475"></p>
<p>有阻塞就需要排队，实现排队必然需要队列：</p>
<ol>
<li><strong>AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的 FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成 一个Node节点来实现锁的分配，通过CAS完成对State值的修改</strong>。</li>
<li>Node 节点是啥？<ul>
<li>答：你有见过 HashMap 的 Node 节点吗？JDK 用 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 来封装我们传入的 KV 键值对。</li>
<li>这里也是一样的道理，JDK 使用 Node 来封装（管理）Thread</li>
</ul>
</li>
<li>可以将 Node 和 Thread 类比于候客区的椅子和等待用餐的顾客</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/c4cbe27c2615bbe033144019d3142dfb.png" alt="image-20201227171739495"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211006145617321.png" alt="image-20211006145617321"></p>
<h5 id="2、AQS内部体系架构"><a href="#2、AQS内部体系架构" class="headerlink" title="2、AQS内部体系架构"></a>2、AQS内部体系架构</h5><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/10a24b1847439613cd2a7215553142b1.png" alt="image-20201227182248032"></p>
<ul>
<li><p>AQS的int变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>AQS的同步状态State成员变量，类似于银行办理业务的受理窗口状态：零就是没人，自由状态可以办理；大于等于1，有人占用窗口，需要等待</p>
</li>
<li><p>AQS的CLH队列</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5105058dbcfd3dc94f40d560f1070432.png" alt="image-20201227180550246"></p>
<p>CLH队列（三个大牛的名字组成），原是一个双向链表，被AQS修改为一个双向队列，类似于银行侯客区的等待顾客</p>
</li>
<li><p>内部类Node（Node类在AQS类内部）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment"> *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment"> *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment"> *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment"> *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment"> *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment"> *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment"> *               on failure, block.</span></span><br><span class="line"><span class="comment"> *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment"> *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment"> *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment"> *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment"> *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment"> *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment"> *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment"> *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment"> *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment"> *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment"> *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment"> *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment"> *               continues, even if other operations have</span></span><br><span class="line"><span class="comment"> *               since intervened.</span></span><br><span class="line"><span class="comment"> *   0:          None of the above</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment"> * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment"> * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment"> * values, just for sign.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment"> * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment"> * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure>

<p>Node的等待状态waitState成员变量，类似于等候区其它顾客(其它线程)的等待状态，队列中每个排队的个体就是一个Node</p>
<p>Node类的内部结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//独占</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程被取消了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后继线程需要唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待condition唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始为e，状态是上面的几种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><p>有阻塞就需要排队，实现排队必然需要队列</p>
<ul>
<li>AQS就是通过state 变量 + CLH双端 Node 队列（头尾指针）实现</li>
<li>Node就是通过waitStatus + 前后指针 实现</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/b2cce18d2b747938c3ed826e35b88bfa.png" alt="image-20201227181324215"></p>
<p>Node当中的属性说明：</p>
<p>两种模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHARED</td>
<td>表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td>EXCLUSIVE</td>
<td>表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>六个属性：</p>
<table>
<thead>
<tr>
<th>方法和属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>waitStatus</td>
<td>当前节点在队列当中的状态</td>
</tr>
<tr>
<td>thread</td>
<td>表示处于该节点的线程</td>
</tr>
<tr>
<td>prev</td>
<td>前驱指针</td>
</tr>
<tr>
<td>next</td>
<td>后继指针</td>
</tr>
<tr>
<td>predecessor</td>
<td>返回前驱节点，没有的话抛npe</td>
</tr>
<tr>
<td>nextWaiter</td>
<td>指向下一个处于CONDITION状态的节点</td>
</tr>
</tbody></table>
<p>waitStatus的五种取值：</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td>CANCELLED</td>
<td>为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td>CONDITION</td>
<td>为-2，表示节点在等待队列当中，节点线程等待唤醒</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>为-3，当前线程处于SHARED情况下，该字段才会使用。共享式同步状态获取将会无条件地传播下去</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<h5 id="4、AQS底层是怎么排队的？"><a href="#4、AQS底层是怎么排队的？" class="headerlink" title="4、AQS底层是怎么排队的？"></a>4、AQS底层是怎么排队的？</h5><p>通过调用 <code>LockSupport.pork()</code> 来进行排队</p>
<h4 id="5、AQS的源码解读（通过ReentrantLock为突破口）"><a href="#5、AQS的源码解读（通过ReentrantLock为突破口）" class="headerlink" title="5、AQS的源码解读（通过ReentrantLock为突破口）"></a>5、AQS的源码解读（通过ReentrantLock为突破口）</h4><h5 id="1、加锁"><a href="#1、加锁" class="headerlink" title="1、加锁"></a>1、加锁</h5><p>只要涉及到加锁，底层会调用NonfairSync的lock()方法来进行加锁。（以ReentrantLock的非公平锁为例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果当前资源锁的状态为0，则表示当前没有线程占有锁</li>
<li>使用CAS将锁状态从0设置为1，并将当前线程设置为占有此锁</li>
<li>CAS设置失败表示当前已经有线程占用该锁，进入acquire()方法</li>
</ol>
<p>而AQS的acquire()方法是一个模板方法，如果子类没有重写该方法就会抛出异常。</p>
<p>而子类的重写肯定会调用如下三个方法进行锁的抢夺与线程阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>tryAcquire()：试图获取锁</p>
<ol>
<li><p>首先再次获取当前资源的锁的状态——因为此时可能出现此时占用锁的线程已经释放锁的情况</p>
<ol>
<li>如果当前资源锁的状态为0，则表示当前没有线程占有锁——证明之前占用锁的线程已经释放了锁</li>
<li>使用CAS将锁状态从0设置为1，并将当前线程设置为占有此锁</li>
<li>返回true，由于前面的<code>!</code>取反之后为false，退出if块</li>
</ol>
</li>
<li><p>如果当前锁的状态不等于0，表示当前有线程占有锁，则判断当前占用锁的线程是不是当前线程</p>
<ol>
<li>如果是当前线程，表示此时正是锁的重入</li>
<li>增加重入的次数，并将其设置进锁的状态status当中</li>
<li>返回true，由于前面的<code>!</code>取反之后为false，退出if块</li>
</ol>
</li>
<li><p>如果不是以上两种情况，返回false。由于前面的<code>!</code>取反之后为true，继续执行addWaiter()方法。</p>
<blockquote>
<p>注：公平锁与非公平锁的区别就是在第一个if判断中：公平锁的最前面有!hasQueuePredecessors()方法判断当前的CLH等待队列中是否有等待的线程，而非公平锁没有该方法。</p>
<p>hasQueuePredecessors()方法如何能体现公平锁与非公平锁的区别？</p>
<ul>
<li>当一个新的线程来抢占锁，如果当前的CLH等待队列中有等待的线程，那么直接返回true，在<code>!</code>取反为false直接退出if块，不进行之后锁的CAS抢占。tryAcquire()方法直接返回false</li>
<li>之后由addWaiter()方法添加进CLH等待队列——体现了公平</li>
<li>如果没有hasQueuePredecessors()方法，那么新来的线程会与等待队列中头结点的下一个线程（正在被唤醒的线程）一同争抢锁</li>
<li>当前等待队列中头结点的下一个线程有可能争抢失败继续进入等待队列的最尾部继续等待唤醒，有可能导致饥饿现象——体现了非公平</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>addWaiter()：将当前线程封装成一个节点Node加入CLH等待队列</p>
<ol>
<li>将当前的线程包装成一个节点Node，此时Node的属性为<ul>
<li>Thread：当前线程</li>
<li>mode：Node.EXCLUSIVE（独占模式）</li>
<li>waitStatus：0</li>
<li>prev/next：null</li>
</ul>
</li>
<li>CLH等待队列的尾节点赋值pred——一开始肯定为null，后面为tail指向的节点</li>
<li>判断尾结点是否为null——一开始肯定为null，不进入if块，执行下面的enq(node)入队方法<ol>
<li>不为null的话，将当前节点（也就是线程的节点）的prev指针指向尾节点</li>
<li>使用CAS将CLH等待队列的尾节点从尾节点指向当前节点（线程节点）</li>
<li>将尾节点的next指针指向当前节点（线程节点）</li>
<li>返回当前节点（线程节点）——此时当前节点（线程节点）的属性<ul>
<li>Thread：当前线程</li>
<li>mode：Node.EXCLUSIVE（独占模式）</li>
<li>waitStatus：0</li>
<li>prev：尾节点</li>
<li>next：null</li>
</ul>
</li>
</ol>
</li>
<li>如果尾节点为null的话，进入enq(node)入队方法：enq(node)方法是一个自旋锁for(;;)<ol>
<li>CLH等待队列的尾节点赋值t</li>
<li>如果当前尾结点为null的话，就要进行一些初始化操作——一开始肯定为null<ul>
<li>使用CAS创建一个哨兵节点（空节点），并且将CLH等待队列的头结点与尾结点都指向该哨兵节点</li>
<li>结束f块继续进入自旋</li>
</ul>
</li>
<li>如果当前尾结点不为null的话——初始化操作之后的尾结点就不为null了<ol start="4">
<li>将当前节点当前节点（线程节点）的prev指向尾节点</li>
<li>使用CAS将CLH等待队列的尾节点从尾节点指向当前节点（线程节点）</li>
<li>将尾节点的next指针指向当前节点（线程节点）</li>
</ol>
</li>
</ol>
</li>
<li>返回尾结点</li>
</ol>
<blockquote>
<p>注：</p>
<ul>
<li>第一个进入CLH等待队列的线程执行路线：1 ==》 2 ==》 4 ==》 5</li>
<li>后面进入CLH等待队列的线程执行路线：1 ==》 2 ==》 3</li>
</ul>
</blockquote>
</li>
<li><p>acquireQueued(final Node node, int arg)：将当前节点的前驱节点的waitStatus状态修改为SINGAL(-1)——acquireQueued)方法也是一个自旋锁for(;;)</p>
<ul>
<li><p>设置一个失败的标志变量failed为true，目的是为了下面finally块当中线程的取消做准备</p>
</li>
<li><p>try块</p>
<ol>
<li><p>设置一个中断的标志变量interrupted为false</p>
</li>
<li><p>自旋：</p>
<ol>
<li><p>获取当前节点（线程节点）的前驱节点</p>
</li>
<li><p>如果当前节点（线程节点）的前驱节点为头结点并且当前节点（线程节点）试图获取锁成功——当前节点（线程节点）依旧没有放弃获取锁（或者被唤醒之后试图获取锁），注意此时是头结点的下一个线程结点</p>
<ol>
<li>将当前节点（线程节点）设置为CLH等待队列的头结点——此时的当前节点（线程节点）已经抢到了锁</li>
<li>将前哨兵节点的next指向null——此时的前哨兵节点就没有任何的引用指向，慢慢地就会被GC回收掉，此时的当前节点（线程节点）的就是最新的哨兵节点</li>
<li>将失败的标志变量failed修改为false</li>
<li>返回中断的标志变量interrupted为false</li>
</ol>
</li>
<li><p>判断当前节点试图获取锁失败之后是否应该被park挂起shouldParkAfterFailedAcquire(p, node)方法——别忘了acquireQueued方法是一个自旋方法，即shouldParkAfterFailedAcquire(p, node)方法会被多次执行直至线程被挂起或者抢到锁</p>
<ol>
<li>获取前驱节点的waitStatus</li>
<li>如果前驱节点的waitStatus是SINGAL（-1）——负责唤醒它的下一个线程，返回true</li>
<li>如果前驱节点的waitStatus大于0，即CANCELLED（1）——表示前驱节点要被取消了<ol>
<li>使用自旋锁的方式当前节点的prev节点修改为前驱节点的prev</li>
<li>前驱节点的前驱节点的next指向当前节点</li>
<li>返回false</li>
</ol>
</li>
<li>否则，使用CAS将前驱节点的waitStatus从ws修改为SINGAL</li>
<li>返回false</li>
</ol>
<blockquote>
<p>返回false之后继续进行acquireQueued方法的自旋，继续试图去抢夺锁，失败之后继续进入shouldParkAfterFailedAcquire()方法</p>
<p>此时前驱节点的waitStatus为SINGAL（-1），返回true。继续执行parkCheckInterrupt()方法</p>
</blockquote>
</li>
<li><p>执行parkCheckInterrupt()方法将线程进行park挂起</p>
<ol>
<li>调用LockSupport的park方法将当前线程挂起，等待抢占锁的节点的unpark进行唤醒</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>finally块</p>
<ol>
<li>如果失败的标志变量failed为true<ol>
<li>取消当前节点</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>以上6个方法的相关源码：</p>
<p>tryAcquire()：试图获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前CLH等待队列的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果状态为0，表示当前没有人抢占锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用CAS抢占锁，修改状态值从0到acquires</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置当前的锁为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程是当前锁的线程——可重入锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 将当前状态设置为可重入的次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前的CLH等待队列有没有线程等待</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addWaiter()：将当前线程封装成一个节点Node加入CLH等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成一个Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 将CLH等待队列的尾节点赋值给pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果当前CLH尾节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的前节点prev指向CLH队列的尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS将当前CLH尾节点从pred设置为当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// pred的next指向当前节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 返回当前节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建CLH等待队列，将当前节点加入CLH等待队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">// 返回当前节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq()：构建CLH等待队列，将当前节点加入CLH等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将CLH等待队列的尾节点赋值给t</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果当前CLH等待队列的尾节点为null，进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 使用CAS将CLH等待队列的头节点指向一个哨兵节点——空节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 将CLH等待队列的头节点指向尾节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前CLH等待队列的尾节点不为null</span></span><br><span class="line">            <span class="comment">// 将当前节点的prev指向尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 使用CAS将当前CLH等待队列的尾节点从t指向当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 将t的next节点指向当前节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="comment">// 返回CLH等待队列的尾节点</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued(final Node node, int arg)：将当前节点的前驱节点的waitStatus状态修改为SINGAL(-1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个失败的标志变量failed为true，目的是为了下面finally块当中线程的取消做准备</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置一个中断的标志变量interrupted为false</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点为头节点，并且当前节点抢夺锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为CLH等待队列的头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将前驱节点（此时为头节点，即哨兵节点）的next指向null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC，此时的哨兵节点就没有任何的引用指向，慢慢地就会被GC回收掉。而当前节点就变成了新的哨兵节点</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点在获取锁失败之后是否应该挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 挂起当前节点线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 取消当前线程</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire(p, node)：判断当前节点在获取锁失败之后是否应该挂起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱节点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱节点的waitStatus为SNGAL</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 返回true，执行parkAndCheckInterrupt()挂起线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前驱节点的waitStatus大于0，即CANCELLED取消当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 自旋将当前节点的prev节点指向取消节点的前一个节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取消节点的前一个节点的next指向当前节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// CAS将前驱节点的waitStatus从ws设置为SINGAL(-1)</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false，进行执行shouldParkAfterFailedAcquire()方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parkAndCheckInterrupt()：挂起线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用LockSupport的park方法将线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/0cc1c6dc17e11c0eb76c2f24b14a4683.png" alt="image-20210121204517530"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/df751e0935dd3a3dc18d447ea434c9a3.png" alt="image-20210121204530559"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/92128bc9be81f4c38c52cb9a1a5390ac.png" alt="image-20210121212502988"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211006234534626.png" alt="image-20211006234534626"></p>
<h5 id="2、解锁"><a href="#2、解锁" class="headerlink" title="2、解锁"></a>2、解锁</h5><p>ReentrantLock调用unLock进行解锁，<code>unlock()</code> 方法底层调用了 <code>sync.release(1)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 试图释放锁，成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 将CLH等待队列的头节点赋值给h</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果不为null并且哨兵节点的waitStatus不为0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒CLH等待队列哨兵节点之后的第一个线程节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上主要是两个方法：</p>
<ul>
<li>tryRelease()：试图释放锁</li>
<li>unparkSuccessor()：唤醒CLH等待队列哨兵节点之后的第一个线程节点</li>
</ul>
<p>tryRelease()：试图释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前的状态减去释放的锁得到c</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前释放锁的线程是否是占用锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 释放是否成功的标志变量</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果c等于0，代表锁应经释放结束</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 将锁的占用情况设置为null，即没有线程占用该锁</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将c设置为当前的状态</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 返回锁是否释放成功</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unparkSuccessor()：唤醒CLH等待队列哨兵节点之后的第一个线程节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取当前节点（此时为头节点）的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果当前节点（此时为头节点）的waitStatus小于0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 使用CAS将当前节点的waitStatus设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前节点（头节点）的下一个结点（即将被唤醒的节点）</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果s为null或者s的waitStatus为0，即CANCELLED取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将s赋值为null</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从CLH等等队列的尾到头进行遍历，查找符合waitStatus小于等于0的节点，将它赋值给s</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果s不为null</span></span><br><span class="line">    <span class="comment">// 如果当前节点（头节点）的下一个结点不为null并且waitStatus不为CANCELLED的话 </span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 调用LockSupport的unpark对s进行唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007000856860.png" alt="image-20211007000856860"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007001005389.png" alt="image-20211007001005389"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211007001033334.png" alt="image-20211007001033334"></p>
<h5 id="3、AQS-的面试考点"><a href="#3、AQS-的面试考点" class="headerlink" title="3、AQS 的面试考点"></a>3、AQS 的面试考点</h5><p><strong>第一个考点</strong>：我相信你应该看过源码了，那么AQS里面有个变量叫State，它的值有几种？</p>
<p><strong>答</strong>：3个状态：没占用是0，占用了是1，大于1是可重入锁</p>
<p><strong>第二个考点</strong>：如果锁正在被占用，AB两个线程进来了以后，请问这个时候CLH等待队列当中总共有多少个Node节点？</p>
<p><strong>答</strong>：答案是3个，分别是哨兵节点、nodeA、nodeB</p>
<p><strong>第三个考点</strong>：在占有锁的线程释放锁的过程中，此时CLH等待队列中的头节点的下一个节点被取消了，此时占有锁的线程唤醒的是CLH队列当中的哪一个挂起线程？</p>
<p>答：唤醒的是CLH等待队列当中从尾到头数的第一个符合唤醒条件的线程。唤醒条件：</p>
<ul>
<li>线程不为空</li>
<li>线程的waitStatus小于等于0</li>
</ul>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1、JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，它们的算法是什么"><a href="#1、JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，它们的算法是什么" class="headerlink" title="1、JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，它们的算法是什么"></a>1、JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，它们的算法是什么</h3><p>GC发生在JVM哪部分？有几种GC？</p>
<ul>
<li>GC发生在堆与方法区中</li>
<li>次数上频繁收集Young区（新生代）——Minor GC</li>
<li>次数上较少收集Old区（老年代）——Major GC</li>
<li>基本不动Perm方法区</li>
</ul>
<blockquote>
<p>关于 Full GC 与 major GC 的区别</p>
<ul>
<li>部分收集（Partial GC）：指目标不是完整收集整个java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。<ul>
<li>注意：”Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集</li>
</ul>
</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集</li>
</ul>
</blockquote>
<p>垃圾收集的算法是什么</p>
<ol>
<li>引用计数法<ul>
<li>计数该对象有多少个引用，如果计数的值不为0，则代表该对象存在引用，不对它进行垃圾回收</li>
<li>这种方法存在循环引用问题，JVM没有采用该方法</li>
</ul>
</li>
<li>复制算法（Copying）<ul>
<li>该算法常在JVM回收新生代Young GC使用</li>
<li>从跟集合（GC Root）开始，通过可达性分析算法Tracing从From中找到存活对象，拷贝到To区中；</li>
<li>之后From、To区交换身份下次内存分配依旧是从From区开始</li>
<li>优点：<ul>
<li>没有标记和清除的过程，效率高</li>
<li>没有内存碎片，可以利用bump-the-pointer（碰撞指针）实现快速分配内存</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要双倍的空间</li>
</ul>
</li>
</ul>
</li>
<li>标记清除算法（Mark-Sweep）<ul>
<li>标记（Mark）：<ul>
<li>从根集合（GC Root）开始扫描，对存活的对象进行标记</li>
</ul>
</li>
<li>清除（Sweep）：<ul>
<li>扫描整个内存空间，回收未被标记的对象，使用free-list记录可用区域</li>
</ul>
</li>
<li>优点：<ul>
<li>不需要额外的空间</li>
</ul>
</li>
<li>缺点：<ul>
<li>两次扫描，耗时严重</li>
<li>会产生内存碎片</li>
</ul>
</li>
</ul>
</li>
<li>标记压缩算法（Mark-Compact）：<ul>
<li>标记（Mark）：<ul>
<li>从根集合（GC Root）开始扫描，对存活的对象进行标记</li>
</ul>
</li>
<li>压缩（Compact）：<ul>
<li>再次扫描，并往一端滑动存活对象</li>
<li>在整理压缩阶段，不在对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接消除边界以外的内存</li>
</ul>
</li>
<li>优点：<ul>
<li>没有内存碎片，可以利用bump-the-pointer（碰撞指针）实现快速分配内存</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要移动对象的成本</li>
</ul>
</li>
</ul>
</li>
<li>标记清除压缩算法（Mark-Sweep-Compact）：<ul>
<li>老年代一般都是使用由标记清除或者是标记清除与标记整理的混合实现进行垃圾回收</li>
<li>就是将以上的标记清除算法和标记压缩算法混合实现</li>
</ul>
</li>
</ol>
<h3 id="2、JVM内存结构"><a href="#2、JVM内存结构" class="headerlink" title="2、JVM内存结构"></a>2、JVM内存结构</h3><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929154440600.png" alt="image-20210929154440600"></p>
<h3 id="3、关于类加载子系统常问的问题"><a href="#3、关于类加载子系统常问的问题" class="headerlink" title="3、关于类加载子系统常问的问题"></a>3、关于类加载子系统常问的问题</h3><h4 id="1、类加载器有哪些？"><a href="#1、类加载器有哪些？" class="headerlink" title="1、类加载器有哪些？"></a>1、类加载器有哪些？</h4><ol>
<li><p>JVM支持<strong>两种类型的类加载器</strong>，分别为<strong>引导类加载器( Bootstrap ClassLoader)**和</strong>自定义类加载器(User-Defined ClassLoader)** 。</p>
<ol>
<li><p>引导类加载器( Bootstrap ClassLoader)：</p>
<ul>
<li>本身不是使用java语言编写，而是使用C与C++进行编写</li>
</ul>
</li>
<li><p>自定义类加载器(User-Defined ClassLoader)</p>
<ul>
<li><p>使用java语言编写</p>
</li>
<li><p><strong>派生于抽象类ClassLoader</strong>。所以扩展类加载器（Extinction Class Loader）与系统类加载器（System Class Loader）都属于自定义类加载器</p>
<p>其中sun.misc.Launcher它是一个java虚拟机的入口应用</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929154740187.png" alt="image-20210929154740187"></p>
<p>这里的四者之间的关系是<strong>包含关系</strong>。不是上层下层，也不是子父类的继承关系。</p>
<p>对于引导类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）与系统类加载器（System Class Loader）三者的关系：</p>
<ul>
<li>系统类加载器（System Class Loader）的上层就是扩展类加载器（Extension Class Loader）：对于用户自定义类来说：默认使用系统类加载器进行加载</li>
<li>扩展类加载器（Extension Class Loader）的上层是引导类加载器（Bootstrap Class Loader）</li>
<li>引导类加载器（Bootstrap Class Loader）是最高层的类加载器：<strong>Java的核心类库</strong>都是使用引导类加载器进行加载的。并且我们获取不到引导类加载器。因为引导类加载器并不是所以java语言进行编写的。</li>
</ul>
<h4 id="2、双亲委派机制"><a href="#2、双亲委派机制" class="headerlink" title="2、双亲委派机制"></a>2、双亲委派机制</h4><h4 id="3、沙箱安全机制"><a href="#3、沙箱安全机制" class="headerlink" title="3、沙箱安全机制"></a>3、沙箱安全机制</h4><h3 id="4、GC-Roots的作用域"><a href="#4、GC-Roots的作用域" class="headerlink" title="4、GC Roots的作用域"></a>4、GC Roots的作用域</h3><h4 id="1、什么是垃圾"><a href="#1、什么是垃圾" class="headerlink" title="1、什么是垃圾"></a>1、什么是垃圾</h4><ul>
<li>内存中已经不再被使用到的空间就是垃圾</li>
<li>即没有被引用的对象</li>
</ul>
<h4 id="2、要进行垃圾回收，如何判断一个对象是否可以被回收？——两种算法"><a href="#2、要进行垃圾回收，如何判断一个对象是否可以被回收？——两种算法" class="headerlink" title="2、要进行垃圾回收，如何判断一个对象是否可以被回收？——两种算法"></a>2、要进行垃圾回收，如何判断一个对象是否可以被回收？——两种算法</h4><h5 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h5><p>Java中，引用和对象是有关联的。如果要操作对象则必须引用进行。</p>
<p>因此，简单的办法是通过引用计数来判断一个对象是否可以回收。简单的说，给对象中添加一个引用计数，每当有一个引用失效时，计数器值减1.</p>
<p>任何时刻计数器值为0的对象就是不可能再被利用的，那么这个对象就是可回收对象。</p>
<p><strong>那么为什么主流的Java虚拟机里面都没有选择这种算法呢？主要的原因是它很难解决对象之间==相互循环引用==的问题。</strong></p>
<h5 id="2、枚举根节点做可达性分析（根搜索路径算法）"><a href="#2、枚举根节点做可达性分析（根搜索路径算法）" class="headerlink" title="2、枚举根节点做可达性分析（根搜索路径算法）"></a>2、枚举根节点做可达性分析（根搜索路径算法）</h5><p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。</p>
<p>所谓“GC Roots”或者tracing GC的“根集合”<strong>就是==一组==必须活跃的引用</strong>。</p>
<p><strong>基本思路就是通过一系列名为“GC Roots”的对象作为起点</strong>，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可达性的）对象就被判定为存活，没有被遍历到的就被判断为死亡。</p>
<h4 id="3、Java中可以作为GC-Roots的对象"><a href="#3、Java中可以作为GC-Roots的对象" class="headerlink" title="3、Java中可以作为GC Roots的对象"></a>3、Java中可以作为GC Roots的对象</h4><ul>
<li><strong>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</strong><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><strong>方法区中的类静态属性引用的对象。</strong><ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li><strong>方法区中常量引用的对象</strong><ul>
<li>比如：<strong>字符串常量池(String Table)里的引用</strong></li>
</ul>
</li>
<li><strong>本地方法栈中JNI（Native方法）引用的对象。</strong></li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。</li>
<li><strong>反映java虛拟机内部情况的JMXBean</strong>、<strong>JVMTI中注册的回调</strong>、<strong>本地代码缓存</strong>等。</li>
</ul>
<h3 id="5、你说你做过JVM调优和参数配置，请问如何查看JVM系统默认值"><a href="#5、你说你做过JVM调优和参数配置，请问如何查看JVM系统默认值" class="headerlink" title="5、你说你做过JVM调优和参数配置，请问如何查看JVM系统默认值"></a>5、你说你做过JVM调优和参数配置，请问如何查看JVM系统默认值</h3><h4 id="1、JVM的参数类型"><a href="#1、JVM的参数类型" class="headerlink" title="1、JVM的参数类型"></a>1、JVM的参数类型</h4><ol>
<li>标配参数<ul>
<li>-version</li>
<li>-help</li>
<li>java -showversion</li>
</ul>
</li>
<li>x参数（了解）<ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式</li>
</ul>
</li>
<li>xx参数（重点）<ul>
<li>Boolean类型<ul>
<li>公式：-XX：+或者-某个属性值<ul>
<li>+表示开启 </li>
<li>-表示关闭</li>
</ul>
</li>
<li>是否打印GC收集细节<ul>
<li>-XX:-PrintGCDetails：不打印GC收集细节</li>
<li>-XX:+PrintGCDetails：打印GC收集细节</li>
</ul>
</li>
<li>是否使用串行垃圾回收器<ul>
<li>-XX:-UseSerialGC：不使用串行垃圾回收器</li>
<li>-XX:+UseSerialGC：使用串行垃圾回收器</li>
</ul>
</li>
</ul>
</li>
<li>KV设值类型<ul>
<li>公式：-XX:属性key=属性值value<ul>
<li>-XX:MetaspaceSize=128m</li>
<li>-XX:MaxTenuringThreadhold=15</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>jinfo举例，如何查看当前运行程序的配置：</p>
<p>先使用jps查看需要的java进程的进程id，然后使用jinfo查看当前运行程序的配置</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929160007999.png" alt="image-20210929160007999"></p>
<h4 id="2、-Xms和-Xmx是属于哪一种参数类型？"><a href="#2、-Xms和-Xmx是属于哪一种参数类型？" class="headerlink" title="2、-Xms和-Xmx是属于哪一种参数类型？"></a>2、-Xms和-Xmx是属于哪一种参数类型？</h4><ul>
<li>-Xms：等价于-XX:InitialHeapSize——用来设置初始堆的大小</li>
<li>-Xmx：等价于-XX：MaxHeapSize——用来设置最大的对的大小</li>
</ul>
<p>因此这两个参数属于xx参数的类型</p>
<h4 id="3、怎么不使用VM参数，使用java代码的方式查看当前进程的内存总量等等信息"><a href="#3、怎么不使用VM参数，使用java代码的方式查看当前进程的内存总量等等信息" class="headerlink" title="3、怎么不使用VM参数，使用java代码的方式查看当前进程的内存总量等等信息"></a>3、怎么不使用VM参数，使用java代码的方式查看当前进程的内存总量等等信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看当前java虚拟机中的内存总量</span></span><br><span class="line"><span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前java虚拟机试图使用的最大内存量</span></span><br><span class="line"><span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br></pre></td></tr></table></figure>



<h4 id="4、盘点家底查看JVM默认值"><a href="#4、盘点家底查看JVM默认值" class="headerlink" title="4、盘点家底查看JVM默认值"></a>4、盘点家底查看JVM默认值</h4><h5 id="1、查看当前java虚拟机的初始默认值"><a href="#1、查看当前java虚拟机的初始默认值" class="headerlink" title="1、查看当前java虚拟机的初始默认值"></a>1、查看当前java虚拟机的初始默认值</h5><p>-XX:+PrintFlagsInitial</p>
<p>公式：</p>
<ul>
<li>java -XX:+PrintFlagsInitial -version</li>
<li>java -XX:+PrintFlagsInitial</li>
</ul>
<h5 id="2、查看当前java虚拟机修改更新之后的值"><a href="#2、查看当前java虚拟机修改更新之后的值" class="headerlink" title="2、查看当前java虚拟机修改更新之后的值"></a>2、查看当前java虚拟机修改更新之后的值</h5><p>-XX:+PrintFlagsFinal</p>
<p>公式：</p>
<ul>
<li>java -XX:+PrintFlagsFinal -version</li>
<li>java -XX:+PrintFlags</li>
</ul>
<h5 id="3、查看在VM当中设置的参数值"><a href="#3、查看在VM当中设置的参数值" class="headerlink" title="3、查看在VM当中设置的参数值"></a>3、查看在VM当中设置的参数值</h5><p>-XX:+PrintCommandLineFlags</p>
<p>公式：</p>
<ul>
<li>java -XX:+PrintCommandLineFlags -version</li>
</ul>
<blockquote>
<p>对于上面命令查看到的默认值的相关说明</p>
<ul>
<li>如果当前默认值是true或者false，表示当前的属性是Boolean类型</li>
<li>如果当前默认值是具体的值，表示当前的属性是KV设值类型</li>
<li><code>=</code>表示当前值没有被修改更新过</li>
<li><code>:=</code>表示当前默认值因虚拟机启动时进行了修改或者人为修改更新过</li>
</ul>
</blockquote>
<h3 id="6、你平时工作用过的JVM常用基本配置参数有哪些？"><a href="#6、你平时工作用过的JVM常用基本配置参数有哪些？" class="headerlink" title="6、你平时工作用过的JVM常用基本配置参数有哪些？"></a>6、你平时工作用过的JVM常用基本配置参数有哪些？</h3><h4 id="1、常用参数"><a href="#1、常用参数" class="headerlink" title="1、常用参数"></a>1、常用参数</h4><h5 id="1、-Xms"><a href="#1、-Xms" class="headerlink" title="1、-Xms"></a>1、-Xms</h5><ul>
<li>初始大小内存，默认为物理内存的1/64</li>
<li>等价于<code>-XX:InitialHeapSize</code>——初始化堆的大小</li>
</ul>
<h5 id="2、-Xmx"><a href="#2、-Xmx" class="headerlink" title="2、-Xmx"></a>2、-Xmx</h5><ul>
<li>最大分配内存，默认为物理内存的1/4</li>
<li>等价于<code>-XX:MaxHeapSize</code>——最大堆内存大小</li>
</ul>
<h5 id="3、-Xss"><a href="#3、-Xss" class="headerlink" title="3、-Xss"></a>3、-Xss</h5><ul>
<li>设置单个线程栈的大小，一般默认为512k~1024k</li>
<li>等价于<code>-XX:ThreadStackSize</code>——当前线程栈的大小</li>
</ul>
<p>如果使用jinfo去查看-Xss的初始默认值，发现：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929161910910.png" alt="image-20210929161910910"></p>
<p>-XX:ThreadStackSize的默认值是0，而不是512k或者1024k？</p>
<ul>
<li>这里的0代表的是JVM已经设置好的初始值</li>
</ul>
<p>这个初始值在不同的平台有不同的取值：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929162641205.png" alt="image-20210929162641205"></p>
<blockquote>
<p>在64位的Linux系统一般为1024KB</p>
<p>在Windows系统的话则取决于当前的虚拟内存</p>
</blockquote>
<h5 id="4、-Xmn"><a href="#4、-Xmn" class="headerlink" title="4、-Xmn"></a>4、-Xmn</h5><ul>
<li>设置年轻代的大小</li>
</ul>
<h5 id="5、-XX-MetaspaceSize"><a href="#5、-XX-MetaspaceSize" class="headerlink" title="5、-XX:MetaspaceSize"></a>5、-XX:MetaspaceSize</h5><ul>
<li><p>设置元空间大小</p>
<ul>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**==元空间并不在虚拟机中，使用的是本地内存==**</li>
<li>因此，默认情况下，元空间的大小受本地内存限制。类的元数据放入本地内存，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不在由<code>MaxPermSize</code>控制，而由系统的实际可用空间来控制。</li>
</ul>
</li>
<li><p>元空间并不在虚拟机中，使用的是本地内存。本地内存的空间一般比虚拟机大，但是为什么在本地空间充足的情况下，依旧会出现元空间的OOM？</p>
<ul>
<li><p>使用jinfo去查看MetaspaceSize的默认初始值时，发现：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929163807231-16329046893941.png" alt="image-20210929163807231"></p>
</li>
<li><p>元空间的大小并不是如我们所想那样是本地内存的大小，这个初始值的大小与当前虚拟机的核数有关</p>
</li>
<li><p>所以在生产环境下，会适当的调高元空间的默认初始值。使其不会轻易出现OOM。</p>
</li>
<li><p>经典的VM参数设置：（这里指的是经常使用的，具体还是的由具体的业务决定）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="6、-XX-PrintGCDetails"><a href="#6、-XX-PrintGCDetails" class="headerlink" title="6、-XX:PrintGCDetails"></a>6、-XX:PrintGCDetails</h5><ul>
<li>输出详细的GC收集日志信息</li>
</ul>
<h6 id="1、MinorGC（或-young-GC-或-YGC）日志"><a href="#1、MinorGC（或-young-GC-或-YGC）日志" class="headerlink" title="1、MinorGC（或 young GC 或 YGC）日志"></a>1、MinorGC（或 young GC 或 YGC）日志</h6><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164652331.png" alt="image-20210929164652331"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164702060.png" alt="image-20210929164702060"></p>
<h6 id="2、Full-GC-日志"><a href="#2、Full-GC-日志" class="headerlink" title="2、Full GC 日志"></a>2、Full GC 日志</h6><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164525230.png" alt="image-20210929164525230"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929164531215.png" alt="image-20210929164531215"></p>
<h5 id="7、-XX-SurvivorRatio"><a href="#7、-XX-SurvivorRatio" class="headerlink" title="7、-XX:SurvivorRatio"></a>7、-XX:SurvivorRatio</h5><ul>
<li>设置新生代中Eden和S0/S1空间的比例</li>
<li>默认为：-XX:SurvivorRatio=8——即Eden:S0:S1 = 8:1:1</li>
<li>假如设置-XX:SurvivorRatio=4——即Eden:S0:S1 = 4:1:1</li>
<li>SurvivorRatio值就是设置Eden区的比例占多少，S0/S1相同</li>
</ul>
<h5 id="8、-XX-NewRatio"><a href="#8、-XX-NewRatio" class="headerlink" title="8、-XX:NewRatio"></a>8、-XX:NewRatio</h5><ul>
<li>配置年轻代与老年代在堆结构的占比</li>
<li>默认为：-XX:NewRatio=2——新生代占1，老年代占2。年轻代占整一个堆的1/3</li>
<li>假如设置-XX:NewRatio=4——新生代占1，老年代占4。年轻代占整一个堆的1/5</li>
<li>NewRatio值就是设置老年代的占比，剩下的1给新生代</li>
</ul>
<h5 id="9、-XX-MaxTenuringThreshold"><a href="#9、-XX-MaxTenuringThreshold" class="headerlink" title="9、-XX:MaxTenuringThreshold"></a>9、-XX:MaxTenuringThreshold</h5><ul>
<li>设置垃圾最大年龄</li>
</ul>
<p>使用jinfo查看默认进入老年代的年龄</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929165529641.png" alt="image-20210929165529641"></p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。</p>
<ul>
<li><p>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。</p>
</li>
<li><p>如果将此值设置为一个较大值，这年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概论</p>
<ul>
<li><p>在JDk1.8之前，一般会将这个值设置为31，使更多的对象在年轻代就被回收掉，不让对象轻易进入老年代。以此来减少Full GC的次数。</p>
</li>
<li><p>这种方法在JDK1.8之后就不能实现了。因为在JDK1.8的环境下，如果设置的设置大于15的话，会报一个<code>Error：Could not create the Java Virtual Machine</code></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210929170211758.png" alt="image-20210929170211758"></p>
</li>
</ul>
</li>
</ul>
<h3 id="7、强引用、软引用、弱引用、虚引用分别是什么？"><a href="#7、强引用、软引用、弱引用、虚引用分别是什么？" class="headerlink" title="7、强引用、软引用、弱引用、虚引用分别是什么？"></a>7、强引用、软引用、弱引用、虚引用分别是什么？</h3><h4 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930022132677.png" alt="image-20210930022132677"></p>
<h4 id="2、强引用（默认支持模式）——StrongReference"><a href="#2、强引用（默认支持模式）——StrongReference" class="headerlink" title="2、强引用（默认支持模式）——StrongReference"></a>2、强引用（默认支持模式）——StrongReference</h4><p>当内存不足，JVM开始垃圾回收，<strong>对于强引用的对象，就算是出现了OOM也不会对该对象进行回收</strong>，死都不收。</p>
<p>强引用是最常见的普通对象引用，只要还有引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰到这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾机制回收的，<strong>即使该对象以后永远都不能被用到，JVM也不会回收</strong>。因此<strong>强引用是造成Java内存泄露的主要原因之一。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时还要看垃圾收集策略）。</p>
<h4 id="3、软引用——SoftReference"><a href="#3、软引用——SoftReference" class="headerlink" title="3、软引用——SoftReference"></a>3、软引用——SoftReference</h4><p>软引用是一种相对强化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一次垃圾收集。</p>
<p>对于只有软引用的对象来说：</p>
<ol>
<li><strong>当系统内存充足时，它不会被回收</strong></li>
<li><strong>当系统内存不足时，它会被回收</strong></li>
</ol>
<p>软引用通常用在<strong>对内存敏感</strong>的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收。</p>
<h4 id="4、弱引用——WeakReference"><a href="#4、弱引用——WeakReference" class="headerlink" title="4、弱引用——WeakReference"></a>4、弱引用——WeakReference</h4><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短。</p>
<p>对于软引用对象来说，只要垃圾回收机制一运行，<strong>不管JVM的内存空间是否足够，都会回收该对象占用的内存</strong>。</p>
<h4 id="5、软引用和弱引用的使用场景"><a href="#5、软引用和弱引用的使用场景" class="headerlink" title="5、软引用和弱引用的使用场景"></a>5、软引用和弱引用的使用场景</h4><p>假如有一个应用需要读取大量的本地图片：</p>
<ol>
<li>如果每次读取图片都从硬盘读取则会严重影响性能。</li>
<li>如果一次性全部加载到内存中有可能造成内存泄露。</li>
</ol>
<p>此时使用软引用可以解决这个问题。</p>
<p>设计思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免OOM的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>你知道所引用的话，能谈谈weakHashMap吗？</p>
<p>weakHashMap的key都是弱引用对象，如果发生了垃圾回收并且在finally块中不能复活的话，被回收的key会被移除出Map。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930022952843.png" alt="image-20210930022952843"></p>
<h4 id="6、虚引用——PhantomReference"><a href="#6、虚引用——PhantomReference" class="headerlink" title="6、虚引用——PhantomReference"></a>6、虚引用——PhantomReference</h4><p>虚引用需要java.lang.refPhantonReference类来实现。</p>
<p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p>
<p><strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，<strong>虚引用必须和队列（ReferenceQueue）联合使用</strong>。</p>
<p>虚引用的主要作用是<strong>跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制</strong>。</p>
<p><strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对应的引用对象。其意义在于说明一个对象那个已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>换句话说，<strong>设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理</strong>。</p>
<p>Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清楚之前做必要的清理工作。</p>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><p>在对象被回收前需要被引用队列保存一下。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930023036859.png" alt="image-20210930023036859"></p>
<h4 id="7、GCRoots和四大引用小总结"><a href="#7、GCRoots和四大引用小总结" class="headerlink" title="7、GCRoots和四大引用小总结"></a>7、GCRoots和四大引用小总结</h4><p>java提供了4种引用类型，在垃圾回收的时候，都有自己各自的特点。</p>
<ul>
<li>ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。</li>
<li>创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</li>
<li>这相当于是一种通知机制。</li>
<li>当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210930024037129.png" alt="image-20210930024037129"></p>
<h3 id="8、请谈谈你对OOM的认识？"><a href="#8、请谈谈你对OOM的认识？" class="headerlink" title="8、请谈谈你对OOM的认识？"></a>8、请谈谈你对OOM的认识？</h3><h4 id="1、java-lang-StackOverFlowError"><a href="#1、java-lang-StackOverFlowError" class="headerlink" title="1、java.lang.StackOverFlowError"></a>1、java.lang.StackOverFlowError</h4><p>java.lang.StackOverFlowError——栈溢出异常</p>
<p>一般的线程栈的大小也只有512Kb或者1024Kb，当递归的深度太深或者出现不合理的递归时，容易出现以上异常</p>
<p>这里说的”异常”并不是说StackOverFlowError是一个异常，<strong>StackOverFlowError不是异常而是错误</strong>。只是平时大家习以为常说是异常，其实StackOverFlowError是一个Error错误。</p>
<h4 id="2、java-lang-OutOfMemoryError-Java-heap-space"><a href="#2、java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="2、java.lang.OutOfMemoryError:Java heap space"></a>2、java.lang.OutOfMemoryError:Java heap space</h4><p>java.lang.OutOfMemoryError:Java heap space——堆空间溢出异常</p>
<p>若当前的堆空间不满足创建对象的大小，就会出现Java heap space——堆空间溢出异常</p>
<p>同理，Java heap space也不是异常，而是一个Error错误。</p>
<h4 id="3、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded——GC时间过长异常"><a href="#3、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded——GC时间过长异常" class="headerlink" title="3、java.lang.OutOfMemoryError:GC overhead limit exceeded——GC时间过长异常"></a>3、java.lang.OutOfMemoryError:GC overhead limit exceeded——GC时间过长异常</h4><p>GC回收时间长时会抛出OutOfMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存，连续多次GC都只回收了不到2%的极端情况下才会抛出。</p>
<p>假设不抛出GC overhead limit错误会发生什么情况呢？</p>
<ul>
<li>那就是GC清理的这么点内存很快会再次填满，迫使GC再次执行，这样就形成恶性循环，CPU使用率一直是100%，而GC缺没有任何成果。</li>
</ul>
<p>同理，GC overhead limit exceeded也不是异常，而是一个Error错误。</p>
<h4 id="4、java-lang-OutOfMemoryError-Direct-buffer-memory——本地内存溢出异常"><a href="#4、java-lang-OutOfMemoryError-Direct-buffer-memory——本地内存溢出异常" class="headerlink" title="4、java.lang.OutOfMemoryError:Direct buffer memory——本地内存溢出异常"></a>4、java.lang.OutOfMemoryError:Direct buffer memory——本地内存溢出异常</h4><p>导致原因：</p>
<ul>
<li>写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</li>
<li>这样能在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。</li>
<li>ByteBuffer.allocate(capability)第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢。</li>
<li>ByteBuffer.allocateDirect(capability)第一种方式是分配OS本地内存，<strong>不属于GC管辖范围</strong>，由于不需要内存拷贝，所以速度相对较快。</li>
<li>但如果不断分配内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。</li>
</ul>
<p>同理，也不是异常，而是一个Error错误。</p>
<h4 id="5、java-langOutOfMemoryError-Metaspace"><a href="#5、java-langOutOfMemoryError-Metaspace" class="headerlink" title="5、java.langOutOfMemoryError:Metaspace"></a>5、java.langOutOfMemoryError:Metaspace</h4><p>使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数：-XX:Metaspacesize为218103768（大约为20.8M）</p>
<p>Java 8及以后的版本使用Metaspace来代替永久代</p>
<p>Metaspace是方法区在HotSpot中的实现，它与永久代最大的区别在于：Metaspace并不在虚拟机内存中，而是<strong>使用本地内存</strong>，也就是说在Java8中，class metadata（the virtual machines internal presentation of Java class）,被存储在叫做Metaspace的native memory</p>
<p>Metaspace存放了以下信息：</p>
<ul>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul>
<h4 id="6、java-lang-OutOfMemoryError-unable-to-create-new-native-thread——无法创建本地线程异常"><a href="#6、java-lang-OutOfMemoryError-unable-to-create-new-native-thread——无法创建本地线程异常" class="headerlink" title="6、java.lang.OutOfMemoryError:unable to create new native thread——无法创建本地线程异常"></a>6、java.lang.OutOfMemoryError:unable to create new native thread——无法创建本地线程异常</h4><p>高并发请求服务器时，经常出现如下异常：java.lang.OutOfMemoryError:unbale to create new native thread</p>
<p><strong>准确的说该native thread异常与对应的平台有关</strong>。</p>
<p>导致原因：</p>
<ol>
<li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限。</li>
<li>服务器并不允许应用程序创建那么多线程，linux系统默认允许单个进程可以创建的线程数是1024个，如果应用创建超过这个数量，就会报java.lang.OutOfMemoryError:unable to create new native thread</li>
</ol>
<p>解决办法：</p>
<ol>
<li><strong>想办法降低应用程序创建线程的数量</strong>，分析应用是否真的需要创建那么多线程，如果不是，<strong>改代码将线程数降到最低</strong>。</li>
<li>对于有的应用，确实需要创建多个线程，远超过linux系统默认的1024个线程的限制，可以<strong>通过修改linux服务器配置，扩大linux默认限制</strong>。</li>
</ol>
<h5 id="1、非root用户登录linux系统测试"><a href="#1、非root用户登录linux系统测试" class="headerlink" title="1、非root用户登录linux系统测试"></a>1、非root用户登录linux系统测试</h5><p>查看最大线程数量命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -u</span><br></pre></td></tr></table></figure>

<h5 id="2、服务器级别调参调优"><a href="#2、服务器级别调参调优" class="headerlink" title="2、服务器级别调参调优"></a>2、服务器级别调参调优</h5><p>扩大服务器线程数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/security/limits.d/90-nproc.conf</span><br></pre></td></tr></table></figure>



<h3 id="9、GC回收算法和垃圾收集器的关系？分别是什么请你谈谈"><a href="#9、GC回收算法和垃圾收集器的关系？分别是什么请你谈谈" class="headerlink" title="9、GC回收算法和垃圾收集器的关系？分别是什么请你谈谈"></a>9、GC回收算法和垃圾收集器的关系？分别是什么请你谈谈</h3><h4 id="1、GC回收算法"><a href="#1、GC回收算法" class="headerlink" title="1、GC回收算法"></a>1、GC回收算法</h4><p>GC算法是内存回收的方法论，垃圾收集器就是算法落地实现。常见的GC算法有：</p>
<ul>
<li>引用计数</li>
<li>复制算法</li>
<li>标记清除算法</li>
<li>标记整理算法（标记压缩算法）</li>
</ul>
<p>因为目前为止还没有完美的收集器出现，更加没有万能的收集器，知识针对具体应用最合适的收集器，进行分代收集。</p>
<h4 id="2、4种主要垃圾收集器"><a href="#2、4种主要垃圾收集器" class="headerlink" title="2、4种主要垃圾收集器"></a>2、4种主要垃圾收集器</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003192451779.png" alt="image-20211003192451779"></p>
<ul>
<li>串行垃圾回收器（Serial）：它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。</li>
<li>并行垃圾回收器（Parallel）：多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理平台处理等弱交互场景。</li>
<li>并发垃圾回收器（CMS）：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程，使用对响应时间有要求的场景。</li>
<li>GI垃圾回收器：G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。</li>
</ul>
<h4 id="3、串行（Serial）-VS-并行（Parallel）"><a href="#3、串行（Serial）-VS-并行（Parallel）" class="headerlink" title="3、串行（Serial） VS 并行（Parallel）"></a>3、串行（Serial） VS 并行（Parallel）</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193243584.png" alt="image-20211003193243584"></p>
<blockquote>
<p>注：不管是串行还是并行，都存在STW问题。只是并行的STW时间比串行的要短很多。</p>
</blockquote>
<h4 id="4、STW（Stop-the-World）-VS-并发（Concurrent）"><a href="#4、STW（Stop-the-World）-VS-并发（Concurrent）" class="headerlink" title="4、STW（Stop-the-World） VS 并发（Concurrent）"></a>4、STW（Stop-the-World） VS 并发（Concurrent）</h4><p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193407527.png" alt="image-20211003193407527"></p>
<blockquote>
<p>并发使得在进行垃圾收集时也可以执行工作线程。</p>
</blockquote>
<h3 id="10、怎么查看服务器默认的垃圾收集器是哪个？生产上你是如何配置垃圾收集器的？谈谈你的理解？"><a href="#10、怎么查看服务器默认的垃圾收集器是哪个？生产上你是如何配置垃圾收集器的？谈谈你的理解？" class="headerlink" title="10、怎么查看服务器默认的垃圾收集器是哪个？生产上你是如何配置垃圾收集器的？谈谈你的理解？"></a>10、怎么查看服务器默认的垃圾收集器是哪个？生产上你是如何配置垃圾收集器的？谈谈你的理解？</h3><h4 id="1、怎么查看默认的垃圾收集器是哪个？"><a href="#1、怎么查看默认的垃圾收集器是哪个？" class="headerlink" title="1、怎么查看默认的垃圾收集器是哪个？"></a>1、怎么查看默认的垃圾收集器是哪个？</h4><p>使用JVM参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX：+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>



<h4 id="2、默认的垃圾收集器有哪些？"><a href="#2、默认的垃圾收集器有哪些？" class="headerlink" title="2、默认的垃圾收集器有哪些？"></a>2、默认的垃圾收集器有哪些？</h4><p><strong>Java的GC回收的类型主要有以下七种</strong>：</p>
<ul>
<li>UseSerialGC：串行垃圾回收器——新生代</li>
<li>UseParallelGC：并行垃圾回收器——新生代</li>
<li>UseConcMarkSweepGC（CMS）：并发垃圾回收器——老年代</li>
<li>UseParNewGC——新生代并行垃圾回收器</li>
<li>UseParallelOldGC——老年代并行垃圾回收器</li>
<li>UseG1GC——G1垃圾回收器——整堆</li>
</ul>
<p>相关的源码：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003193748985.png" alt="image-20211003193748985"></p>
<p><strong>垃圾收集器的组合关系</strong>：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<p><strong>Java不同版本的默认垃圾回收器组合</strong>：</p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">Young</th>
<th align="center">Old</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK6</td>
<td align="center">PSScavenge(Parallel Scavenge)</td>
<td align="center">PSMarkSweep (Parallel Scavenge)</td>
</tr>
<tr>
<td align="center">JDK7</td>
<td align="center">PSScavenge(Parallel Scavenge)</td>
<td align="center">PSParallelCompact(Parallel Old)</td>
</tr>
<tr>
<td align="center">JDK8</td>
<td align="center">PSScavenge(Parallel Scavenge)</td>
<td align="center">PSParallelCompact(Parallel Old)</td>
</tr>
<tr>
<td align="center">JDK9</td>
<td align="center">G1</td>
<td align="center">G1</td>
</tr>
</tbody></table>
<h4 id="3、垃圾收集器详解"><a href="#3、垃圾收集器详解" class="headerlink" title="3、垃圾收集器详解"></a>3、垃圾收集器详解</h4><h5 id="1、部分参数预先说明"><a href="#1、部分参数预先说明" class="headerlink" title="1、部分参数预先说明"></a>1、部分参数预先说明</h5><ul>
<li>DefNew——Default New Generation</li>
<li>Tenured——Old</li>
<li>ParNew——Parallel New Generation</li>
<li>PSYoungGen——Parallel Scavenge</li>
<li>ParOldGen——Parallel Old Generation</li>
</ul>
<h5 id="2、Server-Client模式分别是什么意思"><a href="#2、Server-Client模式分别是什么意思" class="headerlink" title="2、Server/Client模式分别是什么意思"></a>2、Server/Client模式分别是什么意思</h5><ol>
<li>使用范围：只需要掌握<strong>Server模式</strong>即可，Client模式基本不会用。</li>
<li>操作系统：<ul>
<li>32位操作系统，不论硬件如何都默认使用Client的JVM模式。</li>
<li>32位操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是Client模式。</li>
<li><strong>64位only server模式</strong></li>
</ul>
</li>
</ol>
<h5 id="3、新生代"><a href="#3、新生代" class="headerlink" title="3、新生代"></a>3、新生代</h5><h5 id="1、串行GC（Serial）-Serial-Copying"><a href="#1、串行GC（Serial）-Serial-Copying" class="headerlink" title="1、串行GC（Serial）/(Serial Copying)"></a>1、串行GC（Serial）/(Serial Copying)</h5><p>串行收集器：Serial收集器。一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程知道它收集结束。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003195511732.png" alt="image-20211003195511732"></p>
<p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾收集过程中可能会产生较长的停顿（Stor-the-World状态）。虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，<strong>对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率</strong>，因此<strong>Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器</strong>。</p>
<p>对应JVM参数是：**-XX:+UseSerialGC**</p>
<p>开启后会使用：Serial（Young区用）+ Serial Old（Old区用）的收集器组合。</p>
<p>表示：新生代、老年代都会使用串行回收收集器，<strong>新生代使用复制算法</strong>，<strong>老年代使用标记-整理算法</strong>。</p>
<h5 id="2、并行GC（ParNew）"><a href="#2、并行GC（ParNew）" class="headerlink" title="2、并行GC（ParNew）"></a>2、并行GC（ParNew）</h5><p>ParNew（并行）收集器。一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-the-World暂停其他所有的工作线程直到它收集结束，时间较串行垃圾收集器来说要短。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003220332605.png" alt="image-20211003220332605"></p>
<p><strong>ParNew收集器其实就是Serial收集器新生代的并行多线程版本</strong>，最常见的应用场景是配合<strong>老年代的CMS GC</strong>工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程<strong>。它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。</strong></p>
<p>常用对应JVM参数：**-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代。**</p>
<p><strong>开启上述参数后，会使用：ParNew（Young区用）+ Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。</strong></p>
<p>但是，ParNew + Tenured这样的搭配，java8已经不在推荐</p>
<blockquote>
<p>Java HotSpot(TM) 64-Bit Server VM warning:</p>
<p>Using <strong>the ParNew young collector with the Serial old collecto is deprecated</strong> and will likely be removed in a future release</p>
</blockquote>
<p>备注：关于新生代并行线程数的设置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads</span><br></pre></td></tr></table></figure>

<p>限制线程数量，默认开启和CPU数目相同的线程数。</p>
<h5 id="3、并行回收GC-Parallel-Parallel-Scavenge"><a href="#3、并行回收GC-Parallel-Parallel-Scavenge" class="headerlink" title="3、并行回收GC(Parallel)/(Parallel Scavenge)"></a>3、并行回收GC(Parallel)/(Parallel Scavenge)</h5><p>Parallel Scavenge收集器类似ParNew也是一个<strong>新生代</strong>垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称<strong>吞吐量有限收集器</strong>。一句话：<strong>串行收集器在新生代和老年代的并行化</strong>。</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003220751051.png" alt="image-20211003220751051"></p>
<p>它重点关注的是：</p>
<ul>
<li><strong>可控制的吞吐量</strong>（Thoughput=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%）。<ul>
<li>高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。</li>
</ul>
</li>
<li><strong>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别</strong>。<ul>
<li>自使用调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大的吞吐量。</li>
</ul>
</li>
</ul>
<p>常用JVM参数：**-XX:+UseParallelGC或-XX:+UseParallelOldGC（可互相激活）**使用Parallel Scanvenge收集器</p>
<p>备注：关于新生代与老年代并行线程数的设置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=[数字N]</span><br></pre></td></tr></table></figure>

<p>表示启动多少个GC线程：</p>
<ul>
<li>当CPU &gt; 8：N = 5/8</li>
<li>当CPU &lt; 8：N = CPU实际个数</li>
</ul>
<h5 id="4、老年代"><a href="#4、老年代" class="headerlink" title="4、老年代"></a>4、老年代</h5><h6 id="1、串行GC-Serial-Old-Serial-MSC"><a href="#1、串行GC-Serial-Old-Serial-MSC" class="headerlink" title="1、串行GC(Serial Old)/(Serial MSC)"></a>1、串行GC(Serial Old)/(Serial MSC)</h6><p><strong>Serial Old是Serial垃圾收集器老年代版本</strong>，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。</p>
<p>在Server模式下，主要有两个用途(了解，版本已经到8及以后)：</p>
<ol>
<li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。 (Parallel Scavenge + Serial Old )</li>
<li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li>
</ol>
<blockquote>
<p>注：理论了解即可，实际中java8已经被优化掉了，没有了。</p>
<p>如果在java8的VM配置相关参数启动Serial Old垃圾收集器，会发生：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221514373.png" alt="image-20211003221514373"></p>
</blockquote>
<h6 id="2、并行GC（Parallel-Old）-Parallel-MSC"><a href="#2、并行GC（Parallel-Old）-Parallel-MSC" class="headerlink" title="2、并行GC（Parallel Old）/(Parallel MSC)"></a>2、并行GC（Parallel Old）/(Parallel MSC)</h6><p><strong>Parallel Old收集器是Parallel Scavenge的老年代版本</strong>，使用<strong>多线程的标记-整理算法</strong>，Parallel Old收集器在JDK1.6才开始提供。</p>
<p>JVM常用参数：**-XX:+UseParallel Old** 使用Parallel Old收集器，设置该参数后，<strong>新生代Parallel+老年代Parallel Old</strong></p>
<h6 id="3、并发标记清除GC（CMS）"><a href="#3、并发标记清除GC（CMS）" class="headerlink" title="3、并发标记清除GC（CMS）"></a>3、并发标记清除GC（CMS）</h6><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）<strong>是一种以获取==最短回收停顿时间==为目标的收集器</strong>。</p>
<p>适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短</strong>。</p>
<p>CMS非常适合<strong>堆内存大</strong>、<strong>CPU核数多</strong>的服务器端应用，也是G1出现之前大型应用的首选收集器。</p>
<p>Concurrent Mark Sweep并发标记清除，<strong>并发收集低停顿，并发指的是与用户线程一起执行</strong>。</p>
<p>开启该收集器的JVM参数：**-XX:+UseConcMarkSweepGC** 开启该参数后<strong>会自动将-XX:+UseParNewGC打开</strong></p>
<p>开启该参数后，<strong>使用ParNew（Young区用）+CMS（Old区用）+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器。</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221017872.png" alt="image-20211003221017872"></p>
<p><strong>CMS垃圾收集的过程：</strong></p>
<ol>
<li>初始标记（CMS initial mark）<ul>
<li>只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li>
</ul>
</li>
<li>并发标记（CMS concurrent mark）和用户线程一起<ul>
<li>进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。</li>
</ul>
</li>
<li>重新标记（CMS remark）<ul>
<li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li>
<li>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正。</li>
</ul>
</li>
<li>并发清除（CMS concurrent sweep）和用户线程一起<ul>
<li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象。</li>
<li>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发执行。</li>
</ul>
</li>
</ol>
<blockquote>
<p>CMS也存在STW，发生在第一步：初始标记和第三步：重新标记。时间很短。</p>
</blockquote>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221029445.png" alt="image-20211003221029445"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211003221035370.png" alt="image-20211003221035370"></p>
<p><strong>CMS的优缺点</strong>：</p>
<ul>
<li>优点：<ul>
<li><strong>并发收集低停顿</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>并发执行，<strong>对CPU资源压力大</strong><ul>
<li>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，<strong>CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时</strong>，将触发担保机制，串行老年代收集器会以STW的方式进行一次GC，从而造成较大停顿时间。</li>
</ul>
</li>
<li>采用的标记清除算法会导致<strong>大量碎片</strong><ul>
<li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数<code>-XX:CMSFullGCsBeForeCompaction</code>（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、如何选择垃圾收集器"><a href="#4、如何选择垃圾收集器" class="headerlink" title="4、如何选择垃圾收集器"></a>4、如何选择垃圾收集器</h4><p>组合的选择：</p>
<ol>
<li><p>单CPU或小内存，单机程序——使用串行垃圾回收器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>
</li>
<li><p>多CPU，需要最大吞吐量，如后台计算型应用——使用并行垃圾回收器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">// 或（相互激活）</span><br><span class="line">-XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure>
</li>
<li><p>多CPU，追求低停顿时间，需要快速响应如互联网应用——CMS垃圾回收器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+ParNewGC</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5、垃圾收集器总结"><a href="#5、垃圾收集器总结" class="headerlink" title="5、垃圾收集器总结"></a>5、垃圾收集器总结</h4><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">新生代垃圾收集器</th>
<th align="center">新生代算法</th>
<th align="center">老年代垃圾收集器</th>
<th align="center">老年代算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">SerialGC</td>
<td align="center">复制</td>
<td align="center">SerialOldGC</td>
<td align="center">标记-整理</td>
</tr>
<tr>
<td align="center">-XX:+UseParNewGC</td>
<td align="center">ParNew</td>
<td align="center">复制</td>
<td align="center">SerialOldGC</td>
<td align="center">标记-整理</td>
</tr>
<tr>
<td align="center">-XX:+UseParallelGC/+XX:+UsePallallelOldGC</td>
<td align="center">Parallel[Scavenge]</td>
<td align="center">复制</td>
<td align="center">Parallel Old</td>
<td align="center">标记-整理</td>
</tr>
<tr>
<td align="center">-XX:+UseConcMarkSweepGC</td>
<td align="center">ParNew</td>
<td align="center">复制</td>
<td align="center">CMS + SerialOld的收集器组合（Serial Old作为CMS出错的后备收集器）</td>
<td align="center">标记-清除</td>
</tr>
<tr>
<td align="center">-XX:+UseG1GC</td>
<td align="center">G1整体上采用标记-整理算法</td>
<td align="center">局部是通过复制算法，不会产生内存碎片</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="11、G1垃圾收集器"><a href="#11、G1垃圾收集器" class="headerlink" title="11、G1垃圾收集器"></a>11、G1垃圾收集器</h3><h4 id="1、以前收集器特点"><a href="#1、以前收集器特点" class="headerlink" title="1、以前收集器特点"></a>1、以前收集器特点</h4><ol>
<li>年轻代和老年代是各自独立且连续的内存块</li>
<li>年轻代收集使用单eden+S0+S1进行复制算法</li>
<li>老年代收集必须扫描整个老年代区域</li>
<li>都是以尽可能少而快速地执行GC为设计原则。</li>
</ol>
<h4 id="2、G1是什么？"><a href="#2、G1是什么？" class="headerlink" title="2、G1是什么？"></a>2、G1是什么？</h4><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器——G1垃圾收集器。</p>
<p>G1是在2012年才在jdk1.7u4中可用。oracle官方计划<strong>在jdk9中将G1变成默认的垃圾收集器以替代CMS</strong>。它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。</p>
<p>主要改变是Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p>
<p>G1（Garbage-First）收集器，是一款<strong>面向服务端应用</strong>的收集器，<strong>应用在多处理器和大容量内存环境中</strong>，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。另外还具有以下特性：</p>
<ul>
<li>像CMS收集器一样，能与应用程序线程并发执行。</li>
<li>整理空间空间更快</li>
<li>需要更多的时间来预测GC停顿时间</li>
<li>不希望牺牲大量的吞吐性能</li>
<li>不需要更大的Java Heap</li>
</ul>
<p><strong>G1收集器的设计目标是取代CMS收集器</strong>，它同CMS相比，在以下方面表现的更出色：</p>
<ul>
<li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li>
<li>G1的Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li>
</ul>
<h4 id="3、G1的特点"><a href="#3、G1的特点" class="headerlink" title="3、G1的特点"></a>3、G1的特点</h4><ul>
<li>G1能充分利用多CPU、多核环境硬件优势，<strong>尽量缩短STW</strong>。</li>
<li>G1 <strong>整体上采用标记-整理算法</strong>，<strong>局部是通过复制算法</strong>，<strong>不会产生内存碎片</strong>。</li>
<li>宏观上看G1之中不再区分年轻代和老年代。**把内存划分成多个独立的子区域(Region)**，可以近似理解为一个围棋的棋盘。</li>
<li>G1收集器里面讲整个的内存区都混合在一起了，<strong>但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代</strong>，但它们不再是物理隔离的，而是一部分Region的集合且不需要Region是连续的，也就是说依然会采用不同的GC方式来处理不同的区域。</li>
<li>G1 虽然也是<strong>分代收集器</strong>，但整个内存分区<strong>不存在物理上</strong>的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1<strong>只有逻辑上的分代概念</strong>，或者说<strong>每个分区都可能随G1的运行在不同代之间前后切换</strong>。</li>
</ul>
<h4 id="4、底层原理"><a href="#4、底层原理" class="headerlink" title="4、底层原理"></a>4、底层原理</h4><h5 id="1、Region区域化垃圾收集器"><a href="#1、Region区域化垃圾收集器" class="headerlink" title="1、Region区域化垃圾收集器"></a>1、Region区域化垃圾收集器</h5><p>区域化内存划片Region，整体编为一系列不连续的内存区域，<strong>避免了全内存的GC操作</strong>。</p>
<p><strong>核心思想</strong>是<strong>将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置这些子区域的大小。</strong></p>
<p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以<strong>按需在年轻代和老年代之间切换</strong>。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小（1MB-32MB，且必须是2的幂），<strong>默认将整个堆划分为2048个分区</strong>。大小范围在1MB-32MB，最多能设置2048个区域。也即能够支持的最大内存为：32MB * 2048 = 65536MB = 64G内存。</p>
<p><strong>G1将新生代、老年代的物理空间取消了。</strong></p>
<p><strong>最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。</strong></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004023839443.png" alt="image-20211004023839443"></p>
<p>G1算法将堆划分为若干个区域（Region），它<strong>仍然属于分代收集器</strong></p>
<p>这些Region的一部分包含<strong>新生代</strong>，<strong>新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</strong>。</p>
<p>这些Region的一部分包含<strong>老年代</strong>，G1收集器通过将对象从一个区域复制到另一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），<strong>这样也就不会有CMS内存碎片问题的存在了。</strong></p>
<p>在G1中，还有一种特殊的区域，叫<strong>Humongous（巨大的）区域</strong>。<strong>如果一个对象占用的空间超过了分区容量的50%以上，G1收集器就认为这是一个巨型对象</strong>。这些巨型对象默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。</p>
<p>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。<strong>为了能找到连续的H区，有时候不得不启动Full GC</strong>——所以说要尽量避免创建大对象。</p>
<h5 id="2、回收步骤"><a href="#2、回收步骤" class="headerlink" title="2、回收步骤"></a>2、回收步骤</h5><p>G1收集器下的Young GC</p>
<p>针对Eden区进行收集，Eden区耗尽后会被触发，<strong>主要是小区域收集+形成连续的内存块，避免内存碎片</strong>。</p>
<ol>
<li>Eden区的数据移动到新的Survivor区，部分数据晋升到Old区。</li>
<li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区。</li>
<li>最后Eden区收集干净了，GC结束，用户的应用程序继续执行。</li>
</ol>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024015511.png" alt="image-20211004024015511"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024112912.png" alt="image-20211004024112912"></p>
<h5 id="3、4步过程"><a href="#3、4步过程" class="headerlink" title="3、4步过程"></a>3、4步过程</h5><ul>
<li>初始标记：只标记GC Roots能直接关联到的对象</li>
<li>并发标记：进行GC Roots Tracing的过程</li>
<li>最终标记：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象</li>
<li>筛选回收：根据时间来进行价值最大化的回收。</li>
</ul>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004024222685.png" alt="image-20211004024222685"></p>
<h4 id="5、常用配置参数（了解）"><a href="#5、常用配置参数（了解）" class="headerlink" title="5、常用配置参数（了解）"></a>5、常用配置参数（了解）</h4><p><strong>开发人员仅仅声明一下参数即可</strong>。</p>
<p><strong>三步归纳：开始G1 + 设置最大内存 + 设置最大停顿时间</strong></p>
<ul>
<li>-XX:+UseG1GC——使用G1垃圾回收器</li>
<li>-Xmx32g——设置最大内存</li>
<li>-XX:MaxGCPauseMillis=100——设置最大停顿时间</li>
</ul>
<blockquote>
<p>注：-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，<strong>JVM将尽可能（但不保证）停顿小于这个时间</strong>。</p>
</blockquote>
<h5 id="1、-XX-UseG1GC——常用"><a href="#1、-XX-UseG1GC——常用" class="headerlink" title="1、-XX:+UseG1GC——常用"></a>1、-XX:+UseG1GC——常用</h5><p>使用G1垃圾回收器</p>
<h5 id="2、-XX-G1HeapRegionSize-n——常用"><a href="#2、-XX-G1HeapRegionSize-n——常用" class="headerlink" title="2、-XX:G1HeapRegionSize=n——常用"></a>2、-XX:G1HeapRegionSize=n——常用</h5><p>设置的G1区域的大小。值是2的幂，范围是1MB到32MB。目标是根据最小的Java堆大小划分出约2048个区域。</p>
<h5 id="3、-XX-MaxGCPauseMillis-n——常用"><a href="#3、-XX-MaxGCPauseMillis-n——常用" class="headerlink" title="3、-XX:MaxGCPauseMillis=n——常用"></a>3、-XX:MaxGCPauseMillis=n——常用</h5><p>最大GC停顿时间，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。</p>
<h5 id="4、-XX-InitiatingHeapOccupancyPercent-n——默认"><a href="#4、-XX-InitiatingHeapOccupancyPercent-n——默认" class="headerlink" title="4、-XX:InitiatingHeapOccupancyPercent=n——默认"></a>4、-XX:InitiatingHeapOccupancyPercent=n——默认</h5><p>堆占用了多少的时候就触发GC，默认为45</p>
<h5 id="5、-XX-ConcGCThreads-n——默认"><a href="#5、-XX-ConcGCThreads-n——默认" class="headerlink" title="5、-XX:ConcGCThreads=n——默认"></a>5、-XX:ConcGCThreads=n——默认</h5><p>并发GC使用的线程数。</p>
<h5 id="6、-XX-G1ReservePercent-n——默认"><a href="#6、-XX-G1ReservePercent-n——默认" class="headerlink" title="6、-XX:G1ReservePercent=n——默认"></a>6、-XX:G1ReservePercent=n——默认</h5><p>设置作为空闲的预留内存百分比，以降低目标空间溢出的风险，默认值是10%</p>
<h4 id="6、和CMS相比的优势"><a href="#6、和CMS相比的优势" class="headerlink" title="6、和CMS相比的优势"></a>6、和CMS相比的优势</h4><p>两个优势：</p>
<ol>
<li><strong>G1不会产生内存碎片</strong></li>
<li><strong>G1可以精确控制停顿</strong>。该收集器是把整个堆（新生代、老生代）划分成多个固定大小的区域，每次根据允许停顿时间去收集垃圾最多的区域。</li>
</ol>
<h4 id="7、在将要上线的项目中配置JVM参数"><a href="#7、在将要上线的项目中配置JVM参数" class="headerlink" title="7、在将要上线的项目中配置JVM参数"></a>7、在将要上线的项目中配置JVM参数</h4><p>在有包的路径下，运行jar命令，公式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -server [JVM的各种参数] -jar jar/war包的名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">java -server -Xms1024M -Xmx1024M -XX:+UseG1GC -jar Hello.jar</span><br></pre></td></tr></table></figure>



<h3 id="12、生产环境服务器变慢，诊断思路和性能评估谈谈？"><a href="#12、生产环境服务器变慢，诊断思路和性能评估谈谈？" class="headerlink" title="12、生产环境服务器变慢，诊断思路和性能评估谈谈？"></a>12、生产环境服务器变慢，诊断思路和性能评估谈谈？</h3><h4 id="1、整机：top"><a href="#1、整机：top" class="headerlink" title="1、整机：top"></a>1、整机：top</h4><p>主要关注的几个参数：</p>
<ul>
<li>lad average：三个负载值，分别代表系统在1、5、15内的负载情况。<ul>
<li>如果三个负载值的平均值超过0.6或者0.7，说明当前系统的负载比较大，需要进行优化</li>
</ul>
</li>
<li>%CPU：CPU占比</li>
<li>%MEM：内存占比</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统性能命令的精简版</span></span><br><span class="line">uptime</span><br></pre></td></tr></table></figure>



<h4 id="2、CPU：vmstat"><a href="#2、CPU：vmstat" class="headerlink" title="2、CPU：vmstat"></a>2、CPU：vmstat</h4><h5 id="1、vmstat：查看CPU（包含不限于）"><a href="#1、vmstat：查看CPU（包含不限于）" class="headerlink" title="1、vmstat：查看CPU（包含不限于）"></a>1、vmstat：查看CPU（包含不限于）</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat -n 2 3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004034427789.png" alt="image-20211004034427789"></p>
<p>一般vmstat工具的使用是通过两个数字参数来完成的，<strong>第一个参数是采样的时间间隔数单位是秒</strong>，<strong>第二个参数是采样的次数</strong>。</p>
<p><strong>-procs</strong></p>
<ul>
<li>r：<strong>运行等待CPU时间片的进程数</strong>，原则上1核的CPU运行队列不要超过2，整个系统的运行队列不能超过总核数的2倍，否则代表系统压力过大。</li>
<li>b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等。</li>
</ul>
<p><strong>-cpu</strong></p>
<ul>
<li><strong>us</strong>：<strong>用户进程消耗CPU时间百分比</strong>，us值高，用户进程小号CPU时间多，如果长期大于50%，优化程序；</li>
<li><strong>sy</strong>：<strong>内核进程消耗的CPU百分比</strong>；<ul>
<li>us + sy参考值为80%，如果us + sy大于80%，说明可能存在CPU不足</li>
</ul>
</li>
<li>id：处于空闲的CPU百分比</li>
<li>wa：系统等待IO的CPU时间百分比</li>
<li>st：来自于一个虚拟机偷取的CPU时间的百分比</li>
</ul>
<h5 id="2、vmstat：查看额外"><a href="#2、vmstat：查看额外" class="headerlink" title="2、vmstat：查看额外"></a>2、vmstat：查看额外</h5><p>查看所有cpu核信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 2</span><br></pre></td></tr></table></figure>

<p>每个进程使用cpu的用量分解信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u1 -p 进程编号</span><br></pre></td></tr></table></figure>



<h4 id="3、内存：free"><a href="#3、内存：free" class="headerlink" title="3、内存：free"></a>3、内存：free</h4><h5 id="1、应用程序可用内存数"><a href="#1、应用程序可用内存数" class="headerlink" title="1、应用程序可用内存数"></a>1、应用程序可用内存数</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free </span><br><span class="line">free -g</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004035000114.png" alt="image-20211004035000114"></p>
<p>经验：</p>
<ul>
<li>应用程序可用内存/系统物理内存&gt;70%内存充足。</li>
<li>应用程序可用内存/系统物理内存&lt;20%内存不足，需要增加内存。</li>
<li><strong>20%&lt;应用程序可用内存/系统物理内存&lt;70%内训基本够用</strong></li>
</ul>
<h5 id="2、查看额外"><a href="#2、查看额外" class="headerlink" title="2、查看额外"></a>2、查看额外</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p 进程号 -r 采样间隔秒数</span><br></pre></td></tr></table></figure>



<h4 id="4、硬盘：df"><a href="#4、硬盘：df" class="headerlink" title="4、硬盘：df"></a>4、硬盘：df</h4><p>查看磁盘剩余空间数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>



<h4 id="5、磁盘IO：iostat"><a href="#5、磁盘IO：iostat" class="headerlink" title="5、磁盘IO：iostat"></a>5、磁盘IO：iostat</h4><p><strong>磁盘I/O性能评估</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -xdk 2 3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004035101683.png" alt="image-20211004035101683"></p>
<p>磁盘块设备发布：</p>
<ul>
<li>rkB/s：每秒读取数据量kB</li>
<li>wkB/s：每秒写入数据量kB</li>
<li>svctm I/O：请求的平均等待时间，单位毫秒</li>
<li>await I/O：请求的拼接等待杰斯安，单位毫秒；值越小，性能越好</li>
<li><strong>util：疫苗中有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加硬盘</strong></li>
</ul>
<blockquote>
<p>rkB/s、wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p>
<p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，</p>
<p>如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或者更换磁盘。</p>
</blockquote>
<p><strong>查看额外</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -d 采样间隔秒数 -p 进程号</span><br></pre></td></tr></table></figure>



<h4 id="6、网络IO：ifstat"><a href="#6、网络IO：ifstat" class="headerlink" title="6、网络IO：ifstat"></a>6、网络IO：ifstat</h4><p>默认本地没有，下载ifstat：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gz</span><br><span class="line">tar -xzvf ifstat-1.1.war.gz</span><br><span class="line"><span class="built_in">cd</span> ifstat-1.1</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>查看网络IO：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20211004040241718.png" alt="image-20211004040241718"></p>
<h3 id="13、假设生产环境出现CPU占用过高，请谈谈你的分析思路和定位"><a href="#13、假设生产环境出现CPU占用过高，请谈谈你的分析思路和定位" class="headerlink" title="13、假设生产环境出现CPU占用过高，请谈谈你的分析思路和定位"></a>13、假设生产环境出现CPU占用过高，请谈谈你的分析思路和定位</h3><p>需要结合Linux和JDK命令一块分析</p>
<p>案例步骤：</p>
<ol>
<li>先用top命令找出CPU占比最高的</li>
<li>ps -ef或者jps进一步定位，得知是一个怎么样的一个后台程序惹事</li>
<li><strong>定位到具体线程或者代码</strong><ul>
<li>ps -mp pid -o THREAD,tid,time<ul>
<li>-m：显示所有的线程</li>
<li>-p pid进程使用cpu的时间</li>
<li>-o该参数后是用户自定义格式</li>
</ul>
</li>
</ul>
</li>
<li>将需要的<strong>线程ID</strong>转换为16进制格式（英文小写格式）<ul>
<li>printf “%x\n”有问题的线程ID</li>
</ul>
</li>
<li>jstack 进程ID | grep（16进制线程ID小写英文） -A60<ul>
<li>-A60指的是打印出前60行</li>
</ul>
</li>
</ol>
<h3 id="14、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？"><a href="#14、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？" class="headerlink" title="14、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？"></a>14、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？</h3><h4 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools">相关网站</a></p>
<h4 id="2、性能监控工具"><a href="#2、性能监控工具" class="headerlink" title="2、性能监控工具"></a>2、性能监控工具</h4><ul>
<li>jps</li>
<li>jinfo</li>
<li>jmap</li>
<li>jstat</li>
<li>jstack</li>
</ul>
<hr>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="1、Elasticsearch-和-solr-的区别"><a href="#1、Elasticsearch-和-solr-的区别" class="headerlink" title="1、Elasticsearch 和 solr 的区别"></a>1、Elasticsearch 和 solr 的区别</h3><p>背景：</p>
<ul>
<li>它们都是基于Lucene搜索服务器基础之上开发，一款优秀的，<strong>高性能</strong>的企业级搜索服务器。<ul>
<li>高性能是因为他们都是基于分词技术构建的<strong>倒排索引</strong>的方式进行查询</li>
</ul>
</li>
<li>开发语言：java语言开发</li>
<li>诞生时间：<ul>
<li>Solr ：2004年诞生。</li>
<li>Es：2010年诞生。</li>
</ul>
</li>
<li>Es 比Solr更新，因此Es的功能越强大</li>
</ul>
<p>区别：</p>
<ol>
<li>当<strong>实时建立索引</strong>的时候，<strong>solr会产生io阻塞，而es则不会，es查询性能要高于solr。</strong></li>
<li>在<strong>不断动态添加数据</strong>的时候，<strong>solr的检索效率会变的低下，而es则没有什么变化。</strong></li>
<li><strong>Solr利用zookeeper进行分布式管理</strong>，而<strong>es自身带有分布式系统管理功能</strong>。</li>
<li><strong>Solr一般都要部署到web服务器上，比如tomcat</strong>。启动tomcat的时候需要配置tomcat与solr的关联。<ul>
<li><strong>Solr 的本质是一个动态web项目</strong></li>
</ul>
</li>
<li><strong>Solr支持更多的格式数据[xml,json,csv等]，而es仅支持json文件格式。</strong></li>
<li><strong>Solr是传统搜索应用的有力解决方案</strong>，但是<strong>es更适用于新兴的实时搜索应用</strong>。<ul>
<li><strong>单纯的对已有数据进行检索的时候，solr效率更好，高于es。</strong></li>
<li>如果是对实时建立索引的数据，而且需要不断动态添加数据，使用es会更好</li>
<li>现在的互联网数据基本上都是不断动态变化的，因此Es运用得比solr更多</li>
</ul>
</li>
<li><strong>Solr官网提供的功能更多</strong>，而<strong>es本身更注重于核心功能，高级功能多有第三方插件。</strong></li>
</ol>
<p>关于solr与Es的集群：</p>
<ul>
<li><p>SolrCloud:集群图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223828690.png" alt="image-20210925223828690"></p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223911772.png" alt="image-20210925223911772"></p>
</li>
<li><p>Elasticsearch：集群图</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925223950346.png" alt="image-20210925223950346"></p>
</li>
</ul>
<hr>
<h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><h3 id="1、单点登陆的实现"><a href="#1、单点登陆的实现" class="headerlink" title="1、单点登陆的实现"></a>1、单点登陆的实现</h3><p>单点登录：一处登录多处使用！</p>
<ul>
<li>如：使用浏览器在网页当中登陆京东账号，打开另外有关京东的网页，发现已经是登陆的状态了</li>
</ul>
<p>单点登陆的前提：单点登录<strong>多使用在分布式系统中</strong></p>
<ul>
<li>也不是说普通的web项目不能使用单点登陆，只能说是没有必要</li>
</ul>
<p>实现思路流程图：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925224505115.png" alt="image-20210925224505115"></p>
<blockquote>
<p>注意：这里的单点登陆是基于cookie的，是将token放入到cookie中的。如果浏览器禁用cookie的话，那么就无法实现单点登陆功能，甚至还会登陆失败。</p>
</blockquote>
<h3 id="2、购物车的实现"><a href="#2、购物车的实现" class="headerlink" title="2、购物车的实现"></a>2、购物车的实现</h3><p>分析：</p>
<p>购物车：</p>
<ol>
<li>购物车跟用户的关系?<ul>
<li>一个用户必须对应一个购物车【一个用户不管买多少商品，都会存在属于自己的购物车中。】</li>
<li>单点登录一定在购物车之前。</li>
</ul>
</li>
<li>跟购物车有关的操作有哪些?<ul>
<li>添加购物车<ul>
<li>用户未登录状态<ul>
<li>添加到什么地方?未登录将数据保存到什么地方?<ul>
<li>Redis — 京东</li>
<li><strong>Cookie</strong> — 自己开发项目的时候【如果浏览器禁用cookie，就只能使用Redis了】</li>
</ul>
</li>
</ul>
</li>
<li>用户登录状态<ul>
<li>Redis 缓存中 【读写速度快】<ul>
<li>Hash ：hset(key,field,value)<ul>
<li>Key:user:userId:cart</li>
<li>Hset(key,skuId,value);</li>
</ul>
</li>
</ul>
</li>
<li>存在数据库中【oracle，mysql】</li>
</ul>
</li>
</ul>
</li>
<li>展示购物车<ul>
<li>未登录状态展示<ul>
<li>直接从cookie 中取得数据展示即可</li>
</ul>
</li>
<li>登录状态<ul>
<li>用户一旦登录：必须显示数据库【redis】+ cookie 中的购物车的数据<ul>
<li>Cookie 中有三条记录</li>
<li>Redis中有五条记录</li>
<li>真正展示的时候应该是八条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="1、消息队列在项目中的使用"><a href="#1、消息队列在项目中的使用" class="headerlink" title="1、消息队列在项目中的使用"></a>1、消息队列在项目中的使用</h3><p>背景：<strong>在分布式系统中是如何处理高并发的</strong>。</p>
<p>由于在高并发的环境下，来不及同步处理用户发送的请求，则会导致请求发生阻塞。比如说，大量的insert，update之类的请求同时到达数据库MYSQL，直接导致了无数的行锁表锁的产生，甚至会导致请求堆积很多。从而触发 too many connections 错误。使用消息队列可以解决【异步通信】</p>
<ol>
<li><p>异步</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225359975.png" alt="image-20210925225359975"></p>
</li>
<li><p>并行</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225423420.png" alt="image-20210925225423420"></p>
</li>
<li><p>排队（起到削峰填谷的作用）</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225451607.png" alt="image-20210925225451607"></p>
</li>
</ol>
<p>消息队列在电商的使用场景：</p>
<p><img src="/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210925225658814.png" alt="image-20210925225658814"></p>
<p>消息队列的弊端：</p>
<ul>
<li><strong>消息的不确定性</strong>：使用延迟队列，轮询技术来解决该问题即可！</li>
</ul>
<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/oneby1314/article/details/113789384">第 4 章 Spring</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/youzhibing/p/14337244.html">Spring 的循环依赖，源码详细分析 → 真的非要三级缓存吗</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64d422217685">spring循环依赖一定要三级缓存吗？就算用来解决AOP，也需要三级缓存吗？</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">http://xgh-user.github.io/2021/09/23/面试题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/11/Linux/" rel="prev" title="Linux">
      <i class="fa fa-chevron-left"></i> Linux
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95"><span class="nav-number">1.</span> <span class="nav-text">面试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-SE"><span class="nav-number">1.1.</span> <span class="nav-text">JAVA SE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E5%A2%9E%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、自增变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-1"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Singleton"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、单例模式——Singleton</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-2"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSingleton%EF%BC%9F"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">1、什么是Singleton？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%A6%81%E7%82%B9"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">2、要点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.1.2.2.3.</span> <span class="nav-text">3、几种常见形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.2.2.4.</span> <span class="nav-text">4、实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E7%AE%80%E6%B4%81%E7%9B%B4%E8%A7%82%EF%BC%89"><span class="nav-number">1.1.2.2.4.1.</span> <span class="nav-text">1、饿汉式——直接实例化饿汉式（简洁直观）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE%E5%BC%8F%EF%BC%88%E6%9C%80%E7%AE%80%E6%B4%81%E3%80%81%E6%9C%80%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">1.1.2.2.4.2.</span> <span class="nav-text">2、饿汉式——枚举式（最简洁、最安全）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%80%82%E5%90%88%E5%A4%8D%E6%9D%82%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89%EF%BC%88%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9D%A5%E8%A7%A3%E8%80%A6%E5%90%88%EF%BC%89"><span class="nav-number">1.1.2.2.4.3.</span> <span class="nav-text">3、饿汉式——静态代码块饿汉式（适合复杂实例化）（可以使用配置文件来解耦合）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-number">1.1.2.2.4.4.</span> <span class="nav-text">4、懒汉式——线程不安全（适用于单线程）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E5%8A%A0%E9%94%81%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-number">1.1.2.2.4.5.</span> <span class="nav-text">5、懒汉式——线程安全（加锁，适用于多线程）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%95%88%E7%8E%87%E6%AF%94%E5%8A%A0%E9%94%81%E9%AB%98%EF%BC%89"><span class="nav-number">1.1.2.2.4.6.</span> <span class="nav-text">6、懒汉式——双重检查（适用于多线程，效率比加锁高）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%BD%A2%E5%BC%8F%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-number">1.1.2.2.4.7.</span> <span class="nav-text">7、懒汉式——静态内部类形式（适用于多线程）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、类初始化与实例初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-3"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">1、类初始化过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">2、实例初始化过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">3、方法的重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.4.</span> <span class="nav-text">4、方法参数传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-4"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.1.5.</span> <span class="nav-text">5、递归与迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-5"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-4"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">1、递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">2、循环迭代</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">6、成员变量与局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95-6"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-5"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8Fjava%E5%86%85%E9%83%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.1.7.</span> <span class="nav-text">7、字符串常量java内部加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B2-4-3"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">面试——《深入理解Java虚拟机第三版》2.4.3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-6"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81OpenJDK8%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">1、OpenJDK8底层源码说明问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81System%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.7.2.1.1.</span> <span class="nav-text">1、System源码解析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8Crt-jar"><span class="nav-number">1.1.7.2.1.2.</span> <span class="nav-text">2、类加载器和rt.jar</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8EString-%E7%9A%84-intern%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.7.2.2.</span> <span class="nav-text">2、关于String 的 intern方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-EE"><span class="nav-number">1.2.</span> <span class="nav-text">JAVA EE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Spring-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、Spring Bean 的作用域之间有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Spring%E6%94%AF%E6%8C%81%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、Spring支持的常用数据库事务传播属性和事务隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%EF%BC%9F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1、什么是事务的传播？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2、事务的传播行为种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BE%8B%E5%AD%90"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3、例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81REQUIRED"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">1、REQUIRED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81REQUIRES-NEW"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">2、REQUIRES_NEW</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">4、数据库的事务并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">5、隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%90%84%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">6、各个隔离级别解决并发问题的能力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A7%E5%93%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%94%AF%E6%8C%81%E7%A8%8B%E5%BA%A6"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">7、各种数据库产品对事务隔离级别的支持程度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81SpringMVC%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3POST%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、SpringMVC如何解决POST请求中文乱码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8BSpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、简单谈一下SpringMVC的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81MyBatis%E4%B8%AD%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、MyBatis中当实体类中的属性名和表中的字段名不一样的解决方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%EF%BC%9A%E4%B8%BB%E8%A6%81%E8%80%83%E5%AF%9FIOC-AOP-TX%EF%BC%88%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">Spring：主要考察IOC + AOP +TX（事务相关）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Aop%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、Aop的常用注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%9C%89%E5%85%B3%E4%BA%8ESpring-aop%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、有关于Spring aop的面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Srping-aop%E5%85%A8%E9%83%A8%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1、Srping aop全部通知顺序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Spring4%E7%9A%84aop%E7%9A%84%E5%85%A8%E9%83%A8%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">1、Spring4的aop的全部通知顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Spring5%E7%9A%84aop%E7%9A%84%E5%85%A8%E9%83%A8%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">2、Spring5的aop的全部通知顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Srping-aop%E5%85%A8%E9%83%A8%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">3、Srping aop全部通知顺序总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Spring-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2、Spring 的循环依赖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">1、相关面试题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">2、什么是循环依赖？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%A4%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%AF%B9%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">3、两种注入方式对循环依赖的影响</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E9%82%A3%E4%B9%88Spring%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%91%A2"><span class="nav-number">1.3.2.2.4.</span> <span class="nav-text">4、那么Spring底层是怎么解决循环依赖的呢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%BA%90%E7%A0%81-Deug-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.3.2.2.5.</span> <span class="nav-text">5、源码 Deug 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96-amp-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.2.2.5.1.</span> <span class="nav-text">1、实例化 &amp; 初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%813%E4%B8%AAMap-amp-5%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.2.5.2.</span> <span class="nav-text">2、3个Map &amp; 5个方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="nav-number">1.3.2.2.5.3.</span> <span class="nav-text">3、对象在三级缓存中的迁移</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E8%AF%A6%E7%BB%86-Debug-%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.2.6.</span> <span class="nav-text">6、详细 Debug 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81beanA%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.3.2.2.6.1.</span> <span class="nav-text">1、beanA的实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81beanA-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.2.2.6.2.</span> <span class="nav-text">2、beanA 的属性填充——初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81beanB-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.3.2.2.6.3.</span> <span class="nav-text">3、beanB 的实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81beanB-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.2.2.6.4.</span> <span class="nav-text">4、beanB 的属性填充——初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81beanA-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85"><span class="nav-number">1.3.2.2.6.5.</span> <span class="nav-text">5、beanA 的属性填充</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.2.2.6.6.</span> <span class="nav-text">6、循环依赖总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.2.2.7.</span> <span class="nav-text">7、三级缓存总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.2.2.8.</span> <span class="nav-text">8、Spring循环依赖+AOP源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%BE%9D%E8%B5%96%EF%BC%8C%E6%9C%89-AOP"><span class="nav-number">1.3.2.2.8.1.</span> <span class="nav-text">1、情况一：没有依赖，有 AOP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%8C%E6%B2%A1%E6%9C%89AOP"><span class="nav-number">1.3.2.2.8.2.</span> <span class="nav-text">2、情况二：循环依赖，没有AOP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-AOP"><span class="nav-number">1.3.2.2.8.3.</span> <span class="nav-text">3、情况三：循环依赖 + AOP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%83%85%E5%86%B5%E5%9B%9B%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-AOP-%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.2.2.8.4.</span> <span class="nav-text">4、情况四：循环依赖 + AOP + 删除第三级缓存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%83%85%E5%86%B5%E4%BA%94%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-AOP-%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.2.2.8.5.</span> <span class="nav-text">5、情况五：循环依赖 + AOP + 注解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.2.2.8.6.</span> <span class="nav-text">6、总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E8%A7%A3%E7%AD%94"><span class="nav-number">1.3.2.2.9.</span> <span class="nav-text">9、循环依赖于三级缓存相关面试解答</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%AF%B4%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">1.3.2.2.9.1.</span> <span class="nav-text">1、说下什么是循环依赖</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%82%A3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2"><span class="nav-number">1.3.2.2.9.2.</span> <span class="nav-text">2、那循环依赖会有什么问题呢</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%82%A3%E4%B9%88Spring-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.3.2.2.9.3.</span> <span class="nav-text">3、那么Spring 是如何解决的呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E9%87%8C%E9%9D%A2%E5%88%86%E5%88%AB%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.2.2.9.4.</span> <span class="nav-text">4、三级缓存里面分别存的什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81Spring%E4%BD%BF%E7%94%A8%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%89%8D%E6%8F%90%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.2.2.9.5.</span> <span class="nav-text">5、Spring使用三级缓存解决循环依赖的前提是什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AA%E7%94%A8%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%8C%E5%8F%AA%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%89"><span class="nav-number">1.3.2.2.9.6.</span> <span class="nav-text">6、为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E5%A6%82%E6%9E%9C%E5%B0%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%8F%90%E5%89%8D%EF%BC%8C%E7%B4%A7%E9%9A%8F%E4%BA%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%80%8C%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%89%8D%EF%BC%8C%E9%82%A3%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8F%AA%E7%94%A8%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BA%86%EF%BC%9F"><span class="nav-number">1.3.2.2.9.7.</span> <span class="nav-text">7、如果将代理对象的创建过程提前，紧随于实例化之后，而在初始化之前，那是不是就可以只用两级缓存了？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">1.4.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Linux%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、Linux常用服务类相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81service-Centos6"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1、service (Centos6)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81systemctl-Centos7"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2、systemctl (Centos7)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">1.5.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81git%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.1.</span> <span class="nav-text">1、git分支相关命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%AF%B7%E8%AE%B2%E4%B8%80%E4%B8%8BGit%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">2、请讲一下Git的工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81GitHub%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%8D"><span class="nav-number">1.5.3.</span> <span class="nav-text">3、GitHub的常用词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81in%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%88%B6%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4"><span class="nav-number">1.5.4.</span> <span class="nav-text">4、in关键字限制搜索范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81stars%E6%88%96fork%E6%95%B0%E9%87%8F%E5%85%B3%E9%94%AE%E8%AF%8D%E5%8E%BB%E6%9F%A5%E6%89%BE"><span class="nav-number">1.5.5.</span> <span class="nav-text">5、stars或fork数量关键词去查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81awesome%E5%8A%A0%E5%BC%BA%E6%90%9C%E7%B4%A2"><span class="nav-number">1.5.6.</span> <span class="nav-text">6、awesome加强搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%E6%9F%90%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.7.</span> <span class="nav-text">7、高亮显示某一行代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E9%A1%B9%E7%9B%AE%E5%86%85%E6%90%9C%E7%B4%A2"><span class="nav-number">1.5.8.</span> <span class="nav-text">8、项目内搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E6%90%9C%E7%B4%A2%E6%9F%90%E4%B8%AA%E5%9C%B0%E5%8C%BA%E5%86%85%E7%9A%84%E5%A4%A7%E4%BD%AC"><span class="nav-number">1.5.9.</span> <span class="nav-text">9、搜索某个地区内的大佬</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">1.6.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.6.1.</span> <span class="nav-text">1、redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81RDB"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1、RDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81AOF"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">2、AOF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.6.2.</span> <span class="nav-text">2、Redis在项目中的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Redis-6-0-7%E7%9A%84bug"><span class="nav-number">1.6.3.</span> <span class="nav-text">3、Redis 6.0.7的bug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Redis-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8"><span class="nav-number">1.6.4.</span> <span class="nav-text">4、Redis 命令大全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.6.5.</span> <span class="nav-text">5、Redis的分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">1、分布式锁的常见面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%9C%80%E7%BB%88%E5%BD%A2%E6%88%90"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">2、为什么需要分布式锁？分布式锁的最终形成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%89%88%E6%9C%AC1-0%EF%BC%9A%E5%8D%95%E6%9C%BA%E7%89%88-amp-%E6%B2%A1%E5%8A%A0%E9%94%81"><span class="nav-number">1.6.5.2.1.</span> <span class="nav-text">1、版本1.0：单机版&amp;没加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%89%88%E6%9C%AC2-0%EF%BC%9A%E5%8D%95%E6%9C%BA%E7%89%88-amp-%E5%8A%A0%E9%94%81"><span class="nav-number">1.6.5.2.2.</span> <span class="nav-text">2、版本2.0：单机版&amp;加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%89%88%E6%9C%AC3-0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88-amp-%E4%B8%8D%E5%8A%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.6.5.2.3.</span> <span class="nav-text">3、版本3.0：分布式版&amp;不加分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%89%88%E6%9C%AC4-0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88-amp-%E7%94%A8redis%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.6.5.2.4.</span> <span class="nav-text">4、版本4.0：分布式版&amp;用redis做分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%89%88%E6%9C%AC5-0%EF%BC%9Afinally%E7%89%88"><span class="nav-number">1.6.5.2.5.</span> <span class="nav-text">5、版本5.0：finally版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E7%89%88%E6%9C%AC6-0%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%89%88"><span class="nav-number">1.6.5.2.6.</span> <span class="nav-text">6、版本6.0：过期时间版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E7%89%88%E6%9C%AC7-0%EF%BC%9A%E5%8A%A0%E9%94%81%E5%8E%9F%E5%AD%90%E7%89%88"><span class="nav-number">1.6.5.2.7.</span> <span class="nav-text">7、版本7.0：加锁原子版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81%E7%89%88%E6%9C%AC8-0%EF%BC%9A%E5%8A%A0UUID%E9%98%B2%E6%AD%A2%E5%BC%A0%E5%86%A0%E6%9D%8E%E6%88%B4"><span class="nav-number">1.6.5.2.8.</span> <span class="nav-text">8、版本8.0：加UUID防止张冠李戴</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81%E7%89%88%E6%9C%AC9-0%EF%BC%9A%E8%A7%A3%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.6.5.2.9.</span> <span class="nav-text">9、版本9.0：解锁原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%89%88%E6%9C%AC9-1%EF%BC%9A%E8%A7%A3%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E2%80%94%E2%80%94lura%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E8%A7%A3%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.6.5.2.9.1.</span> <span class="nav-text">1、版本9.1：解锁原子性——lura脚本保证解锁原子性操作（常用）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%89%88%E6%9C%AC9-2%EF%BC%9A%E8%A7%A3%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E2%80%94%E2%80%94Redis%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E8%A7%A3%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.5.2.9.2.</span> <span class="nav-text">2、版本9.2：解锁原子性——Redis事务保证解锁原子性操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10%E3%80%81%E7%89%88%E6%9C%AC10-0%EF%BC%9A%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F%E7%89%88"><span class="nav-number">1.6.5.2.10.</span> <span class="nav-text">10、版本10.0：自动续期版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.5.2.11.</span> <span class="nav-text">11、分布式锁总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Redis-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">3、Redis 删除策略与缓存淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Redis-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.6.5.3.1.</span> <span class="nav-text">1、Redis 缓存淘汰策略相关的面试题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81redis-%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.6.5.3.2.</span> <span class="nav-text">2、redis 内存满了怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-redis-%E6%9C%80%E5%A4%A7%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-number">1.6.5.3.2.1.</span> <span class="nav-text">1、如何查看 redis 最大占用内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81redis-%E4%BC%9A%E5%8D%A0%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%BA%E5%99%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.6.5.3.2.2.</span> <span class="nav-text">2、redis 会占用物理机器多少内存？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%B8%80%E8%88%AC%E7%94%9F%E4%BA%A7%E4%B8%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-redis-%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">1.6.5.3.2.3.</span> <span class="nav-text">3、一般生产上如何配置 redis 的内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-redis-%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.6.5.3.2.4.</span> <span class="nav-text">4、如何修改 redis 内存设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B-redis-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">1.6.5.3.2.5.</span> <span class="nav-text">5、通过命令查看 redis 内存使用情况?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E5%A6%82%E6%9E%9C%E6%8A%8A-redis-%E5%86%85%E5%AD%98%E6%89%93%E6%BB%A1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88-%E5%A6%82%E6%9E%9C-redis-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E8%B6%85%E5%87%BA%E4%BA%86%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.6.5.3.2.6.</span> <span class="nav-text">6、如果把 redis 内存打满了会发生什么? 如果 redis 内存使用超出了设置的最大值会怎样?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81redis-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.5.3.3.</span> <span class="nav-text">3、redis 删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81redis%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.5.3.3.1.</span> <span class="nav-text">1、redis过期键的删除策略</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.5.3.4.</span> <span class="nav-text">4、Redis的缓存淘汰策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81redis-LRU-%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.5.3.5.</span> <span class="nav-text">5、redis LRU 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81LRU-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="nav-number">1.6.5.3.5.1.</span> <span class="nav-text">1、LRU 算法简介</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81LRU-%E7%AE%97%E6%B3%95%E9%A2%98%E6%9D%A5%E6%BA%90"><span class="nav-number">1.6.5.3.5.2.</span> <span class="nav-text">2、LRU 算法题来源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81LRU-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">1.6.5.3.5.3.</span> <span class="nav-text">3、LRU 算法设计思想</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81LRU-%E7%AE%97%E6%B3%95%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.3.5.4.</span> <span class="nav-text">4、LRU 算法编码实现</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql"><span class="nav-number">1.7.</span> <span class="nav-text">MySql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Mysql%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">1、Mysql什么时候建索引，什么时候不能建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">1、索引是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">2、索引的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">3、什么时候建索引，什么时候不能建索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">1.8.</span> <span class="nav-text">JUC多线程及高并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.8.1.</span> <span class="nav-text">1、谈谈你对volatile的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E7%AD%94"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1、解答</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%B0%88%E8%B0%88JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">2、谈谈JMM（Java内存模型）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">3、解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81volatile%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.1.3.1.</span> <span class="nav-text">1、volatile解决可见性问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81volatile%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.1.3.2.</span> <span class="nav-text">2、volatile不能解决原子性问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">1.8.1.3.3.</span> <span class="nav-text">3、volatile禁止指令重排序——保证有序性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81volatile%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.1.3.4.</span> <span class="nav-text">4、volatile底层原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8"><span class="nav-number">1.8.1.3.5.</span> <span class="nav-text">4、保证线程的安全</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%A0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E8%BF%87volatile%EF%BC%9F"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">4、你在哪些地方用过volatile？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81CAS%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97"><span class="nav-number">1.8.2.</span> <span class="nav-text">2、CAS你知道吗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">1、什么是CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81CAS%E7%9A%84%E5%BA%95%E5%B1%82"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2、CAS的底层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Unsafe"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">3、Unsafe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81CAS%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8E%9F%E5%AD%90%E7%B1%BBAtomiclnteger%E7%9A%84ABA%E9%97%AE%E9%A2%98%E8%B0%88%E8%B0%88%EF%BC%9F%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">4、CAS的缺点是什么？原子类Atomiclnteger的ABA问题谈谈？原子更新引用知道吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.2.4.1.</span> <span class="nav-text">1、ABA问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">1.8.2.4.2.</span> <span class="nav-text">2、循环时间长开销大</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.4.3.</span> <span class="nav-text">3、只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93ArrayList%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%8C%E8%AF%B7%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%A1%88%E4%BE%8B%E5%B9%B6%E7%BB%99%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.8.3.</span> <span class="nav-text">3、我们知道ArrayList是线程不安全，请编写一个不安全的案例并给出解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%AF%B7%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.8.4.</span> <span class="nav-text">4、公平锁&#x2F;非公平锁&#x2F;可重入锁&#x2F;递归锁&#x2F;自旋锁谈谈你的理解？请手写一个自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">1、公平锁和非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.8.4.1.1.</span> <span class="nav-text">1、是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.4.1.2.</span> <span class="nav-text">2、两者区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81ReentrantLock-%E4%B8%8E-Synchronized"><span class="nav-number">1.8.4.1.3.</span> <span class="nav-text">3、ReentrantLock 与  Synchronized</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E5%8F%88%E5%90%8D%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">2、可重入锁（又名递归锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%8B%AC%E5%8D%A0%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">3、独占锁&#x2F;共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.8.4.4.</span> <span class="nav-text">4、自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81synchronized%E5%92%8Clock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%94%A8%E6%96%B0%E7%9A%84lock%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%BD%A0%E4%B8%BE%E4%BE%8B%E8%AF%B4%E8%AF%B4"><span class="nav-number">1.8.4.5.</span> <span class="nav-text">5、synchronized和lock有什么区别？用新的lock有什么好处？你举例说说</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81CountDownLatch-CyclicBarrier-Semaphore"><span class="nav-number">1.8.5.</span> <span class="nav-text">5、CountDownLatch&#x2F;CyclicBarrier&#x2F;Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81CountDownLatch%E2%80%94%E2%80%94%E5%81%9A%E5%87%8F%E6%B3%95"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">1、CountDownLatch——做减法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81CyclicBarrier%E2%80%94%E2%80%94%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">2、CyclicBarrier——做加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Semaphore%E2%80%94%E2%80%94%E4%BC%B8%E7%BC%A9%EF%BC%88%E5%8A%A0%E5%87%8F%E6%B3%95%EF%BC%89"><span class="nav-number">1.8.5.3.</span> <span class="nav-text">3、Semaphore——伸缩（加减法）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9F%A5%E9%81%93%E5%90%97"><span class="nav-number">1.8.6.</span> <span class="nav-text">6、阻塞队列知道吗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%98%9F%E5%88%97-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">1、队列+阻塞队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">2、为什么用？有什么好处？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86-%E7%A7%8D%E7%B1%BB%E5%88%86%E6%9E%90"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">3、架构梳理+种类分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81BlockingQueue%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.6.4.</span> <span class="nav-text">4、BlockingQueue的核心方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">1.8.6.5.</span> <span class="nav-text">5、阻塞队列用在哪里</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E4%BD%BF%E7%94%A8FutureTask-%E4%B8%8E-Callable%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.7.</span> <span class="nav-text">7、使用FutureTask 与 Callable的几个注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8FutureTask%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.7.1.</span> <span class="nav-text">1、使用FutureTask的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Java%E6%9C%89%E4%BA%86Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81Callable%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">1.8.7.2.</span> <span class="nav-text">2、Java有了Runnable接口，为什么还需要Callable接口？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9FThreadPoolExecutor%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.8.8.</span> <span class="nav-text">8、线程池用过吗？ThreadPoolExecutor谈谈你的理解？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.8.8.1.</span> <span class="nav-text">1、为什么用线程池？——线程池的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">1.8.8.2.</span> <span class="nav-text">2、线程池如何使用？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.8.8.2.1.</span> <span class="nav-text">1、架构说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.8.2.2.</span> <span class="nav-text">2、编码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81Executors-newFixedThreadPool-int"><span class="nav-number">1.8.8.2.2.1.</span> <span class="nav-text">1、Executors.newFixedThreadPool(int)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Executors-newSingleThreadExecutor"><span class="nav-number">1.8.8.2.2.2.</span> <span class="nav-text">2、Executors.newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81Executors-newCachedThreadPool"><span class="nav-number">1.8.8.2.2.3.</span> <span class="nav-text">3、Executors.newCachedThreadPool()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81ThreadPoolExcutor"><span class="nav-number">1.8.8.2.3.</span> <span class="nav-text">3、ThreadPoolExcutor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.8.8.3.</span> <span class="nav-text">3、线程池的几个重要参数介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ThreadPoolExecutor%E7%9A%84%E5%BA%95%E5%B1%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E4%B8%83%E7%A7%8D%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8D%B4%E5%8F%AA%E6%9C%895%E4%B8%AA%EF%BC%9F%E5%89%A9%E4%B8%8B%E7%9A%84%E9%82%A3%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.8.8.3.1.</span> <span class="nav-text">为什么在ThreadPoolExecutor的底层构造函数有七种参数，而线程池的创建却只有5个？剩下的那两个参数是什么？有什么作用？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.8.8.4.</span> <span class="nav-text">4、说说线程池的底层工作原理？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E7%94%9F%E4%BA%A7%E4%B8%8A%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%90%88%E7%90%86%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">1.8.9.</span> <span class="nav-text">9、线程池用过吗？生产上你是如何设置合理参数？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E4%BD%A0%E8%B0%88%E8%B0%88%EF%BC%9FJDK%E5%86%85%E7%BD%AE%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.8.9.1.</span> <span class="nav-text">1、线程池的拒绝策略你谈谈？JDK内置的拒绝策略有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%8D%95%E4%B8%80%E7%9A%84-%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%9A%84-%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8D%95%E9%87%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%A0%E7%94%A8%E5%93%AA%E4%B8%AA%E5%A4%9A%EF%BC%9F"><span class="nav-number">1.8.9.2.</span> <span class="nav-text">2、你在工作中单一的&#x2F;固定数的&#x2F;可变的单重创建线程池的方法，你用哪个多？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E7%9A%84%EF%BC%9F"><span class="nav-number">1.8.9.3.</span> <span class="nav-text">3、合理配置线程池你是如何考虑的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E6%AD%BB%E9%94%81%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90"><span class="nav-number">1.8.10.</span> <span class="nav-text">10、死锁编程及定位分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81Java%E9%87%8C%E9%9D%A2%E9%94%81%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E8%83%BD%E8%AF%B4%E5%A4%9A%E5%B0%91%E8%AF%B4%E5%A4%9A%E5%B0%91"><span class="nav-number">1.8.11.</span> <span class="nav-text">11、Java里面锁请谈谈你的理解，能说多少说多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E5%85%B3%E4%BA%8ELockSupport%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.8.12.</span> <span class="nav-text">12、关于LockSupport的面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%85%88%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%E5%90%8E%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.8.12.1.</span> <span class="nav-text">1、为什么可以先唤醒线程后阻塞线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%94%A4%E9%86%92%E4%B8%A4%E4%B8%AA%E5%90%8E%E9%98%BB%E5%A1%9E%E4%B8%A4%E6%AC%A1%E3%80%82%E4%BD%86%E6%98%AF%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%E8%BF%98%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.8.12.2.</span> <span class="nav-text">2、为什么唤醒两个后阻塞两次。但是最终结果还会阻塞线程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E5%85%B3%E4%BA%8EAQS"><span class="nav-number">1.8.13.</span> <span class="nav-text">13、关于AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81AQS-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.8.13.1.</span> <span class="nav-text">1、AQS 是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81AQS-%E6%98%AF-JUC-%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-number">1.8.13.2.</span> <span class="nav-text">2、AQS 是 JUC 的基石</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81AQS-%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="nav-number">1.8.13.3.</span> <span class="nav-text">3、AQS 能干嘛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AQS-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86"><span class="nav-number">1.8.13.4.</span> <span class="nav-text">4、AQS 初步认识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81AQS%E5%88%9D%E8%AF%86"><span class="nav-number">1.8.13.4.1.</span> <span class="nav-text">1、AQS初识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81AQS%E5%86%85%E9%83%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">1.8.13.4.2.</span> <span class="nav-text">2、AQS内部体系架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.13.4.3.</span> <span class="nav-text">3、总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81AQS%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%92%E9%98%9F%E7%9A%84%EF%BC%9F"><span class="nav-number">1.8.13.4.4.</span> <span class="nav-text">4、AQS底层是怎么排队的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81AQS%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E9%80%9A%E8%BF%87ReentrantLock%E4%B8%BA%E7%AA%81%E7%A0%B4%E5%8F%A3%EF%BC%89"><span class="nav-number">1.8.13.5.</span> <span class="nav-text">5、AQS的源码解读（通过ReentrantLock为突破口）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8A%A0%E9%94%81"><span class="nav-number">1.8.13.5.1.</span> <span class="nav-text">1、加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E9%94%81"><span class="nav-number">1.8.13.5.2.</span> <span class="nav-text">2、解锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81AQS-%E7%9A%84%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9"><span class="nav-number">1.8.13.5.3.</span> <span class="nav-text">3、AQS 的面试考点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.9.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%8CGC%E5%8F%91%E7%94%9F%E5%9C%A8JVM%E5%93%AA%E9%83%A8%E5%88%86%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8DGC%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.9.1.</span> <span class="nav-text">1、JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，它们的算法是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.2.</span> <span class="nav-text">2、JVM内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.3.</span> <span class="nav-text">3、关于类加载子系统常问的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">1、类加载器有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">2、双亲委派机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">3、沙箱安全机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81GC-Roots%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.9.4.</span> <span class="nav-text">4、GC Roots的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">1、什么是垃圾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">2、要进行垃圾回收，如何判断一个对象是否可以被回收？——两种算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.9.4.2.1.</span> <span class="nav-text">1、引用计数法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%81%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.9.4.2.2.</span> <span class="nav-text">2、枚举根节点做可达性分析（根搜索路径算法）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Java%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.4.3.</span> <span class="nav-text">3、Java中可以作为GC Roots的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E4%BD%A0%E8%AF%B4%E4%BD%A0%E5%81%9A%E8%BF%87JVM%E8%B0%83%E4%BC%98%E5%92%8C%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BJVM%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">1.9.5.</span> <span class="nav-text">5、你说你做过JVM调优和参数配置，请问如何查看JVM系统默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81JVM%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">1、JVM的参数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81-Xms%E5%92%8C-Xmx%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E7%A7%8D%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">2、-Xms和-Xmx是属于哪一种参数类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%80%8E%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8VM%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%BF%E7%94%A8java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%80%BB%E9%87%8F%E7%AD%89%E7%AD%89%E4%BF%A1%E6%81%AF"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">3、怎么不使用VM参数，使用java代码的方式查看当前进程的内存总量等等信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%9B%98%E7%82%B9%E5%AE%B6%E5%BA%95%E6%9F%A5%E7%9C%8BJVM%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">1.9.5.4.</span> <span class="nav-text">4、盘点家底查看JVM默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8Djava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9D%E5%A7%8B%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">1.9.5.4.1.</span> <span class="nav-text">1、查看当前java虚拟机的初始默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8Djava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%AE%E6%94%B9%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%90%8E%E7%9A%84%E5%80%BC"><span class="nav-number">1.9.5.4.2.</span> <span class="nav-text">2、查看当前java虚拟机修改更新之后的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E5%9C%A8VM%E5%BD%93%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-number">1.9.5.4.3.</span> <span class="nav-text">3、查看在VM当中设置的参数值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%B7%A5%E4%BD%9C%E7%94%A8%E8%BF%87%E7%9A%84JVM%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.6.</span> <span class="nav-text">6、你平时工作用过的JVM常用基本配置参数有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">1、常用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81-Xms"><span class="nav-number">1.9.6.1.1.</span> <span class="nav-text">1、-Xms</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81-Xmx"><span class="nav-number">1.9.6.1.2.</span> <span class="nav-text">2、-Xmx</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81-Xss"><span class="nav-number">1.9.6.1.3.</span> <span class="nav-text">3、-Xss</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81-Xmn"><span class="nav-number">1.9.6.1.4.</span> <span class="nav-text">4、-Xmn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81-XX-MetaspaceSize"><span class="nav-number">1.9.6.1.5.</span> <span class="nav-text">5、-XX:MetaspaceSize</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81-XX-PrintGCDetails"><span class="nav-number">1.9.6.1.6.</span> <span class="nav-text">6、-XX:PrintGCDetails</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81MinorGC%EF%BC%88%E6%88%96-young-GC-%E6%88%96-YGC%EF%BC%89%E6%97%A5%E5%BF%97"><span class="nav-number">1.9.6.1.6.1.</span> <span class="nav-text">1、MinorGC（或 young GC 或 YGC）日志</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Full-GC-%E6%97%A5%E5%BF%97"><span class="nav-number">1.9.6.1.6.2.</span> <span class="nav-text">2、Full GC 日志</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81-XX-SurvivorRatio"><span class="nav-number">1.9.6.1.7.</span> <span class="nav-text">7、-XX:SurvivorRatio</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81-XX-NewRatio"><span class="nav-number">1.9.6.1.8.</span> <span class="nav-text">8、-XX:NewRatio</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81-XX-MaxTenuringThreshold"><span class="nav-number">1.9.6.1.9.</span> <span class="nav-text">9、-XX:MaxTenuringThreshold</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.9.7.</span> <span class="nav-text">7、强引用、软引用、弱引用、虚引用分别是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.9.7.1.</span> <span class="nav-text">1、整体架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E6%A8%A1%E5%BC%8F%EF%BC%89%E2%80%94%E2%80%94StrongReference"><span class="nav-number">1.9.7.2.</span> <span class="nav-text">2、强引用（默认支持模式）——StrongReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E2%80%94%E2%80%94SoftReference"><span class="nav-number">1.9.7.3.</span> <span class="nav-text">3、软引用——SoftReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E2%80%94%E2%80%94WeakReference"><span class="nav-number">1.9.7.4.</span> <span class="nav-text">4、弱引用——WeakReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.9.7.5.</span> <span class="nav-text">5、软引用和弱引用的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E2%80%94%E2%80%94PhantomReference"><span class="nav-number">1.9.7.6.</span> <span class="nav-text">6、虚引用——PhantomReference</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">1.9.7.6.1.</span> <span class="nav-text">引用队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81GCRoots%E5%92%8C%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.7.7.</span> <span class="nav-text">7、GCRoots和四大引用小总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9OOM%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9F"><span class="nav-number">1.9.8.</span> <span class="nav-text">8、请谈谈你对OOM的认识？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81java-lang-StackOverFlowError"><span class="nav-number">1.9.8.1.</span> <span class="nav-text">1、java.lang.StackOverFlowError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81java-lang-OutOfMemoryError-Java-heap-space"><span class="nav-number">1.9.8.2.</span> <span class="nav-text">2、java.lang.OutOfMemoryError:Java heap space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81java-lang-OutOfMemoryError-GC-overhead-limit-exceeded%E2%80%94%E2%80%94GC%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.8.3.</span> <span class="nav-text">3、java.lang.OutOfMemoryError:GC overhead limit exceeded——GC时间过长异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81java-lang-OutOfMemoryError-Direct-buffer-memory%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.8.4.</span> <span class="nav-text">4、java.lang.OutOfMemoryError:Direct buffer memory——本地内存溢出异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81java-langOutOfMemoryError-Metaspace"><span class="nav-number">1.9.8.5.</span> <span class="nav-text">5、java.langOutOfMemoryError:Metaspace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81java-lang-OutOfMemoryError-unable-to-create-new-native-thread%E2%80%94%E2%80%94%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.8.6.</span> <span class="nav-text">6、java.lang.OutOfMemoryError:unable to create new native thread——无法创建本地线程异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95linux%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="nav-number">1.9.8.6.1.</span> <span class="nav-text">1、非root用户登录linux系统测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%A7%E5%88%AB%E8%B0%83%E5%8F%82%E8%B0%83%E4%BC%98"><span class="nav-number">1.9.8.6.2.</span> <span class="nav-text">2、服务器级别调参调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88"><span class="nav-number">1.9.9.</span> <span class="nav-text">9、GC回收算法和垃圾收集器的关系？分别是什么请你谈谈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.9.9.1.</span> <span class="nav-text">1、GC回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%814%E7%A7%8D%E4%B8%BB%E8%A6%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.9.9.2.</span> <span class="nav-text">2、4种主要垃圾收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%B8%B2%E8%A1%8C%EF%BC%88Serial%EF%BC%89-VS-%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="nav-number">1.9.9.3.</span> <span class="nav-text">3、串行（Serial） VS 并行（Parallel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81STW%EF%BC%88Stop-the-World%EF%BC%89-VS-%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89"><span class="nav-number">1.9.9.4.</span> <span class="nav-text">4、STW（Stop-the-World） VS 并发（Concurrent）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E7%94%9F%E4%BA%A7%E4%B8%8A%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%EF%BC%9F%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.9.10.</span> <span class="nav-text">10、怎么查看服务器默认的垃圾收集器是哪个？生产上你是如何配置垃圾收集器的？谈谈你的理解？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="nav-number">1.9.10.1.</span> <span class="nav-text">1、怎么查看默认的垃圾收集器是哪个？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.10.2.</span> <span class="nav-text">2、默认的垃圾收集器有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.9.10.3.</span> <span class="nav-text">3、垃圾收集器详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E9%A2%84%E5%85%88%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.10.3.1.</span> <span class="nav-text">1、部分参数预先说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Server-Client%E6%A8%A1%E5%BC%8F%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">1.9.10.3.2.</span> <span class="nav-text">2、Server&#x2F;Client模式分别是什么意思</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="nav-number">1.9.10.3.3.</span> <span class="nav-text">3、新生代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%B2%E8%A1%8CGC%EF%BC%88Serial%EF%BC%89-Serial-Copying"><span class="nav-number">1.9.10.3.4.</span> <span class="nav-text">1、串行GC（Serial）&#x2F;(Serial Copying)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8CGC%EF%BC%88ParNew%EF%BC%89"><span class="nav-number">1.9.10.3.5.</span> <span class="nav-text">2、并行GC（ParNew）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6GC-Parallel-Parallel-Scavenge"><span class="nav-number">1.9.10.3.6.</span> <span class="nav-text">3、并行回收GC(Parallel)&#x2F;(Parallel Scavenge)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.9.10.3.7.</span> <span class="nav-text">4、老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%B8%B2%E8%A1%8CGC-Serial-Old-Serial-MSC"><span class="nav-number">1.9.10.3.7.1.</span> <span class="nav-text">1、串行GC(Serial Old)&#x2F;(Serial MSC)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8CGC%EF%BC%88Parallel-Old%EF%BC%89-Parallel-MSC"><span class="nav-number">1.9.10.3.7.2.</span> <span class="nav-text">2、并行GC（Parallel Old）&#x2F;(Parallel MSC)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4GC%EF%BC%88CMS%EF%BC%89"><span class="nav-number">1.9.10.3.7.3.</span> <span class="nav-text">3、并发标记清除GC（CMS）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.9.10.4.</span> <span class="nav-text">4、如何选择垃圾收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.10.5.</span> <span class="nav-text">5、垃圾收集器总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.9.11.</span> <span class="nav-text">11、G1垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%A5%E5%89%8D%E6%94%B6%E9%9B%86%E5%99%A8%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.11.1.</span> <span class="nav-text">1、以前收集器特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81G1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.9.11.2.</span> <span class="nav-text">2、G1是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81G1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.11.3.</span> <span class="nav-text">3、G1的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.11.4.</span> <span class="nav-text">4、底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Region%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.9.11.4.1.</span> <span class="nav-text">1、Region区域化垃圾收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.9.11.4.2.</span> <span class="nav-text">2、回收步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%814%E6%AD%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">1.9.11.4.3.</span> <span class="nav-text">3、4步过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.9.11.5.</span> <span class="nav-text">5、常用配置参数（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81-XX-UseG1GC%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8"><span class="nav-number">1.9.11.5.1.</span> <span class="nav-text">1、-XX:+UseG1GC——常用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81-XX-G1HeapRegionSize-n%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8"><span class="nav-number">1.9.11.5.2.</span> <span class="nav-text">2、-XX:G1HeapRegionSize&#x3D;n——常用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81-XX-MaxGCPauseMillis-n%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8"><span class="nav-number">1.9.11.5.3.</span> <span class="nav-text">3、-XX:MaxGCPauseMillis&#x3D;n——常用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81-XX-InitiatingHeapOccupancyPercent-n%E2%80%94%E2%80%94%E9%BB%98%E8%AE%A4"><span class="nav-number">1.9.11.5.4.</span> <span class="nav-text">4、-XX:InitiatingHeapOccupancyPercent&#x3D;n——默认</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81-XX-ConcGCThreads-n%E2%80%94%E2%80%94%E9%BB%98%E8%AE%A4"><span class="nav-number">1.9.11.5.5.</span> <span class="nav-text">5、-XX:ConcGCThreads&#x3D;n——默认</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81-XX-G1ReservePercent-n%E2%80%94%E2%80%94%E9%BB%98%E8%AE%A4"><span class="nav-number">1.9.11.5.6.</span> <span class="nav-text">6、-XX:G1ReservePercent&#x3D;n——默认</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%92%8CCMS%E7%9B%B8%E6%AF%94%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.9.11.6.</span> <span class="nav-text">6、和CMS相比的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%9C%A8%E5%B0%86%E8%A6%81%E4%B8%8A%E7%BA%BF%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AEJVM%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.11.7.</span> <span class="nav-text">7、在将要上线的项目中配置JVM参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E6%85%A2%EF%BC%8C%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E8%B0%88%E8%B0%88%EF%BC%9F"><span class="nav-number">1.9.12.</span> <span class="nav-text">12、生产环境服务器变慢，诊断思路和性能评估谈谈？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B4%E6%9C%BA%EF%BC%9Atop"><span class="nav-number">1.9.12.1.</span> <span class="nav-text">1、整机：top</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81CPU%EF%BC%9Avmstat"><span class="nav-number">1.9.12.2.</span> <span class="nav-text">2、CPU：vmstat</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81vmstat%EF%BC%9A%E6%9F%A5%E7%9C%8BCPU%EF%BC%88%E5%8C%85%E5%90%AB%E4%B8%8D%E9%99%90%E4%BA%8E%EF%BC%89"><span class="nav-number">1.9.12.2.1.</span> <span class="nav-text">1、vmstat：查看CPU（包含不限于）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81vmstat%EF%BC%9A%E6%9F%A5%E7%9C%8B%E9%A2%9D%E5%A4%96"><span class="nav-number">1.9.12.2.2.</span> <span class="nav-text">2、vmstat：查看额外</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%EF%BC%9Afree"><span class="nav-number">1.9.12.3.</span> <span class="nav-text">3、内存：free</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E6%95%B0"><span class="nav-number">1.9.12.3.1.</span> <span class="nav-text">1、应用程序可用内存数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E9%A2%9D%E5%A4%96"><span class="nav-number">1.9.12.3.2.</span> <span class="nav-text">2、查看额外</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%A1%AC%E7%9B%98%EF%BC%9Adf"><span class="nav-number">1.9.12.4.</span> <span class="nav-text">4、硬盘：df</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%A3%81%E7%9B%98IO%EF%BC%9Aiostat"><span class="nav-number">1.9.12.5.</span> <span class="nav-text">5、磁盘IO：iostat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E7%BD%91%E7%BB%9CIO%EF%BC%9Aifstat"><span class="nav-number">1.9.12.6.</span> <span class="nav-text">6、网络IO：ifstat</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E5%81%87%E8%AE%BE%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%87%BA%E7%8E%B0CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%EF%BC%8C%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.9.13.</span> <span class="nav-text">13、假设生产环境出现CPU占用过高，请谈谈你的分析思路和定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81%E5%AF%B9%E4%BA%8EJDK%E8%87%AA%E5%B8%A6%E7%9A%84JVM%E7%9B%91%E6%8E%A7%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%B8%80%E8%88%AC%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.14.</span> <span class="nav-text">14、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%A7%88"><span class="nav-number">1.9.14.1.</span> <span class="nav-text">1、概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.14.2.</span> <span class="nav-text">2、性能监控工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">1.10.</span> <span class="nav-text">Elasticsearch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Elasticsearch-%E5%92%8C-solr-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.1.</span> <span class="nav-text">1、Elasticsearch 和 solr 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.</span> <span class="nav-text">面试相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.1.</span> <span class="nav-text">1、单点登陆的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.2.</span> <span class="nav-text">2、购物车的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.12.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.12.1.</span> <span class="nav-text">1、消息队列在项目中的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%96%99%E6%9D%A5%E6%BA%90"><span class="nav-number">1.13.</span> <span class="nav-text">资料来源</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
