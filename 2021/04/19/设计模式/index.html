<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="23种设计模式 [TOC] 1、引子1、设计模式采用的七大原则： 单一职责原则  接口隔离原则  依赖倒转原则  里氏替换原则  开闭原则（ocp）  工厂模式     迪米特原则  合成复用原则   单例设计模式一共有 8 种写法:  饿汉式 两种 懒汉式 三种 双重检查 静态内部类 枚举  2、设计模式的重要性 软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="23种设计模式 [TOC] 1、引子1、设计模式采用的七大原则： 单一职责原则  接口隔离原则  依赖倒转原则  里氏替换原则  开闭原则（ocp）  工厂模式     迪米特原则  合成复用原则   单例设计模式一共有 8 种写法:  饿汉式 两种 懒汉式 三种 双重检查 静态内部类 枚举  2、设计模式的重要性 软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/76.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/31.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/75.PNG">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/27.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/28.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/79.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/29.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/33.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/77.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/35.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/36.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/78.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/37.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/38.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/39.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/40.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/73.PNG">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/41.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/43.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/45.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/47.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/49.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users/风间&琉璃/AppData/Roaming/Typora/typora-user-images/image-20210414224710829.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/54.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/55.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/56.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/57.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/58.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/60.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/62.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/50.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/80.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/64.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/66.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/71.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/72.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/69.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/70.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/81.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/82.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/83.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/84.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/86.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/89.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/90.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/91.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/92.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/87.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/88.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/93.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/94.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/95.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/96.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/98.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/101.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/107.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/102.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/103.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/104.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/105.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/106.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/99.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/108.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/109.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/111.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/112.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/113.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/114.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/115.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/121.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/116.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/117.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/118.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/119.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/120.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/110.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/122.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/123.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/124.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/127.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/128.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/129.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/130.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/131.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/125.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/126.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/100.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/132.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/134.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/137.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/135.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/138.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/133.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/136.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/140.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/139.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/141.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/74.PNG">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/142.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users/风间&琉璃/AppData/Roaming/Typora/typora-user-images/image-20210416200834855.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/144.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/145.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/146.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/147.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/148.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/149.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/150.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/151.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/152.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/153.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/155.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/154.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/156.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/157.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/158.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/159.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/143.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/160.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/161.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/162.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/164.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/165.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/166.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/167.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/168.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/169.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/170.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/171.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/173.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/172.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/174.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/175.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/163.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog/XGH-blog/source_posts/设计模式/176.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/177.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/178.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/179.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/180.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/181.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/183.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/184.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/186.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/189.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/188.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/191.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/190.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/192.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/193.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/194.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/195.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/196.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/197.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/198.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/200.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/187.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/199.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001550797.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001617106.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002547098.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002701455.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002801559.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002150098.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015159710.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015442922.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015737148.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015636229.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418020018759.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418011458744.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418010916983.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418021014591.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141702195.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141912987.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141852365.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142259490.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142556064.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418143949322.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418145233471.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418152450078.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153109616.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153258446.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418154508695.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418162744613.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180415987.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180640123.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181009303.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181353124.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194307766.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194430819.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194613016.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194717484.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194936179.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195208607.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195226794.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195314345.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195658830.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195826923.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog/XGH-blog/source_posts/设计模式/image-20210418200021479.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200257640.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200553239.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194009115.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418201124106.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205430235.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205732564.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418210441898.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213432465.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213517578.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213541498.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418212557965.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418214750299.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418225857983.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230442078.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230737776.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001920044.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419000512228.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001129754.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001333373.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418232858259.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419002157100.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419020914621.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419021241297.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022414374.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022837598.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419011833309.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012005876.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012029050.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012220314.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012326046.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012558289.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog/XGH-blog/source_posts/设计模式/image-20210419013424983.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419013555142.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014131628.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014819146.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419025540539.png">
<meta property="article:published_time" content="2021-04-18T19:10:19.000Z">
<meta property="article:modified_time" content="2021-08-06T16:20:12.067Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>设计模式 | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 03:10:19" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-07 00:20:12" itemprop="dateModified" datetime="2021-08-07T00:20:12+08:00">2021-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><hr>
<p>[TOC]</p>
<h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><h3 id="1、设计模式采用的七大原则："><a href="#1、设计模式采用的七大原则：" class="headerlink" title="1、设计模式采用的七大原则："></a>1、设计模式采用的七大原则：</h3><ul>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转原则</p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则（ocp）</p>
<ul>
<li><p>工厂模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png" alt="image-20210410201229604"></p>
</li>
</ul>
</li>
<li><p>迪米特原则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ul>
<p>单例设计模式一共有 <strong>8</strong> 种写法:</p>
<ul>
<li>饿汉式 两种</li>
<li>懒汉式 三种</li>
<li>双重检查</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<h3 id="2、设计模式的重要性"><a href="#2、设计模式的重要性" class="headerlink" title="2、设计模式的重要性"></a>2、设计模式的重要性</h3><ul>
<li>软件工程中，<strong>设计模式</strong>（design pattern）是对软件设计中<strong>普遍存在（反复出现）</strong>的各种问题，所提出的<strong>解决方案</strong>。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的</li>
<li>拿实际工作经历来说, 当一个项目开发完后，如果<strong>客户提出增新功能</strong>，怎么办?（<strong>可扩展性</strong>,使用设计模式，软件具有很好的扩展性）</li>
<li>如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (<strong>维护性</strong>[可读性、规范性])</li>
<li>目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中<strong>使用过什么设计模式，怎样使用的，解决了什么问题</strong></li>
<li><strong>设计模式在软件中哪里</strong>？面向对象(oo)=&gt;<strong>功能模块</strong>[设计模式+算法(数据结构)]=&gt;<strong>框架</strong>[使用到多种设计模式]=&gt; 架构 [服务器集群]</li>
<li>如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的.</li>
</ul>
<h3 id="3、设计模式的讲解过程"><a href="#3、设计模式的讲解过程" class="headerlink" title="3、设计模式的讲解过程"></a>3、设计模式的讲解过程</h3><p>讲解的步骤</p>
<ol>
<li>应用场景</li>
<li>普通代码解决</li>
<li>设计模式解决【对比】</li>
<li>剖析原理</li>
<li>分析实现步骤(图解)</li>
<li>代码实现</li>
<li> 框架或项目源码分析(找到使用的地方)  的步骤讲解</li>
</ol>
<hr>
<h2 id="2、设计模式七大原则（单接依里开迪合）"><a href="#2、设计模式七大原则（单接依里开迪合）" class="headerlink" title="2、设计模式七大原则（单接依里开迪合）"></a>2、设计模式七大原则（单接依里开迪合）</h2><h3 id="2-1、设计模式的目的"><a href="#2-1、设计模式的目的" class="headerlink" title="2.1、设计模式的目的"></a>2.1、设计模式的目的</h3><p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ol>
<h3 id="2-2-、设计模式七大原则"><a href="#2-2-、设计模式七大原则" class="headerlink" title="2.2 、设计模式七大原则"></a>2.2 、设计模式七大原则</h3><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：<strong>设计模式为什么这样设计的依据</strong>)</p>
<p>设计模式常用的七大原则有:</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<h3 id="2-3、单一职责原则-Single-Responsibility-Principle"><a href="#2-3、单一职责原则-Single-Responsibility-Principle" class="headerlink" title="2.3、单一职责原则(Single Responsibility Principle)"></a>2.3、单一职责原则(Single Responsibility Principle)</h3><h4 id="2-3-1、基本介绍"><a href="#2-3-1、基本介绍" class="headerlink" title="2.3.1、基本介绍"></a>2.3.1、基本介绍</h4><p>单一职责的含义是：<strong>类的职责单一，引起类变化的原因单一</strong>。对类来说的，即<strong>一个类应该只负责一项职责</strong>。解释一下，这也是灵活的前提，如果我们把类拆分成最小的职能单位，那组合与复用就简单的多了，如果一个类做的事情太多，在组合的时候，必然会产生不必要的方法出现，这实际上是一种污染。</p>
<p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p>
<p>SRP优点：消除耦合，减小因需求变化引起代码僵化。</p>
<h4 id="2-3-2、应用实例"><a href="#2-3-2、应用实例" class="headerlink" title="2.3.2、应用实例"></a>2.3.2、应用实例</h4><p>需求：以交通工具案例讲解（海陆空）</p>
<p>方案 1  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 交通工具类</span></span><br><span class="line">    <span class="comment">// 方式 1</span></span><br><span class="line">    <span class="comment">// 1. 在方式 1 的 run 方法中，违反了单一职责原则</span></span><br><span class="line">    <span class="comment">// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 2  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方案 2</span></span><br><span class="line">    <span class="comment">//1. 遵守单一职责原则</span></span><br><span class="line">    <span class="comment">//2. 但是这样做的改动很大，即将类分解，同时修改客户端</span></span><br><span class="line">    <span class="comment">//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 3     [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub Vehicle2 vehicle2	= new Vehicle2();</span></span><br><span class="line">        vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式 3 </span></span><br><span class="line">    <span class="comment">//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span></span><br><span class="line">	<span class="comment">//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理</span></span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3、单一职责原则注意事项和细节"><a href="#2-3-3、单一职责原则注意事项和细节" class="headerlink" title="2.3.3、单一职责原则注意事项和细节"></a>2.3.3、单一职责原则注意事项和细节</h4><ol>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>在实际编码的过程中很难将它恰当地运用，需要结合实际情况进行运用。</li>
<li>通常情况下，<strong>我们应当遵守单一职责原则</strong>，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="2-4-、接口隔离原则-Interface-Segregation-Principle"><a href="#2-4-、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="2.4 、接口隔离原则(Interface Segregation Principle)"></a>2.4 、接口隔离原则(Interface Segregation Principle)</h3><h4 id="2-4-1、基本介绍"><a href="#2-4-1、基本介绍" class="headerlink" title="2.4.1、基本介绍"></a>2.4.1、基本介绍</h4><ol>
<li><p>它的含义是<strong>尽量使用职能单一的接口，而不使用职能复杂、全面的接口。</strong></p>
</li>
<li><p>接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。 相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。</p>
</li>
<li><p>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
</li>
<li><p>先看一张图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png" alt="image-20210411004513392"></p>
</li>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p>
</li>
<li><p>按隔离原则应当这样处理：</p>
<p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 **3</strong> 个接口**)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
</ol>
<h4 id="2-4-2、应用实例"><a href="#2-4-2、应用实例" class="headerlink" title="2.4.2、应用实例"></a>2.4.2、应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//接口</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation5</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation5&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation5();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3、应传统方法的问题和使用接口隔离原则改进"><a href="#2-4-3、应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="2.4.3、应传统方法的问题和使用接口隔离原则改进"></a>2.4.3、应传统方法的问题和使用接口隔离原则改进</h4><ol>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>
</li>
<li><p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
<li><p>接口 Interface1 中出现的方法，根据实际情况拆分为三个接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png" alt="image-20210411010354543"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 使用一把</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A 类通过接口去依赖 B 类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">        c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C 类通过接口去依赖(使用)D 类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接 口 3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D 实现了  operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation4</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C  类通过接口 Interface1,Interface3  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123; </span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-4-4、接口隔离原则注意事项和细节"><a href="#2-4-4、接口隔离原则注意事项和细节" class="headerlink" title="2.4.4、接口隔离原则注意事项和细节"></a>2.4.4、接口隔离原则注意事项和细节</h4><ol>
<li>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</li>
<li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
</ol>
<h3 id="2-5-、依赖倒转原则-Dependence-Inversion-Principle"><a href="#2-5-、依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="2.5 、依赖倒转原则(Dependence Inversion Principle)"></a>2.5 、依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="2-5-1、基本介绍"><a href="#2-5-1、基本介绍" class="headerlink" title="2.5.1、基本介绍"></a>2.5.1、基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该<strong>依赖其抽象</strong></li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong>，<strong>面向抽象编程，解耦调用和被调用者</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，<strong>抽象指的是接口或抽象类，细节就是具体的实现类</strong></li>
<li>当两个模块之间存在紧密的耦合关系时，最好的方法就是<strong>分离接口和实现</strong>：在<strong>依赖之间</strong>定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把<strong>展现细节</strong>的任务交给他们的<strong>实现类</strong>去完成</li>
</ol>
<h4 id="2-5-2、应用实例"><a href="#2-5-2、应用实例" class="headerlink" title="2.5.2、应用实例"></a>2.5.2、应用实例</h4><p>请编程完成 Person 接收消息 的功能。</p>
<p>实现方案 1 + 分析说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//方式1分析</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 但如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">		System.out.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方案 2(依赖倒转) + 分析说明（同时也满足了开闭原则ocp）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3、-依赖关系传递的三种方式和应用案例"><a href="#2-5-3、-依赖关系传递的三种方式和应用案例" class="headerlink" title="2.5.3、 依赖关系传递的三种方式和应用案例"></a>2.5.3、 依赖关系传递的三种方式和应用案例</h4><h5 id="2-5-3-1、接口传递"><a href="#2-5-3-1、接口传递" class="headerlink" title="2.5.3.1、接口传递"></a>2.5.3.1、接口传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        <span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.open(changHong);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-2、构造方法传递"><a href="#2-5-3-2、构造方法传递" class="headerlink" title="2.5.3.2、构造方法传递"></a>2.5.3.2、构造方法传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员</span></span><br><span class="line">    <span class="keyword">public</span> ITV tv; </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-3、setter-方式传递"><a href="#2-5-3-3、setter-方式传递" class="headerlink" title="2.5.3.3、setter 方式传递"></a>2.5.3.3、setter 方式传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">//通过setter方法进行依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.setTv(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// setter方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITV tv;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4、依赖倒转原则的注意事项和细节"><a href="#2-5-4、依赖倒转原则的注意事项和细节" class="headerlink" title="2.5.4、依赖倒转原则的注意事项和细节"></a>2.5.4、依赖倒转原则的注意事项和细节</h4><ol>
<li><strong>低层模块尽量都要有抽象类或接口</strong>，或者两者都有，程序稳定性更好.</li>
<li><strong>变量的声明类型尽量是抽象类或接口</strong>, 这样我们的变量引用和实际对象间，就存在一个<strong>缓冲层</strong>，利于程序扩展和优化</li>
<li><strong>继承时遵循里氏替换原则</strong>.</li>
</ol>
<h3 id="2-6、里氏替换原则-Liskov-Substitution-Principle"><a href="#2-6、里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="2.6、里氏替换原则(Liskov Substitution Principle)"></a>2.6、里氏替换原则(Liskov Substitution Principle)</h3><h4 id="2-6-1、OO-中的继承性的思考和说明"><a href="#2-6-1、OO-中的继承性的思考和说明" class="headerlink" title="2.6.1、OO 中的继承性的思考和说明"></a>2.6.1、OO 中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果<strong>子类对这些已经实现的方法任意修改</strong>，就会对<strong>整个继承体系造成破坏</strong>。</li>
<li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的<strong>可移植性降低</strong>， <strong>增加对象间的耦合性</strong>，如果<strong>一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类</strong>，并且<strong>父类修改</strong>后，<strong>所有涉及到子类的功能都有可能产生故障</strong></li>
<li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法。</strong></li>
<li>问题提出：在编程中，<strong>如何正确的使用继承</strong>? =&gt; <strong>里氏替换</strong>原则</li>
</ol>
<h4 id="2-6-2、-基本介绍"><a href="#2-6-2、-基本介绍" class="headerlink" title="2.6.2、 基本介绍"></a>2.6.2、 基本介绍</h4><ol>
<li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>里氏替换原则的含义是：<strong>子类可以在任何地方替换它的父类。</strong></li>
<li>也就是说在程序中将基类替换为子类，程序的行为不会发生任何变化。</li>
<li>Liskov替换原则是<strong>关于继承机制的设计原则</strong>，<strong>违反了Liskov替换原则就必然导致违反开放封闭原则</strong></li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li>
<li>在使用继承时，遵循里氏替换原则，在**<code>子类中尽量不要重写父类的方法</code>**。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**<code>聚合，组合，依赖</code>**来解决问题。</li>
</ol>
<p>里氏原则的优点：</p>
<ol>
<li>能够保证系统具有良好的拓展性</li>
<li>同时实现基于多态的抽象机制</li>
<li>能够减少代码冗余</li>
<li>避免运行期的类型判别</li>
</ol>
<h4 id="2-6-3、-一个程序引出的问题和思考"><a href="#2-6-3、-一个程序引出的问题和思考" class="headerlink" title="2.6.3、 一个程序引出的问题和思考"></a>2.6.3、 一个程序引出的问题和思考</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png" alt="image-20210411022902982"></p>
<p>程序员原本是想调用b中继承的a的func1的方法求出11-3，但b无意重写了a的func1方法，使相减变成了相加。</p>
<h4 id="2-6-4、解决方法"><a href="#2-6-4、解决方法" class="headerlink" title="2.6.4、解决方法"></a>2.6.4、解决方法</h4><ol>
<li><p>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是<strong>运行多态比较频繁</strong>的时候</p>
</li>
<li><p>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等关系代替.</p>
</li>
<li><p>即：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
</li>
<li><p>改进方案：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png" alt="image-20210411023703967"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		<span class="comment">//因为B类不再继承A类，因此调用者，不会再认为func1是求减法</span></span><br><span class="line">		<span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A类继承了Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 重写func1返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了Base</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了Base类的方法,</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-7、开闭原则（Open-Closed-Principle）"><a href="#2-7、开闭原则（Open-Closed-Principle）" class="headerlink" title="2.7、开闭原则（Open Closed Principle）"></a>2.7、开闭原则（Open Closed Principle）</h3><h4 id="2-7-1、基本介绍"><a href="#2-7-1、基本介绍" class="headerlink" title="2.7.1、基本介绍"></a>2.7.1、基本介绍</h4><ol>
<li>开闭原则（Open Closed Principle）是编程中<strong>最基础、最重要</strong>的设计原则</li>
<li>一个软件实体如类，模块和函数应该<strong>对扩展开放(对提供方)**，</strong>对修改关闭(对使用方)<strong>。用</strong>抽象构建框架<strong>，用</strong>实现扩展细节**。</li>
<li>采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。</li>
<li>所以当软件需要变化时，尽量<strong>通过扩展软件实体</strong>的行为来实现变化，而<strong>不是通过修改已有的代码</strong>来实现变化。</li>
<li><strong>编程中遵循其它原则</strong>，以及<strong>使用设计模式的目的就是遵循开闭原则</strong>。</li>
</ol>
<h4 id="2-7-2、看下面一段代码"><a href="#2-7-2、看下面一段代码" class="headerlink" title="2.7.2、看下面一段代码"></a>2.7.2、看下面一段代码</h4><p>实现画图形的功能</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png" alt="image-20210411025709019"></p>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png" alt="image-20210411025938974"></p>
<p>但我们增加一个功能：画三角形</p>
<p>方式1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">			drawRectangle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">			drawCircle(s);</span><br><span class="line">        <span class="comment">// 修改1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">			drawTriangle(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制圆形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="comment">//修改2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3、方式-1-的优缺点"><a href="#2-7-3、方式-1-的优缺点" class="headerlink" title="2.7.3、方式 1 的优缺点"></a>2.7.3、方式 1 的优缺点</h4><ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是违反了设计模式的 ocp 原则，即**对扩展开放(提供方)，对修改关闭(使用方)**。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时要<strong>新增加一个图形种类三角形，我们需要做如下修改，修改的地方较多（使用方要修改两次）</strong></p>
</li>
<li><p>代码演示（方式2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">         <span class="comment">//使用方直接使用</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类（使用抽象类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-7-4、改进的思路分析"><a href="#2-7-4、改进的思路分析" class="headerlink" title="2.7.4、改进的思路分析"></a>2.7.4、改进的思路分析</h4><p>把创建 <strong>Shape</strong> 类做成<strong>抽象类</strong>，并提供一个<strong>抽象的 draw 方法</strong>，让<strong>子类去实现</strong>即可，这样我们有<strong>新的图形种类</strong>时，只需要让<strong>新的图形类继承 Shape</strong>，并<strong>实现 draw 方法</strong>即可，<strong>使用方的代码就不需要修改-&gt;    满足了开闭原则</strong></p>
<h4 id="2-7-5、开闭原则注意事项和细节"><a href="#2-7-5、开闭原则注意事项和细节" class="headerlink" title="2.7.5、开闭原则注意事项和细节"></a>2.7.5、开闭原则注意事项和细节</h4><ol>
<li>OCP 可以具有良好的可扩展性，可维护性。</li>
<li>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它。</li>
</ol>
<h3 id="2-8、迪米特法则-Demeter-Principle"><a href="#2-8、迪米特法则-Demeter-Principle" class="headerlink" title="2.8、迪米特法则(Demeter Principle)"></a>2.8、迪米特法则(Demeter Principle)</h3><h4 id="2-8-1、基本介绍"><a href="#2-8-1、基本介绍" class="headerlink" title="2.8.1、基本介绍"></a>2.8.1、基本介绍</h4><ol>
<li>迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。就是说<strong>一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。</strong></li>
<li>一个对象应该对其他对象<strong>保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于<strong>被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></li>
<li><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要<strong>两个对象之间有耦合关系</strong>，我们就说这两个对象之间是<strong>朋友关系</strong>。耦合的方式很多，<strong>依赖</strong>，<strong>关联</strong>，<strong>组合</strong>，<strong>聚合</strong>等。其中，我们称出现<strong>成员变量</strong>，<strong>方法参数</strong>，<strong>方法返回值</strong>中的类为<strong>直接的朋友</strong>，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要以局部变量的形式出现在类的内部</strong>。最好将其封装到直接朋友里面。</li>
<li>迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。</li>
</ol>
<h4 id="2-8-2、应用实例"><a href="#2-8-2、应用实例" class="headerlink" title="2.8.2、应用实例"></a>2.8.2、应用实例</h4><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id。编程实现上面的功能, 看代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">////添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">		<span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">		<span class="comment">//3. 违反了 迪米特法则 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-3、应用实例改进"><a href="#2-8-3、应用实例改进" class="headerlink" title="2.8.3、应用实例改进"></a>2.8.3、应用实例改进</h4><ol>
<li><p>前面设计的问题在于 SchoolManager 中，<strong>CollegeEmployee</strong> 类并不是 <strong>SchoolManager</strong> 类的直接朋友 (分析)</p>
</li>
<li><p>按照迪米特法则，应该<strong>避免类中出现这样非直接朋友关系的耦合</strong></p>
</li>
<li><p>对代码按照迪米特法则 进行改进：</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出学院员工的信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-8-4、迪米特法则注意事项和细节"><a href="#2-8-4、迪米特法则注意事项和细节" class="headerlink" title="2.8.4、迪米特法则注意事项和细节"></a>2.8.4、迪米特法则注意事项和细节</h4><ol>
<li><p>迪米特法则的核心是<strong>降低类之间的耦合</strong></p>
</li>
<li><p>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</p>
</li>
</ol>
<h3 id="2-9、合成复用原则（Composite-Reuse-Principle）"><a href="#2-9、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="2.9、合成复用原则（Composite Reuse Principle）"></a>2.9、合成复用原则（Composite Reuse Principle）</h3><h4 id="2-9-1、基本介绍"><a href="#2-9-1、基本介绍" class="headerlink" title="2.9.1、基本介绍"></a>2.9.1、基本介绍</h4><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而<strong>不是使用继承</strong></p>
<p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p>
<p>因为继承的耦合性更大，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。说白了就是我只用你的方法，但我们并不是同类。</p>
<p>在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png" alt="image-20210411150334377"></p>
<h3 id="2-10、设计原则核心思想"><a href="#2-10、设计原则核心思想" class="headerlink" title="2.10、设计原则核心思想"></a>2.10、设计原则核心思想</h3><ol>
<li>找出应用中<strong>可能需要变化</strong>之处，把它们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起。</li>
<li><strong>针对接口编程</strong>，而不是针对实现编程。</li>
<li>为了交互对象之间的<strong>松耦合</strong>设计而努力</li>
</ol>
<h3 id="2-11、设计七大原则总结"><a href="#2-11、设计七大原则总结" class="headerlink" title="2.11、设计七大原则总结"></a>2.11、设计七大原则总结</h3><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p>
<p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<p>实际上，这些原则的目的只有一个：<strong>降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性</strong>。</p>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p>
<h2 id="3、UML-类图"><a href="#3、UML-类图" class="headerlink" title="3、UML 类图"></a>3、UML 类图</h2><h3 id="3-1、UML-基本介绍"><a href="#3-1、UML-基本介绍" class="headerlink" title="3.1、UML 基本介绍"></a>3.1、UML 基本介绍</h3><ol>
<li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p>
</li>
<li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<strong>类、接口、实现、泛化、依赖、组合、聚合</strong>等，如右图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.png" alt="image-20210411172838273"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png" alt="image-20210411173002251"></p>
</li>
<li><p>使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</p>
</li>
</ol>
<h3 id="3-2、UML-图"><a href="#3-2、UML-图" class="headerlink" title="3.2、UML 图"></a>3.2、UML 图</h3><p>画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML 图分类：</p>
<ol>
<li>用例图(use case)</li>
<li> 静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ol>
<p>说明：</p>
<ol>
<li>类图是描述<strong>类与类之间的关系</strong>的，是 UML 图中最核心的</li>
<li>在讲解设计模式时，我们必然会使用类图，为了让学员们能够把设计模式学到位，需要先给大家讲解类图</li>
</ol>
<h3 id="3-3、UML-类图"><a href="#3-3、UML-类图" class="headerlink" title="3.3、UML 类图"></a>3.3、UML 类图</h3><ol>
<li><p>用于描述系统中的类**(<strong>对象</strong>)<strong>本身的组成和类</strong>(<strong>对象</strong>)**之间的各种静态关系。</p>
</li>
<li><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。</p>
</li>
<li><p>类图简单举例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">//代码形式-&gt;类图</span></span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>	name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png" alt="image-20210411192255196"></p>
</li>
</ol>
<h3 id="3-4、类图—依赖关系（Dependence）"><a href="#3-4、类图—依赖关系（Dependence）" class="headerlink" title="3.4、类图—依赖关系（Dependence）"></a>3.4、类图—依赖关系（Dependence）</h3><p>只要是<strong>在类中用到了对方</strong>，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png" alt="image-20210411192418668"></p>
<p>依赖关系小结：</p>
<ol>
<li><strong>类中用到了对方</strong></li>
<li>如果是类的<strong>成员属性</strong></li>
<li>如果是<strong>方法的返回类型</strong></li>
<li>是方法<strong>接收的参数类型</strong></li>
<li><strong>方法中使用到</strong></li>
</ol>
<h3 id="3-5、类图—泛化关系-generalization）"><a href="#3-5、类图—泛化关系-generalization）" class="headerlink" title="3.5、类图—泛化关系(generalization）"></a>3.5、类图—泛化关系(generalization）</h3><p>泛化关系实际上就是<strong>继承关系</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png" alt="image-20210411192748570"></p>
<p>泛化关系小结:</p>
<ol>
<li>泛化关系实际上就是<strong>继承关系</strong></li>
<li>如果 A 类继承了 B 类，我们就说 A 和 B 存在<strong>泛化关系</strong></li>
</ol>
<h3 id="3-6、类图—实现关系（Implementation）"><a href="#3-6、类图—实现关系（Implementation）" class="headerlink" title="3.6、类图—实现关系（Implementation）"></a>3.6、类图—实现关系（Implementation）</h3><p>实现关系实际上就是 <strong>A 类实现 B 接口</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png" alt="image-20210411193029031"></p>
<h3 id="3-7、类图—关联关系（Association）"><a href="#3-7、类图—关联关系（Association）" class="headerlink" title="3.7、类图—关联关系（Association）"></a>3.7、类图—关联关系（Association）</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png" alt="image-20210411193416238"></p>
<h3 id="3-8、类图—聚合关系（Aggregation）"><a href="#3-8、类图—聚合关系（Aggregation）" class="headerlink" title="3.8、类图—聚合关系（Aggregation）"></a>3.8、类图—聚合关系（Aggregation）</h3><h4 id="3-8-1、基本介绍"><a href="#3-8-1、基本介绍" class="headerlink" title="3.8.1、基本介绍"></a>3.8.1、基本介绍</h4><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开</strong>。聚合关系是<strong>关联关系的特例</strong>，所以他具有关联的<strong>导航性与多重性</strong>。</p>
<p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png" alt="image-20210411193519679"></p>
<h3 id="3-9、类图—组合关系（Composition）"><a href="#3-9、类图—组合关系（Composition）" class="headerlink" title="3.9、类图—组合关系（Composition）"></a>3.9、类图—组合关系（Composition）</h3><h4 id="3-9-1、基本介绍"><a href="#3-9-1、基本介绍" class="headerlink" title="3.9.1、基本介绍"></a>3.9.1、基本介绍</h4><p>组合关系：也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开</strong>。</p>
<p>再看一个案例：在程序中我们定义实体：Person 与 IDCard、Head, 那么 <strong>Head 和 Person 就是 组合</strong>，<strong>IDCard 和Person 就是聚合。</strong></p>
<p>但是如果在程序中 Person 实体中定义了对 IDCard 进行<strong>级联删除</strong>，即删除 Person 时连同 IDCard 一起删除，那么 <strong>IDCard 和 Person 就是组合了.</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="comment">// 在创建Person对象的同时创建了Head对象</span></span><br><span class="line">    <span class="keyword">private</span> Head head = <span class="keyword">new</span> Head();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png" alt="image-20210411193901631"></p>
<h2 id="4、设计模式概述"><a href="#4、设计模式概述" class="headerlink" title="4、设计模式概述"></a>4、设计模式概述</h2><h3 id="4-1、设计模式介绍"><a href="#4-1、设计模式介绍" class="headerlink" title="4.1、设计模式介绍"></a>4.1、设计模式介绍</h3><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，<strong>模式</strong>不是代码，而是某类问题的<strong>通用解决方案</strong>，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li>
<li>设计模式的本质提高<strong>软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li>
<li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）</li>
<li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li>
</ol>
<h3 id="4-2、设计模式类型"><a href="#4-2、设计模式类型" class="headerlink" title="4.2、设计模式类型"></a>4.2、设计模式类型</h3><p>设计模式分为<strong>三种类型</strong>，共 <strong>23</strong> 种</p>
<ol>
<li><strong>创建型</strong>模式：<strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</li>
<li><strong>结构型</strong>模式：适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong>。</li>
<li><strong>行为型</strong>模式：模版方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li>
</ol>
<p>注意：不同的书籍上对分类和名称略有差别</p>
<p>对于创建型模式的概述请看第27点</p>
<p>对于结构型模式的概述请看第28点</p>
<p>对于行为型模式的概述请看第29点</p>
<h2 id="5、单例设计模式Singleton（创建型设计模式）"><a href="#5、单例设计模式Singleton（创建型设计模式）" class="headerlink" title="5、单例设计模式Singleton（创建型设计模式）"></a>5、单例设计模式Singleton（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/76.png" alt="image-20210415031845856"></p>
<h3 id="5-1、单例设计模式介绍"><a href="#5-1、单例设计模式介绍" class="headerlink" title="5.1、单例设计模式介绍"></a>5.1、单例设计模式介绍</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例</strong>， 并且该类**只提供一个取得其对象实例的方法(静态方法)**。</p>
<p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。<strong>SessionFactory 并不是轻量级的</strong>，一般情况下，<strong>一个项目通常只需要一个</strong> SessionFactory 就够，这是就会<strong>使用到单例模式</strong>。</p>
<p>注意：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ol>
<p>测试方法（除了枚举）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断创建的两个实例是不是同一个</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">		System.out.println(instance == instance2); </span><br><span class="line">		System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2、单例设计模式八种方式"><a href="#5-2、单例设计模式八种方式" class="headerlink" title="5.2、单例设计模式八种方式"></a>5.2、单例设计模式八种方式</h3><p><strong>加黑属于推荐使用</strong></p>
<ol>
<li><strong>饿汉式（两种）</strong><ol>
<li>饿汉式**(静态常量)**</li>
<li>饿汉式<strong>（静态代码块）</strong></li>
</ol>
</li>
<li>懒汉式（三种）<ol>
<li>懒汉式(线程不安全)</li>
<li>懒汉式(线程安全，同步方法)</li>
<li> 懒汉式(同步代码块)</li>
</ol>
</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="5-3、饿汉式（两种）"><a href="#5-3、饿汉式（两种）" class="headerlink" title="5.3、饿汉式（两种）"></a>5.3、饿汉式（两种）</h3><h4 id="5-3-1、饿汉式（静态常量）"><a href="#5-3-1、饿汉式（静态常量）" class="headerlink" title="5.3.1、饿汉式（静态常量）"></a>5.3.1、饿汉式（静态常量）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>类的<strong>内部创建对象</strong></li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态常量）</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ul>
<li>优点：这种写法比较简单，就是<strong>在类装载的时候就完成实例化</strong>。避免了线程同步问题。</li>
<li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终<strong>从未使用</strong>过这个实例，则会造成<strong>内存的浪费</strong></li>
<li>这种方式基于 <code>classloder</code> 机制<strong>避免了多线程的同步问题</strong>，不过，<strong>instance 在类装载时就实例化</strong>，在单例模式中大多数都是调用 getInstance 方法， 但是导致<strong>类装载的原因有很多种</strong>，因此<strong>不能确定有其他的方式（或者其他的静态方法）导致类装载</strong>，这时候初始化 instance 就<strong>没有达到 <code>lazy loading</code> 的效果</strong></li>
<li>结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成<strong>内存浪费</strong>，同时也不能实现懒加载（lazy loading）</li>
</ul>
<h4 id="5-3-2、饿汉式（静态代码块）"><a href="#5-3-2、饿汉式（静态代码块）" class="headerlink" title="5.3.2、饿汉式（静态代码块）"></a>5.3.2、饿汉式（静态代码块）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>在<strong>静态代码块</strong>中，创建单例对象</li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态代码块）</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.在静态代码块中，创建单例对象</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在<strong>类装载</strong>的时候，就<strong>执行静态代码块中的代码</strong>，<strong>初始化类的实例</strong>。优缺点和上面是一样的。</li>
<li>结论：这种单例模式可用，但是可能造成<strong>内存浪费</strong></li>
</ol>
<h3 id="5-4、懒汉式（三种）"><a href="#5-4、懒汉式（三种）" class="headerlink" title="5.4、懒汉式（三种）"></a>5.4、懒汉式（三种）</h3><h4 id="5-4-1、懒汉式-线程不安全"><a href="#5-4-1、懒汉式-线程不安全" class="headerlink" title="5.4.1、懒汉式(线程不安全)"></a>5.4.1、懒汉式(线程不安全)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，当<strong>使用到该方法</strong>时，才去创建 instance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程不安全)</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在<strong>单线程下使用</strong>。</li>
<li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在<strong>多线程环境下不可使用</strong>这种方式。（线程不安全）</li>
<li>结论：在实际开发中，<strong>不要使用这种方式.</strong></li>
</ol>
<h4 id="5-4-2、懒汉式-线程安全，同步方法"><a href="#5-4-2、懒汉式-线程安全，同步方法" class="headerlink" title="5.4.2、懒汉式(线程安全，同步方法)"></a>5.4.2、懒汉式(线程安全，同步方法)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入同步处理的代码<strong>synchronized</strong> ，解决线程安全问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li><strong>解决了线程安全问题</strong></li>
<li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而<strong>其实</strong>这个方法<strong>只执行一次实例化代码就够了</strong>，<strong>后面的想获得该类实例，直接 return 就行了</strong>。方法进行同步<strong>效率太低。</strong></li>
<li>结论：在实际开发中，<strong>不推荐使用</strong>这种方式</li>
</ol>
<h4 id="5-4-3、懒汉式-同步代码块"><a href="#5-4-3、懒汉式-同步代码块" class="headerlink" title="5.4.3、懒汉式(同步代码块)"></a>5.4.3、懒汉式(同步代码块)</h4><ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入<strong>同步产生实例化的的代码块</strong>，解决效率问题。</li>
</ol>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png" alt="image-20210412194454470"></p>
<p>优缺点说明：</p>
<ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为<strong>同步产生实例化的的代码块。</strong></li>
<li>但是这种同步并<strong>不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例</strong>。（<strong>线程不安全</strong>）</li>
<li>结论：在实际开发中，**<code>不能使用</code>**这种方式</li>
</ol>
<h3 id="5-5、双重检查"><a href="#5-5、双重检查" class="headerlink" title="5.5、双重检查"></a>5.5、双重检查</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法，加入**双重检查代码(双if)**，解决线程安全问题, 同时解决懒加载问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重检查</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们<strong>进行了两次 if (singleton == null)检查</strong>，这样就可以<strong>保证线程安全</strong>了。</li>
<li>是对懒汉式(线程安全，同步方法)的优化</li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也<strong>避免的反复进行方法同步</strong>。</li>
<li><strong>线程安全</strong>；<strong>延迟加载</strong>；<strong>效率较高</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>双重检锁虽然是线程安全的，会出现<strong>内部成员变量空指针异常</strong>，如果要使用，需将<strong>类实例用volatile修饰</strong></li>
<li>volatile 是<strong>改变立即更新到主存</strong>，<strong>保证变化各线程可见</strong>，即：<strong>立即从主内存中获取值，更新工作内存的值</strong>。在多线程情况下，不仅<strong>防止指令重排</strong>，而且<strong>保证happes-before规则</strong>，前一个线程的操作对后一个线程可见。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">（happens-before规则相关）</a></li>
<li>如果<strong>不用volatile关键字</strong>，有可能会出现异常。因为instance = new Singleton();并不是一个原子操作。new对象分为三步：<ol>
<li>第一步：分配对象的内存空间</li>
<li>第二步：初始化对象</li>
<li>第三步：设置instance指向内存空间</li>
</ol>
</li>
<li>但是这个被返回的instance是有问题的——它还没有被初始化（第二步还未被执行)。</li>
<li>这里必须要volatile，volatile就是保证一个线程更新了instance，其余线程立马可知，不然第二个if没有用。（可见性）</li>
<li>volitile保证了线程间的可见性，和一定程度上的顺序性（不能保证原子性），更好的方式是用一个boolean变量标识对象是否创建过（原子性）</li>
</ul>
<p>双重检查创建单例实现步骤</p>
<ol>
<li>第一个if(singleton==null){}：第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进</li>
<li>synchronized (Singleton.class) {}：第一层锁，保证只有一个线程进入</li>
<li>第二个if(singleton==null){}：第二层检查<ul>
<li>双重检查，防止多个线程同时进入第一层检查(因单例模式只允许存在一个对象，故在创建对象之前无引用指向对象，所有线程均可进入第一层检查)</li>
<li>当某一线程获得锁创建一个Singleton对象时,即已有引用指向对象，singleton不为空，从而保证只会创建一个对象</li>
<li>假设没有第二层检查，那么第一个线程创建完对象释放锁后，后面进入对象也会创建对象，会产生多个对象。（5.4.3的情况）</li>
</ul>
</li>
<li>instance = new Singleton()：volatile关键字作用为禁止指令重排，保证返回Singleton对象一定在创建对象后<ul>
<li>该语句为非原子性，实际上会执行以下内容：<ol>
<li>在堆上开辟空间</li>
<li>属性初始化</li>
<li>引用指向对象</li>
</ol>
</li>
<li>假设以上三个内容为三条单独指令，因指令重排可能会导致执行顺序为1-&gt;3-&gt;2(正常为1-&gt;2-&gt;3),当单例模式中存在普通变量需要在构造方法中进行初始化操作时，单线程情况下，顺序重排没有影响；但在多线程情况下，假如线程1执行singleton=new Singleton()语句时先1再3，由于系统调度线程2的原因没来得及执行步骤2，但此时已有引用指向对象也就是singleton!=null，故线程2在第一次检查时不满足条件直接返回singleton，此时singleton为一个没有被步骤2正确初始化的singleton。</li>
<li>volatile关键字可保证singleton=new Singleton()语句执行顺序为123，因其为非原子性依旧可能存在系统调度问题(即执行步骤时被打断)，但能确保的是只要singleton!=null，就表明一定执行了属性初始化操作；而若在步骤3之前被打断，此时singleton依旧为null，其他线程可进入第一层检查向下执行创建对象。</li>
</ul>
</li>
</ol>
<h3 id="5-6、静态内部类"><a href="#5-6、静态内部类" class="headerlink" title="5.6、静态内部类"></a>5.6、静态内部类</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>写一个<strong>静态内部类</strong>,该类中有一个<strong>静态属性 Singleton</strong></li>
<li>提供一个静态的公有方法，直接返回<strong>SingletonInstance.INSTANCE</strong></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="comment">// 1.构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式采用了<strong>类装载的机制</strong>来<strong>保证初始化实例时只有一个线程</strong>。</li>
<li>静态内部类方式<strong>在 Singleton 类被装载时并不会立即实例化</strong>，而是在需要实例化时，<strong>调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化</strong>。</li>
<li><strong>类的静态属性只会在第一次加载类的时候初始化</strong>，所以在这里，<strong>JVM</strong> 帮助我们<strong>保证了线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的。</li>
<li>优点：<strong>避免了线程不安全</strong>，利用静态内部类特点<strong>实现延迟加载</strong>，<strong>效率高</strong></li>
<li>缺点：<strong>不能传参</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>静态内部类：这里的关键是类在加载的时候是线程安全的，一个类只会被加载一次</li>
<li>JVM初始化时机：<ol>
<li>首次，主动使用才会初始化。即只有第一次加载类的时候初始化。</li>
<li>之后调用getInstance()方法，直接返回对象，不会再次初始化了</li>
</ol>
</li>
<li>这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</li>
</ul>
<h3 id="5-7、枚举"><a href="#5-7、枚举" class="headerlink" title="5.7、枚举"></a>5.7、枚举</h3><p>使用步骤：</p>
<ol>
<li>直接使用枚举实现单例</li>
<li>在枚举里面有<strong>INSTANCE属性</strong></li>
<li>外部直接通过<strong>Singleton.INSTANCE</strong>的方式创建实例</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 通过Singleton.INSTANCE的方式创建实例</span></span><br><span class="line">		Singleton instance = Singleton.INSTANCE;</span><br><span class="line">		Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">		System.out.println(instance == instance2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">		instance.sayOK();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">	INSTANCE; </span><br><span class="line">    <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        value = <span class="number">1</span>; </span><br><span class="line">        System.out.println(<span class="string">&quot;INSTANCE now created!&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能<strong>避免多线程同步</strong>问题，而且还能<strong>防止反序列化重新创建新的对象</strong>。</li>
<li><strong>JVM 会阻止反射获取枚举类的私有构造方法</strong></li>
<li>枚举真正实现了单例，把反序列化和反射创建第二对象的路都堵死了</li>
<li>这种方式是 <strong>Effective Java</strong> 作者 <strong>Josh Bloch</strong> 提倡的方式</li>
<li>缺点：<strong>无法进行懒加载</strong>。如果Singleton必须拓展一个超类，而不是扩展Enum的时候，则不宜使用这个方法。</li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<h3 id="5-8、单例模式在-JDK-应用的源码分析"><a href="#5-8、单例模式在-JDK-应用的源码分析" class="headerlink" title="5.8、单例模式在 JDK 应用的源码分析"></a>5.8、单例模式在 JDK 应用的源码分析</h3><p>我们 JDK 中，java.lang.Runtime 就是经典的<strong>单例模式(饿汉式)</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/31.png" alt="image-20210413021321623"></p>
<h3 id="5-9、单例模式总结"><a href="#5-9、单例模式总结" class="headerlink" title="5.9、单例模式总结"></a>5.9、单例模式总结</h3><h4 id="5-9-1、单例模式的优缺点"><a href="#5-9-1、单例模式的优缺点" class="headerlink" title="5.9.1、单例模式的优缺点"></a>5.9.1、单例模式的优缺点</h4><p>优点：</p>
<ul>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>可以避免对资源的多重占用。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ul>
<h4 id="5-9-2、单例模式的应用场景"><a href="#5-9-2、单例模式的应用场景" class="headerlink" title="5.9.2、单例模式的应用场景"></a>5.9.2、单例模式的应用场景</h4><p>对于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。</p>
<ul>
<li>需要<strong>频繁创建的一些类</strong>，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类<strong>只要求生成一个对象的时候</strong>，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时<strong>占用资源较多，或实例化耗时较长</strong>，且经常使用。</li>
<li>某类需要<strong>频繁实例化</strong>，而创建的对象又<strong>频繁被销毁</strong>的时候，如<strong>多线程的线程池</strong>、<strong>网络连接池</strong>等。</li>
<li><strong>频繁访问数据库或文件的对象</strong>。</li>
<li>对于一些<strong>控制硬件级别</strong>的操作，或者从系统上来讲应当是<strong>单一控制逻辑</strong>的操作，如果有多个实例，则系统会完全乱套。</li>
<li>当<strong>对象需要被共享</strong>的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 <strong>Web 中的配置对象、数据库的连接池</strong>等。</li>
</ul>
<h4 id="5-9-3、单例模式的结构"><a href="#5-9-3、单例模式的结构" class="headerlink" title="5.9.3、单例模式的结构"></a>5.9.3、单例模式的结构</h4><p>单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p>结构：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png" alt="image-20210412211111576"></p>
<h4 id="5-9-4、相关的设计模式"><a href="#5-9-4、相关的设计模式" class="headerlink" title="5.9.4、相关的设计模式"></a>5.9.4、相关的设计模式</h4><p>在以下模式中， 多数情况下只会生成一个实例。</p>
<ul>
<li>AbstractFactory模式</li>
<li>Builder模式</li>
<li>Facade模式</li>
<li>Prototype模式</li>
</ul>
<h4 id="5-9-5、单例模式注意事项和细节说明"><a href="#5-9-5、单例模式注意事项和细节说明" class="headerlink" title="5.9.5、单例模式注意事项和细节说明"></a>5.9.5、单例模式注意事项和细节说明</h4><ul>
<li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li>
<li>枚举是最安全的单例，是不可破坏的，其余所有的单例都是可以用反射破坏的</li>
<li>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符。因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</li>
<li><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种静态内部方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</li>
</ul>
<h4 id="5-9-6、反射与反序列化破坏单例模式的方法及解决办法"><a href="#5-9-6、反射与反序列化破坏单例模式的方法及解决办法" class="headerlink" title="5.9.6、反射与反序列化破坏单例模式的方法及解决办法"></a>5.9.6、反射与反序列化破坏单例模式的方法及解决办法</h4><p>除枚举方式外, 其他方法都会通过反射或反序列化的方式破坏单例</p>
<h5 id="5-9-6-1、反射破坏单例模式"><a href="#5-9-6-1、反射破坏单例模式" class="headerlink" title="5.9.6.1、反射破坏单例模式"></a>5.9.6.1、反射破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyb628/p/6371827.html">反射如何破坏单例模式</a></p>
<p>通过反射获得单例类的构造函数，由于该构造函数是private的，通过setAccessible(true)指示反射的对象在使用时应该取消 Java 语言访问检查，使得私有的构造函数能够被访问，这样使得单例模式失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Singleton s1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s2 = constructor.newInstance();</span><br><span class="line"> </span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-9-6-2、反序列化破坏单例模式"><a href="#5-9-6-2、反序列化破坏单例模式" class="headerlink" title="5.9.6.2、反序列化破坏单例模式"></a>5.9.6.2、反序列化破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903745772339214">序列化和反序列化的对单例破坏的防止及其原理</a></p>
<p>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例。</p>
<p>我们使用正常的方式来获取一个对象。通过序列化将对象写入文件中，然后我们通过反序列化的到一个对象，我们再对比这个对象，输出的内存地址和布尔结果都表示这不是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;单例构造器禁止反射调用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用之前的饿汉式的单例作为例子。在之前饿汉式的代码上做点小改动。就是让我们的单例类实现 Serializable接口。然后我们在测试类中测试一下怎么破坏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;singleton_file&quot;</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;singleton_file&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">        System.out.println(instance == newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-9-7、单例模式的扩展"><a href="#5-9-7、单例模式的扩展" class="headerlink" title="5.9.7、单例模式的扩展"></a>5.9.7、单例模式的扩展</h4><p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png" alt="image-20210412215700680"></p>
<h2 id="6、工厂模式（创建型设计模式）"><a href="#6、工厂模式（创建型设计模式）" class="headerlink" title="6、工厂模式（创建型设计模式）"></a>6、工厂模式（创建型设计模式）</h2><p>在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。</p>
<blockquote>
<p>注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。</p>
</blockquote>
<p>工厂模式的定义：定义一个<strong>创建产品对象的工厂接口</strong>，将<strong>产品对象的实际创建工作推迟到具体子工厂类</strong>当中。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="6-1、简单工厂模式SimpleFactory"><a href="#6-1、简单工厂模式SimpleFactory" class="headerlink" title="6.1、简单工厂模式SimpleFactory"></a>6.1、简单工厂模式SimpleFactory</h3><h4 id="6-1-1、简单工厂模式介绍"><a href="#6-1-1、简单工厂模式介绍" class="headerlink" title="6.1.1、简单工厂模式介绍"></a>6.1.1、简单工厂模式介绍</h4><ol>
<li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</li>
<li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li>
<li>在软件开发中，当我们会用到<strong>大量的创建某种、某类或者某批对象</strong>时，就会使用到工厂模式。</li>
<li>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</li>
<li>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
</ol>
<p>可总结：</p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<h4 id="6-1-2、模式的结构与实现"><a href="#6-1-2、模式的结构与实现" class="headerlink" title="6.1.2、模式的结构与实现"></a>6.1.2、模式的结构与实现</h4><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26.png" alt="image-20210413003915038"></p>
<p>根据上图写出该模式的代码如下：(模板)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3、应用实例"><a href="#6-1-3、应用实例" class="headerlink" title="6.1.3、应用实例"></a>6.1.3、应用实例</h4><p>看一个具体的需求：披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</li>
<li>披萨的制作有 prepare，bake, cut, box</li>
<li>完成披萨店订购功能。</li>
</ol>
<p>使用简单工厂模式实现：</p>
<p>简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.png" alt="image-20210413001450106"></p>
<p>代码实现（省略pizza抽象类与具体实现类的编写）：</p>
<p>根据简单工厂模式创建：</p>
<ol>
<li><p>创建工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据orderType 返回对应的Pizza 对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">	SimpleFactory simpleFactory;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		setFactory(simpleFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line">		<span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType(); </span><br><span class="line">			pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line">			<span class="comment">//输出pizza</span></span><br><span class="line">			<span class="keyword">if</span>(pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用简单工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> SimpleFactory());</span><br><span class="line">		System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>根据静态工厂模式创建：</p>
<ol>
<li><p>创建静态工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//简单工厂模式 也叫 静态工厂模式 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	String orderType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line">			<span class="comment">// 输出pizza</span></span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用静态工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza();</span><br><span class="line">         System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-1-4、简单工厂模式（静态工厂模式）的相关说明"><a href="#6-1-4、简单工厂模式（静态工厂模式）的相关说明" class="headerlink" title="6.1.4、简单工厂模式（静态工厂模式）的相关说明"></a>6.1.4、简单工厂模式（静态工厂模式）的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。<strong>客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品</strong>。工厂和产品的职责区分明确。</li>
<li>客户端<strong>无需知道所创建具体产品的类名，只需知道参数</strong>即可。</li>
<li>也可以<strong>引入配置文件</strong>，在<strong>不修改客户端代码</strong>的情况下<strong>更换和添加新的具体产品类</strong>。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>简单工厂模式的<strong>工厂类单一，负责所有产品的创建，职责过重</strong>，一旦异常，整个系统将受影响。且工厂类<strong>代码</strong>会非常<strong>臃肿</strong>，<strong>违背高聚合原则</strong>。</li>
<li>使用简单工厂模式会<strong>增加系统中类的个数</strong>（引入新的工厂类），增加系统的<strong>复杂度和理解难度</strong></li>
<li>系统<strong>扩展困难</strong>，一旦<strong>增加</strong>新产品不得不<strong>修改工厂逻辑</strong>，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 <strong>static 工厂方法</strong>，造成工厂角色<strong>无法形成基于继承</strong>的等级结构。</li>
</ol>
</li>
<li><p>应用场景</p>
<p>对于<strong>产品种类相对较少</strong>的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
</li>
<li><p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
</li>
</ul>
<h3 id="6-2、工厂方法模式Factory-Method"><a href="#6-2、工厂方法模式Factory-Method" class="headerlink" title="6.2、工厂方法模式Factory Method"></a>6.2、工厂方法模式Factory Method</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/75.PNG" alt="image-20210415031807022"></p>
<h4 id="6-2-1、工厂方法模式介绍"><a href="#6-2-1、工厂方法模式介绍" class="headerlink" title="6.2.1、工厂方法模式介绍"></a>6.2.1、工厂方法模式介绍</h4><ol>
<li> 简单工厂模式提到了违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是<strong>可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则</strong>。</li>
<li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</li>
</ol>
<h4 id="6-2-2、模式的结构与实现"><a href="#6-2-2、模式的结构与实现" class="headerlink" title="6.2.2、模式的结构与实现"></a>6.2.2、模式的结构与实现</h4><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h5 id="6-2-2-1-模式的结构"><a href="#6-2-2-1-模式的结构" class="headerlink" title="6.2.2.1. 模式的结构"></a>6.2.2.1. 模式的结构</h5><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图 1 所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/27.png" alt="image-20210413004548795"></p>
<h5 id="6-2-2-2、模式的实现"><a href="#6-2-2-2、模式的实现" class="headerlink" title="6.2.2.2、模式的实现"></a>6.2.2.2、模式的实现</h5><p>根据图 1 写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3、应用实例"><a href="#6-2-3、应用实例" class="headerlink" title="6.2.3、应用实例"></a>6.2.3、应用实例</h4><ol>
<li><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/28.png" alt="image-20210413012849728"></p>
</li>
<li><p>代码实现：</p>
<p>订购披萨OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">			<span class="comment">//输出pizza 制作过程</span></span><br><span class="line">			pizza.prepare();</span><br><span class="line">			pizza.bake();</span><br><span class="line">			pizza.cut();</span><br><span class="line">			pizza.box();	</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京的pizza继承OrderPizza（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String loc = <span class="string">&quot;bj&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (loc.equals(<span class="string">&quot;bj&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">//创建北京口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> BJOrderPizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//创建伦敦口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-2-4、工厂方法模式的相关说明"><a href="#6-2-4、工厂方法模式的相关说明" class="headerlink" title="6.2.4、工厂方法模式的相关说明"></a>6.2.4、工厂方法模式的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li><strong>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类</strong>。</li>
<li>典型的<strong>解耦框架</strong>。高层模块只需要知道产品的抽象类，无须关心其他实现类，<strong>满足迪米特法则、依赖倒置原则和里氏替换原则。</strong></li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><strong>类的个数容易过多，增加复杂度</strong></li>
<li><strong>增加了系统的抽象性和理解难度</strong></li>
<li><strong>抽象产品只能生产一种产品</strong>，此弊端可使用<strong>抽象工厂模式</strong>解决。</li>
</ol>
</li>
<li><p>应用场景：</p>
<ol>
<li><strong>客户只知道创建产品的工厂名</strong>，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li><strong>创建对象的任务由多个具体子工厂中的某一个完成</strong>，而抽象工厂只提供创建产品的接口。</li>
<li><strong>客户</strong>不关心创建产品的细节，<strong>只关心产品的品牌</strong></li>
</ol>
</li>
<li><p>注意：</p>
<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p>
</li>
</ul>
<h3 id="6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）"><a href="#6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）" class="headerlink" title="6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）"></a>6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）</h3><p>在 Factory Method 模式中有以下登场角色。 通过查看 Factory Method 模式的类图，我们可以知道， <strong>父类（框架）这一方的 Creator 角色</strong>和 <strong>Product 角色的关系</strong>与<strong>子类（具体加工）</strong>这一方的 ConcreteCreator 角色和 ConcreteProduct 角色的<strong>关系是平行的</strong>。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34.png" alt="image-20210413023513528"></p>
<ul>
<li><p>Product (产品）</p>
<p>Product角色属于框架这一方， 是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口(API)， 但具体的处理则由子类ConcreteProduct角色决定。 在示例程序中由Product类扮演此角色。</p>
</li>
<li><p>Creator (创建者）</p>
<p>Creator角色属千框架这一方， 它是负责生成 Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。 在示例程序中， 由Factory类扮演此角色。</p>
</li>
<li><p>Creator角色对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的就是， 只要调用Product角色和生成实例的方法（图4-3中的factoryMethod 方法）， 就可以生成Productde的实例。 在示例程序中，createProduct 方法是用于生成实例的方法。 <strong>不用new关键字来生成实例， 而是调用生成实例的专用方法来生成实例， 这样就可以防止父类与其他具体类耦合。</strong></p>
</li>
<li><p>ConcreteProduct (具体的产品）</p>
<p>Concrete Product角色属于具体加工这一方，它决定了具体的产品。 在示例程序中， 由IDCard 类扮演此角色。</p>
</li>
<li><p>ConcreteCreator (具体的创建者）</p>
<p>ConcreteCreator角色属于具体加工这一方， 它负责生成具体的产品。 在示例程序中，由IDCardFactory类扮演此角色。</p>
</li>
</ul>
<h3 id="6-2-6、相关的设计模式"><a href="#6-2-6、相关的设计模式" class="headerlink" title="6.2.6、相关的设计模式"></a>6.2.6、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>Factory Method模式是Template Method的典型应用。在示例程序中， create方法就是模板方法。</p>
</li>
<li><p>Singleton 模式</p>
<p>在多数情况下我们都可以将Singleton模式用于扮演Creator角色（或是ConcreteCreator角色） 的类。这是因为在程序中没有必要存在多个 Creator角色（或是ConcreteCreator角色）的实例。不过在示例程序中， 我们并没有使用Singleton模式。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以将 Composite模式用于Product角色（或是ConcreteProduct角色）。</p>
</li>
<li><p>Iterator 模式</p>
<p>有时， 在Iterator模式中使用iterator方法生成Iterator的实例时会使用Factory Method 模式。</p>
</li>
</ul>
<h3 id="6-3、抽象工厂模式Abstract-Factory"><a href="#6-3、抽象工厂模式Abstract-Factory" class="headerlink" title="6.3、抽象工厂模式Abstract Factory"></a>6.3、抽象工厂模式Abstract Factory</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/79.png" alt="image-20210415032040170"></p>
<h4 id="6-3-1、抽象工厂模式介绍"><a href="#6-3-1、抽象工厂模式介绍" class="headerlink" title="6.3.1、抽象工厂模式介绍"></a>6.3.1、抽象工厂模式介绍</h4><ol>
<li>前面介绍的<strong>工厂方法模式中考虑的是一类产品的生产</strong>，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</li>
<li>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</li>
<li><strong>抽象工厂模式将考虑多等级产品的生产</strong>，将同一个具体工厂所生产的位于<strong>不同等级的一组产品称为一个产品族</strong>.</li>
</ol>
<p>抽象工厂（AbstractFactory）模式的定义：定义了一个 <strong>interface</strong> 用于创建相关或有依赖关系的对象簇，而无需指明具体的类，是一种<strong>为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且<strong>访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</strong>。可以看作：抽象工厂是一个超级工厂，围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。</p>
<p><strong>抽象工厂模式是工厂方法模式的升级版本</strong>，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p>
<p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</p>
<p>将工厂抽象成两层，<strong>AbsFactory(**抽象工厂</strong>)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<h4 id="6-3-2、模式的结构与实现"><a href="#6-3-2、模式的结构与实现" class="headerlink" title="6.3.2、模式的结构与实现"></a>6.3.2、模式的结构与实现</h4><h5 id="6-3-2-1、模式的结构"><a href="#6-3-2-1、模式的结构" class="headerlink" title="6.3.2.1、模式的结构"></a>6.3.2.1、模式的结构</h5><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<h5 id="6-3-2-2、模式的实现类图（具体代码）"><a href="#6-3-2-2、模式的实现类图（具体代码）" class="headerlink" title="6.3.2.2、模式的实现类图（具体代码）"></a>6.3.2.2、模式的实现类图（<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html">具体代码</a>）</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/29.png" alt="image-20210413015123090"></p>
<h4 id="6-3-3、应用实例"><a href="#6-3-3、应用实例" class="headerlink" title="6.3.3、应用实例"></a>6.3.3、应用实例</h4><p>使用抽象工厂模式来完成披萨项目。</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30.png" alt="image-20210413015603989"></p>
<p>代码：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京工厂实现抽象工厂生产披萨（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是工厂子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订购披萨：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	AbsFactory factory;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		setFactory(factory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">		<span class="keyword">this</span>.factory = factory;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			<span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">			pizza = factory.createPizza(orderType);</span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> BJFactory());</span><br><span class="line">		<span class="comment">// new OrderPizza(new LDFactory());</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4、抽象工厂模式的相关说明"><a href="#6-3-4、抽象工厂模式的相关说明" class="headerlink" title="6.3.4、抽象工厂模式的相关说明"></a>6.3.4、抽象工厂模式的相关说明</h4><ul>
<li><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ol>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，<strong>抽象工厂可以保证客户端始终只使用同一个产品的产品组</strong>。</li>
<li>抽象工厂增强了<strong>程序的可扩展性</strong>，当增加一个新的产品族时，不需要修改原代码，<strong>满足开闭原则</strong>。</li>
</ol>
</li>
<li><p>其缺点是：<strong>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度</strong></p>
<p>模式的应用场景</p>
<p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 Java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p>
<ol>
<li>当需要创建的对象是一系列<strong>相互关联或相互依赖的产品族</strong>时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li><strong>系统中有多个产品族，但每次只使用其中的某一族产品</strong>。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li><strong>系统中提供了产品的类库，且所有产品的接口相同</strong>，客户端不依赖产品实例的创建细节和内部结构。</li>
</ol>
</li>
<li><p>模式的扩展</p>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
</li>
<li><p>进阶阅读</p>
<p>如果您想了解抽象工厂在框架源码中的应用，可阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8392.html">《抽象工厂在Java源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8393.html">《抽象工厂模式在Spring源码中的应用》</a></li>
</ul>
</li>
</ul>
<h4 id="6-3-5、相关的设计模式"><a href="#6-3-5、相关的设计模式" class="headerlink" title="6.3.5、相关的设计模式"></a>6.3.5、相关的设计模式</h4><ul>
<li><p>Builder模式</p>
<p>Abstract Factory模式通过调用抽象产品的接口 (APl) 来组装抽象产品， 生成具有复杂结构的实例。</p>
<p>Builder模式则是分阶段地制作复杂实例。</p>
</li>
<li><p>Factory Method模式</p>
<p>有时AbstractFactory模式中零件和产品的生成会使用到Factory Method模式。</p>
</li>
<li><p>Composite模式</p>
<p>有时AbstractFactory模式在制作产品时会使用Composite模式。</p>
</li>
<li><p>Singleton模式</p>
<p>有时AbstractFactory模式中的具体工厂会使用Singleton模式。</p>
</li>
</ul>
<h3 id="6-4、工厂模式在-JDK-Calendar-应用的源码分析"><a href="#6-4、工厂模式在-JDK-Calendar-应用的源码分析" class="headerlink" title="6.4、工厂模式在 JDK-Calendar 应用的源码分析"></a>6.4、工厂模式在 JDK-Calendar 应用的源码分析</h3><p>JDK 中的 Calendar 类中，就使用了<strong>简单工厂模式</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/33.png" alt="image-20210413021425940"></p>
<p>其中createCalendar()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32.png" alt="image-20210413022320157"></p>
<h3 id="6-5、工厂模式小结"><a href="#6-5、工厂模式小结" class="headerlink" title="6.5、工厂模式小结"></a>6.5、工厂模式小结</h3><ol>
<li><p>工厂模式的意义</p>
<p>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p>
</li>
<li><p>三种工厂模式 </p>
<ol>
<li>简单工厂模式（不在23种之中）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
</li>
<li><p>设计模式的<strong>依赖抽象原则</strong></p>
</li>
</ol>
<p>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</p>
<p>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</p>
<p>不要覆盖基类中已经实现的方法。</p>
<h2 id="7、原型模式ProtoType（创建型设计模式）"><a href="#7、原型模式ProtoType（创建型设计模式）" class="headerlink" title="7、原型模式ProtoType（创建型设计模式）"></a>7、原型模式ProtoType（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/77.png" alt="image-20210415031921912"></p>
<h3 id="7-1、基本介绍"><a href="#7-1、基本介绍" class="headerlink" title="7.1、基本介绍"></a>7.1、基本介绍</h3><ol>
<li>原型模式(Prototype 模式)是指：用<strong>原型实例指定创建对象的种类</strong>，并且通过<strong>拷贝</strong>这些原型，创建新的对象</li>
<li>原型模式是一种<strong>创建型设计</strong>模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象<strong>通过请求原型对象拷贝它们自己来实施创建</strong>，即 对象**.clone**()</li>
</ol>
<h3 id="7-2、原型模式原理结构图-uml-类图"><a href="#7-2、原型模式原理结构图-uml-类图" class="headerlink" title="7.2、原型模式原理结构图-uml 类图"></a>7.2、原型模式原理结构图-uml 类图</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.png" alt="image-20210413222550496"></p>
<p>原理结构图说明：</p>
<ul>
<li>Prototype : 原型类，<strong>声明一个克隆自己的接口</strong></li>
<li>ConcretePrototype: 具体的原型类, <strong>实现</strong>一个克隆自己的操作</li>
<li>Client: 使用者；让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li>
</ul>
<h3 id="7-3、应用举例"><a href="#7-3、应用举例" class="headerlink" title="7.3、应用举例"></a>7.3、应用举例</h3><p>克隆羊问题：</p>
<p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊。</p>
<h4 id="7-3-1、传统方式解决克隆羊问题"><a href="#7-3-1、传统方式解决克隆羊问题" class="headerlink" title="7.3.1、传统方式解决克隆羊问题"></a>7.3.1、传统方式解决克隆羊问题</h4><h5 id="7-3-1-1、思路分析-类图"><a href="#7-3-1-1、思路分析-类图" class="headerlink" title="7.3.1.1、思路分析(类图)"></a>7.3.1.1、思路分析(类图)</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.png" alt="image-20210413222817657"></p>
<h5 id="7-3-1-2、相关代码：（在Client中）"><a href="#7-3-1-2、相关代码：（在Client中）" class="headerlink" title="7.3.1.2、相关代码：（在Client中）"></a>7.3.1.2、相关代码：（在Client中）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的方法</span></span><br><span class="line">Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); </span><br></pre></td></tr></table></figure>

<h5 id="7-3-1-3、传统的方式的优缺点"><a href="#7-3-1-3、传统的方式的优缺点" class="headerlink" title="7.3.1.3、传统的方式的优缺点"></a>7.3.1.3、传统的方式的优缺点</h5><ol>
<li>优点是比较好理解，简单易操作。</li>
<li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
</ol>
<h5 id="7-3-1-4、改进方法（使用原型模式）"><a href="#7-3-1-4、改进方法（使用原型模式）" class="headerlink" title="7.3.1.4、改进方法（使用原型模式）"></a>7.3.1.4、改进方法（使用原型模式）</h5><p>Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt;原型模式</p>
<h4 id="7-3-2、原型模式解决克隆羊问题"><a href="#7-3-2、原型模式解决克隆羊问题" class="headerlink" title="7.3.2、原型模式解决克隆羊问题"></a>7.3.2、原型模式解决克隆羊问题</h4><p>实现步骤：</p>
<ol>
<li>实例实现接口Cloneable，并重写Object的clone方法</li>
<li>在Client使用创建的实例的clone方法进行对象的克隆</li>
</ol>
<p>代码实现：</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sheep;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">		sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		<span class="comment">//克隆</span></span><br><span class="line">		Sheep sheep2 = (Sheep)sheep.clone(); </span><br><span class="line">		System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原型模式改进传统方式，让程序具有<strong>更高的效率和扩展性</strong>。</p>
<h3 id="7-4、浅拷贝和深拷贝"><a href="#7-4、浅拷贝和深拷贝" class="headerlink" title="7.4、浅拷贝和深拷贝"></a>7.4、浅拷贝和深拷贝</h3><h4 id="7-4-1、浅拷贝的介绍"><a href="#7-4-1、浅拷贝的介绍" class="headerlink" title="7.4.1、浅拷贝的介绍"></a>7.4.1、浅拷贝的介绍</h4><ol>
<li>对于数据类型是<strong>基本数据类型</strong>的成员变量，<strong>浅拷贝会直接进行值传递</strong>，也就是将该<strong>属性值复制一份给新的对象</strong>。</li>
<li>对于String，虽然String不是基本数据结构，而是应用数据类型。但是在JVM中存在字符串常量池会存储已创建的字符串。在克隆的时候也是引用也是直接指向字符串常量池里的字符串。所以在clone当中可以将String近似于看作基本数据类型。</li>
<li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是<strong>某个数组、某个类的对象</strong>等，那么浅拷贝会进行<strong>引用传递</strong>，也就是只是将<strong>该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为实际上两个对象的该成员变量都<strong>指向同一个实例</strong>。在这种情况下，在<strong>一个对象中修改该成员变量会影响到另一个对象的该成员变量值</strong>。</li>
<li>前面我们克隆羊就是浅拷贝（里面的friend是同一个friend，即所有的克隆羊都有同一个朋友）</li>
<li>浅拷贝是使用默认的 clone()方法来实现：sheep = (Sheep) super.clone();</li>
</ol>
<h4 id="7-4-2、深拷贝基本介绍"><a href="#7-4-2、深拷贝基本介绍" class="headerlink" title="7.4.2、深拷贝基本介绍"></a>7.4.2、深拷贝基本介绍</h4><ol>
<li>复制对象的<strong>所有基本数据类型</strong>的成员变量值</li>
<li>为<strong>所有引用数据类型的成员变量申请存储空间</strong>，并<strong>复制每个引用数据类型成员变量所引用的对象</strong>，直到该对象可达的所有对象。也就是说，对象进行深拷贝要<strong>对整个对象(包括对象的引用类型)进行拷贝</strong></li>
<li>深拷贝实现方式 1：重写 <strong>clone</strong> 方法来实现深拷贝</li>
<li>深拷贝实现方式 2：通过<strong>对象序列化</strong>实现深拷贝(<strong>推荐</strong>)</li>
</ol>
<h4 id="7-4-3、深拷贝应用实例"><a href="#7-4-3、深拷贝应用实例" class="headerlink" title="7.4.3、深拷贝应用实例"></a>7.4.3、深拷贝应用实例</h4><h5 id="7-4-3-1、使用-重写-clone-方法实现深拷贝"><a href="#7-4-3-1、使用-重写-clone-方法实现深拷贝" class="headerlink" title="7.4.3.1、使用 重写 clone 方法实现深拷贝"></a>7.4.3.1、使用 重写 clone 方法实现深拷贝</h5><p>DeepCloneableTarget：其他实例当中的成员变量：实现克隆接口与序列化接口Serializable, Cloneable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String cloneName;</span><br><span class="line">	<span class="keyword">private</span> String cloneClass;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">		<span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//深拷贝 - 方式 1 使用clone 方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Object deep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">		deep = <span class="keyword">super</span>.clone(); </span><br><span class="line">		<span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">		DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line">		<span class="keyword">return</span> deepProtoType;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);	</span><br><span class="line">        <span class="comment">//方式1 完成深拷贝</span></span><br><span class="line">        DeepProtoType p2 = (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-2、使用序列化来实现深拷贝"><a href="#7-4-3-2、使用序列化来实现深拷贝" class="headerlink" title="7.4.3.2、使用序列化来实现深拷贝"></a>7.4.3.2、使用序列化来实现深拷贝</h5><p>DeepCloneableTarget：同上</p>
<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建流对象</span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//序列化</span></span><br><span class="line">			bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">			<span class="comment">//反序列化</span></span><br><span class="line">			bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">			DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">			<span class="keyword">return</span> copyObj;	</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭流</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bos.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				bis.close();</span><br><span class="line">				ois.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">		p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">		p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);</span><br><span class="line">		<span class="comment">//方式2 完成深拷贝</span></span><br><span class="line">		DeepProtoType p2 = (DeepProtoType) p.deepClone();</span><br><span class="line">		System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝："><a href="#7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝：" class="headerlink" title="7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝："></a>7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝：</h5><p>使用序列化可以实现，但是使用clone方法会报StackOverflowError异常</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//实例类的成员变量为本身</span></span><br><span class="line">    <span class="keyword">public</span> Sheep friend;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, friend=&quot;</span> + friend +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝 通过对象的序列化实现 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Sheep copyObj = (Sheep)ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>,<span class="string">&quot;black&quot;</span>);</span><br><span class="line">        sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;john&quot;</span>, <span class="number">2</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.deepClone();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;sheep.name=&quot;</span> + sheep.getName() + <span class="string">&quot; sheep.age=&quot;</span> + sheep.getAge() + <span class="string">&quot; sheep.color=&quot;</span> + sheep.getColor() + <span class="string">&quot; sheep.friend&quot;</span> + sheep.friend.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;sheep1.name=&quot;</span> + sheep1.getName() + <span class="string">&quot; sheep1.age=&quot;</span> + sheep1.getAge() + <span class="string">&quot; sheep1.color=&quot;</span> + sheep1.getColor() + <span class="string">&quot; sheep1.friend&quot;</span> + sheep1.friend.hashCode());</span><br><span class="line">        System.out.println(sheep.friend == sheep1.friend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-4、对于深拷贝的clone方法与序列化方法"><a href="#7-4-4、对于深拷贝的clone方法与序列化方法" class="headerlink" title="7.4.4、对于深拷贝的clone方法与序列化方法"></a>7.4.4、对于深拷贝的clone方法与序列化方法</h4><h5 id="7-4-4-1、clone方法"><a href="#7-4-4-1、clone方法" class="headerlink" title="7.4.4.1、clone方法"></a>7.4.4.1、clone方法</h5><ul>
<li>clone方法分成两步：<ol>
<li>先克隆<strong>基本数据类型和String</strong></li>
<li>在对其<strong>引用数据类型</strong>进行多次克隆</li>
</ol>
</li>
<li>如果想要深拷贝一个对象， 这个对象必须要<strong>实现Cloneable接口，实现clone方法</strong>，并且在<strong>clone方法内部，把该对象引用的其他对象也要clone一份</strong> ， 这就要求这个<strong>被引用的对象必须也要实现Cloneable接口并且实现clone方法。</strong></li>
<li>clone实际上就是实现了<strong>多重clone</strong>，实例本身有其他的应用数据类型（除String），就先重写其他的<strong>引用数据类型</strong>的clone方法；若在其他的应用数据类型（除String）又有其他的引用数据类型，又重复该过程，直到做到所有的成员变量都完成clone。</li>
<li>所以，如果在拷贝一个对象时，要想让<strong>这个拷贝的对象和源对象完全彼此独立</strong>，那么在<strong>引用链上的每一级对象都要被显式的拷贝</strong>。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而<strong>这个对象没有实现clone方法</strong>， 那么在它之后的所有引用的对象都是被共享的。或者如果某一个类<strong>没有实现Cloneable接口</strong>，我们还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中这种深拷贝方式<strong>不常用</strong>。</li>
</ul>
<h5 id="7-4-4-2、序列化方法"><a href="#7-4-4-2、序列化方法" class="headerlink" title="7.4.4.2、序列化方法"></a>7.4.4.2、序列化方法</h5><ul>
<li>序列化方法也分成两步<ol>
<li>将要实现克隆的实例进行序列化</li>
<li>在将其进行反序列化出来实现实例的拷贝</li>
</ol>
</li>
<li>使用该类的<strong>对象必须要实现Serializable接口</strong>，否则是没有办法实现克隆的。无须继承Cloneable接口实现clone()方法。</li>
<li>在内存中通过字节流的拷贝是比较容易实现的。把<strong>母对象写入到一个字节流</strong>中，再<strong>从字节流中将其读出来</strong>，这样就可以<strong>创建一个新的对象</strong>了，并且该<strong>新对象与母对象之间并不存在引用共享</strong>的问题，<strong>真正实现对象的深拷贝</strong>。</li>
<li>能实现<strong>对于实例类的成员变量为本身的实例的深拷贝</strong></li>
<li>缺点：使用该类的<strong>对象必须要实现Serializable接口</strong>，所以在一些类并没有实现Serializable接口，如果还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中<strong>推荐</strong>使用这种方式进行深拷贝。</li>
</ul>
<h3 id="7-5、原型模式在-Spring-框架中源码分析"><a href="#7-5、原型模式在-Spring-框架中源码分析" class="headerlink" title="7.5、原型模式在 Spring 框架中源码分析"></a>7.5、原型模式在 Spring 框架中源码分析</h3><p>Spring 中原型 bean 的创建，就是原型模式的应用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.png" alt="image-20210414025832896"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.png" alt="image-20210414030430256"></p>
<h3 id="7-6、new一个对象的过程和clone一个对象的过程区别"><a href="#7-6、new一个对象的过程和clone一个对象的过程区别" class="headerlink" title="7.6、new一个对象的过程和clone一个对象的过程区别"></a>7.6、new一个对象的过程和clone一个对象的过程区别</h3><p>关于new：</p>
<p>new操作符的本意是<strong>分配内存</strong>。程序执行到new操作符时，会<strong>先去看new操作符后面的类型</strong>，因为知道了类型，才能知道要分配多大的内存空间。<strong>分配</strong>完<strong>内存</strong>之后，<strong>再调用构造函数</strong>，填充对象的各个域，这一步叫做<strong>对象的初始化</strong>，构造方法返回后，一个对象创建完毕，可以<strong>把它的引用</strong>（也就是地址）<strong>发布到外部</strong>，在外部就可以使用这个引用操作这个对象。</p>
<p>关于clone：</p>
<p><strong>clone在第一步</strong>是和new相似的，都是<strong>分配内存</strong>，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后<strong>再使用原对象中对应的各个域，填充新对象的域</strong>，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把<strong>这个新对象的引用发布到外部</strong>。</p>
<blockquote>
<ol>
<li>clone()不会调用构造方法；new会调用构造方法。</li>
<li>new对象时根据类型确定分配内存空间的大小, clone是根据原对象分配内</li>
</ol>
</blockquote>
<h3 id="7-7、原型模式的总结"><a href="#7-7、原型模式的总结" class="headerlink" title="7.7、原型模式的总结"></a>7.7、原型模式的总结</h3><p>原型模式的优点：</p>
<ul>
<li>Java 自带的原型模式基于内存<strong>二进制流的复制</strong>，在<strong>性能上比直接 new 一个对象更加优良</strong>。</li>
<li>它<strong>逃避了构造函数的约束</strong>。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如<strong>恢复到历史某一状态</strong>），可辅助实现<strong>撤销操作</strong>。</li>
</ul>
<p>原型模式的缺点：</p>
<ul>
<li>需要为<strong>每一个类都配置一个 clone 方法</strong></li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，<strong>违背了开闭原则</strong>。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，<strong>每一层对象对应的类都必须支持深克隆</strong>，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<p>原型模式的应用场景：</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</li>
<li>资源优化场景</li>
<li>一个对象多个修改者的场景</li>
<li>想要生成实例的框架不依赖与具体的类，解耦框架与生成的实例</li>
</ul>
<p>在实际项目中，原型模式很少单独出现，一般是<strong>和工厂方法模式一起出现</strong>，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 中，原型模式应用的非常广泛，例如 scope=’prototype’、JSON.parseObject() 等都是原型模式的具体应用。</p>
<h3 id="7-8、原型模式的扩展（带原型管理器的原型模式）"><a href="#7-8、原型模式的扩展（带原型管理器的原型模式）" class="headerlink" title="7.8、原型模式的扩展（带原型管理器的原型模式）"></a>7.8、原型模式的扩展（带原型管理器的原型模式）</h3><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/35.png" alt="image-20210414092155079"></p>
<p>举例：</p>
<p>用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，是其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/36.png" alt="image-20210414092311712"></p>
<p>ProtoTypeManager ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt; ht = <span class="keyword">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>, <span class="keyword">new</span> Circle());</span><br><span class="line">        ht.put(<span class="string">&quot;Square&quot;</span>, <span class="keyword">new</span> Square());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String key, Shape obj)</span> </span>&#123;</span><br><span class="line">        ht.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Shape temp = ht.get(key);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-9、进阶阅读"><a href="#7-9、进阶阅读" class="headerlink" title="7.9、进阶阅读"></a>7.9、进阶阅读</h3><p>原型模式也称为克隆模式，如果您想深入了解原型（克隆）模式，可以猛击阅读下面的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8379.html">《浅克隆和深克隆》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8382.html">《克隆会破坏单例对象吗》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8383.html">《原型模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="7-10、相关的设计模式"><a href="#7-10、相关的设计模式" class="headerlink" title="7.10、相关的设计模式"></a>7.10、相关的设计模式</h3><ul>
<li><p>Flyweight 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。 而使用Flyweight模式可以在不同的地方使用同一个实例。</p>
</li>
<li><p>Memento 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。而使用Memento模式可以保存当前实例的状态， 以实现快照和撤销功能。</p>
</li>
<li><p>Composite 模式以及 Decorator 模式</p>
<p>经常使用Composite模式和Decorator模式时， 需要能够动态地创建复杂结构的实例。 这时可 以使用Prototype模式， 以帮助我们方便地生成实例。</p>
</li>
<li><p>Command 模式</p>
<p>想要复制Command模式中出现的命令时， 可以使用Prototype模式。</p>
</li>
</ul>
<h3 id="7-11、原型模式的注意事项和细节"><a href="#7-11、原型模式的注意事项和细节" class="headerlink" title="7.11、原型模式的注意事项和细节"></a>7.11、原型模式的注意事项和细节</h3><ul>
<li>创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程，同时也能够提高效率</strong></li>
<li>不用<strong>重新初始化对象</strong>，而是<strong>动态地获得对象运行时的状态</strong></li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li>Cloneable接口是一个标记接口，没有声明方法</li>
<li>缺点：需要为<strong>每一个类配备一个克隆方法</strong>，这对全新的类来说不是很难，但<strong>对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。</strong></li>
<li>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</li>
</ul>
<h2 id="8、建造者模式Builder（创建型设计模式）"><a href="#8、建造者模式Builder（创建型设计模式）" class="headerlink" title="8、建造者模式Builder（创建型设计模式）"></a>8、建造者模式Builder（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/78.png" alt="image-20210415031952053"></p>
<h3 id="8-1、基本介绍"><a href="#8-1、基本介绍" class="headerlink" title="8.1、基本介绍"></a>8.1、基本介绍</h3><ol>
<li>建造者模式（<strong>Builder Pattern</strong>） 又叫<strong>生成器模式</strong>，是一种<strong>对象构建模式</strong>。它可以将<strong>复杂对象</strong>的建造过程<strong>抽象出来（抽象类别）</strong>，使这个抽象过程的<strong>不同实现方法可以构造出不同表现（属性）的对象</strong>。</li>
<li>建造者模式将一个复杂对象的<strong>构造</strong>与它的<strong>表示分离</strong>，使<strong>同样的构建过程可以创建不同的表示</strong>。它是将<strong>一个复杂的对象分解为多个简单的对象，然后一步一步构建而成</strong>。它将<strong>变与不变相分离</strong>，即<strong>产品的组成部分</strong>是<strong>不变</strong>的，但<strong>每一部分</strong>是可以<strong>灵活选择</strong>的。</li>
</ol>
<h3 id="8-2、建造者模原理结构图-uml类图与模板实现"><a href="#8-2、建造者模原理结构图-uml类图与模板实现" class="headerlink" title="8.2、建造者模原理结构图-uml类图与模板实现"></a>8.2、建造者模原理结构图-uml类图与模板实现</h3><h4 id="8-2-1、建造者模式的四个角色"><a href="#8-2-1、建造者模式的四个角色" class="headerlink" title="8.2.1、建造者模式的四个角色"></a>8.2.1、建造者模式的四个角色</h4><p>建造者（Builder）模式由<strong>产品</strong>、<strong>抽象建造者</strong>、<strong>具体建造者</strong>、<strong>指挥者</strong>等 4 个要素构成</p>
<ol>
<li>Product（<strong>产品角色</strong>）： 它是包含多个组成部件的复杂对象，由<strong>具体建造者来创建其各个零部件</strong>。</li>
<li>Builder（<strong>抽象建造者</strong>）： 它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回**复杂产品的方法 getResult()**。</li>
<li>ConcreteBuilder（<strong>具体建造者</strong>）： <strong>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</strong></li>
<li>Director（<strong>指挥者</strong>）： 构建一个<strong>使用 Builder 接口的对象</strong>。它主要是用于<strong>创建一个复杂的对象</strong>。它主要有两个作用：<ol>
<li><strong>隔离</strong>了客户与对象的生产过程</li>
<li>负责<strong>控制</strong>产品对象的生产过程</li>
</ol>
</li>
</ol>
<h4 id="8-2-2、建造者模式原理类图"><a href="#8-2-2、建造者模式原理类图" class="headerlink" title="8.2.2、建造者模式原理类图"></a>8.2.2、建造者模式原理类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/37.png" alt="image-20210414182531377"></p>
<h4 id="8-2-3、类图的模板代码实现"><a href="#8-2-3、类图的模板代码实现" class="headerlink" title="8.2.3、类图的模板代码实现"></a>8.2.3、类图的模板代码实现</h4><p>产品角色Product：包含多个组成部件的复杂对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">	<span class="comment">// setters方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象建造者Builder：包含创建产品各个子部件的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者ConcreteBuilder：实现了抽象建造者接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者Director：调用建造者中的方法完成复杂对象的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3、应用举例"><a href="#8-3、应用举例" class="headerlink" title="8.3、应用举例"></a>8.3、应用举例</h3><p>盖房项目需求</p>
<ol>
<li>需要建房子：这一过程为打桩、砌墙、封顶</li>
<li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li>
<li>请编写程序，完成需求.</li>
</ol>
<h4 id="8-3-1、传统方法"><a href="#8-3-1、传统方法" class="headerlink" title="8.3.1、传统方法"></a>8.3.1、传统方法</h4><p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/38.png" alt="image-20210414183731177"></p>
<p>传统方式的问题分析</p>
<ol>
<li>优点是比较好理解，简单易操作。</li>
<li>设计的程序结构，过于简单，<strong>没有设计缓存层对象</strong>，程序的<strong>扩展和维护不好</strong>. 也就是说，这种设计方案，把<strong>产品(**即：房子) 和 **创建产品的过程</strong>(即：建房子流程) <strong>封装在一起，耦合性增强了</strong>。</li>
<li>解决方案：将<strong>产品和产品建造过程解耦</strong>  =&gt; <strong>建造者模式</strong></li>
</ol>
<h4 id="8-3-2、建造者模式解决盖房子问题"><a href="#8-3-2、建造者模式解决盖房子问题" class="headerlink" title="8.3.2、建造者模式解决盖房子问题"></a>8.3.2、建造者模式解决盖房子问题</h4><p>思路分析图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/39.png" alt="image-20210414183956399"></p>
<h3 id="8-4、建造者模式在JDK中的应用与源码分析"><a href="#8-4、建造者模式在JDK中的应用与源码分析" class="headerlink" title="8.4、建造者模式在JDK中的应用与源码分析"></a>8.4、建造者模式在JDK中的应用与源码分析</h3><p>java.lang.StringBuilder 中的建造者模式</p>
<p>代码说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/40.png" alt="image-20210414185001199"></p>
<p>源码中建造者模式角色分析</p>
<ul>
<li>Appendable 接口定义了多个 append 方法(抽象方法), 即 <strong>Appendable 为抽象建造者（builder）</strong>, 定义了<strong>抽象方法</strong></li>
<li>AbstractStringBuilder <strong>实现</strong>了  Appendable <strong>接口方法</strong>，这里的 AbstractStringBuilder 已经是<strong>建造者（ConcreteBuilder）</strong>，只是<strong>不能实例化</strong></li>
<li>StringBuilder 即充当了<strong>指挥者角色（Director）</strong>，同时充当了<strong>具体的建造者（ConcreteBuilder）</strong>，<strong>建造方法的实现是由 AbstractStringBuilder 完成</strong> , 而 StringBuilder <strong>继承了 AbstractStringBuilder</strong>。直接使用了AbstractStringBuilder实现的方法。</li>
</ul>
<h3 id="8-5、建造者模式与工厂模式对区别"><a href="#8-5、建造者模式与工厂模式对区别" class="headerlink" title="8.5、建造者模式与工厂模式对区别"></a>8.5、建造者模式与工厂模式对区别</h3><ul>
<li>抽象工厂模式实现对<strong>产品家族</strong>的创建，一个产品家族是这样的一系列产品：具有<strong>不同分类维度的产品组合</strong>，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。</li>
<li>建造者模式则是要求<strong>按照指定的蓝图建造产品</strong>，它的主要目的是通过<strong>组装零配件而产生一个新产品</strong>。</li>
</ul>
<p>主要区别：</p>
<ul>
<li><strong>建造者模式</strong>更加注重方法的<strong>调用顺序</strong>，<strong>工厂模式</strong>注重<strong>创建对象</strong>。</li>
<li>创建对象的<strong>力度不同</strong>，<strong>建造者模式创建复杂的对象，由各种复杂的部件组成</strong>，<strong>工厂模式创建出来的对象都一样</strong></li>
<li><strong>关注重点不一样</strong>，<strong>工厂模式</strong>只需要把<strong>对象创建出来</strong>就可以了，而<strong>建造者模式</strong>不仅要<strong>创建出对象</strong>，还要知道<strong>对象由哪些部件组成</strong>。</li>
<li><strong>建造者模式</strong>根据建造过程中的<strong>顺序不一样</strong>，最终<strong>对象部件组成也不一样</strong>。</li>
</ul>
<p>建造者模式唯一区别于工厂模式的是<strong>针对复杂对象的创建</strong>。也就是说，如果<strong>创建简单对象</strong>，通常都是使用<strong>工厂模式</strong>进行创建，而如果<strong>创建复杂对象</strong>，就可以考虑使用<strong>建造者模式</strong>。</p>
<p>当需要创建的产品具备<strong>复杂创建过程</strong>时，可以<strong>抽取出共性创建过程</strong>，然后交由<strong>具体实现类自定义创建流程</strong>，使得同样的创建行为可以生产出不同的产品，<strong>分离了创建与表示</strong>，使创建产品的灵活性大大增加。</p>
<h3 id="8-6、建造者模式总结"><a href="#8-6、建造者模式总结" class="headerlink" title="8.6、建造者模式总结"></a>8.6、建造者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>封装性好</strong>，构建和表示分离。</li>
<li><strong>扩展性好</strong>，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于<strong>控制细节风险</strong>。</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>产品的<strong>组成部分必须相同</strong>，这限制了其使用范围。</li>
<li>如果产品的<strong>内部变化复杂</strong>，如果<strong>产品内部发生变化</strong>，则<strong>建造者也要同步修改</strong>，后期<strong>维护成本较大</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ul>
<li><strong>相同的方法</strong>，<strong>不同的执行顺序</strong>，<strong>产生不同的结果</strong>。</li>
<li><strong>多个部件或零件</strong>，都可以<strong>装配到一个对象中</strong>，但是产生的<strong>结果又不相同</strong>。</li>
<li><strong>产品类非常复杂</strong>，或者产品类中<strong>不同的调用顺序产生不同的作用</strong>。</li>
<li><strong>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</strong></li>
</ul>
<h3 id="8-7、进阶阅读"><a href="#8-7、进阶阅读" class="headerlink" title="8.7、进阶阅读"></a>8.7、进阶阅读</h3><p>如果您想了解建造者模式在实际项目中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8404.html">《建造者模式实现链式赋值》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8409.html">《使用静态内部类实现建造者模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8415.html">《使用建造者模式构建动态SQL语句》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8420.html">《建造者模式在框架源码中的应用》</a></li>
</ul>
<h3 id="8-8、相关的设计模式"><a href="#8-8、相关的设计模式" class="headerlink" title="8.8、相关的设计模式"></a>8.8、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<ul>
<li>在 Builder 模式中， Director 角色控制 Builder 角色。</li>
<li>在 Template Method 模式中 ， 父类控制子类。</li>
</ul>
</li>
<li><p>Composite 模式</p>
<p>有些情况下 Builder 模式生成的实例构成了 Composite 模式。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>Builder 模式和 Abstract Factory 模式都用千生成复杂的实例。</p>
</li>
<li><p>Facade 模式</p>
<p>在 Builder 模式中， Director 角色通过组合 Builder 角色中的复杂方法向外部提供可以简单生成 实例的接口 (API) （相当于示例程序中的 construct 方法）。</p>
<p>Facade 模式中的 Facade 角色则是通过组合内部模块向外部提供可以简单调用的接口 (API)。</p>
</li>
</ul>
<h3 id="8-9、建造者模式的注意事项和细节"><a href="#8-9、建造者模式的注意事项和细节" class="headerlink" title="8.9、建造者模式的注意事项和细节"></a>8.9、建造者模式的注意事项和细节</h3><ol>
<li>客户端(使用程序)不必知道产品内部组成的细节，将<strong>产品本身与产品的创建过程解耦</strong>，使得<strong>相同的创建过程可以创建不同的产品对象</strong></li>
<li>每一个<strong>具体建造者都相对独立</strong>，而<strong>与其他的具体建造者无关</strong>，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></li>
<li>可以更加<strong>精细</strong>地控制产品的创建过程 。将<strong>复杂产品的创建步骤分解在不同的方法中</strong>，使得创建过程更加清晰， 也更方便使用程序来<strong>控制创建过程</strong></li>
<li>增加新的具体建造者<strong>无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统<strong>扩展方便</strong>，<strong>符合“开闭原则”</strong></li>
<li>建造者（Builder）模式在应用过程中可以根据需要改变，如果<strong>创建的产品种类只有一种</strong>，只需要<strong>一个具体建造者</strong>，这时可以<strong>省略</strong>掉<strong>抽象建造者</strong>，甚至可以<strong>省略掉指挥者角色</strong>。</li>
<li>建造者模式所创建的产品<strong>一般具有较多的共同点</strong>，其<strong>组成部分相似</strong>，如果<strong>产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li>
<li>如果产品的<strong>内部变化复杂</strong>，可能会导致需要定义<strong>很多具体建造者类来实现这种变化</strong>，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li>
</ol>
<h2 id="9、适配器模式Adapter（结构型模式）"><a href="#9、适配器模式Adapter（结构型模式）" class="headerlink" title="9、适配器模式Adapter（结构型模式）"></a>9、适配器模式Adapter（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/73.PNG" alt="image-20210415031546174"></p>
<h3 id="9-1、基本介绍"><a href="#9-1、基本介绍" class="headerlink" title="9.1、基本介绍"></a>9.1、基本介绍</h3><ol>
<li><p>适配器模式(Adapter Pattern)将<strong>某个类的接口转换成客户端期望的另一个接口表示</strong>，主的目的是<strong>兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为<strong>包装器(Wrapper)</strong></p>
</li>
<li><p>适配器模式属于<strong>结构型模式</strong></p>
</li>
<li><p>主要分为三类</p>
<ol>
<li>类适配器模式</li>
<li>对象适配器模式</li>
<li>接口适配器模式</li>
</ol>
</li>
<li><p>工作原理</p>
<p>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p>
<ol>
<li><p>从用户的角度看不到被适配者，是解耦的</p>
</li>
<li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p>
</li>
<li><p>用户收到反馈结果，感觉只是和目标接口交互，如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/41.png" alt="image-20210414214311154"></p>
</li>
</ol>
</li>
</ol>
<h3 id="9-2、适配器模式原理结构图-uml类图"><a href="#9-2、适配器模式原理结构图-uml类图" class="headerlink" title="9.2、适配器模式原理结构图-uml类图"></a>9.2、适配器模式原理结构图-uml类图</h3><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li><strong>目标</strong>（Target）接口：当前系统业务<strong>所期待的接口</strong>，它可以是<strong>抽象类或接口</strong>。</li>
<li><strong>被适配者</strong>（Adaptee\src）类：它是<strong>被访问和适配</strong>的现存组件库中的<strong>组件接口</strong>。</li>
<li><strong>适配器</strong>（Adapter）类：它是一个<strong>转换器</strong>，通过<strong>继承(类适配器)或引用(对象适配器)适配者的对象</strong>，把<strong>适配者接口转换成目标接口</strong>，让客户按目标接口的格式访问适配者。</li>
</ol>
<h4 id="9-2-1、类适配器模式"><a href="#9-2-1、类适配器模式" class="headerlink" title="9.2.1、类适配器模式"></a>9.2.1、类适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42.png" alt="image-20210414215313478"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2、对象适配器模式"><a href="#9-2-2、对象适配器模式" class="headerlink" title="9.2.2、对象适配器模式"></a>9.2.2、对象适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/43.png" alt="image-20210414215540735"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3、接口适配器模式"><a href="#9-2-3、接口适配器模式" class="headerlink" title="9.2.3、接口适配器模式"></a>9.2.3、接口适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44.png" alt="image-20210414215753292"></p>
<p>代码：</p>
<p>Interface4（适配者（Adaptee）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbsAdapter（适配器（Adapter）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="comment">//默认实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client（）：只需要去覆盖我们 需要使用 接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">			<span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		absAdapter.m1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3、三种适配器模式的基本介绍"><a href="#9-3、三种适配器模式的基本介绍" class="headerlink" title="9.3、三种适配器模式的基本介绍"></a>9.3、三种适配器模式的基本介绍</h3><h4 id="9-3-1、类适配器模式"><a href="#9-3-1、类适配器模式" class="headerlink" title="9.3.1、类适配器模式"></a>9.3.1、类适配器模式</h4><p>实现步骤：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</p>
<p>类适配器模式注意事项和细节：</p>
<ol>
<li>由于其<strong>继承了 src 类</strong>，所以它可以<strong>根据需求重写 src 类的方法</strong>，使得 Adapter 的灵活性增强了。</li>
<li>Java 是<strong>单继承机制</strong>，所以类适配器需要<strong>继承 src 类这一点算是一个缺点</strong>, 因为这<strong>要求 dst 必须是接口</strong>，有一定局限性。</li>
<li>由于Adapter继承了src类，所以不可避免的会去重写src的方法。在一定程度上<strong>违反了里氏原则</strong>与<strong>合成复用原则</strong>。</li>
<li><strong>src 类的方法在 Adapter 中都会暴露出来</strong>，也<strong>增加了使用的成本</strong>。</li>
</ol>
<h4 id="9-3-2、对象适配器模式"><a href="#9-3-2、对象适配器模式" class="headerlink" title="9.3.2、对象适配器模式"></a>9.3.2、对象适配器模式</h4><p>对象适配器模式介绍</p>
<ol>
<li>基本思路和类的适配器模式相同，只是将 <strong>Adapter 类</strong>作修改，<strong>不是继承 src 类</strong>，而是<strong>持有 src 类的实例（依赖），</strong>以解决兼容性的问题**。 </li>
<li>实现步骤：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li>
<li>根据“<strong>合成复用原则</strong>”，在系统中尽量<strong>使用关联关系（聚合）来替代继承</strong>关系。</li>
<li>对象适配器模式是适配器模式<strong>常用</strong>的一种</li>
</ol>
<p>对象适配器模式注意事项和细节 </p>
<ol>
<li>对象适配器和类适配器其实算是<strong>同一种思想</strong>，只不过<strong>实现方式不同</strong>。</li>
<li>根据<strong>合成复用原则</strong>，使用<strong>聚合替代继承</strong>， 所以它解决了<strong>类适配器必须继承 src 的局限性问题</strong>，也<strong>不再要求 dst必须是接口</strong>。</li>
<li>使用<strong>成本更低，更灵活</strong>。</li>
</ol>
<h4 id="9-3-3、接口适配器模式"><a href="#9-3-3、接口适配器模式" class="headerlink" title="9.3.3、接口适配器模式"></a>9.3.3、接口适配器模式</h4><p>接口适配器模式介绍 </p>
<ol>
<li>一些书籍称为：<strong>适配器模式(Default Adapter Pattern)**或</strong>缺省适配器模式**。</li>
<li>核心思路：当<strong>不需要全部实现接口</strong>提供的方法时，可先<strong>设计一个抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现（空方法）</strong>，那么<strong>该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</strong></li>
<li>适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</li>
</ol>
<p>接口适配器模式注意事项和细节 </p>
<ol>
<li>在<strong>JDK8</strong>开始，<strong>接口就可以默认实现</strong>了，所以这个可以不要抽象类，全部弄个默认实现就好。</li>
<li>然后定义接口的实现类可有选择地覆盖接口的默认方法来实现需求</li>
</ol>
<h3 id="9-4、应用举例"><a href="#9-4、应用举例" class="headerlink" title="9.4、应用举例"></a>9.4、应用举例</h3><p>需求：</p>
<p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电。</p>
<h4 id="9-4-1、使用类适配器模式实现"><a href="#9-4-1、使用类适配器模式实现" class="headerlink" title="9.4.1、使用类适配器模式实现"></a>9.4.1、使用类适配器模式实现</h4><p>思路分析(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/45.png" alt="image-20210414222333677"></p>
<p>代码实现</p>
<p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">	<span class="comment">//输出220V的电压</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> src;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IVoltage5V：<strong>目标</strong>（Target）接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//获取到220V电压</span></span><br><span class="line">		<span class="keyword">int</span> srcV = output220V();</span><br><span class="line">		<span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">		<span class="keyword">return</span> dstV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//充电</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-2、使用对象适配器模式实现"><a href="#9-4-2、使用对象适配器模式实现" class="headerlink" title="9.4.2、使用对象适配器模式实现"></a>9.4.2、使用对象适配器模式实现</h4><p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类：同上</p>
<p>IVoltage5V：<strong>目标</strong>（Target）接口：同上</p>
<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line">	<span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">			<span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">			System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">			dst = src / <span class="number">44</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> dst;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：同上</p>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-3、接口适配器模式应用实例"><a href="#9-4-3、接口适配器模式应用实例" class="headerlink" title="9.4.3、接口适配器模式应用实例"></a>9.4.3、接口适配器模式应用实例</h4><ul>
<li><p>Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener)方法添加监听器， 那么常规写法如下：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46.png" alt="image-20210414224410293"></p>
</li>
<li><p>有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/47.png" alt="image-20210414224454278"></p>
</li>
<li><p>AnimatorListenerAdapter 类，就是一个接口适配器，代码如下图:它空实现了Animator.AnimatorListener 类(src)的所有方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48.png" alt="image-20210414224618055"></p>
</li>
<li><p>AnimatorListener 是一个接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/49.png" alt="image-20210414224645907"></p>
</li>
<li><p>程序里的匿名内部类就是 Listener 具体实现类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210414224710829.png" alt="image-20210414224710829"></p>
</li>
</ul>
<h3 id="9-5、适配器模式在Spring-MVC的应用与源码分析"><a href="#9-5、适配器模式在Spring-MVC的应用与源码分析" class="headerlink" title="9.5、适配器模式在Spring MVC的应用与源码分析"></a>9.5、适配器模式在Spring MVC的应用与源码分析</h3><ul>
<li><p>SpringMvc 中的 <strong>HandlerAdapter,</strong> 就使用了适配器模式</p>
</li>
<li><p>SpringMVC 处理请求的流程回顾</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53.png" alt="image-20210414234012692"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/54.png" alt="image-20210414234049194"></p>
</li>
<li><p>使用 HandlerAdapter 的原因分析：</p>
<p>可以看到<strong>处理器的类型不同</strong>，有<strong>多重实现方式</strong>，那么<strong>调用方式就不是确定的</strong>，如果需要直接调用 Controller 方法，需要调用的时候就得<strong>不断是使用 if else 来进行判断是哪一种子类然后执行</strong>。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 <strong>OCP 原则</strong>。</p>
</li>
<li><p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/55.png" alt="image-20210415002836481"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/56.png" alt="image-20210415002913253"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/57.png" alt="image-20210415002940414"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/58.png" alt="image-20210415003150913"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/59.png" alt="image-20210415003221357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/60.png" alt="image-20210415003242857"></p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61.png" alt="image-20210415003342721"></p>
<p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/62.png" alt="image-20210415010612924"></p>
<p>动手写 SpringMVC 通过适配器设计模式获取到对应的 Controller 的源码：</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/50.png" alt="image-20210414225130202"></p>
<p>实现代码：</p>
<p>HandlerAdapter：一个Adapter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Adapter接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多种适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((SimpleController) handler).doSimplerHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((HttpController) handler).doHttpHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((AnnotationController) handler).doAnnotationHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多种Controller实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;http...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;simple...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;annotation...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span></span><br><span class="line">		<span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">		 HttpController controller = <span class="keyword">new</span> HttpController();</span><br><span class="line">		<span class="comment">// AnnotationController controller = new AnnotationController();</span></span><br><span class="line">		<span class="comment">//SimpleController controller = new SimpleController();</span></span><br><span class="line">		<span class="comment">// 得到对应适配器</span></span><br><span class="line">		HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">		<span class="comment">// 通过适配器执行对应的controller对应方法</span></span><br><span class="line">		adapter.handle(controller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span></span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adapter.supports(controller)) &#123;</span><br><span class="line">				<span class="keyword">return</span> adapter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关补充：</p>
<ul>
<li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</li>
<li>适配器代替Controller执行相应的方法</li>
<li>扩展Controller时（即添加一个OtherController），只需要增加一个适配器类就完成了SpringMVC的扩展了（满足OCP原则）</li>
</ul>
<h3 id="9-6、适配器模式总结"><a href="#9-6、适配器模式总结" class="headerlink" title="9.6、适配器模式总结"></a>9.6、适配器模式总结</h3><p>主要优点如下：</p>
<ul>
<li>客户端通过适配器可以<strong>透明地调用目标接口</strong>。</li>
<li><strong>复用了现存的类</strong>，程序员<strong>不需要修改原有代码</strong>而重用现有的适配者类。</li>
<li>将<strong>目标类和适配者类解耦</strong>，<strong>解决</strong>了目标类和适配者类<strong>接口不一致</strong>的问题。</li>
<li>在很多业务场景中<strong>符合开闭原则</strong>。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会<strong>增加系统的复杂性</strong>。</li>
<li>增加代码阅读难度，<strong>降低代码可读性</strong>，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<p>模式的应用场景：</p>
<ul>
<li>以前开发的系统<strong>存在满足新系统功能需求的类</strong>，但<strong>其接口同新系统的接口不一致</strong>。</li>
<li>使用<strong>第三方提供的组件</strong>，但<strong>组件接口定义和自己要求的接口定义不同</strong>。</li>
</ul>
<h3 id="9-7、适配器模式的扩展"><a href="#9-7、适配器模式的扩展" class="headerlink" title="9.7、适配器模式的扩展"></a>9.7、适配器模式的扩展</h3><p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51.png" alt="image-20210414225959454"></p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;目标代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapteeRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双向适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapter</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span>,<span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TwoWayTarget target;</span><br><span class="line">    <span class="keyword">private</span> TwoWayAdaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayTarget target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayAdaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标通过双向适配器访问适配者：&quot;</span>);</span><br><span class="line">        TwoWayAdaptee adaptee = <span class="keyword">new</span> AdapteeRealize();</span><br><span class="line">        TwoWayTarget targe = <span class="keyword">new</span> TwoWayAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者通过双向适配器访问目标：&quot;</span>);</span><br><span class="line">        target = <span class="keyword">new</span> TargetRealize();</span><br><span class="line">        adaptee = <span class="keyword">new</span> TwoWayAdapter(target);</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8、进阶阅读"><a href="#9-8、进阶阅读" class="headerlink" title="9.8、进阶阅读"></a>9.8、进阶阅读</h3><p>如果您想了解适配器模式在实际中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8439.html">《使用类适配器重构第三方登录自由适配》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8447.html">《适配器模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="9-9、相关的设计模式"><a href="#9-9、相关的设计模式" class="headerlink" title="9.9、相关的设计模式"></a>9.9、相关的设计模式</h3><ul>
<li><p>Bridge模式</p>
<p>Adapter模式用千连接接口(API)不同的类，而Bridge模式则用于连接类的功能层次结构与实现层次结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Adapter 模式用于填补不同接口 (API) 之间的缝隙，而 Decorator 模式则是在不改变接口 (API)的前提下增加功能。</p>
</li>
</ul>
<h3 id="9-10、适配器模式的注意事项和细节"><a href="#9-10、适配器模式的注意事项和细节" class="headerlink" title="9.10、适配器模式的注意事项和细节"></a>9.10、适配器模式的注意事项和细节</h3><ol>
<li>三种命名方式，是<strong>根据 src 是以怎样的形式给到 Adapter</strong>（在 Adapter 里的形式）来命名的。</li>
<li>类适配器：以<strong>类</strong>给到，在 Adapter 里，就是将 src 当做<strong>类</strong>，<strong>继承</strong></li>
<li>对象适配器：以<strong>对象</strong>给到，在 Adapter 里，将 src 作为一个<strong>对象</strong>，持有接口适配器：以<strong>接口给到</strong>，在 Adapter 里，将 src 作为一个<strong>接口</strong>，<strong>实现</strong></li>
<li>Adapter 模式最大的作用还是<strong>将原本不兼容的接口融合在一起工作</strong>。</li>
<li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li>
</ol>
<h2 id="10、桥接模式Bridge（结构型模式）"><a href="#10、桥接模式Bridge（结构型模式）" class="headerlink" title="10、桥接模式Bridge（结构型模式）"></a>10、桥接模式Bridge（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/80.png" alt="image-20210415032242015"></p>
<h3 id="10-1、基本介绍"><a href="#10-1、基本介绍" class="headerlink" title="10.1、基本介绍"></a>10.1、基本介绍</h3><ol>
<li>桥接模式(Bridge 模式)是指：将<strong>实现与抽象放在两个不同的类层次</strong>中，使<strong>两个层次可以独立改变</strong>。</li>
<li>是一种结构型设计模式</li>
<li>Bridge 模式<strong>基于类的最小设计原则</strong>，通过使用<strong>封装</strong>、<strong>聚合</strong>及<strong>继承</strong>等行为<strong>让不同的类承担不同的职责</strong>。它的主要特点是<strong>把抽象(Abstraction)与行为实现(Implementation)分离开来</strong>，从而可以保持各部分的独立性以及应对他们的功能扩展</li>
<li>它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</li>
<li>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
</ol>
<h3 id="10-2、桥接模式原结构图-uml类图"><a href="#10-2、桥接模式原结构图-uml类图" class="headerlink" title="10.2、桥接模式原结构图-uml类图"></a>10.2、桥接模式原结构图-uml类图</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="10-2-1、-模式的结构"><a href="#10-2-1、-模式的结构" class="headerlink" title="10.2.1、 模式的结构"></a>10.2.1、 模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li><strong>抽象化（Abstraction）</strong>角色：定义抽象类，并<strong>包含一个对实现化对象的引用</strong>。</li>
<li><strong>扩展抽象化（Refined Abstraction）</strong>角色：是<strong>抽象化角色的子类</strong>，<strong>实现父类中的业务方法</strong>，并通过<strong>组合关系调用实现化角色中的业务方法</strong>。</li>
<li><strong>实现化（Implementor）</strong>角色：定义<strong>实现化角色的接口</strong>，供<strong>扩展抽象化角色调用</strong>。</li>
<li><strong>具体实现化（Concrete Implementor）</strong>角色：给出<strong>实现化角色接口的具体实现</strong>。</li>
</ol>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63.png" alt="image-20210415020129290"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3、应用举例"><a href="#10-3、应用举例" class="headerlink" title="10.3、应用举例"></a>10.3、应用举例</h3><p>手机操作问题：</p>
<p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/64.png" alt="image-20210415020831299"></p>
<h4 id="10-3-1、使用传统方式"><a href="#10-3-1、使用传统方式" class="headerlink" title="10.3.1、使用传统方式"></a>10.3.1、使用传统方式</h4><p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65.png" alt="image-20210415021009808"></p>
<p>传统方案解决手机操作问题分析</p>
<ol>
<li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li>
<li><strong>违反了单一职责原则</strong>，当我们增加手机样式时，要同时增加所有品牌的手机，这样<strong>增加了代码维护成本</strong>.</li>
<li>解决方案-使用桥接模式</li>
</ol>
<h4 id="10-3-2、使用桥接模式"><a href="#10-3-2、使用桥接模式" class="headerlink" title="10.3.2、使用桥接模式"></a>10.3.2、使用桥接模式</h4><p>对应的类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/66.png" alt="image-20210415021509975"></p>
<p>对于类图的相关解析：</p>
<ol>
<li>在FoldedPhone调用的open()方法其实调用了其父类Phone的open()方法</li>
<li>然而在Phone当中是通过聚合了Brand接口拿到了open()方法</li>
<li>而Vivo类才是真正实现Brank接口open()方法的实现类</li>
<li>所以FoldedPhone调用的open()方法最终是调用了Vivo的open()方法</li>
<li>而Phone在这其中起到了一个桥接的作用</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68.png" alt="image-20210415024111311"></p>
<p>代码实现：</p>
<p>Brand：实现化（Implementor）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phone：抽象化（Abstraction）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//组合品牌</span></span><br><span class="line">	<span class="keyword">private</span> Brand brand;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.brand.open();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.call();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FoldedPhone：扩展抽象化（Refined Abstraction）（UpRightPhone类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(brand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.open();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.close();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.call();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vivo：具体实现化（Concrete Implementor）（XiaoMi类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机开机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机关机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//获取折叠式手机 (样式 + 品牌 )</span></span><br><span class="line">		Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">		phone1.open();</span><br><span class="line">		phone1.call();</span><br><span class="line">		phone1.close();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Phone phone2 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">		phone2.open();</span><br><span class="line">		phone2.call();</span><br><span class="line">		phone2.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4、桥接模式在JDBC的应用与源码分析"><a href="#10-4、桥接模式在JDBC的应用与源码分析" class="headerlink" title="10.4、桥接模式在JDBC的应用与源码分析"></a>10.4、桥接模式在JDBC的应用与源码分析</h3><p>JDBC的 <strong>Driver</strong> 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的Driver，这些就可以当做实现接口类</p>
<p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/71.png" alt="image-20210415030654222"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/72.png" alt="image-20210415031227696"></p>
<h3 id="10-5、桥接模式总结"><a href="#10-5、桥接模式总结" class="headerlink" title="10.5、桥接模式总结"></a>10.5、桥接模式总结</h3><p>桥接模式遵循了<strong>里氏替换原则</strong>和<strong>依赖倒置原则</strong>，<strong>最终实现了开闭原则</strong>，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>优点：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点：</p>
<p>由于聚合关系建立在<strong>抽象层</strong>，要求开发者针对抽象化进行设计与编程，能<strong>正确地识别出系统中两个独立变化的维度</strong>，这增加了系统的理解与设计难度。</p>
<p>桥接模式的应用场景：</p>
<p>当<strong>一个类内部具备两种或多种变化维度</strong>时，使用桥接模式可以<strong>解耦这些变化的维度</strong>，使高层代码架构稳定。</p>
<p>桥接模式通常适用于以下场景：</p>
<ol>
<li>当<strong>一个类存在两个独立变化的维度</strong>，且这<strong>两个维度都需要进行扩展</strong>时。</li>
<li>当一个系统<strong>不希望使用继承</strong>或因为<strong>多层次继承导致系统类的个数急剧增加</strong>时。</li>
<li>当一个系统<strong>需要在构件的抽象化角色</strong>和<strong>具体化角色之间增加更多的灵活性</strong>时。</li>
</ol>
<p>桥接模式的一个常见使用场景就是<strong>替换继承</strong>。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。因为父类拥有的方法，子类也会继承得到，<strong>无论子类需不需要</strong>，这说明<strong>继承具备强侵入性（父类代码侵入子类）</strong>，同时会导致<strong>子类臃肿</strong>。因此，在设计模式中，<strong>有一个原则为优先使用组合/聚合，而不是继承（合成复用原则）</strong>。</p>
<p>在实际系统开发时常见的应用场景：</p>
<ul>
<li><p>JDBC 驱动程序</p>
</li>
<li><p>银行转账系统转账分类: </p>
<p>网上转账，柜台转账，AMT 转账    （抽象层）</p>
<p>转账用户类型：普通用户，银卡用户，金卡用户..    (实现层)</p>
</li>
<li><p>消息管理</p>
<p>消息类型：即时消息，延时消息    （抽象层）</p>
<p>消息分类：手机短信，邮件消息，QQ 消息…    (实现层)</p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/69.png" alt="image-20210415025038485"></p>
<p>很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。</p>
<h3 id="10-6、桥接模式的扩展"><a href="#10-6、桥接模式的扩展" class="headerlink" title="10.6、桥接模式的扩展"></a>10.6、桥接模式的扩展</h3><p>在软件开发中，有时<strong>桥接（Bridge）模式可与适配器模式联合使用</strong>。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/70.png" alt="image-20210415025940379"></p>
<h3 id="10-7、进阶阅读"><a href="#10-7、进阶阅读" class="headerlink" title="10.7、进阶阅读"></a>10.7、进阶阅读</h3><p>如果您想深入了解桥接模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8458.html">《使用桥接模式设计复杂消息系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8460.html">《桥接模式在JDBC源码中的应用》</a></li>
</ul>
<h3 id="10-8、相关设计模式"><a href="#10-8、相关设计模式" class="headerlink" title="10.8、相关设计模式"></a>10.8、相关设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>在 Template Method 模式中使用了 ＂类的实现层次结构＂。父类调用抽象方法， 而子类实现抽象方法。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>为了能够根据需求设计出良好的 ConcreteImplementor 角色， 有时我们会使用Abstract Factory 模式。</p>
</li>
<li><p>Adapter 模式</p>
<p>使用 Bridge 模式可以达到类的功能层次结构与类的实现层次结构分离的目的， 并在此基础上使这些层次结构结合起来。</p>
<p>而使用Adapter 模式则可以结合那些功能上相似但是接口 (API) 不同的类。</p>
</li>
</ul>
<h3 id="10-9、桥接模式的注意事项和细节"><a href="#10-9、桥接模式的注意事项和细节" class="headerlink" title="10.9、桥接模式的注意事项和细节"></a>10.9、桥接模式的注意事项和细节</h3><ol>
<li>实现了<strong>抽象和实现部分的分离</strong>，从而极大的<strong>提升了系统的灵活性</strong>，让抽象部分和实现部分独立开来，这有助于<strong>系统进行分层设计</strong>，从而产生更好的<strong>结构化系统</strong>。</li>
<li>对于<strong>系统的高层部分</strong>，只需要知道<strong>抽象部分和实现部分的接口</strong>就可以了，<strong>其它的部分由具体业务</strong>来完成。</li>
<li>桥接模式<strong>替代多层继承方案</strong>，可以减少子类的个数，降低系统的管理和维护成本</li>
<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者**针对抽象进行设计和编程桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性。</li>
</ol>
<h2 id="11、装饰者模式Decorator（结构型模式）"><a href="#11、装饰者模式Decorator（结构型模式）" class="headerlink" title="11、装饰者模式Decorator（结构型模式）"></a>11、装饰者模式Decorator（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/81.png" alt="image-20210415032321784"></p>
<h3 id="11-1、基本介绍"><a href="#11-1、基本介绍" class="headerlink" title="11.1、基本介绍"></a>11.1、基本介绍</h3><ol>
<li>装饰者模式：在不改变现有对象结构的情况下，<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也**体现了开闭原则(ocp)**。</li>
<li>它属于对象结构型模式</li>
</ol>
<h3 id="11-2、装饰者模式原理结构图-uml类图"><a href="#11-2、装饰者模式原理结构图-uml类图" class="headerlink" title="11.2、装饰者模式原理结构图-uml类图"></a>11.2、装饰者模式原理结构图-uml类图</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但<strong>继承具有静态特征，耦合度高</strong>，并且随着扩展功能的增多，<strong>子类会很膨胀（类爆炸）</strong>。如果<strong>使用<code>组合关系</code>来创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。装饰者模式就像打包一个快递。</p>
<p>下面来分析其基本结构和实现方法。</p>
<h4 id="11-2-1、模式的结构"><a href="#11-2-1、模式的结构" class="headerlink" title="11.2.1、模式的结构"></a>11.2.1、模式的结构</h4><p>装饰器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象构件（Component）</strong>角色：定义一个<strong>抽象接口以规范准备接收附加责任的对象</strong>。（被装饰者）</li>
<li><strong>具体构件（ConcreteComponent）</strong>角色：<strong>实现抽象构件</strong>，通过装饰角色为其添加一些职责。</li>
<li><strong>抽象装饰（Decorator）</strong>角色：<strong>继承抽象构件</strong>，并<strong>包含具体构件的实例（组合）</strong>，可以通过其子类扩展具体构件的功能。（装饰者）</li>
<li><strong>具体装饰（ConcreteDecorator）</strong>角色：<strong>实现抽象装饰的相关方法</strong>，并<strong>给具体构件对象添加附加的责任</strong>。</li>
<li>（可选）缓冲角色：如果有太多的具体构建角色，可以在<strong>具体构件（ConcreteComponent）</strong>角色与<strong>抽象构件（Component）</strong>角色建立一个缓冲角色。抽取<strong>具体构件（ConcreteComponent）</strong>角色的公共部分，对其进行进一步的抽象。</li>
</ol>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/82.png" alt="image-20210415105021790"></p>
<h4 id="11-2-2、实现代码"><a href="#11-2-2、实现代码" class="headerlink" title="11.2.2、实现代码"></a>11.2.2、实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3、应用举例"><a href="#11-3、应用举例" class="headerlink" title="11.3、应用举例"></a>11.3、应用举例</h3><p>星巴克咖啡订单项目（咖啡馆）：</p>
<ol>
<li>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li>
<li>调料：Milk、Soy(豆浆)、Chocolate</li>
<li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li>
<li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li>
</ol>
<h4 id="11-3-1、使用方案1（较差）解决需求"><a href="#11-3-1、使用方案1（较差）解决需求" class="headerlink" title="11.3.1、使用方案1（较差）解决需求"></a>11.3.1、使用方案1（较差）解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/83.png" alt="image-20210415110413076"></p>
<p>方案 1-解决星巴克咖啡订单实现与问题分析</p>
<ol>
<li>Drink 是一个抽象类，表示饮料</li>
<li>des 就是对咖啡的描述, 比如咖啡的名字</li>
<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li>
<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li>
<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>
<li>问题：这样设计，<strong>会有很多类</strong>，当我们<strong>增加</strong>一个单品咖啡，或者一个新的调料，<strong>类的数量就会倍增</strong>，就会出现<strong>类爆炸</strong></li>
</ol>
<h4 id="11-3-2、使用方案2（较好）解决需求"><a href="#11-3-2、使用方案2（较好）解决需求" class="headerlink" title="11.3.2、使用方案2（较好）解决需求"></a>11.3.2、使用方案2（较好）解决需求</h4><p>思路分析（类图）：</p>
<p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进：</p>
<ol>
<li>将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性</li>
<li>说明: milk,soy,chocolate 可以设计为 Boolean,表示是否要添加相应的调料.</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/84.png" alt="image-20210415110911652"></p>
<p>方案 2-解决星巴克咖啡订单问题分析</p>
<ol>
<li>方案 2 将调料放在了Drink当中，把它作为<strong>成员变量</strong>。它可以<strong>控制类的数量</strong>，不至于造成很多的类。</li>
<li>在<strong>增加或者删除调料种类</strong>时，代码的维护量很大</li>
<li>考虑到用户可以<strong>添加多份调料</strong>时，可以将hasMilk返回一个对应<strong>int</strong></li>
<li>考虑使用 装饰者 模式</li>
</ol>
<h4 id="11-3-3、使用装饰者模式解决需求"><a href="#11-3-3、使用装饰者模式解决需求" class="headerlink" title="11.3.3、使用装饰者模式解决需求"></a>11.3.3、使用装饰者模式解决需求</h4><p>说明：</p>
<ul>
<li>Drink 类就是前面说的抽象类，Component</li>
<li>ShortBlack 就单品咖啡</li>
<li>Decorator 是一个装饰类，含有一个被装饰的对象(Drink obj)</li>
<li>Decorator 的cost 方法进行一个费用的叠加计算，递归的计算价格</li>
<li>Coffee类就是具体构件（ConcreteComponent）角色与抽象构件（Component）角色之间的缓冲角色，将ShortBlack等等各种咖啡抽象成一个Coffee类</li>
</ul>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85.png" alt="image-20210415111510913"></p>
<p>装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack的CoffeeBar(Client)实现思路：</p>
<ul>
<li>Milk包含了LongBlack</li>
<li>一份Chocolate包含了(Milk+LongBlack)</li>
<li>一份Chocolate包含了(Chocolate+Milk+LongBlack)</li>
<li>这样不管是什么形式的单品咖啡+调料组合，通过<strong>递归方式</strong>可以方便的组合和维护。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/86.png" alt="image-20210415112049116"></p>
<p>实现代码：</p>
<p>Drink：饮料抽象类。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算费用的抽象方法</span></span><br><span class="line">	<span class="comment">//子类来实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Coffee：咖啡类。（可选）缓冲角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShortBlack：具体咖啡对象。<strong>具体构件（ConcreteComponent）</strong>角色（其他具体咖啡类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setDes(<span class="string">&quot; shortblack &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">4.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator：调料装饰者。<strong>抽象装饰（Decorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Drink obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123; <span class="comment">//组合</span></span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// getPrice 自己价格</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// super.des/super.getPrice()：输出装饰者的描述信息与价格</span></span><br><span class="line">		<span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.des + <span class="string">&quot; &quot;</span> + <span class="keyword">super</span>.getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Milk：牛奶。<strong>具体装饰（ConcreteDecorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(obj);</span><br><span class="line">		setDes(<span class="string">&quot; 牛奶 &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">2.0f</span>); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeBar：星巴克。调用2 份巧克力+一份牛奶的 LongBlack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line">		<span class="comment">// 1. 点一份 LongBlack</span></span><br><span class="line">		Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">		System.out.println(<span class="string">&quot;费用1=&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;描述=&quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">		order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 4. order 再加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4、装饰者模式在IO结构的应用与源码"><a href="#11-4、装饰者模式在IO结构的应用与源码" class="headerlink" title="11.4、装饰者模式在IO结构的应用与源码"></a>11.4、装饰者模式在IO结构的应用与源码</h3><p>Java 的 IO 结构，FilterInputStream 就是一个装饰者</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/89.png" alt="image-20210415131821549"></p>
<p>源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/90.png" alt="image-20210415132235381"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/91.png" alt="image-20210415132326718"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/92.png" alt="image-20210415132344822"></p>
<p>对源码的解析：</p>
<ol>
<li>InputStream 是抽象类, 类似我们前面讲的 Drink</li>
<li>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</li>
<li>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</li>
<li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li>
<li>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</li>
<li>分析得出在jdk 的io体系中，就是使用装饰者模式</li>
</ol>
<h3 id="11-5、装饰者模式总结"><a href="#11-5、装饰者模式总结" class="headerlink" title="11.5、装饰者模式总结"></a>11.5、装饰者模式总结</h3><p>主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在<strong>不改变原有对象的情况下</strong>，<strong>动态的给一个对象扩展功能</strong>，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式<strong>完全遵守开闭原则</strong></li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，<strong>装饰模式是继承的一个替代模式</strong>，装饰模式可以动态扩展一个实现类的功能。</li>
</ul>
<p>主要缺点：</p>
<ul>
<li>装饰器模式会增加许多子类，过度使用会<strong>增加程序得复杂性</strong>。</li>
</ul>
<p>装饰者模式的应用场景：</p>
<ul>
<li>当需要给一个<strong>现有类添加附加职责</strong>，而又<strong>不能采用生成子类的方法</strong>进行扩充时。例如，<strong>该类被隐藏</strong>或者<strong>该类是终极类</strong>或者<strong>采用继承方式会产生大量的子类</strong>。</li>
<li>当需要通过对<strong>现有的一组基本功能进行排列组合而产生非常多的功能</strong>时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>
<li>当对象的<strong>功能</strong>要求可以<strong>动态地添加</strong>，也可以再<strong>动态地撤销</strong>时。（可插拔）</li>
</ul>
<p>装饰器模式在 Java 语言中的最著名的应用莫过于 <strong>Java I/O 标准库</strong>的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<h3 id="11-6、装饰者模式扩展"><a href="#11-6、装饰者模式扩展" class="headerlink" title="11.6、装饰者模式扩展"></a>11.6、装饰者模式扩展</h3><p>装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p>
<h4 id="11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"><a href="#11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件" class="headerlink" title="11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"></a>11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/87.png" alt="image-20210415115027987"></p>
<h4 id="11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"><a href="#11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并" class="headerlink" title="11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"></a>11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/88.png" alt="image-20210415115057914"></p>
<h3 id="11-7、进阶阅读"><a href="#11-7、进阶阅读" class="headerlink" title="11.7、进阶阅读"></a>11.7、进阶阅读</h3><p>如果您想深入了解装饰器模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8461.html">《使用装饰器模式解决煎饼“加码”问题》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8463.html">《装饰器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8464.html">《装饰器模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8466.html">《装饰器模式和代理模式的区别》</a></li>
</ul>
<h3 id="11-8、相关设计模式"><a href="#11-8、相关设计模式" class="headerlink" title="11.8、相关设计模式"></a>11.8、相关设计模式</h3><ul>
<li><p>Adapter模式</p>
<p>Decorator 模式可以在不改变被装饰物的接口 (API) 的前提下， 为被装饰物添加边框（透明性）。</p>
<p>Adapter 模式用千适配两个不同的接口 (API)。</p>
</li>
<li><p>Stragety模式</p>
<p>Decorator 模式可以像改变被装饰物的边框或是为被装饰物添加多重边框那样， 来增加类的功能。</p>
<p>Stragety 模式通过整体地替换算法来改变类的功能。</p>
</li>
</ul>
<h3 id="11-9、装饰者模式的注意事项与细节"><a href="#11-9、装饰者模式的注意事项与细节" class="headerlink" title="11.9、装饰者模式的注意事项与细节"></a>11.9、装饰者模式的注意事项与细节</h3><ul>
<li>得益于接口(API)的透明性， Decorator模式中也形成了类似千Composite模式中的递归结构。 </li>
<li>也就是说， 装饰边框里面的 ”被装饰物” 实际上又是别的物体的 ＂装饰边框＂。就像是剥洋葱时以为洋葱心要出来了， 结果却发现还是皮。 </li>
<li>不过， Decorator模式虽然与Composite模式一样， 都具有递归 结构， 但是它们的使用目的不同。 </li>
<li>Decorator模式的主要目的是通过添加装饰物来增加对象的功能。</li>
</ul>
<h2 id="12、组合模式Composite（结构型模式）"><a href="#12、组合模式Composite（结构型模式）" class="headerlink" title="12、组合模式Composite（结构型模式）"></a>12、组合模式Composite（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/93.png" alt="image-20210415133116987"></p>
<h3 id="12-1、基本介绍"><a href="#12-1、基本介绍" class="headerlink" title="12.1、基本介绍"></a>12.1、基本介绍</h3><ol>
<li><p>组合模式（Composite Pattern），又叫<strong>部分整体模式</strong>，它创建了<strong>对象组的树形结构</strong>，将对象组合成树状结构以表示“<strong>整体-部分</strong>”的层次关系。</p>
</li>
<li><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
</li>
<li><p>这种类型的设计模式属于<strong>结构型模式</strong>。</p>
</li>
<li><p>组合模式使得用户对<strong>单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象</p>
</li>
<li><p>组合模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
</li>
<li><p>组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，<strong>顶层的节点被称为根节点</strong>，根节点下面可以包含<strong>树枝节点</strong>和<strong>叶子节点</strong>，<strong>树枝节点</strong>下面<strong>又可以包含树枝节点和叶子节点</strong>，树形结构图如下:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/94.png" alt="image-20210415201954362"></p>
<p>由上图可以看出，其实<strong>根节点和树枝节点本质上属于同一种数据类型</strong>，可以作为<strong>容器</strong>使用；而<strong>叶子节点与树枝节点在语义上不属于用一种类型</strong>。但是在组合模式中，会把<strong>树枝节点和叶子节点看作属于同一种数据类型</strong>（用统一接口定义），让它们<strong>具备一致行为</strong>。</p>
<p>这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p>
</li>
</ol>
<h3 id="12-2、组合模式的原理结构图-uml类图"><a href="#12-2、组合模式的原理结构图-uml类图" class="headerlink" title="12.2、组合模式的原理结构图-uml类图"></a>12.2、组合模式的原理结构图-uml类图</h3><p>组合模式主要包含以下角色：</p>
<ul>
<li><strong>抽象构件（Component）</strong>角色：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</li>
<li><strong>树叶构件（Leaf）</strong>角色： 在组合中表示叶子节点，叶子节点没有子节点。用于继承或实现抽象构件。</li>
<li><strong>树枝构件（Composite）</strong>角色 / 中间构件：是组合中的分支节点对象，非叶子节点，用于存储子部件。它的主要作用是存储和管理子部件，在Component接口中实现子部件的相关操作，比如增加(add), 删除（remove）。</li>
</ul>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/95.png" alt="image-20210415203743668"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树叶&quot;</span> + name + <span class="string">&quot;：被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3、应用举例"><a href="#12-3、应用举例" class="headerlink" title="12.3、应用举例"></a>12.3、应用举例</h3><p>看一个学校院系展示需求 </p>
<p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/96.png" alt="image-20210415205203158"></p>
<h4 id="12-3-1、传统方案解决需求"><a href="#12-3-1、传统方案解决需求" class="headerlink" title="12.3.1、传统方案解决需求"></a>12.3.1、传统方案解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统方案解决学校院系展示存在的问题分析</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在<strong>组织大小</strong>来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，<strong>不能很好实现的管理</strong>的操作，比如对学院、系的添加，删除，遍历等</li>
<li>解决方案：把学校、院、系都看做是<strong>组织结构</strong>，<strong>他们之间没有继承</strong>的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt; 组合模式</li>
</ol>
<h4 id="12-3-2、组合模式进阶需求"><a href="#12-3-2、组合模式进阶需求" class="headerlink" title="12.3.2、组合模式进阶需求"></a>12.3.2、组合模式进阶需求</h4><p>思路分析和图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/98.png" alt="image-20210415215204104"></p>
<p>代码实现</p>
<p>OrganizationComponent：组织。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">	<span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line">	<span class="comment">// add():增加</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// remove():删除</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>University：大学，组织的一种，管理学院College。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">    <span class="comment">// List 中 存放的College</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院，组织的一种，被University管理，管理各个专业。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">	<span class="comment">// List 中 存放的Department</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Department：专业，组织的一种，被学院College管理，本身是叶子构件，没有管理对象。<strong>树叶构件（Leaf）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 本身是叶子构件，没有管理对象，没有集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">		OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建 学院</span></span><br><span class="line">		OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>);</span><br><span class="line">		OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line">		</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>));</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line">		<span class="comment">//将学院加入到 学校</span></span><br><span class="line">		university.add(computerCollege);</span><br><span class="line">		university.add(infoEngineercollege);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//university.print();</span></span><br><span class="line">		infoEngineercollege.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4、组合模式在JDK的应用与源码"><a href="#12-4、组合模式在JDK的应用与源码" class="headerlink" title="12.4、组合模式在JDK的应用与源码"></a>12.4、组合模式在JDK的应用与源码</h3><p>Java 的集合类-<strong>HashMap</strong> 就使用了组合模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/101.png" alt="image-20210415223718110"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/107.png" alt="image-20210415225016875"></p>
<p>说明：</p>
<ol>
<li><p>Map 就是一个抽象的构建 (类似我们的Component)</p>
</li>
<li><p>HashMap是一个中间的构建(Composite), 实现/继承了相关方法put, putall等等</p>
</li>
<li><p>Node 是 HashMap的静态内部类，类似Leaf叶子节点, 这里就没有put, putall等方法</p>
<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</p>
</li>
</ol>
<p>Map：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/102.png" alt="image-20210415224234562"></p>
<p>AbstractMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/103.png" alt="image-20210415224422322"></p>
<p>HashMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/104.png" alt="image-20210415224607666"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/105.png" alt="image-20210415224705647"></p>
<p>Node：HashMap的静态内部类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/106.png" alt="image-20210415224934928"></p>
<h3 id="12-5、组合模式总结"><a href="#12-5、组合模式总结" class="headerlink" title="12.5、组合模式总结"></a>12.5、组合模式总结</h3><p>主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li><strong>不容易用继承的方法</strong>来增加构件的新功能；</li>
</ol>
<p>组合模式的应用场景</p>
<ol>
<li>在需要<strong>表示一个对象整体与部分的层次结构</strong>的场合。</li>
<li>要求对用户<strong>隐藏组合对象与单个对象的不同</strong>，用户可以<strong>用统一的接口使用组合结构中的所有对象</strong>的场合。</li>
</ol>
<p><strong>应用实例：</strong> </p>
<ol>
<li><strong>算术表达式</strong>包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 </li>
<li>在 <strong>JAVA AWT 和 SWING</strong> 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ol>
<h3 id="12-6、组合模式扩展"><a href="#12-6、组合模式扩展" class="headerlink" title="12.6、组合模式扩展"></a>12.6、组合模式扩展</h3><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/99.png" alt="image-20210415221758204"></p>
<h3 id="12-7、进阶阅读"><a href="#12-7、进阶阅读" class="headerlink" title="12.7、进阶阅读"></a>12.7、进阶阅读</h3><p>如果您想深入了解组合模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8473.html">《使用透明组合模式实现课程目录结构》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8474.html">《使用安全组合模式实现无限级文件系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8475.html">《组合模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8476.html">《组合模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="12-8、相关设计模式"><a href="#12-8、相关设计模式" class="headerlink" title="12.8、相关设计模式"></a>12.8、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>使用Command模式编写宏命令时使用了Composite模式。</p>
</li>
<li><p>Visitor模式</p>
<p>可以使用Visitor模式访问Composite模式中的递归结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Composite模式通过Component角色使容器(Composite角色）和内容(Leaf角色）具有一致性</p>
<p>Decorator模式使装饰框和内容具有一致性。</p>
</li>
</ul>
<h3 id="12-9、组合模式的注意事项与细节"><a href="#12-9、组合模式的注意事项与细节" class="headerlink" title="12.9、组合模式的注意事项与细节"></a>12.9、组合模式的注意事项与细节</h3><ol>
<li>简化客户端操作。客户端<strong>只需要面对一致的对象而不用考虑整体部分或者节点叶子</strong>的问题。</li>
<li>具有<strong>较强的扩展性</strong>。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。<strong>满足了OCP原则</strong>。</li>
<li><strong>方便创建出复杂的层次结构</strong>。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。</li>
<li>需要<strong>遍历组织机构</strong>，或者<strong>处理的对象具有树形结构</strong>时, 非常适合使用组合模式.</li>
<li>要求<strong>较高的抽象性</strong>，如果节点和叶子有<strong>很多差异性</strong>的话，比如<strong>很多方法和属性都不一样</strong>，<strong>不适合</strong>使用组合模式</li>
</ol>
<h2 id="13、外观模式Facade（结构型模式）"><a href="#13、外观模式Facade（结构型模式）" class="headerlink" title="13、外观模式Facade（结构型模式）"></a>13、外观模式Facade（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/108.png" alt="image-20210415225627971"></p>
<h3 id="13-1、基本介绍"><a href="#13-1、基本介绍" class="headerlink" title="13.1、基本介绍"></a>13.1、基本介绍</h3><ol>
<li>外观模式（Facade），也叫<strong>过程模式</strong>、<strong>门面模式</strong>：外观模式为<strong>子系统中的一组接口提供一个一致的界面</strong>，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用</li>
<li>外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。这样会大大降低应用程序的复杂度，提高了程序的可维护性。</li>
<li>外观设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</li>
<li>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度<strong>多个子系统（2个以上的类对象）</strong>，我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段<strong>各种第三方SDK</strong>、<strong>开源类库</strong>，很大概率都会使用外观模式。</li>
</ol>
<h3 id="13-2、外观模式的原理结构图-uml类图"><a href="#13-2、外观模式的原理结构图-uml类图" class="headerlink" title="13.2、外观模式的原理结构图-uml类图"></a>13.2、外观模式的原理结构图-uml类图</h3><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h4 id="13-2-1、模式的结构"><a href="#13-2-1、模式的结构" class="headerlink" title="13.2.1、模式的结构"></a>13.2.1、模式的结构</h4><p>外观（Facade）模式包含以下主要角色。</p>
<ol>
<li><strong>外观（Facade）</strong>角色：为多个子系统对外提供一个<strong>统一的接口</strong>。</li>
<li><strong>子系统（Sub System）</strong>角色：<strong>实现系统的部分功能</strong>，客户可以通过外观角色访问它。</li>
<li><strong>客户（Client）</strong>角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/109.png" alt="image-20210416002002708"></p>
<h4 id="13-2-2、模式的实现"><a href="#13-2-2、模式的实现" class="headerlink" title="13.2.2、模式的实现"></a>13.2.2、模式的实现</h4><p>外观模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade;</span><br><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade f = <span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3、应用举例"><a href="#13-3、应用举例" class="headerlink" title="13.3、应用举例"></a>13.3、应用举例</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/111.png" alt="image-20210416003604096"></p>
<h4 id="13-3-1、使用传统方式解决需求"><a href="#13-3-1、使用传统方式解决需求" class="headerlink" title="13.3.1、使用传统方式解决需求"></a>13.3.1、使用传统方式解决需求</h4><p>思路解析（相关类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/112.png" alt="image-20210416003740197"></p>
<p>传统方式解决影院管理问题分析</p>
<ol>
<li><p>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成<strong>调用过程混乱</strong>，没有清晰的过程</p>
</li>
<li><p><strong>不利于</strong>在 ClientTest 中，去<strong>维护对子系统的操作</strong></p>
</li>
<li><p>解决思路：<strong>定义一个高层接口</strong>，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</p>
</li>
<li><p>也就是说：就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节（既使子系统之间互相调用），使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 =&gt; 外观模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/113.png" alt="image-20210416004046940"></p>
</li>
</ol>
<h4 id="13-3-2、使用外观模式解决需求"><a href="#13-3-2、使用外观模式解决需求" class="headerlink" title="13.3.2、使用外观模式解决需求"></a>13.3.2、使用外观模式解决需求</h4><p>传统方式解决影院管理说明：</p>
<ol>
<li>外观模式可以理解为<strong>转换一群接口</strong>，客户只要<strong>调用一个接口</strong>，而不用调用多个接口才能达到目的。比如：在 pc 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li>
<li>外观模式就是<strong>解决多个复杂接口带来的使用困难，起到简化用户操作</strong>的作用</li>
</ol>
<p>思路解析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/114.png" alt="image-20210416004253007"></p>
<p>代码实现：</p>
<p>Screen：显示器。<strong>子系统（Sub System）</strong>角色，使用<strong>单例模式</strong>实现子系统角色的创建。（其他子系统角色类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构造器私有化, 外部不能new </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Screen</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Screen instance = <span class="keyword">new</span> Screen();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 显示器相关操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen up &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen down &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HomeTheaterFacade：家庭电影院外观控制器。<strong>外观（Facade）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义各个子系统对象</span></span><br><span class="line">	<span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">	<span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">	<span class="keyword">private</span> Stereo stereo;</span><br><span class="line">	<span class="keyword">private</span> Projector projector;</span><br><span class="line">	<span class="keyword">private</span> Screen screen;</span><br><span class="line">	<span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line">	<span class="comment">//构造器（单例模式）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作分成 4 步</span></span><br><span class="line">	<span class="comment">// 开始</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.on();</span><br><span class="line">		popcorn.pop();</span><br><span class="line">		screen.down();</span><br><span class="line">		projector.on();</span><br><span class="line">		stereo.on();</span><br><span class="line">		dVDPlayer.on();</span><br><span class="line">		theaterLight.dim();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 播放</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.play();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 暂停</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.pause();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 结束</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.off();</span><br><span class="line">		theaterLight.bright();</span><br><span class="line">		screen.up();</span><br><span class="line">		projector.off();</span><br><span class="line">		stereo.off();</span><br><span class="line">		dVDPlayer.off();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。<strong>客户（Client）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">         <span class="comment">// 开始</span></span><br><span class="line">		homeTheaterFacade.ready();</span><br><span class="line">         <span class="comment">// 播放</span></span><br><span class="line">		homeTheaterFacade.play();</span><br><span class="line">         <span class="comment">// 暂停</span></span><br><span class="line">         homeTheaterFacade.pause();</span><br><span class="line">         <span class="comment">// 结束</span></span><br><span class="line">		homeTheaterFacade.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-4、外观模式在Mybatis的应用与源码"><a href="#13-4、外观模式在Mybatis的应用与源码" class="headerlink" title="13.4、外观模式在Mybatis的应用与源码"></a>13.4、外观模式在Mybatis的应用与源码</h3><p><strong>MyBatis</strong> 中的 <strong>Configuration</strong> 去创建 <strong>MetaObject</strong>  对象使用到外观模式</p>
<p>代码分析+Debug 源码+示意图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/115.png" alt="image-20210416005522209"></p>
<p>对源码中使用到的外观模式的角色类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/121.png" alt="image-20210416010838982"></p>
<p>Mybatis的Configuration：(Facade外观)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/116.png" alt="image-20210416005648774"></p>
<p>Configuration中组合的三个工厂对象：（子系统Sub System）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/117.png" alt="image-20210416010052394"></p>
<p>Configuration中的newMetaObject()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/118.png" alt="image-20210416010317177"></p>
<p>MetaObject：Client借助Mybatis的Configuration生成的对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/119.png" alt="image-20210416010527422"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/120.png" alt="image-20210416010710795"></p>
<h3 id="13-5、外观模式总结"><a href="#13-5、外观模式总结" class="headerlink" title="13.5、外观模式总结"></a>13.5、外观模式总结</h3><p>外观（Facade）模式是“迪米特法则”的典型应用</p>
<p>主要优点：</p>
<ol>
<li><strong>降低了子系统与客户端之间的耦合度</strong>，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户<strong>屏蔽了子系统组件</strong>，减少了客户处理的对象数目，并使得<strong>子系统使用起来更加容易</strong>。</li>
<li><strong>降低了大型软件系统中的编译依赖性</strong>，<strong>简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li><strong>不能很好地限制客户使用子系统类</strong>，很容易带来未知风险。</li>
<li>增加新的子系统可能需要<strong>修改外观类或客户端的源代码</strong>，<strong>违背了“开闭原则”</strong>，继承重写都不合适。</li>
</ol>
<p>外观模式的应用场景：</p>
<ol>
<li>对<strong>分层结构系统构建</strong>时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当<strong>一个复杂系统的子系统很多</strong>时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当<strong>客户端与多个子系统</strong>之间存在很大的联系时，引入外观模式可将它们<strong>分离</strong>，从而<strong>提高子系统的独立性和可移植性。</strong></li>
</ol>
<p>外观模式应用实例：</p>
<ol>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供<strong>接待人员</strong>，只让接待人员来处理，就很方便</li>
<li><strong>JAVA 的三层开发模式：Controller、Service、Dao</strong></li>
<li>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</li>
<li>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个<strong>统一的网关入口</strong>来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</li>
</ol>
<h3 id="13-6、外观模式扩展"><a href="#13-6、外观模式扩展" class="headerlink" title="13.6、外观模式扩展"></a>13.6、外观模式扩展</h3><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果<strong>引入抽象外观类</strong>，则在一定程度上解决了该问题，其结构图如图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/110.png" alt="image-20210416002803095"></p>
<h3 id="13-7、进阶阅读"><a href="#13-7、进阶阅读" class="headerlink" title="13.7、进阶阅读"></a>13.7、进阶阅读</h3><p>如果您想了解外观模式的实际应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8467.html">《使用外观模式整合调用已知API》</a>一节。</p>
<h3 id="13-8、相关设计模式"><a href="#13-8、相关设计模式" class="headerlink" title="13.8、相关设计模式"></a>13.8、相关设计模式</h3><ul>
<li><p>Abstract Factory 模式</p>
<p>可以将AbstractFactory模式看作生成复杂实例时的Facade模式。 因为它提供了 “要想生成这个实例只需要调用这个方法就OK了＂ 的简单接口。</p>
</li>
<li><p>Singleton 模式</p>
<p>有时会使用Singleton模式创建Facade角色。</p>
</li>
<li><p>Mediator 模式</p>
<p>在Facade模式中，Facade角色单方面地使用其他角色来提供高层接口(API)。</p>
<p>而在Mediator模式中，Mediator角色作为Colleague角色间的仲裁者负责调停。 可以说， <strong>Facade模式是单向的， 而Mediator角色是双向的。</strong></p>
</li>
</ul>
<h3 id="13-9、外观模式的注意事项与细节"><a href="#13-9、外观模式的注意事项与细节" class="headerlink" title="13.9、外观模式的注意事项与细节"></a>13.9、外观模式的注意事项与细节</h3><ol>
<li>外观模式<strong>对外屏蔽了子系统的细节</strong>，因此外观模式降低了客户端对子系统使用的复杂性</li>
<li>外观模式对<strong>客户端与子系统的耦合关系 - 解耦</strong>，让子系统内部的模块更易维护和扩展</li>
<li>通过合理的使用外观模式，可以帮我们<strong>更好的划分访问的层次</strong></li>
<li>当系统需要进行<strong>分层设计</strong>时，可以考虑使用 Facade 模式</li>
<li>在<strong>维护一个遗留的大型系统</strong>时，可能这个系统已经变得<strong>非常难以维护和扩展</strong>，此时可以考虑为新系统开发一个Facade 类，来<strong>提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</strong></li>
<li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以<strong>让系统有层次</strong>，<strong>利于维护</strong>为目的。</li>
</ol>
<h2 id="14、享元模式Flyweight（结构型模式）"><a href="#14、享元模式Flyweight（结构型模式）" class="headerlink" title="14、享元模式Flyweight（结构型模式）"></a>14、享元模式Flyweight（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/122.png" alt="image-20210416011234518"></p>
<h3 id="14-1、基本介绍"><a href="#14-1、基本介绍" class="headerlink" title="14.1、基本介绍"></a>14.1、基本介绍</h3><ol>
<li><p>享元模式（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用<strong>共享技术有效地支持大量细粒度的对象</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</li>
<li><p>享元模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p>
</li>
<li><p>常用于<strong>系统底层开发</strong>，解决<strong>系统的性能</strong>问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</p>
</li>
<li><p>享元模式能够解决<strong>重复对象的内存浪费</strong>的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以<strong>降低系统内存，同时提高效率</strong></p>
</li>
<li><p>享元模式的核心思想：如果<strong>一个对象实例一经创建就不可变</strong>，那么反复创建相同的实例就没有必要，直接向<strong>调用方返回一个共享的实例</strong>就行，这样即<strong>节省内存</strong>，又可以<strong>减少创建对象的过程</strong>，<strong>提高运行速度</strong>。（注意区别单例模式）</p>
<p>一言蔽之：<strong>通过尽量共享实例来避免new出实例</strong>。</p>
</li>
<li><p>享元模式经典的应用场景就是<strong>池技术</strong>了，<strong>String 常量池</strong>、<strong>数据库连接池</strong>、<strong>缓冲池</strong>等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/123.png" alt="image-20210416020802732"></p>
</li>
</ol>
<h3 id="14-2、享元模式的原理结构图-uml类图"><a href="#14-2、享元模式的原理结构图-uml类图" class="headerlink" title="14.2、享元模式的原理结构图-uml类图"></a>14.2、享元模式的原理结构图-uml类图</h3><h4 id="14-2-1、内部状态与外部状态"><a href="#14-2-1、内部状态与外部状态" class="headerlink" title="14.2.1、内部状态与外部状态"></a>14.2.1、内部状态与外部状态</h4><p>享元模式的定义提出了两个要求，<strong>细粒度</strong>和<strong>共享对象</strong>。因为要求细粒度，所以不可避免地会<strong>使对象数量多且性质相近</strong>，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<ul>
<li>内部状态指<strong>对象共享出来的信息</strong>，存储在<strong>享元信息内部</strong>，并且<strong>不会随环境的改变而改变</strong>；</li>
<li>外部状态指<strong>对象得以依赖的一个标记</strong>，<strong>随环境的改变而改变，不可共享</strong>。</li>
</ul>
<p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以<strong>棋子颜色</strong>就是棋子的<strong>内部状态</strong>；而各个棋子之间的差别就是<strong>位置的不同</strong>，当我们落子后，落子颜色是定的，但位置是变化的，所以<strong>棋子坐标</strong>就是棋子的<strong>外部状态</strong>。</p>
<p>又比如，<strong>连接池中的连接对象</strong>，保存在连接对象中的<strong>用户名</strong>、<strong>密码</strong>、<strong>连接URL等信息</strong>，在创建对象的时候就设置好了，<strong>不会随环境的改变而改变</strong>，这些为<strong>内部状态</strong>。而当<strong>每个连接要被回收利用</strong>时，我们需要<strong>将它标记为可用状态</strong>，这些为<strong>外部状态</strong>。</p>
<p>享元模式的本质是缓存共享对象，降低内存消耗。</p>
<p>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p>
<h4 id="14-2-2、模式的结构"><a href="#14-2-2、模式的结构" class="headerlink" title="14.2.2、模式的结构"></a>14.2.2、模式的结构</h4><p>享元模式的主要角色有如下。</p>
<ol>
<li><strong>抽象享元角色（Flyweight）</strong>（轻量级）：是所有的<strong>具体享元类的基类</strong>，为具体享元规范需要实现的<strong>公共接口</strong>，<strong>非享元的外部状态</strong>以<strong>参数</strong>的形式<strong>通过方法传入</strong>。</li>
<li><strong>具体享元（Concrete Flyweight）角色</strong>：<strong>实现抽象享元角色</strong>中所规定的<strong>接口</strong>。</li>
<li><strong>非享元（Unsharable Flyweight)角色</strong>：是<strong>不可以共享的外部状态</strong>，它<strong>以参数的形式注入具体享元的相关方法</strong>中。一般<strong>不会出现在享元工厂</strong>。</li>
<li><strong>享元工厂（Flyweight Factory）角色</strong>（轻量级）：负责<strong>创建和管理享元角色</strong>。用于构建一个池容器(集合)， 同时提供从池中获取对象方法（池技术）。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>享元模式的结构图，其中：</p>
<ul>
<li>UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；</li>
<li>Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；</li>
<li>ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；</li>
<li>FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元；</li>
<li>客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/124.png" alt="image-20210416021500116"></p>
<h4 id="14-2-3、代码实现"><a href="#14-2-3、代码实现" class="headerlink" title="14.2.3、代码实现"></a>14.2.3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f02 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f03 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f11 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Flyweight f12 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用a。&quot;</span>));</span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用a。&quot;</span>));</span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第3次调用a。&quot;</span>));</span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用b。&quot;</span>));</span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用b。&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被调用，&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非享元信息是:&quot;</span> + outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用HashMap作池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;已经存在，被成功获取！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-3、应用举例"><a href="#14-3、应用举例" class="headerlink" title="14.3、应用举例"></a>14.3、应用举例</h3><p>展示网站项目需求：</p>
<p>小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p>
<ul>
<li>有客户要求以新闻的形式发布</li>
<li>有客户人要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ul>
<h4 id="14-3-1、使用传统方式解决需求"><a href="#14-3-1、使用传统方式解决需求" class="headerlink" title="14.3.1、使用传统方式解决需求"></a>14.3.1、使用传统方式解决需求</h4><ol>
<li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li>
<li>给每个网站租用一个空间</li>
</ol>
<p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/127.png" alt="image-20210416024816721"></p>
<p>传统方案解决网站展现项目问题分析：</p>
<ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，<strong>造成服务器的资源浪费</strong></li>
<li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源</li>
<li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li>
<li>上面的解决思路就可以使用享元模式来解决</li>
</ol>
<h4 id="14-3-2、使用享元模式解决需求"><a href="#14-3-2、使用享元模式解决需求" class="headerlink" title="14.3.2、使用享元模式解决需求"></a>14.3.2、使用享元模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/128.png" alt="image-20210416025317394"></p>
<p>代码实现：</p>
<p>WebSite：网站，当中的use方法传入外部状态User。<strong>抽象享元角色（Flyweight）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteWebSite：具体网站，继承WebSite，包含有内部状态type。<strong>具体享元（Concrete Flyweight）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="comment">//共享的部分，内部状态</span></span><br><span class="line">	<span class="keyword">private</span> String type = <span class="string">&quot;&quot;</span>; <span class="comment">//网站发布的形式(类型)</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User：用户，不同的用户的构建网站的类型不同，属于外部状态，通过方法参数传入。<strong>非享元（Unsharable Flyweight)角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSiteFactory：网站工厂类，根据需要返回一个网站。<strong>享元工厂（Flyweight Factory）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站工厂类，根据需要返回一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合， 充当池的作用</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pool.containsKey(type)) &#123;</span><br><span class="line">			<span class="comment">//就创建一个网站，并放入到池中</span></span><br><span class="line">			pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (WebSite)pool.get(type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pool.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个工厂类</span></span><br><span class="line">		WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line">		<span class="comment">// 客户tom要一个以新闻形式发布的网站</span></span><br><span class="line">		WebSite webSite1 = factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">		webSite1.use(<span class="keyword">new</span> User(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户jack要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite2 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite2.use(<span class="keyword">new</span> User(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户smith要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite3 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite3.use(<span class="keyword">new</span> User(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户king要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite4 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite4.use(<span class="keyword">new</span> User(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">         <span class="comment">// 网站的分类共=2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;网站的分类共=&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4、享元模式在JDK-Integer的应用与源码"><a href="#14-4、享元模式在JDK-Integer的应用与源码" class="headerlink" title="14.4、享元模式在JDK-Integer的应用与源码"></a>14.4、享元模式在JDK-Integer的应用与源码</h3><p>Integer 中的享元模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span></span><br><span class="line">		Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span></span><br><span class="line">		Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">		Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">	</span><br><span class="line">		System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">		System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">		System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">		System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">		System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line">	</span><br><span class="line">		Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;x1==x2&quot;</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>如果 Integer.valueOf(x)的参数 x 在  -128 — 127 之间，就是使用享元模式返回,如果不在范围内，则仍然 new 一个Integer对象</li>
<li>在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new)；否则，就直接从缓存池返回</li>
<li>valueOf 方法，就使用到享元模式</li>
<li>如果使用valueOf 方法得到一个Integer 实例，<strong>范围在 -128 - 127 ，执行速度比 new 快</strong></li>
</ul>
<p>为什么使用Integer.valueOf(x)并且其参数 x 的范围在  -128 — 127 之间就是同一个对象，看源码：</p>
<p>Debug 源码+说明：</p>
<p>Integer：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/129.png" alt="image-20210416031357474"></p>
<p>Integer当中的IntegerCache：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/130.png" alt="image-20210416031820357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/131.png" alt="image-20210416032125850"></p>
<h3 id="14-5、享元模式总结"><a href="#14-5、享元模式总结" class="headerlink" title="14.5、享元模式总结"></a>14.5、享元模式总结</h3><p>主要优点是</p>
<ul>
<li><strong>相同对象只要保存一份</strong>，这<strong>降低了系统中对象的数量</strong>，从而<strong>降低了系统中细粒度对象给内存带来的压力</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li>为了使对象可以共享，需要<strong>将一些不能共享的状态外部化</strong>，这将<strong>增加程序的复杂性</strong>。</li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li><strong>读取享元模式的外部状态会使得运行时间稍微变长</strong>。</li>
</ul>
<p>享元模式的应用场景：</p>
<p>当系统中<strong>多处需要同一组信息</strong>时，可以<strong>把这些信息封装到一个对象</strong>中，然后<strong>对该对象进行缓存</strong>，这样，一个对象就可以提供给多出需要使用的地方，<strong>避免大量同一对象的多次创建</strong>，<strong>降低大量内存空间的消耗</strong>。</p>
<p>享元模式其实是<strong>工厂方法模式的一个改进机制</strong>，<strong>享元模式同样要求创建一个或一组对象</strong>，并且<strong>就是通过工厂方法模式生成对象</strong>的，只不过享元模式为工厂方法模式<strong>增加了缓存</strong>这一功能。</p>
<p>享元模式是<strong>通过减少内存中对象的数量来节省内存空间</strong>的，所以以下几种情形适合采用享元模式。</p>
<ol>
<li>系统中<strong>存在大量相同或相似的对象</strong>，这些对象耗费大量的内存资源。</li>
<li>大部分的对象<strong>可以按照内部状态进行分组，且可将不同部分外部化</strong>，这样<strong>每一个组只需保存一个内部状态</strong>。</li>
<li>由于享元模式需要<strong>额外维护一个保存享元的数据结构（多为HashMap\HashTable）</strong>，所以应当在<strong>有足够多的享元实例</strong>时才值得使用享元模式。</li>
</ol>
<h3 id="14-6、享元模式扩展"><a href="#14-6、享元模式扩展" class="headerlink" title="14.6、享元模式扩展"></a>14.6、享元模式扩展</h3><p>在前面介绍的享元模式中，其结构图通常包含<strong>可以共享的部分</strong>和<strong>不可以共享的部分</strong>。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：<strong>单纯享元模式</strong>和<strong>复合享元模式</strong></p>
<h4 id="14-6-1、单纯享元模式"><a href="#14-6-1、单纯享元模式" class="headerlink" title="14.6.1、单纯享元模式"></a>14.6.1、单纯享元模式</h4><p>这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/125.png" alt="image-20210416024136156"></p>
<h4 id="14-6-2、复合享元模式"><a href="#14-6-2、复合享元模式" class="headerlink" title="14.6.2、复合享元模式"></a>14.6.2、复合享元模式</h4><p>这种享元模式中的有些享元对象是<strong>由一些单纯享元对象组合而成的</strong>，它们就是<strong>复合享元对象</strong>。虽然复合享元对象<strong>本身不能共享</strong>，但它们<strong>可以分解成单纯享元对象再被共享</strong>。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/126.png" alt="image-20210416024246399"></p>
<h3 id="14-7、进阶阅读"><a href="#14-7、进阶阅读" class="headerlink" title="14.7、进阶阅读"></a>14.7、进阶阅读</h3><p>如果您想深入了解享元模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8468.html">《使用享元模式实现资源共享池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8469.html">《使用享元模式实现数据库连接池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8471.html">《String中的享元模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8472.html">《Integer中的享元模式》</a></li>
</ul>
<h3 id="14-8、相关设计模式"><a href="#14-8、相关设计模式" class="headerlink" title="14.8、相关设计模式"></a>14.8、相关设计模式</h3><ul>
<li><p>Proxy 模式</p>
<p>如果生成实例的处理需要花费较长时间， 那么使用 Flyweight 模式可以提高程序的处理速度。</p>
<p>而 Proxy 模式则是通过设置代理提高程序的处理速度。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以使用 Flyweight 模式共享 Composite 模式中的 Leaf 角色。</p>
</li>
<li><p>Singleton 模式</p>
<p>在 FlyweightFactory 角色中有时会使用 Singleton 模式。</p>
<p>此外如果使用了 Singleton 模式，由于只会生成一个 Singleton 角色，因此所有使用该实例的地方都共享同一个实例。 在 Singleton 角色的实例中只持有内部（固有）信息。</p>
</li>
</ul>
<h3 id="14-9、享元模式的注意事项与细节"><a href="#14-9、享元模式的注意事项与细节" class="headerlink" title="14.9、享元模式的注意事项与细节"></a>14.9、享元模式的注意事项与细节</h3><ol>
<li>在享元模式这样理解，<strong>“享”就表示共享</strong>，<strong>“元”表示对象</strong></li>
<li>系统中有大量对象，这些对象消耗大量内存，并且<strong>对象的状态大部分可以外部化</strong>时，我们就可以考虑选用享元模式</li>
<li>用<strong>唯一标识码</strong>判断，如果在内存中有，则<strong>返回这个唯一标识码所标识的对象</strong>，用 <strong>HashMap/HashTable</strong> 存储</li>
<li>享元模式大大<strong>减少了对象的创建</strong>，<strong>降低了程序内存的占用</strong>，<strong>提高效率</strong></li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li>使用享元模式时，<strong>注意划分内部状态和外部状态</strong>，并且<strong>需要有一个工厂类加以控制</strong>。</li>
<li>在使用享元模式的时候要注意：<strong>不要让被共享的实例被垃圾回收机制（GC）回收了</strong>。</li>
<li>享元模式经典的应用场景是<strong>需要缓冲池的场景</strong>，比如 String 常量池、数据库连接池。</li>
</ol>
<h3 id="14-10、享元模式与单例模式的区别"><a href="#14-10、享元模式与单例模式的区别" class="headerlink" title="14.10、享元模式与单例模式的区别"></a>14.10、享元模式与单例模式的区别</h3><ol>
<li><p>单例模式是<strong>整个应用系统共用一个实例对象</strong>。</p>
<p>享元模式是<strong>整个系统共用好几个同类型对象</strong>。</p>
</li>
<li><p><strong>连接池本身是单例模式</strong>，连接池里的<strong>多个连接对象是享元模式</strong>。</p>
</li>
<li><p>而且<strong>享元模式的共享对象是按需分配</strong>的，如果<strong>不够还会再创建</strong>！</p>
<p>而<strong>单例模式绝对不会重复创建第二个对象</strong>，这是<strong>本质不同</strong>！</p>
</li>
<li><p><strong>享元模式里的共享对象</strong>在使用时一定是<strong>线程私有的</strong>。</p>
<p>就比如共享单车，虽然是共享的，但在使用时一定是只属于你的</p>
</li>
<li><p>享元模式的<strong>共享对象</strong>是<strong>有借有还</strong>的，在<strong>宏观上是共享</strong>的。</p>
</li>
</ol>
<h2 id="15、代理模式Proxy（结构型模式）"><a href="#15、代理模式Proxy（结构型模式）" class="headerlink" title="15、代理模式Proxy（结构型模式）"></a>15、代理模式Proxy（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/100.png" alt="image-20210416084620231"></p>
<h3 id="15-1、基本介绍"><a href="#15-1、基本介绍" class="headerlink" title="15.1、基本介绍"></a>15.1、基本介绍</h3><ol>
<li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即<strong>通过代理对象访问目标对象</strong>。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</li>
<li><p>这样做的好处是：可以在目标对象实现的基础上，<strong>增强额外的功能操作</strong>，即<strong>扩展目标对象的功能</strong>。</p>
</li>
<li><p>被代理的对象可以是<strong>远程对象</strong>、<strong>创建开销大的对象</strong>或<strong>需要安全控制的对象</strong></p>
</li>
<li><p>代理模式有不同的形式, 主要有三种：</p>
<ul>
<li>静态代理模式：<ul>
<li>静态代理在使用时，需要<strong>定义接口或者父类</strong>,<strong>被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。</strong></li>
</ul>
</li>
<li>动态代理模式 (JDK 代理、接口代理)：<ul>
<li><strong>代理对象不需要实现接口</strong>，但是<strong>目标对象要实现接口</strong>，否则不能用动态代理</li>
<li>代理对象的生成，是利用 <strong>JDK 的 API （反射）</strong>，<strong>动态的在内存中构建代理对象</strong></li>
<li>动态代理也叫做：<strong>JDK 代理</strong>、<strong>接口代理</strong></li>
<li>JDK 中生成代理对象的 API：<ul>
<li>代理类所在包:java.lang.reflect.Proxy</li>
<li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )<ol>
<li>ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</li>
<li>Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</li>
<li>InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Cglib</strong> 代理模式(可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) ：<ul>
<li>静态代理和 JDK 代理模式<strong>都要求目标对象是实现一个接口</strong>，但是有时候<strong>目标对象只是一个单独的对象</strong>，<strong>并没有实现任何的接口</strong>，这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib</strong> 代理。</li>
<li>Cglib 代理也叫作<strong>子类代理**</strong>,<strong>它是</strong>在内存中构建一个子类对象从而实现对目标对象功能扩展**, 有些书也将Cglib 代理归属到动态代理。</li>
<li>Cglib 是<strong>一个强大的高性能的代码生成包</strong>,它可以<strong>在运行期扩展 java 类与实现 java 接口</strong>。它广泛的被许多 <strong>AOP 的框架使用</strong>,例如 <strong>Spring AOP</strong>，实现方法拦截</li>
<li>在 AOP 编程中如何选择代理模式：<ul>
<li><strong>目标对象需要实现接口，用 JDK 代理</strong></li>
<li><strong>目标对象不需要实现接口，用 Cglib 代理</strong></li>
</ul>
</li>
<li>Cglib 包的底层是<strong>通过使用<code>字节码处理框架 ASM</code> 来转换字节码并生成新的类</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代理模式总的类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52.png" alt="image-20210416132054743"></p>
</li>
</ol>
<h3 id="15-2、代理模式的原理结构图-uml类图"><a href="#15-2、代理模式的原理结构图-uml类图" class="headerlink" title="15.2、代理模式的原理结构图-uml类图"></a>15.2、代理模式的原理结构图-uml类图</h3><p>代理模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li><strong>真实主题（Real Subject）</strong>类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li><strong>代理（Proxy）</strong>类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<h4 id="15-2-1、静态代理模式"><a href="#15-2-1、静态代理模式" class="headerlink" title="15.2.1、静态代理模式"></a>15.2.1、静态代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/132.png" alt="image-20210416132423219"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-2、JDK动态代理模式"><a href="#15-2-2、JDK动态代理模式" class="headerlink" title="15.2.2、JDK动态代理模式"></a>15.2.2、JDK动态代理模式</h4><p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/134.png" alt="image-20210416134249061"></p>
<p>执行原理：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/137.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		Subject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		Subject proxyInstance = (Subject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.Request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3、Cglib代理模式"><a href="#15-2-3、Cglib代理模式" class="headerlink" title="15.2.3、Cglib代理模式"></a>15.2.3、Cglib代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/135.png" alt="image-20210416135654386"></p>
<p>执行原理：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/138.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		RealSubject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		RealSubject proxyInstance = (RealSubject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.Request();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3、应用举例"><a href="#15-3、应用举例" class="headerlink" title="15.3、应用举例"></a>15.3、应用举例</h3><p>具体要求：</p>
<ol>
<li>定义一个接口:ITeacherDao</li>
<li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li>
<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li>
<li>调用的时候通过调用代理对象的方法来调用目标对象.</li>
</ol>
<h4 id="15-3-1、使用静态代理模式解决需求"><a href="#15-3-1、使用静态代理模式解决需求" class="headerlink" title="15.3.1、使用静态代理模式解决需求"></a>15.3.1、使用静态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/133.png" alt="image-20210416132715029"></p>
<p>实现代码：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDaoProxy：教师操作代理对象。代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象,静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来组合</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class="comment">//方法</span></span><br><span class="line">		target.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;提交。。。。。&quot;</span>);<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象(被代理对象)</span></span><br><span class="line">		TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class="line">		TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line">		<span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">		<span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class="line">		teacherDaoProxy.teach();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-2、使用动态代理模式解决需求"><a href="#15-3-2、使用动态代理模式解决需求" class="headerlink" title="15.3.2、使用动态代理模式解决需求"></a>15.3.2、使用动态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/136.png" alt="image-20210416141108093"></p>
<p>代码实现：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中.... &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">// 代理工厂，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		ITeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		ITeacherDao proxyInstance = (ITeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.teach();</span><br><span class="line">		proxyInstance.sayHello(<span class="string">&quot; tom &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-3、使用cglib代理模式解决需求"><a href="#15-3-3、使用cglib代理模式解决需求" class="headerlink" title="15.3.3、使用cglib代理模式解决需求"></a>15.3.3、使用cglib代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/140.png" alt="image-20210416143133820"></p>
<p>代码实现：</p>
<p>TeacherDao：教师操作类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="comment">// ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4、代理模式总结"><a href="#15-4、代理模式总结" class="headerlink" title="15.4、代理模式总结"></a>15.4、代理模式总结</h3><h4 id="15-4-1、静态代理优缺点"><a href="#15-4-1、静态代理优缺点" class="headerlink" title="15.4.1、静态代理优缺点"></a>15.4.1、静态代理优缺点</h4><ul>
<li>优点：<ul>
<li>在不修改目标对象的功能前提下, 能<strong>通过代理对象对目标功能扩展</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>因为<strong>代理对象需要与目标对象实现一样的接口</strong>，所以会<strong>有很多代理类</strong></li>
<li>一旦<strong>接口增加方法</strong>,<strong>目标对象与代理对象都要维护</strong></li>
</ul>
</li>
</ul>
<h4 id="15-4-2、JDK动态代理优缺点"><a href="#15-4-2、JDK动态代理优缺点" class="headerlink" title="15.4.2、JDK动态代理优缺点"></a>15.4.2、JDK动态代理优缺点</h4><ul>
<li>优点：<ul>
<li>JDK原声动态代理时java原声支持的、不需要任何外部依赖</li>
</ul>
</li>
<li>缺点：<ul>
<li>但是它只能基于接口进行代理（因为它已经继承了proxy了，java不支持多继承）</li>
</ul>
</li>
</ul>
<h4 id="15-4-3、Cglib动态代理优缺点"><a href="#15-4-3、Cglib动态代理优缺点" class="headerlink" title="15.4.3、Cglib动态代理优缺点"></a>15.4.3、Cglib动态代理优缺点</h4><p>优点：</p>
<ul>
<li>CGLIB通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>需要引入 cglib 的 jar 文件</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/139.png" alt="image-20210416143100693"></p>
</li>
<li><p>在内存中动态构建子类，注意代理的类不能为 final，否则报错java.lang.IllegalArgumentException:</p>
</li>
<li><p>目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。（final修饰的方法不能被覆写）</p>
</li>
</ul>
<h4 id="15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）"><a href="#15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）" class="headerlink" title="15.4.4、两种动态代理模式的对比（JDK VS CGLIB）"></a>15.4.4、两种动态代理模式的对比（JDK VS CGLIB）</h4><table>
<thead>
<tr>
<th></th>
<th>JDK原生动态代理</th>
<th>CGLB动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>核心原理</td>
<td>基于”接口实现”方式</td>
<td>基于类集成方式</td>
</tr>
<tr>
<td>优点</td>
<td>Java原生支持的，不需要任何依赖</td>
<td>对与代理的目标对象无限制，无需实现接口</td>
</tr>
<tr>
<td>不足之处</td>
<td>只能基于接口进行实现</td>
<td>无法处理final方法</td>
</tr>
<tr>
<td>实现方式</td>
<td>Java原生支持，不需要任何依赖</td>
<td>需要引用JAR包cglib-nodep-3.2.5.jar和asm.jar</td>
</tr>
</tbody></table>
<h4 id="15-4-5、代理模式总结"><a href="#15-4-5、代理模式总结" class="headerlink" title="15.4.5、代理模式总结"></a>15.4.5、代理模式总结</h4><p>主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个<strong>中介作用和保护目标对象</strong>的作用；</li>
<li>代理对象可以<strong>扩展目标对象的功能</strong>；</li>
<li>代理模式能将<strong>客户端与目标对象分离</strong>，在一定程度上<strong>降低了系统的耦合度</strong>，<strong>增加了程序的可扩展性</strong></li>
</ul>
<p>主要缺点是（有些缺点可通过动态代理解决）：</p>
<ul>
<li>代理模式会造成系统设计中<strong>类的数量增加</strong></li>
<li>在客户端和目标对象之间增加一个代理对象，会造成<strong>请求处理速度变慢</strong>；</li>
<li><strong>增加了系统的复杂度</strong>；</li>
</ul>
<p>应用场景：</p>
<p>当<strong>无法或不想直接引用某个对象</strong>或<strong>访问某个对象存在困难</strong>时，可以<strong>通过代理对象来间接访问</strong>。使用代理模式主要有两个目的：一是<strong>保护目标对象</strong>，二是<strong>增强目标对象</strong>。</p>
<ol>
<li><p>远程代理：</p>
<ul>
<li>远程代理即<strong>Remote Proxy</strong>，<strong>本地的调用者持有的接口实际上是一个代理</strong>，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。</li>
<li>这种方式通常是为了<strong>隐藏目标对象存在于不同地址空间的事实</strong>，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>Java内置的RMI机制就是一个完整的远程代理模式。</li>
</ul>
</li>
<li><p>虚拟代理：</p>
<ul>
<li>虚代理即<strong>Virtual Proxy</strong>，它让调用者<strong>先持有一个代理对象</strong>，但<strong>真正的对象尚未创建</strong>。如果<strong>没有必要</strong>，这个<strong>真正的对象是不会被创建</strong>的，直到客户端需要<strong>真的必须调用</strong>时，<strong>才创建</strong>真正的对象。</li>
<li>这种方式通常用于<strong>要创建的目标对象开销很大</strong>时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</li>
</ul>
</li>
<li><p>保护代理：</p>
<ul>
<li>保护代理即<strong>Protection Proxy</strong>，它用代理对象控制对原始对象的访问，常用于鉴权。</li>
<li>这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
</ul>
</li>
<li><p>智能引用：</p>
<ul>
<li>智能引用即<strong>Smart Reference</strong>，它也是一种代理对象，如果有很多客户端对它进行访问，通过<strong>内部的计数器可以在外部调用者都不使用后自动释放它</strong>。</li>
<li>主要用于调用目标对象时，<strong>代理附加一些额外的处理功能</strong>。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
</ul>
</li>
<li><p>延迟加载：</p>
<ul>
<li>延迟加载即<strong>Cache缓存代理</strong>。指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>
<li>当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li>
</ul>
</li>
<li><p>防火墙（Firewall）代理：内网通过代理穿透防火墙，实现对公网的访问。</p>
</li>
<li><p>同步化（Synchronization）代理：主要使用在多线程编程中，完成多线程间同步工作</p>
</li>
<li><p>Copy-on-Write 代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</p>
<p>Immer提供了一种更方便的不可变状态操作方式。详情：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>其<strong>方便之处</strong>主要体现在：</p>
<ul>
<li>只有一个（核心）API：<code>produce(currentState, producer: (draftState) =&gt; void): nextState</code></li>
<li>不引入额外的数据结构：没有 List、Map、Set 等任何自定义数据结构，因此也不需要特殊的相等性比较方法</li>
<li>数据操作完全基于类型：用纯原生 API 操作数据，符合直觉</li>
</ul>
</li>
</ol>
<p>应用实际：</p>
<ul>
<li>spring aop</li>
<li>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</li>
<li>买火车票不一定在火车站买，也可以去代售点。</li>
<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</li>
</ul>
<h3 id="15-5、代理模式扩展"><a href="#15-5、代理模式扩展" class="headerlink" title="15.5、代理模式扩展"></a>15.5、代理模式扩展</h3><p>动态代理的一种实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/141.png" alt="image-20210416145841201"></p>
<h3 id="15-6、进阶阅读"><a href="#15-6、进阶阅读" class="headerlink" title="15.6、进阶阅读"></a>15.6、进阶阅读</h3><p>如果您想深入了解代理模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8424.html">《静态代理和动态代理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8427.html">《使用代理模式切换数据源》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8429.html">《彻底搞懂JDK动态代理核心原理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8433.html">《代理模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8435.html">《代理模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="15-7、相关设计模式"><a href="#15-7、相关设计模式" class="headerlink" title="15.7、相关设计模式"></a>15.7、相关设计模式</h3><ul>
<li><p>Adapter 模式：</p>
<p>Adapter 模式适配了两种具有不同接口 (API) 的对象，以使它们可以一同工作。而在 Proxy 模式中，Proxy 角色与Rea)Subject 角色的接口 (API) 是相同的（透明性）。</p>
</li>
<li><p>Decorator 模式：</p>
<p>Decorator 模式与 Proxy 模式在实现上很相似．不过它们的使用目的不同。</p>
<p>Decorator 模式的目的在于增加新的功能。而在 Proxy 模式中，与增加新功能相比，它更注重通过设置代理人的方式来减轻本人的工作负担。</p>
</li>
</ul>
<h3 id="15-8、代理模式与其他模式的区别"><a href="#15-8、代理模式与其他模式的区别" class="headerlink" title="15.8、代理模式与其他模式的区别"></a>15.8、代理模式与其他模式的区别</h3><h4 id="15-8-1、Proxy模式VSDecorator模式"><a href="#15-8-1、Proxy模式VSDecorator模式" class="headerlink" title="15.8.1、Proxy模式VSDecorator模式"></a>15.8.1、Proxy模式VSDecorator模式</h4><ul>
<li>Decorator模式让调用者自己创建核心类，然后组合各种功能</li>
<li>Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能</li>
<li>Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</li>
<li>装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ul>
<h4 id="15-8-2、Proxy模式VSAdapter模式"><a href="#15-8-2、Proxy模式VSAdapter模式" class="headerlink" title="15.8.2、Proxy模式VSAdapter模式"></a>15.8.2、Proxy模式VSAdapter模式</h4><ul>
<li>适配器模式主要改变所考虑对象的接口</li>
<li>代理模式不能改变所代理类的接口</li>
</ul>
<h3 id="15-9、代理模式的注意事项与细节"><a href="#15-9、代理模式的注意事项与细节" class="headerlink" title="15.9、代理模式的注意事项与细节"></a>15.9、代理模式的注意事项与细节</h3><ol>
<li>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</li>
<li>静态代理模式：代理对象与目标对象（被代理对象）都实现同一个接口或者继承同一个抽象类</li>
<li>JDK动态代理模式：目标对象（被代理对象）需要实现接口或继承抽象类，而代理对象不用，它由一个代理工厂来生产</li>
<li>CGLIB动态代模式：目标对象（被代理对象）不需要实现接口或继承抽象类，但是用来生产代理对象的代理工厂需要实现cglib的MethodInterceptor接口。</li>
</ol>
<h2 id="16、模板方法模式Template-Method（行为型模式）"><a href="#16、模板方法模式Template-Method（行为型模式）" class="headerlink" title="16、模板方法模式Template Method（行为型模式）"></a>16、模板方法模式Template Method（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/74.PNG"></p>
<h3 id="16-1、基本介绍"><a href="#16-1、基本介绍" class="headerlink" title="16.1、基本介绍"></a>16.1、基本介绍</h3><ol>
<li>模板方法模式（Template Method Pattern），又叫<strong>模板模式(Template Pattern)**，</strong>在一个抽象类公开定义了执行它的方法的模板<strong>。它的</strong>子类可以按需要重写方法实现<strong>，但</strong>调用将以抽象类中定义的方式进行**。</li>
<li>简单说，模板方法模式<strong>定义一个操作中的算法的骨架</strong>，而将一些步骤延迟到子类中，使得<strong>子类可以不改变一个算法的结构</strong>，就可以<strong>重定义该算法的某些特定步骤</strong></li>
<li>模板方法的核心思想是：<strong>父类定义骨架</strong>，<strong>子类实现某些细节</strong>。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong>。</li>
</ol>
<h3 id="16-2、模板方法模式的原理结构图-uml类图"><a href="#16-2、模板方法模式的原理结构图-uml类图" class="headerlink" title="16.2、模板方法模式的原理结构图-uml类图"></a>16.2、模板方法模式的原理结构图-uml类图</h3><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了<strong>虚函数的多态性技术</strong>以及“不用调用我，让我来调用你”的<strong>反向控制技术</strong>。</p>
<h4 id="16-2-1、模式的结构"><a href="#16-2-1、模式的结构" class="headerlink" title="16.2.1、模式的结构"></a>16.2.1、模式的结构</h4><p>模板方法模式包含以下主要角色：</p>
<ul>
<li>抽象类/抽象模板（Abstract Class）<ul>
<li>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：<ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是整个算法中的一个步骤，包含以下几种类型：<ul>
<li>抽象方法：在抽象类中声明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它。包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体子类/具体实现（Concrete Class）：具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</li>
</ul>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/142.png" alt="image-20210416200400531"></p>
<h4 id="16-2-2、模式的实现"><a href="#16-2-2、模式的实现" class="headerlink" title="16.2.2、模式的实现"></a>16.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass tm = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3、应用举例"><a href="#16-3、应用举例" class="headerlink" title="16.3、应用举例"></a>16.3、应用举例</h3><p>豆浆制作问题：</p>
<p>编写制作豆浆的程序，说明如下:</p>
<ol>
<li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>也可以不添加配料，制作纯豆浆（钩子方法）</li>
<li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
<li>请使用模板方法模式完成 </li>
</ol>
<p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210416200834855.png" alt="image-20210416200834855"></p>
<p>代码实现：</p>
<p>SoyaMilk：制作豆浆的抽象类。抽象类/抽象模板（Abstract Class）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		select(); </span><br><span class="line">		<span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">			addCondiments();</span><br><span class="line">		&#125;</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打碎</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedBeanSoyaMilk：红豆豆浆。具体子类/具体实现（Concrete Class）（PeanutSoyaMilk等等其他豆浆类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PureSoyaMilk：纯豆浆。具体子类/具体实现（Concrete Class）（钩子方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//空实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用制作豆浆。客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line">		System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">		pureSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-4、模板方法模式在Spring框架的应用与源码"><a href="#16-4、模板方法模式在Spring框架的应用与源码" class="headerlink" title="16.4、模板方法模式在Spring框架的应用与源码"></a>16.4、模板方法模式在Spring框架的应用与源码</h3><p><strong>Spring IOC 容器初始化</strong>时运用到的模板方法模式</p>
<p>代码分析+角色分析+说明类图：</p>
<h4 id="16-4-1、说明类图"><a href="#16-4-1、说明类图" class="headerlink" title="16.4.1、说明类图"></a>16.4.1、说明类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/144.png" alt="image-20210416204002753"></p>
<h4 id="16-4-2、角色分析"><a href="#16-4-2、角色分析" class="headerlink" title="16.4.2、角色分析"></a>16.4.2、角色分析</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/145.png" alt="image-20210416204322032"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/146.png" alt="image-20210416204443297"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/147.png" alt="image-20210416204542192"></p>
<h4 id="16-4-3、代码分析"><a href="#16-4-3、代码分析" class="headerlink" title="16.4.3、代码分析"></a>16.4.3、代码分析</h4><p>ConfigurableApplicationContext接口与refresh()抽象模板方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/148.png" alt="image-20210416204750043"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/149.png" alt="image-20210416204918844"></p>
<p>AbstractApplicationContext抽象类实现了ConfigurableApplicationContext接口，并对refresh()模板方法进行了重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/150.png" alt="image-20210416204959220"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/151.png" alt="image-20210416205223899"></p>
<p>refresh()模板方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/152.png" alt="image-20210416205621834"></p>
<p>refresh()模板方法当中的obtainFreshBeanFactory()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/153.png" alt="image-20210416205735418"></p>
<p>refresh()模板方法当中的钩子方法postProcessBeanFactory()与onRefresh()</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/155.png" alt="image-20210416210548820"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/154.png" alt="image-20210416210318005"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/156.png" alt="image-20210416210706001"></p>
<p>GenericApplicationContext类继承了AbstractApplicationContext抽象类，对父类的getBeanFactory()与refreshBeanFactory()抽象方法进行重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/157.png" alt="image-20210416211006295"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/158.png" alt="image-20210416211737520"></p>
<p>XmlWebApplicationContext类、ClassPathXmlApplicationContext类等等子类继承了各自的父类。最好按照父类定义好的模板去实现对应的需求。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/159.png" alt="image-20210416212050470"></p>
<h3 id="16-5、模板方法模式总结"><a href="#16-5、模板方法模式总结" class="headerlink" title="16.5、模板方法模式总结"></a>16.5、模板方法模式总结</h3><p>主要优点：</p>
<ol>
<li>它<strong>封装了不变部分</strong>，<strong>扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在<strong>父类中提取了公共的部分代码</strong>，便于代码复用。</li>
<li><strong>部分方法是由子类实现</strong>的，因此子类可以<strong>通过扩展方式增加相应的功能</strong>，<strong>符合开闭原则</strong>。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li>对<strong>每个不同的实现都需要定义一个子类，这会导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，<strong>子类执行的结果会影响父类的结果</strong>，这导致一种<strong>反向的控制结构</strong>，它<strong>提高了代码阅读的难度</strong>。</li>
<li>由于<strong>继承关系自身的缺点</strong>，如果<strong>父类添加新的抽象方法，则所有子类都要改一遍</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li>算法的<strong>整体步骤很固定，但其中个别部分易变</strong>时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当<strong>多个子类存在公共的行为</strong>时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当<strong>需要控制子类的扩展</strong>时，模板方法<strong>只在特定点调用钩子操作</strong>，这样就<strong>只允许在这些点进行扩展</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异</li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ol>
<h3 id="16-6、模板方法模式扩展"><a href="#16-6、模板方法模式扩展" class="headerlink" title="16.6、模板方法模式扩展"></a>16.6、模板方法模式扩展</h3><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/143.png" alt="image-20210416203027578"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HookAbstractClass tm = <span class="keyword">new</span> HookConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        HookMethod1();</span><br><span class="line">        <span class="keyword">if</span> (HookMethod2()) &#123;</span><br><span class="line">            SpecificMethod();</span><br><span class="line">        &#125;</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookConcreteClass</span> <span class="keyword">extends</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子方法1被重写...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果钩子方法 HookMethod1() 和钩子方法 HookMethod2() 的代码改变，则程序的运行结果也会改变。</p>
<h3 id="16-7、进阶阅读"><a href="#16-7、进阶阅读" class="headerlink" title="16.7、进阶阅读"></a>16.7、进阶阅读</h3><p>如果您想深入了解模板方法模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8477.html">《使用模板模式实现课程基本流程》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8478.html">《使用模板方法模式重构JDBC业务操作》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8479.html">《模板方法模式在Servlet中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8480.html">《模板方法模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="16-8、相关设计模式"><a href="#16-8、相关设计模式" class="headerlink" title="16.8、相关设计模式"></a>16.8、相关设计模式</h3><ul>
<li><p>Factory Method 模式</p>
<p>Factory Method模式是将Template Method模式用于生成实例的一个典型例子。</p>
</li>
<li><p>Strategy 模式</p>
<p>在Template Method模式中， 可以<strong>使用继承改变程序的行为</strong>。 这是因为Template Method模式在父类中定义程序行为的框架．在子类中决定具体的处理。</p>
<p>与此相对的是Strategy模式 ， 它可以<strong>使用委托改变程序的行为</strong>。 与Template Method模式中改 变部分程序行为不同的是，Strategy模式<strong>用于替换整个算法</strong>。</p>
</li>
</ul>
<h3 id="16-9、模板方法模式的注意事项与细节"><a href="#16-9、模板方法模式的注意事项与细节" class="headerlink" title="16.9、模板方法模式的注意事项与细节"></a>16.9、模板方法模式的注意事项与细节</h3><ol>
<li>基本思想是：<strong>算法只存在</strong>于一个地方，也就是在<strong>父类中</strong>，<strong>容易修改</strong>。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。</li>
<li>实现了<strong>最大化代码复用</strong>。<strong>父类的模板方法和已实现的某些步骤会被子类继承而直接使用</strong>。</li>
<li>既<strong>统一了算法</strong>，也<strong>提供了很大的灵活性</strong>。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li>
<li>该模式的不足之处：<strong>每一个不同的实现都需要一个子类实现</strong>，导致<strong>类的个数增加</strong>，使得系统更加庞大</li>
<li>一般<strong>模板方法都加上 <code>final</code> 关键字</strong>， <strong>防止子类重写模板方法</strong>。</li>
<li>模板方法模式使用场景：当要<strong>完成在某个过程，该过程要执行一系列步骤</strong> ，<strong>这一系列的步骤基本相同</strong>，但其<strong>个别步骤在实现时可能不同</strong>，通常考虑用模板方法模式来处理</li>
<li>模板方法是一种<strong>高层定义骨架</strong>，<strong>底层实现细节的设计模式</strong>，适用于<strong>流程固定</strong>，<strong>但某些步骤不确定或可替换</strong>的情况。</li>
</ol>
<h2 id="17、命令模式Command（行为型模式）"><a href="#17、命令模式Command（行为型模式）" class="headerlink" title="17、命令模式Command（行为型模式）"></a>17、命令模式Command（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/160.png" alt="image-20210416212741618"></p>
<h3 id="17-1、基本介绍"><a href="#17-1、基本介绍" class="headerlink" title="17.1、基本介绍"></a>17.1、基本介绍</h3><ol>
<li>命令（Command）模式的定义如下：将<strong>一个请求封装为一个对象</strong>，使<strong>发出请求的责任和执行请求的责任分割开</strong>。这样两者之间通过命令对象进行沟通，这样方便将<strong>命令对象进行储存、传递、调用、增加与管理</strong>。</li>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要<strong>向某些对象发送请求</strong>，但是并<strong>不知道请求的接收者</strong>是谁，<strong>也不知道被请求的操作</strong>是哪个，我们<strong>只需在程序运行时指定具体的请求接收者</strong>即可，此时，可以使用命令模式来进行设计</li>
<li>命名模式使得<strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活，实现解耦。</li>
<li>在命名模式中，会<strong>将一个请求封装为一个对象</strong>，以便<strong>使用不同参数来表示不同的请求(即命名)**，同时命令模式也</strong>支持可撤销**的操作。</li>
<li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象</li>
</ol>
<h3 id="17-2、命令模式的原理结构图-uml类图"><a href="#17-2、命令模式的原理结构图-uml类图" class="headerlink" title="17.2、命令模式的原理结构图-uml类图"></a>17.2、命令模式的原理结构图-uml类图</h3><h4 id="17-2-1、模式的结构"><a href="#17-2-1、模式的结构" class="headerlink" title="17.2.1、模式的结构"></a>17.2.1、模式的结构</h4><p>命令模式包含以下主要角色。</p>
<ol>
<li>抽象命令类（Command）角色：是命令角色，需要执行的所有命令都在这里，拥有执行命令的抽象方法 execute()，可以是接口或抽象类</li>
<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/161.png" alt="image-20210417005514313"></p>
<h4 id="173-2-2、模式的实现"><a href="#173-2-2、模式的实现" class="headerlink" title="173.2.2、模式的实现"></a>173.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker ir = <span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的call()方法...&quot;</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;命令被撤销...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3、应用举例"><a href="#17-3、应用举例" class="headerlink" title="17.3、应用举例"></a>17.3、应用举例</h3><p>17.1   智能生活项目需求</p>
<ol>
<li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个app就可以控制全部智能家电。</li>
<li>要实现一个 app 控制所有智能家电的需要，则<strong>每个智能家电厂家</strong>都要<strong>提供一个统一的接口给 app 调用</strong>，这时 就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li>
<li>在我们的例子中，动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产</li>
<li>编写程序，使用命令模式完成前面的智能家电项目</li>
</ol>
<p>思路分析和图解</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/162.png" alt="image-20210417010355805"></p>
<p>代码实现：</p>
<p>Command：命令接口。抽象命令类（Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//撤销动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightReceiver：电灯接受者。实现者/接收者（Receiver）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯打开了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯关闭了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOnCommand：打开电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.light = light;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOffCommand：关闭电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoCommand：空命令。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做</span></span><br><span class="line"><span class="comment"> * 其实，这样是一种设计模式, 可以省掉对空判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteController：遥控器。调用者/请求者（Invoker）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 开 按钮的命令数组</span></span><br><span class="line">	Command[] onCommands;</span><br><span class="line">	Command[] offCommands;</span><br><span class="line">	<span class="comment">// 执行撤销的命令</span></span><br><span class="line">	Command undoCommand;</span><br><span class="line">	<span class="comment">// 构造器，完成对按钮初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">			offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给我们的按钮设置你需要的命令</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">		onCommands[no] = onCommand;</span><br><span class="line">		offCommands[no] = offCommand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下开按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的开的按钮， 并调用对应方法</span></span><br><span class="line">		onCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = onCommands[no];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下关按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的关的按钮， 并调用对应方法</span></span><br><span class="line">		offCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = offCommands[no];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下撤销按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		undoCommand.undo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。调用遥控器RemoteController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用命令设计模式，完成通过遥控器，对电灯的操作</span></span><br><span class="line">		<span class="comment">//创建电灯的对象(接受者)</span></span><br><span class="line">		LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();</span><br><span class="line">		<span class="comment">//创建电灯相关的开关命令</span></span><br><span class="line">		LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);</span><br><span class="line">		LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);</span><br><span class="line">		<span class="comment">//需要一个遥控器</span></span><br><span class="line">		RemoteController remoteController = <span class="keyword">new</span> RemoteController();</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;=========使用遥控器操作电视机==========&quot;</span>);</span><br><span class="line">		TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line">		TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);</span><br><span class="line">		TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-4、命令模式在Spring框架的应用与源码"><a href="#17-4、命令模式在Spring框架的应用与源码" class="headerlink" title="17.4、命令模式在Spring框架的应用与源码"></a>17.4、命令模式在Spring框架的应用与源码</h3><p>Spring 框架的 JdbcTemplate 就使用到了命令模式</p>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/164.png" alt="image-20210417014539023"></p>
<p>具体代码：</p>
<p>JdbcTemplate类的query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/165.png" alt="image-20210417021850007"></p>
<p>在query方法使用递归调用了query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/166.png" alt="image-20210417022006816"></p>
<p>query方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/167.png" alt="image-20210417022151453"></p>
<p>StatementCallback接口，里面有doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/168.png" alt="image-20210417022235885"></p>
<p>QueryStatementCallback这个静态内部类实现了StatementCallback接口，在里面实现了doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/169.png" alt="image-20210417022649537"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/170.png" alt="image-20210417022952614"></p>
<p>同时，QueryStatementCallback又作为实现者/接收者(Receiver) 角色执行execute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/171.png" alt="image-20210417023039518"></p>
<p>StatementCallback接口的其他实现类：ExecuteStatementCallback</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/173.png" alt="image-20210417023427416"></p>
<p>ExecuteStatementCallback的excute方法：最后调用了JdbcTemplate的excute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/172.png" alt="image-20210417023156907"></p>
<p>JdbcTemplate的excute方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/174.png" alt="image-20210417023635405"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/175.png" alt="image-20210417023940383"></p>
<h3 id="17-5、命令模式总结"><a href="#17-5、命令模式总结" class="headerlink" title="17.5、命令模式总结"></a>17.5、命令模式总结</h3><p>主要优点：</p>
<ol>
<li>通过<strong>引入中间件（抽象接口）降低系统的耦合度</strong>。</li>
<li><strong>扩展性良好</strong>，<strong>增加或删除命令非常方便</strong>。采用命令模式增加与删除命令不会影响其他类，且<strong>满足“开闭原则”</strong>。</li>
<li>可以实现宏命令。<strong>命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</strong>。</li>
<li><strong>方便实现 Undo 和 Redo 操作</strong>。命令模式可以与后面介绍的<strong>备忘录模式结合，实现命令的撤销与恢复</strong>。</li>
<li>可以在现有命令的基础上，<strong>增加额外功能</strong>。比如<strong>日志记录，结合装饰器模式会更加灵活</strong>。</li>
</ol>
<p>缺点是：</p>
<ol>
<li>可能产生<strong>大量具体的命令类</strong>。因为<strong>每一个具体操作都需要设计一个具体命令类</strong>，这会增加系统的复杂性。</li>
<li>命令模式的结果其实就是<strong>接收方的执行结果</strong>，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
</ol>
<p>命令模式的应用场景：</p>
<p>当系统的<strong>某项操作具备命令语义</strong>，且<strong>命令实现不稳定（变化）</strong>时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。<strong>接收方与抽象命令呈现弱耦合</strong>（内部方法无需一致），具备良好的扩展性。</p>
<p>命令模式通常适用于以下场景：</p>
<ol>
<li><strong>请求调用者需要与请求接收者解耦</strong>时，命令模式可以使调用者和接收者不直接交互。</li>
<li>系统<strong>随机请求命令或经常增加、删除命令</strong>时，命令模式可以方便地实现这些功能。</li>
<li>当系统需要<strong>执行一组操作</strong>时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要<strong>支持命令的撤销（Undo）操作和恢复（Redo）操作</strong>时，可以<strong>将命令对象存储起来</strong>，采用<strong>备忘录模式</strong>来实现。</li>
<li>界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制</li>
</ol>
<h3 id="17-6、命令模式扩展"><a href="#17-6、命令模式扩展" class="headerlink" title="17.6、命令模式扩展"></a>17.6、命令模式扩展</h3><p>在软件开发中，有时将命令模式与前面学的<strong>组合模式</strong>联合使用，这就构成了<strong>宏命令模式</strong>，也叫<strong>组合命令模式</strong>。<strong>宏命令包含了一组命令，它充当了具体命令与调用者的双重角色</strong>，执行它时将<strong>递归调用它所包含的所有命令</strong>，其具体结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/163.png" alt="image-20210417013804833"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCommand cmd1 = <span class="keyword">new</span> ConcreteCommand1();</span><br><span class="line">        AbstractCommand cmd2 = <span class="keyword">new</span> ConcreteCommand2();</span><br><span class="line">        CompositeInvoker ir = <span class="keyword">new</span> CompositeInvoker();</span><br><span class="line">        ir.add(cmd1);</span><br><span class="line">        ir.add(cmd2);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的execute()方法...&quot;</span>);</span><br><span class="line">        ir.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand1() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand2() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件: 调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeInvoker</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;AbstractCommand&gt; children = <span class="keyword">new</span> ArrayList&lt;AbstractCommand&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractCommand <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((AbstractCommand) obj).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action1()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action2()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-7、进阶阅读"><a href="#17-7、进阶阅读" class="headerlink" title="17.7、进阶阅读"></a>17.7、进阶阅读</h3><p>如果您想深入了解命令模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8485.html">《使用命令模式实现播放器功能》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8486.html">《命令模式在框架（JDK和JUnit）源码中的应用》</a></li>
</ul>
<h3 id="17-8、相关设计模式"><a href="#17-8、相关设计模式" class="headerlink" title="17.8、相关设计模式"></a>17.8、相关设计模式</h3><ul>
<li><p>Composite 模式</p>
<p>有时会使用Composite模式实现宏命令(macrocommand)。</p>
</li>
<li><p>Memento 模式</p>
<p>有时会使用Memento模式来保存Command角色的历史记录。</p>
</li>
<li><p>Protype 模式</p>
<p>有时会使用Protype模式复制发生的事件（生成的命令）。</p>
</li>
</ul>
<h3 id="17-9、命令模式的注意事项与细节"><a href="#17-9、命令模式的注意事项与细节" class="headerlink" title="17.9、命令模式的注意事项与细节"></a>17.9、命令模式的注意事项与细节</h3><ol>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：<strong>”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用</strong>。</li>
<li>容易设计一个<strong>命令队列</strong>。只要把命令对象放到列队，就可以<strong>多线程的执行命令</strong></li>
<li>容易实现<strong>对请求的撤销和重做</strong></li>
<li>命令模式不足：可能导致某些系统有<strong>过多的具体命令类</strong>，增加了系统的复杂度，这点在在使用的时候要注意</li>
<li><strong>空命令也是一种设计模式</strong>，它为我们<strong>省去了判空的操作</strong>。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li>
<li>命令模式经典的应用场景：<strong>界面的一个按钮都是一条命令</strong>、<strong>模拟 CMD（DOS 命令）订单的撤销/恢复</strong>、<strong>触发- 反馈机制</strong></li>
</ol>
<h2 id="18、访问者模式Visitor（行为型模式）"><a href="#18、访问者模式Visitor（行为型模式）" class="headerlink" title="18、访问者模式Visitor（行为型模式）"></a>18、访问者模式Visitor（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\176.png" alt="image-20210417141823535"></p>
<h3 id="18-1、基本介绍"><a href="#18-1、基本介绍" class="headerlink" title="18.1、基本介绍"></a>18.1、基本介绍</h3><ol>
<li>访问者模式（Visitor Pattern），<strong>封装一些作用于某种数据结构的各元素的操作</strong>，它可以在<strong>不改变数据结构</strong>的前提下定义作用于这些元素的<strong>新的操作</strong>。为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>
<li>主要将<strong>数据结构与数据操作分离</strong>，<strong>解决数据结构和操作耦合</strong>性问题</li>
<li>访问者模式的基本工作原理是：在<strong>被访问的类里面加一个对外提供接待访问者的接口</strong></li>
<li>访问者模式主要应用场景是：需要<strong>对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)**，同时需要</strong>避免让这些操作”污染”这些对象的类**，可以选用访问者模式解决</li>
</ol>
<h3 id="18-2、访问者模式的原理结构图-uml类图"><a href="#18-2、访问者模式的原理结构图-uml类图" class="headerlink" title="18.2、访问者模式的原理结构图-uml类图"></a>18.2、访问者模式的原理结构图-uml类图</h3><p>访问者（Visitor）模式实现的关键是<strong>如何将作用于元素的操作分离出来封装成独立的类</strong></p>
<h4 id="18-2-1、模式的结构"><a href="#18-2-1、模式的结构" class="headerlink" title="18.2.1、模式的结构"></a>18.2.1、模式的结构</h4><p>访问者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象访问者（Visitor）</strong>角色：<strong>定义一个访问具体元素的接口</strong>，为<strong>每个具体元素类对应一个访问操作 visit()</strong> ，该操作中的**参数类型标识了被访问的<code>具体元素</code>**。即：为该对象结构中的 ConcreteElement 的每一个类声明一个 visit 操作。</li>
<li><strong>具体访问者（ConcreteVisitor）</strong>角色：<strong>实现抽象访问者角色</strong>中声明的<strong>各个访问操作</strong>，确定访问者访问一个元素时该做什么。</li>
<li><strong>抽象元素（Element）</strong>角色：声明<strong>一个包含接受操作 accept() 的接口</strong>，<strong>被接受的访问者对象作为 accept() 方法的参数</strong>。即：定义一个 accept 方法，接收一个访问者对象。（与<strong>抽象访问者（Visitor）</strong>角色实现互相关联（但相关联的抽象元素的具体实现类））</li>
<li><strong>具体元素（ConcreteElement）</strong>角色：实现抽象元素角色提供的 accept() 操作，其<strong>方法体通常都是 visitor.visit(this)</strong> （<strong>双分派</strong>），另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li><strong>对象结构（Object Structure）</strong>角色：是<strong>一个包含元素角色的容器</strong>，提供让访问者对象遍历容器中的所有元素的方法，通常由 <code>List</code>、<code>Set</code>、<code>Map</code> 等聚合类实现。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/177.png" alt="img"></p>
<h4 id="18-2-2、代码实现"><a href="#18-2-2、代码实现" class="headerlink" title="18.2.2、代码实现"></a>18.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是具体的元素类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是Visitor访问类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过visit(this)实现双分派</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3、应用举例"><a href="#18-3、应用举例" class="headerlink" title="18.3、应用举例"></a>18.3、应用举例</h3><p>测评系统的需求</p>
<p>将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价有不同的种类，比如 成功、失败等，之后会增加一种状态“待定”以测试程序的扩展性)</p>
<h4 id="18-3-1、使用传统方式解决需求"><a href="#18-3-1、使用传统方式解决需求" class="headerlink" title="18.3.1、使用传统方式解决需求"></a>18.3.1、使用传统方式解决需求</h4><p>思路分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/178.png" alt="image-20210417144957917"></p>
<p>传统方式的问题分析：</p>
<ol>
<li>如果系统比较小，还是 ok 的，但是考虑<strong>系统增加越来越多新的功能</strong>时，对代码改动较大，<strong>违反了 ocp 原则</strong>， 不利于维护</li>
<li>扩展性不好，比如增加了新的人员类型，或者管理方法，都不好做</li>
<li>引出我们会使用新的设计模式 – 访问者模式</li>
</ol>
<h4 id="18-3-2、使用访问者模式解决需求"><a href="#18-3-2、使用访问者模式解决需求" class="headerlink" title="18.3.2、使用访问者模式解决需求"></a>18.3.2、使用访问者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/179.png" alt="image-20210417145718031"></p>
<p>代码实现：</p>
<p>Action：行为抽象类，在里面的方法将<strong>具体元素作为参数传入</strong>。<strong>抽象访问者（Visitor）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到男性 的测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span></span>;</span><br><span class="line">	<span class="comment">//得到女的 测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Success：成功的行为。<strong>具体访问者（ConcreteVisitor）</strong>角色（Fail失败与Wait待定等等行为类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 男人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 女人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person：人类，<strong>将访问者Visitor作为参数传入accept()方法</strong>。<strong>抽象元素（Element）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//提供一个方法，让访问者可以访问</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Man：男人，重写父类的accept方法，并在accept方法里调用<strong>访问者的方法并将this作为参数</strong>传入，以此实现双分派。<strong>具体元素（ConcreteElement）</strong>角色（Woman女人类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</span></span><br><span class="line"><span class="comment">//2. 然后Man类调用作为参数的 &quot;具体方法&quot; 中方法getWomanResult, 同时将自己(this)作为参数</span></span><br><span class="line"><span class="comment">//   传入，完成第二次的分派</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		action.getManResult(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectStructure：<strong>对象结构（Object Structure）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构，管理很多人（Man , Woman）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护了一个集合</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">//增加到list</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.add(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.remove(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示测评情况</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Person p: persons) &#123;</span><br><span class="line">			p.accept(action);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，用来进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建ObjectStructure</span></span><br><span class="line">		ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Man());</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Woman());</span><br><span class="line">		<span class="comment">// 成功</span></span><br><span class="line">		Success success = <span class="keyword">new</span> Success();</span><br><span class="line">		objectStructure.display(success);</span><br><span class="line">		<span class="comment">// 失败</span></span><br><span class="line">		System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">		Fail fail = <span class="keyword">new</span> Fail();</span><br><span class="line">		objectStructure.display(fail);</span><br><span class="line">  		<span class="comment">// 待定</span></span><br><span class="line">		System.out.println(<span class="string">&quot;=======给的是待定的测评========&quot;</span>);	</span><br><span class="line">		Wait wait = <span class="keyword">new</span> Wait();</span><br><span class="line">		objectStructure.display(wait);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4、双分派"><a href="#18-4、双分派" class="headerlink" title="18.4、双分派"></a>18.4、双分派</h3><p>整理一下 Visitor 模式中方法的调用关系：</p>
<ul>
<li><p>accept（接受）方法的调用方式如下：</p>
<p>element.accept(visitor); </p>
</li>
<li><p>visit（访问）方法的调用方式如下：</p>
</li>
<li><p> visitor.visit(element); </p>
</li>
</ul>
<p>对比一下这两个方法会发现， 它们是相反的关系。 <strong>element 接受 visitor, 而 visitor 又访问 element</strong>。</p>
<p>在 Visitor 模式中， ConcreteElement 和 ConcreteVisitor 这两个角色<strong>共同决定了实际进行的处理</strong>。这种消息分发的方式一般被称为双重分发 (double dispatch)。</p>
<p>访问者模式为了实现所谓的“双重分派”，设计了<strong>一个回调再回调的机制</strong>。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>所谓双分派是指<strong>不管类怎么变化</strong>，我们<strong>都能找到期望的方法运行</strong>。双分派意味着<strong>得到执行的操作取决于请求的种类和两个接收者的类型</strong></p>
<p>上述实例为例，假设我们要添加一个 <strong>Wait</strong> 的状态类，考察 <strong>Man</strong> 类和 <strong>Woman</strong> 类的反应，由于使用了双分派，只需增加一个 Action 子类即可在客户端调用即可，不需要改动任何其他类的代码。</p>
<h3 id="18-5、访问者模式总结"><a href="#18-5、访问者模式总结" class="headerlink" title="18.5、访问者模式总结"></a>18.5、访问者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li><strong>复用性好</strong>。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li><strong>灵活性好</strong>。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li><strong>符合单一职责原则</strong>。访问者模式<strong>把相关的行为封装在一起，构成一个访问者</strong>，使每一个访问者的功能都比较单一。可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>增加新的元素类很困难</strong>。在访问者模式中，每增加一个新的元素类，都要在<strong>每一个具体访问者类中增加相应的具体操作</strong>，这<strong>违背了“开闭原则”</strong>。</li>
<li><strong>破坏封装</strong>。访问者模式中<strong>具体元素对访问者公布细节</strong>，这破坏了对象的封装性。</li>
<li><strong>违反了依赖倒置原则</strong>。访问者模式<strong>依赖了具体类，而没有依赖抽象类</strong>。</li>
<li>具体元素对访问者公布细节，<strong>违反了迪米特原则</strong></li>
</ol>
<p>总结一下就是：易于增加的ConcreteVisitor角色，难以增加的ConcreteElement角色</p>
<p>模式的应用场景：</p>
<p>当系统中存在<strong>类型数量稳定（固定）的一类数据结构</strong>时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。</p>
<p>简而言之，就是<strong>当对集合中的不同类型数据（类型数量稳定）进行多种操作</strong>时，使用访问者模式。</p>
<p>通常在以下情况可以考虑使用访问者（Visitor）模式：</p>
<ol>
<li><strong>对象结构相对稳定</strong>，但其<strong>操作算法经常变化</strong>的程序。</li>
<li>对象结构中的对象<strong>需要提供多种不同且不相关的操作</strong>，而且要<strong>避免让这些操作的变化影响对象</strong>的结构。</li>
<li><strong>对象结构包含很多类型的对象</strong>，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ol>
<h3 id="18-6、访问者模式扩展"><a href="#18-6、访问者模式扩展" class="headerlink" title="18.6、访问者模式扩展"></a>18.6、访问者模式扩展</h3><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它<strong>常常同以下两种设计模式联用</strong>。</p>
<ul>
<li>与“<strong>迭代器模式</strong>”联用。因为访问者模式中的“<strong>对象结构</strong>”是一个<strong>包含元素角色的容器</strong>，当<strong>访问者遍历容器中的所有元素时，常常要用迭代器</strong>。如应用举例中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</li>
<li><strong>访问者（Visitor）模式</strong>同“<strong>组合模式</strong>”联用。因为访问者（Visitor）模式中的“<strong>元素对象</strong>”<strong>可能是叶子对象或者是容器对象</strong>，如果<strong>元素对象包含容器对象，就必须用到组合模式</strong>，其结构图如图：</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/180.png" alt="image-20210417153952680"></p>
<h3 id="18-7、进阶阅读"><a href="#18-7、进阶阅读" class="headerlink" title="18.7、进阶阅读"></a>18.7、进阶阅读</h3><p>如果您想深入了解访问者模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8499.html">《访问者模式的伪动态双分派》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8501.html">《访问者模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8502.html">《访问者模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="18-8、相关设计模式"><a href="#18-8、相关设计模式" class="headerlink" title="18.8、相关设计模式"></a>18.8、相关设计模式</h3><ul>
<li><p>Iterator模式</p>
<p>Iterator模式和Visitor模式都是在某种数据结构上进行处理。 </p>
<p>Iterator模式用于逐个遍历保存在数据结构中的元素。</p>
<p>Visitor模式用于对保存在数据结构中的元素进行某种特定的处理。</p>
</li>
<li><p>Composite模式</p>
<p>有时访问者所访问的数据结构会使用Composite模式。</p>
</li>
<li><p>Interpreter模式</p>
<p>在Interpreter模式中， 有时会使用Visitor模式。 例如， 在生成了语法树后， 可能会使用Visitor 模式访问语法树的各个节点进行处理。</p>
</li>
</ul>
<h2 id="19、迭代器模式Iterator（行为型模式）"><a href="#19、迭代器模式Iterator（行为型模式）" class="headerlink" title="19、迭代器模式Iterator（行为型模式）"></a>19、迭代器模式Iterator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/181.png" alt="image-20210417155331998"></p>
<h3 id="19-1、基本介绍"><a href="#19-1、基本介绍" class="headerlink" title="19.1、基本介绍"></a>19.1、基本介绍</h3><ol>
<li>迭代器模式（Iterator Pattern）是常用的设计模式，属于<strong>行为型模式</strong></li>
<li>如果我们的<strong>集合元素是用不同的方式实现</strong>的，有数组，还有 java 的集合类，或者还有其他方式，当客户端<strong>要遍历</strong>这些集合元素的时候<strong>就要使用多种遍历方式</strong>，而且还<strong>会暴露元素的内部结构</strong>，可以考虑使用迭代器模式解决。</li>
<li>迭代器模式，<strong>提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素</strong>，不需要知道集合对象的底层表示，即：<strong>不暴露其内部的结构</strong>。</li>
<li>迭代器模式在客户访问类与聚合类之间插入一个迭代器，这<strong>分离了聚合对象与其遍历行为</strong>，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</li>
</ol>
<h3 id="19-2、迭代器模式的原理结构图-uml类图"><a href="#19-2、迭代器模式的原理结构图-uml类图" class="headerlink" title="19.2、迭代器模式的原理结构图-uml类图"></a>19.2、迭代器模式的原理结构图-uml类图</h3><p>迭代器模式是通过将<strong>聚合对象的遍历行为分离出来，抽象成迭代器类</strong>来实现的，其目的是<strong>在不暴露聚合对象的内部结构的</strong>情况下，<strong>让外部代码透明地访问聚合的内部数据</strong>。现在我们来分析其基本结构与实现方法。</p>
<h4 id="19-2-1、-模式的结构"><a href="#19-2-1、-模式的结构" class="headerlink" title="19.2.1、 模式的结构"></a>19.2.1、 模式的结构</h4><p>迭代器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象聚合（Aggregate）</strong>角色：一个统一的聚合接口， 将客户端和具体聚合解耦。定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li><strong>具体聚合（ConcreteAggregate）</strong>角色：实现抽象聚合类，并提供一个方法，返回一个具体迭代器的实例。该迭代器可以正确遍历集合</li>
<li><strong>抽象迭代器（Iterator）</strong>角色：<strong>定义访问和遍历聚合元素的接口</strong>，是java系统提供的，通常包含 <strong>hasNext()、remove()、next()</strong> 等方法。</li>
<li><strong>具体迭代器（Concretelterator）</strong>角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
<li><strong>Client</strong> :客户端，  通过 Iterator 和   Aggregate 依赖子类</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/183.png" alt="image-20210417182430431"></p>
<h4 id="19-2-2、代码实现"><a href="#19-2-2、代码实现" class="headerlink" title="19.2.2、代码实现"></a>19.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it = ag.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object ob = it.next();</span><br><span class="line">            System.out.print(ob.toString() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object ob = it.first();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFirst：&quot;</span> + ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ConcreteIterator(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-3、应用举例"><a href="#19-3、应用举例" class="headerlink" title="19.3、应用举例"></a>19.3、应用举例</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/184.png" alt="image-20210417183413954"></p>
<h4 id="19-3-1、使用传统方式解决需求"><a href="#19-3-1、使用传统方式解决需求" class="headerlink" title="19.3.1、使用传统方式解决需求"></a>19.3.1、使用传统方式解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统的方式的问题分析：</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的遍历的操作</li>
<li>解决方案：=&gt; 迭代器模式</li>
</ol>
<h4 id="19-3-2、使用迭代器模式解决需求"><a href="#19-3-2、使用迭代器模式解决需求" class="headerlink" title="19.3.2、使用迭代器模式解决需求"></a>19.3.2、使用迭代器模式解决需求</h4><p>原理类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/186.png" alt="image-20210417184732598"></p>
<p>代码实现：</p>
<p>Department：专业。元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象迭代器（Iterator）</strong>角色：java自带的Iterator迭代器接口</p>
<p>ComputerCollegeIterator：计算机学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollegeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们需要Department 是以怎样的方式存放=&gt;数组</span></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">//遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollegeIterator</span><span class="params">(Department[] departments)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departments = departments;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(position &gt;= departments.length || departments[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Department department = departments[position];</span><br><span class="line">		position += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> department;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除的方法，默认空实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoColleageIterator：信息学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoColleageIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList; <span class="comment">// 信息工程学院是以List方式存放系</span></span><br><span class="line">	<span class="keyword">int</span> index = -<span class="number">1</span>;<span class="comment">//索引</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoColleageIterator</span><span class="params">(List&lt;Department&gt; departmentList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departmentList = departmentList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断list中还有没有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(index &gt;= departmentList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			index += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> departmentList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//空实现remove</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院接口，里面有createIterator()方法返回一个迭代器。<strong>抽象聚合（Aggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//增加系的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span></span>;</span><br><span class="line">	<span class="comment">//返回一个迭代器,遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ComputerCollege：计算机学院，实现学院接口，里面对专业这个元素<strong>采用数组方式</strong>存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> numOfDepartment = <span class="number">0</span> ;<span class="comment">// 保存当前数组的对象个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departments = <span class="keyword">new</span> Department[<span class="number">5</span>];</span><br><span class="line">		addDepartment(<span class="string">&quot;Java专业&quot;</span>, <span class="string">&quot; Java专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;PHP专业&quot;</span>, <span class="string">&quot; PHP专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;大数据专业&quot;</span>, <span class="string">&quot; 大数据专业 &quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;计算机学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departments[numOfDepartment] = department;</span><br><span class="line">		numOfDepartment += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ComputerCollegeIterator(departments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoCollege：信息学院，实现学院接口，里面对专业这个元素<strong>采用集合</strong>方式存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departmentList = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line">		addDepartment(<span class="string">&quot;信息安全专业&quot;</span>, <span class="string">&quot; 信息安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;网络安全专业&quot;</span>, <span class="string">&quot; 网络安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;服务器安全专业&quot;</span>, <span class="string">&quot; 服务器安全专业 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;信息工程学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departmentList.add(department);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InfoColleageIterator(departmentList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OutPutImpl：遍历实现对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPutImpl</span> </span>&#123;</span><br><span class="line">	<span class="comment">//学院集合</span></span><br><span class="line">	List&lt;College&gt; collegeList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OutPutImpl</span><span class="params">(List&lt;College&gt; collegeList)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.collegeList = collegeList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有学院,然后调用printDepartment 输出各个学院的系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator</span></span><br><span class="line">		Iterator&lt;College&gt; iterator = collegeList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//取出一个学院</span></span><br><span class="line">			College college = iterator.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;=== &quot;</span>+college.getName() +<span class="string">&quot;=====&quot;</span> );</span><br><span class="line">			printDepartment(college.createIterator()); <span class="comment">//得到对应迭代器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出 学院输出 系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printDepartment</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			Department d = (Department)iterator.next();</span><br><span class="line">			System.out.println(d.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建学院</span></span><br><span class="line">		List&lt;College&gt; collegeList = <span class="keyword">new</span> ArrayList&lt;College&gt;();</span><br><span class="line">		ComputerCollege computerCollege = <span class="keyword">new</span> ComputerCollege();</span><br><span class="line">		InfoCollege infoCollege = <span class="keyword">new</span> InfoCollege();</span><br><span class="line">        </span><br><span class="line">		collegeList.add(computerCollege);</span><br><span class="line">		collegeList.add(infoCollege);</span><br><span class="line">        </span><br><span class="line">		OutPutImpl outPutImpl = <span class="keyword">new</span> OutPutImpl(collegeList);</span><br><span class="line">		outPutImpl.printCollege();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4、迭代器模式在JDK的应用与源码"><a href="#19-4、迭代器模式在JDK的应用与源码" class="headerlink" title="19.4、迭代器模式在JDK的应用与源码"></a>19.4、迭代器模式在JDK的应用与源码</h3><p>JDK 的 <strong>ArrayList</strong> 集合中就使用了迭代器模式</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/189.png" alt="image-20210417202305992"></p>
<p>角色说明：</p>
<ul>
<li>内部类 Itr 充当具体实现迭代器 Iterator 的类， 作为 ArrayList 内部类</li>
<li>List 就是充当了聚合接口，含有一个 iterator() 方法，返回一个迭代器对象</li>
<li>ArrayList 是实现聚合接口 List 的子类，实现了 iterator()</li>
<li>Iterator 接口系统提供</li>
<li>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li>
</ul>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/188.png" alt="image-20210417200928815"></p>
<p>List接口，其中有获取迭代器Iterator的抽象方法，交给实现类去实现</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/191.png" alt="image-20210417203037908"></p>
<p>ArrayList实现了List接口，并实现了List接口的Iterator方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/190.png" alt="image-20210417202736654"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/192.png" alt="image-20210417203908088"></p>
<p>在ArrayList中把元素对象存进了数组里面</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/193.png" alt="image-20210417204155507"></p>
<p>Itr为ArrayList的内部类，实现了Iterator接口，并实现了接口的next()方法与hasNext()方法，由于元素是定义在ArrayList当中的，直接使用即可。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/194.png" alt="image-20210417204819687"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/195.png" alt="image-20210417205056646"></p>
<p>另外实现List接口的实现类的LinkedList类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/196.png" alt="image-20210417210006152"></p>
<p>LinkedList继承了AbstractSequentialList类实现了AbstractSequentialList类当中的Iterator迭代器方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/197.png" alt="image-20210417210011958"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/198.png" alt="image-20210417211542896"></p>
<p>Enumerator实现了Iterator接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/200.png" alt="image-20210417224627356"></p>
<h3 id="19-5、迭代器模式总结"><a href="#19-5、迭代器模式总结" class="headerlink" title="19.5、迭代器模式总结"></a>19.5、迭代器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>访问一个聚合对象的内容而无须暴露它的内部</strong>表示。</li>
<li><strong>遍历任务交由迭代器完成</strong>，这简化了聚合类。</li>
<li>它<strong>支持以不同方式遍历一个聚合</strong>，甚至可以<strong>自定义迭代器的子类以支持新的遍历</strong>。</li>
<li><strong>增加新的聚合类和迭代器类</strong>都很方便，<strong>无须修改原有代码</strong>。</li>
<li><strong>封装性良好</strong>，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<p>其主要缺点是：<strong>增加了类的个数</strong>，这在一定程度上增加了系统的复杂性。</p>
<p>在日常开发中，我们<strong>几乎不会自己写迭代器</strong>。除非需要定制一个自己实现的数据结构对应的迭代器，否则，<strong>开源框架提供的 API 完全够用</strong>。</p>
<p>应用场景：</p>
<ol>
<li>当<strong>需要为聚合对象提供多种遍历方式</strong>时。</li>
<li>当<strong>需要为遍历不同的聚合结构提供一个统一的接口</strong>时。</li>
<li>当<strong>访问一个聚合对象的内容而无须暴露其内部细节的表示</strong>时。</li>
<li>当要<strong>展示一组相似对象，或者遍历一组相同对象</strong>时。</li>
</ol>
<p>由于<strong>聚合与迭代器的关系非常密切</strong>，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p>
<h3 id="19-6、迭代器模式扩展"><a href="#19-6、迭代器模式扩展" class="headerlink" title="19.6、迭代器模式扩展"></a>19.6、迭代器模式扩展</h3><p><strong>迭代器模式常常与组合模式结合起来使用</strong>，在<strong>对组合模式中的容器构件进行访问</strong>时，经常<strong>将迭代器潜藏在组合模式的容器构成类</strong>中。当然也<strong>可以构造一个外部迭代器来对容器构件进行访问</strong>，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/187.png" alt="image-20210417200821530"></p>
<h3 id="19-7、进阶阅读"><a href="#19-7、进阶阅读" class="headerlink" title="19.7、进阶阅读"></a>19.7、进阶阅读</h3><p>如果您想了解迭代器模式在框架源码中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8497.html">《迭代器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8498.html">《迭代器模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="19-8、相关设计模式"><a href="#19-8、相关设计模式" class="headerlink" title="19.8、相关设计模式"></a>19.8、相关设计模式</h3><ul>
<li><p>Visitor 模式</p>
<p>Iterator模式是从集合中一个一个取出元素进行遍历， 但是并没有在Iterator接口中声明对取出的元素进行何种处理。</p>
<p>Visitor模式则是在遍历元素集合的过程中， 对元素进行相同的处理。</p>
<p>在遍历集合的过程中对元素进行固定的处理是常有的需求。 Visitor模式正是为了应对这种需求而出现的。 在访问元素集合的过程中对元素进行相同的处理， 这种模式就是Visitor模式。</p>
</li>
<li><p>Composite 模式</p>
<p>Composite模式是具有递归结构的模式， 在其中使用Iterator模式比较困难。</p>
</li>
<li><p>Factory Method 模式</p>
<p>在iterator方法中生成Iterator的实例时可能会使用Factory Method模式。</p>
</li>
</ul>
<h3 id="19-9、迭代器模式的注意事项与细节"><a href="#19-9、迭代器模式的注意事项与细节" class="headerlink" title="19.9、迭代器模式的注意事项与细节"></a>19.9、迭代器模式的注意事项与细节</h3><p>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。</p>
<h2 id="20、观察者模式Observer（行为型模式）"><a href="#20、观察者模式Observer（行为型模式）" class="headerlink" title="20、观察者模式Observer（行为型模式）"></a>20、观察者模式Observer（行为型模式）</h2><h3 id="20-1、基本介绍"><a href="#20-1、基本介绍" class="headerlink" title="20.1、基本介绍"></a>20.1、基本介绍</h3><ol>
<li><p>观察者（Observer）模式的定义：指<strong>多个对象间存在一对多的依赖关系</strong>，当<strong>一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作<strong>发布-订阅模式</strong>、<strong>模型-视图模式</strong>，它是<strong>对象行为型模式</strong>。</p>
</li>
<li><p>观察者模式类似订牛奶业务</p>
</li>
<li><p>奶站/气象局：Subject 用户/第三方网站：Observer</p>
</li>
<li><p>Subject：登记注册、移除和通知</p>
<ul>
<li>registerObserver 注 册</li>
<li>removeObserver 移 除</li>
<li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送， 看具体需求定</li>
<li>Observer：接收输入</li>
</ul>
<p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject</p>
<p>通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p>
</li>
</ol>
<h3 id="20-2、观察者模式的原理结构图-uml类图"><a href="#20-2、观察者模式的原理结构图-uml类图" class="headerlink" title="20.2、观察者模式的原理结构图-uml类图"></a>20.2、观察者模式的原理结构图-uml类图</h3><p>实现观察者模式时要注意<strong>具体目标对象</strong>和<strong>具体观察者对象之间不能直接调用</strong>，否则<strong>将使两者之间紧密耦合起来</strong>，这<strong>违反了面向对象的设计原则</strong>。</p>
<h4 id="20-2-1、模式的结构"><a href="#20-2-1、模式的结构" class="headerlink" title="20.2.1、模式的结构"></a>20.2.1、模式的结构</h4><p>观察者模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>角色：也叫<strong>抽象目标类</strong>，它提供了一个<strong>用于保存观察者对象的聚集类和增加、删除观察者对象的方法</strong>，以及<strong>通知所有观察者的抽象方法</strong>。</li>
<li><strong>具体主题（Concrete Subject）</strong>角色：也叫<strong>具体目标类</strong>，它<strong>实现抽象目标中的通知方法</strong>，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者（Observer）</strong>角色：它是<strong>一个抽象类或接口</strong>，它<strong>包含了一个更新自己的抽象方法</strong>，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者（Concrete Observer）</strong>角色：<strong>实现抽象观察者中定义的抽象方法</strong>，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p>观察者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/199.png" alt="image-20210417224339045"></p>
<h4 id="20-2-2、代码实现"><a href="#20-2-2、代码实现" class="headerlink" title="20.2.2、代码实现"></a>20.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1 = <span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3、应用举例"><a href="#20-3、应用举例" class="headerlink" title="20.3、应用举例"></a>20.3、应用举例</h3><p>天气预报项目需求，具体要求如下：</p>
<ol>
<li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li>
<li>需要设计开放型 <strong>API</strong>，便于其他第三方也能接入气象站获取数据。</li>
<li>提供温度、气压和湿度的接口</li>
<li>测量数据更新时，要能实时的通知给第三方</li>
</ol>
<h4 id="20-3-1、使用传统方法解决需求"><a href="#20-3-1、使用传统方法解决需求" class="headerlink" title="20.3.1、使用传统方法解决需求"></a>20.3.1、使用传统方法解决需求</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001550797.png" alt="image-20210418001550797"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001617106.png" alt="image-20210418001617106"></p>
<p>实现代码：</p>
<p>WeatherData：天气情况</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002547098.png" alt="image-20210418002547098"></p>
<p>CurrentConditions</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002701455.png" alt="image-20210418002701455"></p>
<p>Client</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002801559.png" alt="image-20210418002801559"></p>
<p>问题分析：</p>
<ol>
<li>其他第三方接入气象站获取数据的问题</li>
<li>无法在运行时动态的添加第三方 (新浪网站)</li>
<li>违反 ocp 原则=&gt;观察者模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-3-2、使用观察者模式解决需求"><a href="#20-3-2、使用观察者模式解决需求" class="headerlink" title="20.3.2、使用观察者模式解决需求"></a>20.3.2、使用观察者模式解决需求</h4><p>类图说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002150098.png" alt="image-20210418002150098"></p>
<p>代码实现：</p>
<p>Subject：<strong>抽象主题（Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口, 让WeatherData 来实现 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WeatherData：包含最新的天气情况信息。<strong>具体主题（Concrete Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类是核心</span></span><br><span class="line"><span class="comment"> * 1. 包含最新的天气情况信息 </span></span><br><span class="line"><span class="comment"> * 2. 含有 观察者集合，使用ArrayList管理</span></span><br><span class="line"><span class="comment"> * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">//观察者集合</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">	<span class="comment">//加入新的第三方</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> temperatrue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pressure;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> humidity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用 接入方的 update</span></span><br><span class="line">		notifyObservers();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		<span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">		dataChange();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		observers.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">			observers.remove(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">			observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer：观察者接口，由观察者来实现。<strong>抽象观察者（Observer）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者接口，由观察者来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CurrentConditions：当前环境。<strong>具体观察者（Concrete Observer）</strong>角色（百度、新浪等等第三方类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 温度，气压，湿度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个WeatherData</span></span><br><span class="line">		WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">		<span class="comment">//创建观察者</span></span><br><span class="line">		CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line">		BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();</span><br><span class="line">		<span class="comment">//注册到weatherData</span></span><br><span class="line">		weatherData.registerObserver(currentConditions);</span><br><span class="line">		weatherData.registerObserver(baiduSite);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">		weatherData.removeObserver(currentConditions);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4、观察者模式在JDK的应用与源码"><a href="#20-4、观察者模式在JDK的应用与源码" class="headerlink" title="20.4、观察者模式在JDK的应用与源码"></a>20.4、观察者模式在JDK的应用与源码</h3><p>Jdk 的 Observable 类就使用了观察者模式</p>
<p>角色分析：</p>
<ul>
<li>Observable  的作用和地位等价于 我们前面讲过 Subject</li>
<li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法 add.. delete .. notify…</li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update</li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式</li>
</ul>
<p>代码分析</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015159710.png" alt="image-20210418015159710"></p>
<p>Observable：相当于Subject接口，但是Observable为一个普通的类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015442922.png" alt="image-20210418015442922"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015737148.png" alt="image-20210418015737148"></p>
<p>Observe接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015636229.png" alt="image-20210418015636229"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418020018759.png" alt="image-20210418020018759"></p>
<h3 id="20-5、观察者模式总结"><a href="#20-5、观察者模式总结" class="headerlink" title="20.5、观察者模式总结"></a>20.5、观察者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了目标与观察者之间的耦合关系</strong>，两者之间是抽象耦合关系。<strong>符合依赖倒置原则</strong>。</li>
<li><strong>目标与观察者之间建立了一套触发机制</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><p>如果在<strong>观察者和观察目标之间有循环依赖</strong>的话，<strong>观察目标会触发它们之间进行循环调用，可能导致系统崩溃</strong></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418011458744.png" alt="image-20210418011458744"></p>
</li>
<li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
</li>
<li><p>当<strong>观察者对象很多</strong>时，<strong>通知的发布会花费很多时间，影响程序的效率</strong>。</p>
</li>
</ol>
<p>在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。</p>
<p>观察者模式的应用情景：</p>
<ol>
<li>对象间<strong>存在一对多关系</strong>，<strong>一个对象的改变将导致其他一个或多个对象也发生改变</strong>，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>当<strong>一个抽象模型有两个方面</strong>，其中<strong>一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</strong>。</li>
<li><strong>实现类似广播机制的功能</strong>，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，<strong>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</strong></li>
</ol>
<h3 id="20-6、观察者模式扩展"><a href="#20-6、观察者模式扩展" class="headerlink" title="20.6、观察者模式扩展"></a>20.6、观察者模式扩展</h3><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口<strong>定义了观察者模式</strong>，只要实现它们的子类就可以编写观察者模式实例。</p>
<h4 id="20-6-1、-Observable类"><a href="#20-6-1、-Observable类" class="headerlink" title="20.6.1、 Observable类"></a>20.6.1、 Observable类</h4><p>Observable 类是<strong>抽象目标类</strong>，它<strong>有一个 Vector 向量</strong>，<strong>用于保存所有要通知的观察者对象</strong>，下面来介绍它最重要的 3 个方法：</p>
<ol>
<li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li>
<li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。<strong>通常越晚加入向量的观察者越先得到通知</strong>。（类似于栈结构）</li>
<li>void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。</li>
</ol>
<h4 id="20-6-2、-Observer-接口"><a href="#20-6-2、-Observer-接口" class="headerlink" title="20.6.2、 Observer 接口"></a>20.6.2、 Observer 接口</h4><p>Observer 接口是<strong>抽象观察者</strong>，它<strong>监视目标对象的变化</strong>，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。</p>
<h4 id="20-6-3、对应例子"><a href="#20-6-3、对应例子" class="headerlink" title="20.6.3、对应例子"></a>20.6.3、对应例子</h4><p>利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例。</p>
<p>分析：当原油价格上涨时，空方伤心，多方局兴；当油价下跌时，空方局兴，多方伤心。本实例中的抽象目标（Observable）类在 Java 中已经定义，可以直接定义其子类，即原油期货（OilFutures）类，它是具体目标类，该类中定义一个 SetPriCe(float price) 方法，当原油数据发生变化时调用其父类的 notifyObservers(Object arg) 方法来通知所有观察者；另外，本实例中的抽象观察者接口（Observer）在 Java 中已经定义，只要定义其子类，即具体观察者类（包括多方类 Bull 和空方类 Bear），并实现 update(Observable o,Object arg) 方法即可。</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418010916983.png" alt="image-20210418010916983"></p>
<h4 id="20-6-4、java-util-Observer接口和java-util-Observable类的相关解析"><a href="#20-6-4、java-util-Observer接口和java-util-Observable类的相关解析" class="headerlink" title="20.6.4、java. util.Observer接口和java. util . Observable类的相关解析"></a>20.6.4、java. util.Observer接口和java. util . Observable类的相关解析</h4><p>话虽如此，但是java. util.Observer接口和java. util . Observable类并不好用。理由很简单，传递给java. util . Observer接口的Subject角色必须是java . util. Observable类型(或者它的子类型)的。但Java只能单继承， 也就说如果Subject角色已经是某个类的子类了，那么它将无法继承java . util . Observable类。</p>
<h3 id="20-7、进阶阅读"><a href="#20-7、进阶阅读" class="headerlink" title="20.7、进阶阅读"></a>20.7、进阶阅读</h3><p>如果您想了解观察者模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8494.html">《基于Java API实现通知机制》</a>文章。</p>
<h3 id="20-8、相关设计模式"><a href="#20-8、相关设计模式" class="headerlink" title="20.8、相关设计模式"></a>20.8、相关设计模式</h3><p>Mediator模式</p>
<ul>
<li>在Mediator模式中，有时会使用Observer模式来实现Mediator角色与Colleague角色之间的通信。</li>
<li>就“发送状态变化通知”这一- 点而言，Mediator 模式与Observer模式是类似的。不过，两种模式中，通知的目的和视角不同。</li>
<li>在Mediator模式中，虽然也会发送通知，不过那不过是为了对Colleague角色进行仲裁而已。</li>
<li>而在Observer模式中，将Subject角色的状态变化通知给Observer 角色的目的则主要是为了使Subject角色和Observer角色同步。</li>
</ul>
<h3 id="20-9、观察者模式的注意事项与细节"><a href="#20-9、观察者模式的注意事项与细节" class="headerlink" title="20.9、观察者模式的注意事项与细节"></a>20.9、观察者模式的注意事项与细节</h3><ol>
<li>观察者模式，又称<strong>发布-订阅模式</strong>，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身</li>
<li>JAVA 中已经有了对观察者模式的支持类，但一般不支持使用。</li>
<li><strong>避免循环引用</strong>。</li>
<li>各个观察者是<strong>依次获得的同步通知</strong>，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，<strong>一般采用异步方式</strong>。</li>
</ol>
<h2 id="21、中介者模式Mediator（行为型模式）"><a href="#21、中介者模式Mediator（行为型模式）" class="headerlink" title="21、中介者模式Mediator（行为型模式）"></a>21、中介者模式Mediator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418021014591.png" alt="image-20210418021014591"></p>
<h3 id="21-1、基本介绍"><a href="#21-1、基本介绍" class="headerlink" title="21.1、基本介绍"></a>21.1、基本介绍</h3><ol>
<li><p>中介者模式（Mediator Pattern），又称调停者模式，是迪米特法则的典型应用。用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
</li>
<li><p>中介者模式属于行为型模式，使代码易于维护</p>
</li>
<li><p>比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141702195.png" alt="image-20210418141702195"></p>
</li>
</ol>
<h3 id="21-2、中介者模式的原理结构图-uml类图"><a href="#21-2、中介者模式的原理结构图-uml类图" class="headerlink" title="21.2、中介者模式的原理结构图-uml类图"></a>21.2、中介者模式的原理结构图-uml类图</h3><p>中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。</p>
<h4 id="21-2-1、模式的结构"><a href="#21-2-1、模式的结构" class="headerlink" title="21.2.1、模式的结构"></a>21.2.1、模式的结构</h4><p>中介者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象中介者（Mediator）</strong>角色：它是中介者的接口，<strong>提供了同事对象注册与转发同事对象信息</strong>的抽象方法。</li>
<li><strong>具体中介者（Concrete Mediator）</strong>角色：实现中介者接口，定义一个 List 来管理同事对象，<strong>协调各个同事角色之间的交互关系</strong>，因此<strong>它依赖于同事角色</strong>。</li>
<li><strong>抽象同事类（Colleague）</strong>角色：定义同事类的接口，<strong>保存中介者对象</strong>，<strong>提供同事对象交互的抽象方法</strong>，<strong>实现所有相互影响的同事类的公共功能</strong>。</li>
<li><strong>具体同事类（Concrete Colleague）</strong>角色：是抽象同事类的实现者，当需要与其他同事对象交互时，<strong>由中介者对象负责后续的交互。</strong></li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141912987.png" alt="image-20210418141912987"></p>
<p>中介者模式的结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141852365.png" alt="image-20210418141852365"></p>
<h4 id="21-2-2、代码实现"><a href="#21-2-2、代码实现" class="headerlink" title="21.2.2、代码实现"></a>21.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator md = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;Colleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ((Colleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3、应用举例"><a href="#21-3、应用举例" class="headerlink" title="21.3、应用举例"></a>21.3、应用举例</h3><p>智能家庭项目：</p>
<ol>
<li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等</li>
<li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作</li>
<li>比如流程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li>
</ol>
<h4 id="21-3-1、使用传统方式解决需求"><a href="#21-3-1、使用传统方式解决需求" class="headerlink" title="21.3.1、使用传统方式解决需求"></a>21.3.1、使用传统方式解决需求</h4><p>思路分析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142259490.png" alt="image-20210418142259490"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂</li>
<li><strong>各个电器对象彼此联系，你中有我，我中有你，不利于松耦合</strong>.</li>
<li>各个电器对象之间所传递的消息(参数)，容易混乱当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 =》 考虑中介者模式</li>
</ol>
<h4 id="21-3-2、使用中介者模式解决需求"><a href="#21-3-2、使用中介者模式解决需求" class="headerlink" title="21.3.2、使用中介者模式解决需求"></a>21.3.2、使用中介者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142556064.png" alt="image-20210418142556064"></p>
<p>代码实现：</p>
<p>Mediator：中介者。<strong>抽象中介者（Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line">	<span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Colleague：<strong>抽象同事类（Colleague）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mediator mediator;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteMediator：<strong>具体中介者（Concrete Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将具体的同事类放入集合中</span></span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Alarm&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;CoffeeMachine&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;TV&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Curtains&quot;</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">&quot;CoffeeMachine&quot;</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//处理咖啡机发出的消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">&quot;Curtains&quot;</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体同事类（Concrete Colleague）</strong>角色：</p>
<p>Alarm：闹钟同事类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeMachine：咖啡机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to startcoffee!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;After 5 minutes!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Coffee is ok!&quot;</span>);</span><br><span class="line">		SendMessage(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TV：电视机、Curtains：窗帘类似</p>
<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个中介者对象</span></span><br><span class="line">		Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">		<span class="comment">//创建Alarm 并且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">		<span class="comment">//创建了CoffeeMachine 对象，并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachine(mediator,<span class="string">&quot;coffeeMachine&quot;</span>);</span><br><span class="line">		<span class="comment">//创建 Curtains , 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">&quot;curtains&quot;</span>);</span><br><span class="line">		TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">&quot;TV&quot;</span>);</span><br><span class="line">		<span class="comment">//让闹钟发出消息</span></span><br><span class="line">		alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">		coffeeMachine.FinishCoffee();</span><br><span class="line">		alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-4、中介者模式总结"><a href="#21-4、中介者模式总结" class="headerlink" title="21.4、中介者模式总结"></a>21.4、中介者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>类之间各司其职，符合迪米特法则。</strong></li>
<li><strong>降低了对象之间的耦合性</strong>，使得对象易于独立地被复用。</li>
<li>将<strong>对象间的一对多关联转变为一对一的关联</strong>，把<strong>多边关系变成多个双边关系</strong>，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>中介者模式将原本<strong>多个对象直接的相互依赖</strong>变成了<strong>中介者和多个同事类的依赖关系</strong>。</li>
<li>当<strong>同事类越多</strong>时，<strong>中介者就会越臃肿</strong>，变得复杂且难以维护。</li>
</ol>
<p>中介者模式的应用场景：</p>
<ul>
<li>当<strong>对象之间存在复杂的网状结构关系</strong>而导致依赖关系混乱且难以复用时。</li>
<li>当想<strong>创建一个运行于多个类之间的对象，又不想生成新的子类</strong>时。</li>
</ul>
<h3 id="21-5、中介者模式扩展"><a href="#21-5、中介者模式扩展" class="headerlink" title="21.5、中介者模式扩展"></a>21.5、中介者模式扩展</h3><p>在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。</p>
<ol>
<li><strong>不定义中介者接口</strong>，把<strong>具体中介者对象实现成为单例</strong>。</li>
<li><strong>同事对象不持有中介者</strong>，而是<strong>在需要的时候直接获取中介者对象并调用</strong>。</li>
</ol>
<p>简化中介者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418143949322.png" alt="image-20210418143949322"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleColleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> SimpleConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> SimpleConcreteColleague2();</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单单例中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleMediator smd = <span class="keyword">new</span> SimpleMediator();</span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleColleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;SimpleColleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleMediator <span class="title">getMedium</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (smd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SimpleColleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(SimpleColleague scl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleColleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(scl)) &#123;</span><br><span class="line">                ((SimpleColleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague1</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague1() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague2</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague2() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-6、进阶阅读"><a href="#21-6、进阶阅读" class="headerlink" title="21.6、进阶阅读"></a>21.6、进阶阅读</h3><p>如果您想了解中介者模式在JDK源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8496.html">《中介者模式在JDK源码中的应用》</a>文章。</p>
<h3 id="21-7、相关设计模式"><a href="#21-7、相关设计模式" class="headerlink" title="21.7、相关设计模式"></a>21.7、相关设计模式</h3><ul>
<li><p>Facade模式</p>
<p>在Mediator模式中，Mediator 角色与Colleague角色进行交互。</p>
<p>而在Facade模式中，Facade 角色单方面地使用其他角色来对外提供高层接口( API)。因此，可以说Mediator模式是双向的，而Facade模式是单向的。</p>
</li>
<li><p>Observer模式</p>
<p>有时会使用Observer模式来实现Mediator角色与Colleague 角色之间的通信。</p>
</li>
</ul>
<h3 id="21-8、中介者模式的注意事项与细节"><a href="#21-8、中介者模式的注意事项与细节" class="headerlink" title="21.8、中介者模式的注意事项与细节"></a>21.8、中介者模式的注意事项与细节</h3><ol>
<li><strong>多个类相互耦合，会形成网状结构</strong>，使用<strong>中介者模式</strong>将网状结构分离为<strong>星型结构</strong>，<strong>进行解耦</strong></li>
<li><strong>减少类间依赖</strong>，降低了耦合，<strong>符合迪米特原则</strong></li>
<li><strong>中介者</strong>承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，<strong>中介者对象本身变得过于复杂</strong>，这点在实际使用时，要特别注意</li>
</ol>
<h2 id="22、备忘录模式Memento（行为型模式）"><a href="#22、备忘录模式Memento（行为型模式）" class="headerlink" title="22、备忘录模式Memento（行为型模式）"></a>22、备忘录模式Memento（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418145233471.png" alt="image-20210418145233471"></p>
<h3 id="22-1、基本介绍"><a href="#22-1、基本介绍" class="headerlink" title="22.1、基本介绍"></a>22.1、基本介绍</h3><ol>
<li>备忘录模式（Memento Pattern）,该模式又叫<strong>快照模式</strong>。在<strong>不破坏封装性</strong>的前提下，<strong>捕获一个对象的内部状态</strong>，并<strong>在该对象之外保存这个状态</strong>。这样以后就可将该对象恢复到原先保存的状态。</li>
<li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</li>
<li>备忘录模式属于行为型模式。</li>
</ol>
<h3 id="22-2、备忘录模式的原理结构图-uml类图"><a href="#22-2、备忘录模式的原理结构图-uml类图" class="headerlink" title="22.2、备忘录模式的原理结构图-uml类图"></a>22.2、备忘录模式的原理结构图-uml类图</h3><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。</p>
<h4 id="22-2-1、模式的结构"><a href="#22-2-1、模式的结构" class="headerlink" title="22.2.1、模式的结构"></a>22.2.1、模式的结构</h4><p>备忘录模式的主要角色如下：</p>
<ol>
<li><p><strong>发起人（Originator）</strong>角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li><p><strong>备忘录（Memento）</strong>角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
<p>Memento角色有以下两种按口( API )：</p>
<ol>
<li><p>wide interface - 宽接口( API )：</p>
<p>Memento角色提供的“宽接口( API)”是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口( API)会暴露所有Memento角色的内部信息，因此能够使用宽接口( API)的只有Originator角色。</p>
</li>
<li><p>narrowinterface - 窄接口 ( API )：</p>
<p>Memento角色为外部的Caretaker角色提供了“窄接口( API)”。可以通过窄接口( API)获取的Memento角色的内部信息非常有限，因此可以有效地防止信息泄露。</p>
</li>
</ol>
<p>通过对外提供以上两种接口( API),可以有效地防止对象的封装性被破坏。</p>
</li>
<li><p><strong>守护者（Caretaker）</strong>角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p>
</li>
</ol>
<p>说明：如果希望保存多个 originator 对象的不同时间的状态也可以，只需要在守护者Caretaker当中使用 HashMap &lt;String, 集合&gt;进行保存就行。</p>
<p>备忘录模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418152450078.png" alt="image-20210418152450078"></p>
<h4 id="22-2-2、代码实现"><a href="#22-2-2、代码实现" class="headerlink" title="22.2.2、代码实现"></a>22.2.2、代码实现</h4><p><strong>发起人（Originator）</strong>角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//编写一个方法，可以保存一个状态对象 Memento</span></span><br><span class="line">	<span class="comment">//因此编写一个方法，返回 Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		state = memento.getState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		mementoList.add(memento);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">         <span class="comment">// 状态#1</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#1 攻击力 100 &quot;</span>);</span><br><span class="line">		<span class="comment">//保存了当前的状态</span></span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#2</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#2 攻击力 80 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#3</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#3 攻击力 50 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());		</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">		<span class="comment">//希望得到状态 1, 将 originator 恢复到状态1	</span></span><br><span class="line">		originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复到状态1 , 当前的状态是&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-3、应用举例"><a href="#22-3、应用举例" class="headerlink" title="22.3、应用举例"></a>22.3、应用举例</h3><p>游戏角色状态恢复问题：</p>
<p>游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态。</p>
<h4 id="22-3-1、使用传统模式解决需求"><a href="#22-3-1、使用传统模式解决需求" class="headerlink" title="22.3.1、使用传统模式解决需求"></a>22.3.1、使用传统模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153109616.png" alt="image-20210418153109616"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大。</li>
<li>传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节</li>
<li>解决方案： =&gt; 备忘录模式</li>
</ol>
<h4 id="22-3-2、使用备忘录模式解决需求"><a href="#22-3-2、使用备忘录模式解决需求" class="headerlink" title="22.3.2、使用备忘录模式解决需求"></a>22.3.2、使用备忘录模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153258446.png" alt="image-20210418153258446"></p>
<p>代码实现：</p>
<p>GameRole：游戏角色。<strong>发起人（Originator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="comment">//创建Memento ,即根据当前的状态得到Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(vit, def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从备忘录对象，恢复GameRole的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverGameRoleFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = memento.getVit();</span><br><span class="line">		<span class="keyword">this</span>.def = memento.getDef();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示当前游戏角色的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;游戏角色当前的攻击力：&quot;</span> + <span class="keyword">this</span>.vit + <span class="string">&quot; 防御力: &quot;</span> + <span class="keyword">this</span>.def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memento：<strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="comment">//攻击力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="comment">//防御力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caretaker：<strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">//守护者对象, 保存游戏角色的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果只保存一次状态</span></span><br><span class="line">	<span class="keyword">private</span> Memento  memento;</span><br><span class="line">	<span class="comment">//对GameRole 保存多次状态</span></span><br><span class="line">	<span class="comment">//private ArrayList&lt;Memento&gt; mementos;</span></span><br><span class="line">	<span class="comment">//对多个游戏角色保存多个状态</span></span><br><span class="line">	<span class="comment">//private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memento;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.memento = memento;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建游戏角色</span></span><br><span class="line">		GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">		gameRole.setVit(<span class="number">100</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战前的状态&quot;</span>);</span><br><span class="line">		gameRole.display();	</span><br><span class="line">		<span class="comment">//把当前状态保存caretaker</span></span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">		caretaker.setMemento(gameRole.createMemento());	</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战~~~&quot;</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">30</span>);</span><br><span class="line">		gameRole.setVit(<span class="number">30</span>);	</span><br><span class="line">		gameRole.display();</span><br><span class="line">		System.out.println(<span class="string">&quot;大战后，使用备忘录对象恢复到大战前&quot;</span>);		</span><br><span class="line">		gameRole.recoverGameRoleFromMemento(caretaker.getMemento());</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复后的状态&quot;</span>);</span><br><span class="line">		gameRole.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-4、备忘录模式总结"><a href="#22-4、备忘录模式总结" class="headerlink" title="22.4、备忘录模式总结"></a>22.4、备忘录模式总结</h3><p>主要优点如下：</p>
<ul>
<li>提供了一种<strong>可以恢复状态</strong>的机制。当用户需要时能够比较<strong>方便地将数据恢复到某个历史的状态</strong>。</li>
<li><strong>实现了内部状态的封装</strong>。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人（Originator）类。<strong>发起人不需要管理和保存其内部状态的各个备份</strong>，所有状态信息都保存在备忘录中，并由管理者进行管理，这<strong>符合单一职责原则</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li><strong>资源消耗大</strong>。如果要保存的<strong>内部状态信息过多</strong>或者<strong>特别频繁</strong>，将会<strong>占用比较大的内存资源</strong>。而且每一次保存都会消耗一定的内存</li>
</ul>
<p>备忘录模式应用场景：</p>
<ol>
<li><strong>需要保存与恢复数据的场景</strong>，如玩游戏时的中间结果的存档功能。</li>
<li>需要<strong>提供一个可回滚操作</strong>的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ol>
<p>备忘录模式应用实例：</p>
<ul>
<li>后悔药</li>
<li>打游戏时的存档</li>
<li>Windows 里的 ctri + z</li>
<li>IE 中的后退</li>
<li>数据库的事务管理</li>
<li>编辑过程中的Undo（撤销）、Redo（重做）、History（历史记录）、Snapshot (快照）都是备忘录模式的应用</li>
</ul>
<h3 id="22-5、备忘录模式扩展"><a href="#22-5、备忘录模式扩展" class="headerlink" title="22.5、备忘录模式扩展"></a>22.5、备忘录模式扩展</h3><h4 id="22-5-1、备忘录模式-原型模式"><a href="#22-5-1、备忘录模式-原型模式" class="headerlink" title="22.5.1、备忘录模式 + 原型模式"></a>22.5.1、备忘录模式 + 原型模式</h4><p>备忘录模式如何同原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类，其结构图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418154508695.png" alt="image-20210418154508695"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeMemento</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OriginatorPrototype or = <span class="keyword">new</span> OriginatorPrototype();</span><br><span class="line">        PrototypeCaretaker cr = <span class="keyword">new</span> PrototypeCaretaker();</span><br><span class="line">        or.setState(<span class="string">&quot;S0&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态:&quot;</span> + or.getState());</span><br><span class="line">        cr.setMemento(or.createMemento()); <span class="comment">//保存状态</span></span><br><span class="line">        or.setState(<span class="string">&quot;S1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;新的状态:&quot;</span> + or.getState());</span><br><span class="line">        or.restoreMemento(cr.getMemento()); <span class="comment">//恢复状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态:&quot;</span> + or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发起人原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginatorPrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(opt.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (OriginatorPrototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型管理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OriginatorPrototype opt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.opt = opt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> opt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-5-2、关于备忘录模式在源码当中的应用"><a href="#22-5-2、关于备忘录模式在源码当中的应用" class="headerlink" title="22.5.2、关于备忘录模式在源码当中的应用"></a>22.5.2、关于备忘录模式在源码当中的应用</h4><p>由于 JDK、Spring、Mybatis 中很少有备忘录模式，所以该设计模式不做典型应用源码分析。</p>
<p>Spring Webflow 中 DefaultMessageContext 类实现了 StateManageableMessageContext 接口，查看其源码可以发现其主要逻辑就相当于给 Message 备份</p>
<h3 id="22-6、进阶阅读"><a href="#22-6、进阶阅读" class="headerlink" title="22.6、进阶阅读"></a>22.6、进阶阅读</h3><p>如果您想了解备忘录模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8504.html">《使用备忘录模式实现草稿箱功能》</a>文章。</p>
<h3 id="22-7、相关设计模式"><a href="#22-7、相关设计模式" class="headerlink" title="22.7、相关设计模式"></a>22.7、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>在使用Command模式处理命令时，可以使用Memento模式实现撤销功能。</p>
</li>
<li><p>Protype模式</p>
<p>在Memento模式中，为了能够实现快照和撤销功能，保存了对象当前的状态。保存的信息只是在恢复状态时所需要的那部分信息。</p>
<p>而在Protype模式中，会生成- 一个与当前实例完全相同的另外一个实例。 这两个实例的内容完全一样。</p>
</li>
<li><p>State 模式</p>
<p>在Memento模式中，是用“实例”表示状态。</p>
<p>而在State模式中，则是用“类”表示状态。</p>
</li>
</ul>
<h3 id="22-8、备忘录模式的注意事项与细节"><a href="#22-8、备忘录模式的注意事项与细节" class="headerlink" title="22.8、备忘录模式的注意事项与细节"></a>22.8、备忘录模式的注意事项与细节</h3><ol>
<li><p>给用户提供了一种<strong>可以恢复状态</strong>的机制，可以使用户能够比较方便地回到某个历史的状态</p>
</li>
<li><p><strong>实现了信息的封装</strong>，使得用户不需要关心状态的保存细节</p>
</li>
<li><p>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</p>
</li>
<li><p>为了节约内存，<strong>备忘录模式可以和原型模式配合使用</strong></p>
</li>
<li><p>在守护者当中的不同情况：</p>
<ol>
<li><p>如果只保存一次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Memento memento;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对发起人（Originator）对象保存多次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Memento&gt; mementos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对多个发起人（Originator）角色保存多个状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="23、解释器模式Interpreter（行为型模式）"><a href="#23、解释器模式Interpreter（行为型模式）" class="headerlink" title="23、解释器模式Interpreter（行为型模式）"></a>23、解释器模式Interpreter（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418162744613.png" alt="image-20210418162744613"></p>
<h3 id="23-1、基本介绍"><a href="#23-1、基本介绍" class="headerlink" title="23.1、基本介绍"></a>23.1、基本介绍</h3><ol>
<li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li>
<li>解释器模式（Interpreter Pattern）：是指给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子(表达式)。也就是说，用编译语言的方式来分析应用中的实例。</li>
<li>这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</li>
<li>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。</li>
</ol>
<h3 id="23-2、编译原理中的“文法、句子、语法树”等相关概念"><a href="#23-2、编译原理中的“文法、句子、语法树”等相关概念" class="headerlink" title="23.2、编译原理中的“文法、句子、语法树”等相关概念"></a>23.2、编译原理中的“文法、句子、语法树”等相关概念</h3><h4 id="23-2-1、文法"><a href="#23-2-1、文法" class="headerlink" title="23.2.1、文法"></a>23.2.1、文法</h4><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。</p>
<p>例如，中文中的“句子”的文法如下：</p>
<p>注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">〈句子〉::&#x3D;〈主语〉〈谓语〉〈宾语〉</span><br><span class="line">〈主语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈谓语〉::&#x3D;〈动词〉</span><br><span class="line">〈宾语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈代词〉你|我|他</span><br><span class="line">〈名词〉7大学生I筱霞I英语</span><br><span class="line">〈动词〉::&#x3D;是|学习</span><br></pre></td></tr></table></figure>

<h4 id="23-2-2、句子"><a href="#23-2-2、句子" class="headerlink" title="23.2.2、句子"></a>23.2.2、句子</h4><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。</p>
<p>例如，上述文法可以推出“我是大学生”，所以它是句子。</p>
<h4 id="23-2-3、语法树"><a href="#23-2-3、语法树" class="headerlink" title="23.2.3、语法树"></a>23.2.3、语法树</h4><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。</p>
<p>下图所示是“我是大学生”的语法树：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180415987.png" alt="image-20210418180415987"></p>
<p>解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。</p>
<h3 id="23-3、解释器模式的原理结构图-uml类图"><a href="#23-3、解释器模式的原理结构图-uml类图" class="headerlink" title="23.3、解释器模式的原理结构图-uml类图"></a>23.3、解释器模式的原理结构图-uml类图</h3><h4 id="23-3-1、模式的结构"><a href="#23-3-1、模式的结构" class="headerlink" title="23.3.1、模式的结构"></a>23.3.1、模式的结构</h4><p>解释器模式包含以下主要角色：</p>
<ol>
<li><strong>抽象表达式（Abstract Expression）</strong>角色：定义解释器的接口，约定解释器的解释操作，主要**包含解释方法 interpret()**，这个方法为抽象语法树中所有的节点所共享。</li>
<li><strong>终结符表达式（Terminal Expression）</strong>角色：是抽象表达式的子类，用来<strong>实现文法中与终结符相关</strong>的操作，文法中的<strong>每一个终结符都有一个具体终结表达式与之相对应</strong>。</li>
<li><strong>非终结符表达式（Nonterminal Expression）</strong>角色：也是抽象表达式的子类，用来<strong>实现文法中与非终结符相关</strong>的操作，文法中的<strong>每条规则都对应于一个非终结符表达式</strong>。</li>
<li><strong>环境（Context）</strong>角色：通常包含<strong>各个解释器需要的数据或是公共的功能</strong>，一般用来传递被所有解释器共享的数据，后面的<strong>解释器可以从这里获取这些值</strong>。</li>
<li><strong>客户端（Client）</strong>：主要任务是<strong>将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树</strong>，然后<strong>调用解释器的解释方法</strong>，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<p>解释器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180640123.png" alt="image-20210418180640123"></p>
<h4 id="23-3-2、代码实现"><a href="#23-3-2、代码实现" class="headerlink" title="23.3.2、代码实现"></a>23.3.2、代码实现</h4><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;    <span class="comment">//解释方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-4、应用举例"><a href="#23-4、应用举例" class="headerlink" title="23.4、应用举例"></a>23.4、应用举例</h3><p>四则运算问题：</p>
<p>通过解释器模式来实现四则运算，如计算 a+b-c 的值，具体要求：</p>
<ol>
<li><p>先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复</p>
</li>
<li><p>在分别输入 a ,b, c, d, e 的值</p>
</li>
<li><p>最后求出结果：如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181009303.png" alt="image-20210418181009303"></p>
</li>
</ol>
<h4 id="23-4-1、使用传统方式解决需求"><a href="#23-4-1、使用传统方式解决需求" class="headerlink" title="23.4.1、使用传统方式解决需求"></a>23.4.1、使用传统方式解决需求</h4><p>传统方案解决四则运算问题分析：</p>
<ol>
<li>编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果</li>
<li>问题分析：如果加入新的运算符，比如<code>*</code>(乘)<code>/</code>(除) 等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，不够清晰。</li>
<li>解决方案：可以考虑使用解释器模式，即：  表达式  -&gt; 解释器(可以有多种) -&gt; 结果</li>
</ol>
<h4 id="23-4-2、使用解释器模式解决需求"><a href="#23-4-2、使用解释器模式解决需求" class="headerlink" title="23.4.2、使用解释器模式解决需求"></a>23.4.2、使用解释器模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181353124.png" alt="image-20210418181353124"></p>
<p>代码实现：</p>
<p>Expression：<strong>抽象表达式（Abstract Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a + b - c</span></span><br><span class="line">	<span class="comment">// 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值</span></span><br><span class="line">	<span class="comment">// HashMap &#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VarExpression：变量的解释器。<strong>终结符表达式（Terminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量的解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String key; <span class="comment">// key=a,key=b,key=c</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VarExpression</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// var 就是&#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="comment">// interpreter 根据 变量名称，返回对应值</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="keyword">this</span>.key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SymbolExpression：抽象运算符号解析器。<strong>非终结符表达式（Nonterminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，</span></span><br><span class="line"><span class="comment"> * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Expression left;</span><br><span class="line">	<span class="keyword">protected</span> Expression right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SymbolExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AddExpression：加法解释器（减法解释器SubExpression类似）继承了SymbolExpression</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加法解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span>  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AddExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(left, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理相加</span></span><br><span class="line">	<span class="comment">//var 仍然是 &#123;a=10,b=20&#125;..</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10</span></span><br><span class="line">		<span class="comment">//super.right.interpreter(var): 返回right 表达式对应值 b = 20</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calculator：计算器。环境（Context）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义表达式</span></span><br><span class="line">	<span class="keyword">private</span> Expression expression;</span><br><span class="line">	<span class="comment">// 构造函数传参，并解析</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expStr)</span> </span>&#123; <span class="comment">// expStr = a+b</span></span><br><span class="line">		<span class="comment">// 安排运算先后顺序</span></span><br><span class="line">		Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">// 表达式拆分成字符数组 </span></span><br><span class="line">		<span class="keyword">char</span>[] charArray = expStr.toCharArray();<span class="comment">// [a, +, b]</span></span><br><span class="line">		Expression left = <span class="keyword">null</span>;</span><br><span class="line">		Expression right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//遍历我们的字符数组， 即遍历  [a, +, b]</span></span><br><span class="line">		<span class="comment">//针对不同的情况，做处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// &#x27;+&#x27;号</span></span><br><span class="line">				left = stack.pop();<span class="comment">// 从stack取出left =&gt; &quot;a&quot;</span></span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));<span class="comment">// 取出右表达式 &quot;b&quot;</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> AddExpression(left, right));<span class="comment">// 然后根据得到left 和 right 构建 AddExpresson加入stack</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// &#x27;-&#x27;号</span></span><br><span class="line">				left = stack.pop();</span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">				stack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: </span><br><span class="line">				<span class="comment">//如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> VarExpression(String.valueOf(charArray[i])));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当遍历完整个 charArray 数组后，stack 就得到最后Expression</span></span><br><span class="line">		<span class="keyword">this</span>.expression = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//最后将表达式a+b和 var = &#123;a=10,b=20&#125;</span></span><br><span class="line">		<span class="comment">//然后传递给expression的interpreter进行解释执行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String expStr = getExpStr(); <span class="comment">// a+b</span></span><br><span class="line">		HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);<span class="comment">// var &#123;a=10, b=20&#125;</span></span><br><span class="line">		Calculator calculator = <span class="keyword">new</span> Calculator(expStr);</span><br><span class="line">		System.out.println(<span class="string">&quot;运算结果：&quot;</span> + expStr + <span class="string">&quot;=&quot;</span> + calculator.run(<span class="keyword">var</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得表达式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;请输入表达式：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得值映射</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> ch : expStr.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!map.containsKey(String.valueOf(ch))) &#123;</span><br><span class="line">					System.out.print(<span class="string">&quot;请输入&quot;</span> + String.valueOf(ch) + <span class="string">&quot;的值：&quot;</span>);</span><br><span class="line">					String in = (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">					map.put(String.valueOf(ch), Integer.valueOf(in));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-5、解释器模式在Spring框架的应用与源码"><a href="#23-5、解释器模式在Spring框架的应用与源码" class="headerlink" title="23.5、解释器模式在Spring框架的应用与源码"></a>23.5、解释器模式在Spring框架的应用与源码</h3><p>Spring 框架中 SpelExpressionParser 就使用到解释器模式</p>
<p>代码分析+Debug源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194307766.png" alt="image-20210418194307766"></p>
<p>main：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194430819.png" alt="image-20210418194430819"></p>
<p>Expression接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194613016.png" alt="image-20210418194613016"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194717484.png" alt="image-20210418194717484"></p>
<p>SpelExpressionParser的parseExpression()方法是继承了其父类TemplateAwareExpressionParser的parseExpression()方法，而TemplateAwareExpressionParser又实现了ExpressionParser接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194936179.png" alt="image-20210418194936179"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195208607.png" alt="image-20210418195208607"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195226794.png" alt="image-20210418195226794"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195314345.png" alt="image-20210418195314345"></p>
<p>TemplateAwareExpressionParser的parseExpression()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195658830.png" alt="image-20210418195658830"></p>
<p>其中的parseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195826923.png" alt="image-20210418195826923"></p>
<p>其中的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210418200021479.png" alt="image-20210418200021479"></p>
<p>子类SpelExpressionParser实现了父类TemplateAwareExpressionParser的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200257640.png" alt="image-20210418200257640"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200553239.png" alt="image-20210418200553239"></p>
<p>说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194009115.png" alt="image-20210418194009115"></p>
<h3 id="23-6、解释器模式总结"><a href="#23-6、解释器模式总结" class="headerlink" title="23.6、解释器模式总结"></a>23.6、解释器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。由于在解释器模式中使用类来表示语言的文法规则，因此可以<strong>通过继承等机制来改变或扩展文法</strong>。</li>
<li><strong>容易实现</strong>。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>执行效率较低</strong>。解释器模式中通常使用<strong>大量的循环和递归调用</strong>，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li><strong>会引起类膨胀</strong>。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li><strong>可应用的场景比较少</strong>。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>当<strong>语言的文法较为简单</strong>，且<strong>执行效率不是关键</strong>问题时。</li>
<li>当<strong>问题重复出现</strong>，且<strong>可以用一种简单的语言来进行表达</strong>时。</li>
<li>当<strong>一个语言需要解释执行</strong>，并且<strong>语言中的句子可以表示为一个抽象语法树</strong>的时候，如 <strong>XML 文档解释</strong>。</li>
</ol>
<p>应用实例：编译器、运算表达式计算、正则表达式、机器人等</p>
<p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</p>
<h3 id="23-7、解释器模式扩展"><a href="#23-7、解释器模式扩展" class="headerlink" title="23.7、解释器模式扩展"></a>23.7、解释器模式扩展</h3><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p>现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。</p>
<p>下面以计算存款利息为例来介绍。存款利息的计算公式是：本金x利率x时间=利息，其相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"><span class="keyword">import</span> com.singularsys.jep.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JepException </span>&#123;</span><br><span class="line">        Jep jep = <span class="keyword">new</span> Jep();</span><br><span class="line">        <span class="comment">//定义要计算的数据表达式</span></span><br><span class="line">        String 存款利息 = <span class="string">&quot;本金*利率*时间&quot;</span>;</span><br><span class="line">        <span class="comment">//给相关变量赋值</span></span><br><span class="line">        jep.addVariable(<span class="string">&quot;本金&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;利率&quot;</span>, <span class="number">0.038</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;时间&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        jep.parse(存款利息);    <span class="comment">//解析表达式</span></span><br><span class="line">        Object accrual = jep.evaluate();    <span class="comment">//计算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;存款利息：&quot;</span> + accrual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-8、进阶阅读"><a href="#23-8、进阶阅读" class="headerlink" title="23.8、进阶阅读"></a>23.8、进阶阅读</h3><p>如果您想了解解释器模式在框架源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8505.html">《解释器模式在JDK和Spring源码中的应用》</a>文章。</p>
<h3 id="23-9、相关设计模式"><a href="#23-9、相关设计模式" class="headerlink" title="23.9、相关设计模式"></a>23.9、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>NonterminalExpression角色多是递归结构，因此常会使用Composite模式来实现NonterminalExpression角色</p>
</li>
<li><p>Flyweight 模式</p>
<p>有时会使用Flyweight模式来共享TerminalExpression角色。</p>
</li>
<li><p>Visitor 模式</p>
<p>在推导出语法树后，有时会使用Visitor模式来访问语法树的各个节点。</p>
</li>
</ul>
<h3 id="23-10、解释器模式的注意事项与细节"><a href="#23-10、解释器模式的注意事项与细节" class="headerlink" title="23.10、解释器模式的注意事项与细节"></a>23.10、解释器模式的注意事项与细节</h3><ol>
<li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展</li>
<li>使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。</li>
<li>解释器模式通过抽象语法树实现对用户输入的解释执行。</li>
<li>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</li>
</ol>
<h2 id="24、状态模式State（行为型模式）"><a href="#24、状态模式State（行为型模式）" class="headerlink" title="24、状态模式State（行为型模式）"></a>24、状态模式State（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418201124106.png" alt="image-20210418201124106"></p>
<h3 id="24-1、基本介绍"><a href="#24-1、基本介绍" class="headerlink" title="24.1、基本介绍"></a>24.1、基本介绍</h3><ol>
<li>状态模式（<strong>State Pattern</strong>）：它主要用来解决<strong>对象在多种状态转换时，需要对外输出不同的行为的</strong>问题。<strong>状态和行为是一一对应的，状态之间可以相互转换</strong></li>
<li>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</li>
<li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</li>
<li><strong>替代了使用if-else解决问题</strong></li>
</ol>
<h3 id="24-2、状态模式的原理结构图-uml类图"><a href="#24-2、状态模式的原理结构图-uml类图" class="headerlink" title="24.2、状态模式的原理结构图-uml类图"></a>24.2、状态模式的原理结构图-uml类图</h3><p>状态模式把<strong>受环境改变的对象行为包装在不同的状态对象</strong>里，其意图是<strong>让一个对象在其内部状态改变的时候</strong>，其<strong>行为也随之改变</strong>。</p>
<h4 id="24-2-1、模式的结构"><a href="#24-2-1、模式的结构" class="headerlink" title="24.2.1、模式的结构"></a>24.2.1、模式的结构</h4><p>状态模式包含以下主要角色：</p>
<ol>
<li><strong>环境类（Context）</strong>角色：也称为<strong>上下文</strong>，它<strong>定义了客户端需要的接口</strong>，<strong>内部维护一个当前状态</strong>，并<strong>负责具体状态的切换</strong>。</li>
<li><strong>抽象状态（State）</strong>角色：定义一个接口，用以<strong>封装环境对象中的特定状态所对应的行为</strong>，可以有<strong>一个或多个</strong>行为。</li>
<li><strong>具体状态（Concrete State）</strong>角色：实现抽象状态所对应的行为，并且<strong>在需要的情况下进行状态切换</strong>。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205430235.png" alt="image-20210418205430235"></p>
<h4 id="24-2-2、代码实现"><a href="#24-2-2、代码实现" class="headerlink" title="24.2.2、代码实现"></a>24.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();    <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle();    <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 A.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 B.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-3、应用举例"><a href="#24-3、应用举例" class="headerlink" title="24.3、应用举例"></a>24.3、应用举例</h3><p>APP 抽奖活动问题：</p>
<p>请编写程序完成 APP 抽奖活动 具体要求如下:</p>
<ol>
<li><p>假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10%</p>
</li>
<li><p>奖品数量固定，抽完就不能抽奖</p>
</li>
<li><p>活动有四个状态: </p>
<ul>
<li>可以抽奖</li>
<li>不能抽奖</li>
<li>发放奖品</li>
<li>奖品领完</li>
</ul>
</li>
<li><p>活动的四个状态转换关系图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205732564.png" alt="image-20210418205732564"></p>
</li>
</ol>
<h4 id="24-3-1、使用传统方式解决需求"><a href="#24-3-1、使用传统方式解决需求" class="headerlink" title="24.3.1、使用传统方式解决需求"></a>24.3.1、使用传统方式解决需求</h4><p>通常通过if/else判断抽奖的状态，从而实现不同的逻辑，伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(不能抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(可以抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(发放奖品)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>传统的方式的问题分析： </p>
<ul>
<li>这类代码难以应对变化，在添加一种状态时，我们需要手动添加if/else</li>
<li>在添加一种功能时，要对所有的状态进行判断。</li>
<li>因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的BUG，难以维护</li>
<li>不符合开闭原则</li>
</ul>
<h4 id="24-3-2、使用状态模式解决需求"><a href="#24-3-2、使用状态模式解决需求" class="headerlink" title="24.3.2、使用状态模式解决需求"></a>24.3.2、使用状态模式解决需求</h4><p>思路分析和图解(类图)</p>
<ul>
<li>定义出一个接口叫状态接口，每个状态都实现它。</li>
<li>接口有扣除积分方法、抽奖方法、发放奖品方法</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418210441898.png" alt="image-20210418210441898"></p>
<p>代码实现：</p>
<p>State：<strong>抽象状态（State）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扣除积分 - 50</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 是否抽中奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 发放奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体状态（Concrete State）</strong>：四种状态：</p>
<p>NoRaffleState：不能抽奖状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不能抽奖状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 初始化时传入活动引用，扣除积分后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);</span><br><span class="line">        activity.setState(activity.getCanRaffleState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能抽奖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣了积分才能抽奖喔！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能发奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CanRaffleState：可以抽奖的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以抽奖的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CanRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经扣除了积分，不能再扣</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经扣取过了积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽奖，请稍等！&quot;</span>);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10%中奖机会</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 改变活动状态为发放奖品 context</span></span><br><span class="line">            activity.setState(activity.getDispenseState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾没有抽中奖品！&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没中奖，不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseState：发放奖品的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发放奖品的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用，发放奖品后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能扣除积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能抽奖&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(activity.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜中奖了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾，奖品发送完了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span></span><br><span class="line">            activity.setState(activity.getDispensOutState());</span><br><span class="line">            <span class="comment">//System.out.println(&quot;抽奖活动结束&quot;);</span></span><br><span class="line">            <span class="comment">//System.exit(0);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseOutState：奖品发放完毕状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖品发放完毕状态</span></span><br><span class="line"><span class="comment"> * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseOutState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseOutState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity：抽奖活动。<strong>环境类（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖活动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="comment">// state 表示活动当前的状态，是变化</span></span><br><span class="line">    State state = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 奖品数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 四个属性，表示四种状态</span></span><br><span class="line">    State noRafflleState = <span class="keyword">new</span> NoRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State canRaffleState = <span class="keyword">new</span> CanRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State dispenseState =   <span class="keyword">new</span> DispenseState(<span class="keyword">this</span>);</span><br><span class="line">    State dispensOutState = <span class="keyword">new</span> DispenseOutState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span></span><br><span class="line">    <span class="comment">//2. 初始化奖品的数量 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RaffleActivity</span><span class="params">( <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = getNoRafflleState();</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣分, 调用当前状态的 deductMoney</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debuctMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.deductMoney();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽奖 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raffle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 如果当前的状态是抽奖成功</span></span><br><span class="line">        <span class="keyword">if</span>(state.raffle())&#123;</span><br><span class="line">        	<span class="comment">//领取奖品</span></span><br><span class="line">            state.dispensePrize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里请大家注意，每领取一次奖品，count--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> curCount = count; </span><br><span class="line">    	count--;</span><br><span class="line">        <span class="keyword">return</span> curCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getNoRafflleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoRafflleState</span><span class="params">(State noRafflleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.noRafflleState = noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCanRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCanRaffleState</span><span class="params">(State canRaffleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseState</span><span class="params">(State dispenseState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispenseState = dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispensOutState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispensOutState</span><span class="params">(State dispensOutState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispensOutState = dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态模式测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建活动对象，奖品有1个奖品</span></span><br><span class="line">        RaffleActivity activity = <span class="keyword">new</span> RaffleActivity(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 我们连续抽30次奖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次抽奖----------&quot;</span>);</span><br><span class="line">            <span class="comment">// 参加抽奖，第一步点击扣除积分</span></span><br><span class="line">            activity.debuctMoney();</span><br><span class="line">            <span class="comment">// 第二步抽奖</span></span><br><span class="line">            activity.raffle();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-4、状态模式在实际项目-借贷平台源码分析"><a href="#24-4、状态模式在实际项目-借贷平台源码分析" class="headerlink" title="24.4、状态模式在实际项目-借贷平台源码分析"></a>24.4、状态模式在实际项目-借贷平台源码分析</h3><p>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态, 项目中的这个模块实现就会使用到状态模式：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213432465.png" alt="image-20210418213432465"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213517578.png" alt="image-20210418213517578"></p>
<p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213541498.png" alt="image-20210418213541498"></p>
<p>代码实现：</p>
<p>State：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定价发布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无人接单失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 付款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单有人支付失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反馈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractState：实现State接口方法的默认实现。子类通过自己的需求进行重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	rotected <span class="keyword">static</span> <span class="keyword">final</span> RuntimeException EXCEPTION = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;操作流程不允许&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各种具体状态类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedBackState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.FEED_BACKED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> ReviewState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.GENERATE.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotPayState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PaidState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.NOT_PAY.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaidState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PAID.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> NotPayState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PUBLISHED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.REVIEWED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StateEnum：状态枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//订单生成</span></span><br><span class="line">    GENERATE(<span class="number">1</span>, <span class="string">&quot;GENERATE&quot;</span>),</span><br><span class="line">    <span class="comment">//已审核</span></span><br><span class="line">    REVIEWED(<span class="number">2</span>, <span class="string">&quot;REVIEWED&quot;</span>),</span><br><span class="line">    <span class="comment">//已发布</span></span><br><span class="line">    PUBLISHED(<span class="number">3</span>, <span class="string">&quot;PUBLISHED&quot;</span>),</span><br><span class="line">    <span class="comment">//待付款</span></span><br><span class="line">    NOT_PAY(<span class="number">4</span>, <span class="string">&quot;NOT_PAY&quot;</span>),</span><br><span class="line">    <span class="comment">//已付款</span></span><br><span class="line">    PAID(<span class="number">5</span>, <span class="string">&quot;PAID&quot;</span>),</span><br><span class="line">    <span class="comment">//已完结</span></span><br><span class="line">    FEED_BACKED(<span class="number">6</span>, <span class="string">&quot;FEED_BACKED&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    StateEnum(<span class="keyword">int</span> key, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context：环境上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">extends</span> <span class="title">AbstractState</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> State state;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkFailEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.makePriceEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.acceptOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.notPeopleAcceptEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.payOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.orderFailureEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.feedBackEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态 : &quot;</span> + state.getCurrentState());</span><br><span class="line">        <span class="keyword">return</span> state.getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientTest：测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">        <span class="comment">//然后可以根据操作变化状态.</span></span><br><span class="line">        <span class="comment">//publish --&gt; not pay</span></span><br><span class="line">       context.acceptOrderEvent(context);</span><br><span class="line">        <span class="comment">//not pay --&gt; paid</span></span><br><span class="line">        context.payOrderEvent(context);</span><br><span class="line">        <span class="comment">// 失败, 检测失败时，会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	context.checkFailEvent(context);</span><br><span class="line">        	System.out.println(<span class="string">&quot;流程正常..&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-5、状态模式总结"><a href="#24-5、状态模式总结" class="headerlink" title="24.5、状态模式总结"></a>24.5、状态模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>结构清晰</strong>，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，<strong>满足“单一职责原则”</strong>。</li>
<li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li>
<li><strong>将状态转换显示化，减少对象间的相互依赖</strong>。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li><strong>允许状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li>
<li>将<strong>所有与某个状态有关的行为放到一个类中</strong>，并且<strong>可以方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。 </li>
<li>可以让多个环境对象共享一个状态对象，从而<strong>减少系统中对象的个数</strong></li>
<li><strong>状态类职责明确，有利于程序的扩展</strong>。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>状态模式的主要缺点如下：</p>
<ol>
<li>状态模式的使用必然会<strong>增加系统的类与对象的个数</strong>。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
<li><strong>状态模式对开闭原则的支持并不太好</strong>，对于可以切换状态的状态模式，增加新的状态类<strong>需要修改那些负责状态转换的源码，否则无法切换到新增状态</strong>，而且修改某个状态类的行为也需要修改对应类的源码。</li>
</ol>
<p>状态模式的应用场景：</p>
<ul>
<li>当一个对象的<strong>行为取决于它的状态</strong>，并且它必须<strong>在运行时根据状态改变它的行为</strong>时，就可以考虑使用状态模式。</li>
<li><strong>一个操作中含有庞大的分支结构</strong>，并且这些<strong>分支决定于对象的状态</strong>时。</li>
<li>当<strong>一个事件或者对象有很多种状态</strong>，<strong>状态之间会相互转换</strong>，对<strong>不同的状态要求有不同的行为</strong>的时候， 可以考虑使用状态模式</li>
</ul>
<h3 id="24-6、状态模式扩展"><a href="#24-6、状态模式扩展" class="headerlink" title="24.6、状态模式扩展"></a>24.6、状态模式扩展</h3><h4 id="24-6-1、状态模式-享元模式"><a href="#24-6-1、状态模式-享元模式" class="headerlink" title="24.6.1、状态模式 + 享元模式"></a>24.6.1、状态模式 + 享元模式</h4><p>在有些情况下，可能有<strong>多个环境对象需要共享一组状态</strong>，这时需要引入<strong>享元模式</strong>，将这些具体状态对象放在集合中供程序共享，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418212557965.png" alt="image-20210418212557965"></p>
<p>分析：共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取，其程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightStatePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareContext context = <span class="keyword">new</span> ShareContext(); <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle(); <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShareState state;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, ShareState&gt; stateSet = <span class="keyword">new</span> HashMap&lt;String, ShareState&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState1();</span><br><span class="line">        stateSet.put(<span class="string">&quot;1&quot;</span>, state);</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState2();</span><br><span class="line">        stateSet.put(<span class="string">&quot;2&quot;</span>, state);</span><br><span class="line">        state = getState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ShareState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShareState <span class="title">getState</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        ShareState s = (ShareState) stateSet.get(key);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态1类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态1&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态2类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态2&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-6-2、状态模式与责任链模式的区别"><a href="#24-6-2、状态模式与责任链模式的区别" class="headerlink" title="24.6.2、状态模式与责任链模式的区别"></a>24.6.2、状态模式与责任链模式的区别</h4><ol>
<li><strong>状态模式和责任链模式都能消除 if-else 分支过多的问题</strong>。但在某些情况下，<strong>状态模式中的状态可以理解为责任</strong>，那么在这种情况下，<strong>两种模式都可以使用</strong>。</li>
<li>从<strong>定义</strong>来看，<strong>状态模式强调的是一个对象内在状态的改变</strong>，而<strong>责任链模式强调的是外部节点对象间的改变</strong>。</li>
<li>从<strong>代码实现</strong>上来看，两者最大的区别就是<strong>状态模式的各个状态对象知道自己要进入的下一个状态对象</strong>，而<strong>责任链模式并不清楚其下一个节点处理对象</strong>，因为<strong>链式组装由客户端负责</strong>。</li>
</ol>
<h4 id="24-6-3、状态模式与策略模式的区别"><a href="#24-6-3、状态模式与策略模式的区别" class="headerlink" title="24.6.3、状态模式与策略模式的区别"></a>24.6.3、状态模式与策略模式的区别</h4><p><strong>状态模式和策略模式的 UML 类图架构几乎完全一样，但两者的应用场景是不一样的</strong>。<strong>策略模式的多种算法行为择其一都能满足，彼此之间是独立的</strong>，<strong>用户可自行更换策略算法</strong>，而<strong>状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果</strong>，并且<strong>用户无法指定状态，只能设置初始状态</strong>。</p>
<h3 id="24-7、进阶阅读"><a href="#24-7、进阶阅读" class="headerlink" title="24.7、进阶阅读"></a>24.7、进阶阅读</h3><p>如果您想深入了解状态模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8490.html">《使用状态模式自由切换登录状态》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8492.html">《使用状态机实现订单状态流转控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8493.html">《状态模式在JSF源码中的应用》</a></li>
</ul>
<h3 id="24-8、相关设计模式"><a href="#24-8、相关设计模式" class="headerlink" title="24.8、相关设计模式"></a>24.8、相关设计模式</h3><ul>
<li><p>Singleton 模式</p>
<p>Singleton模式常常会出现在ConcreteState角色中。这是因为在表示状态的类中并没有定义任何实例字段(即表示实例的状态的字段)。</p>
</li>
<li><p>Flyweight 模式</p>
<p>在表示状态的类中并没有定义任何实例字段。因此，有时我们可以使用Flyweight模式在多个Context角色之间共享ConcreteState角色。</p>
</li>
</ul>
<h3 id="24-9、状态模式的注意事项与细节"><a href="#24-9、状态模式的注意事项与细节" class="headerlink" title="24.9、状态模式的注意事项与细节"></a>24.9、状态模式的注意事项与细节</h3><ol>
<li>代码有<strong>很强的可读性</strong>。状态模式将<strong>每个状态的行为封装到对应的一个类</strong>中</li>
<li><strong>方便维护</strong>。将<strong>容易产生问题的 if-else 语句删除</strong>了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错</li>
<li>会产生很多类。<strong>每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</strong></li>
</ol>
<h2 id="25、策略模式Strategy（行为型模式）"><a href="#25、策略模式Strategy（行为型模式）" class="headerlink" title="25、策略模式Strategy（行为型模式）"></a>25、策略模式Strategy（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418214750299.png" alt="image-20210418214750299"></p>
<h3 id="25-1、基本介绍"><a href="#25-1、基本介绍" class="headerlink" title="25.1、基本介绍"></a>25.1、基本介绍</h3><ol>
<li>策略模式（Strategy Pattern）中，<strong>定义算法族（策略组），分别封装起来，让他们之间可以互相替换</strong>，此模式让<strong>算法的变化独立于使用算法的客户</strong></li>
<li>策略模式属于对象行为模式，它通过<strong>对算法进行封装</strong>，把<strong>使用算法的责任和算法的实现分割开来</strong>，并<strong>委派给不同的对象对这些算法进行管理</strong>。</li>
<li>在策略模式中，我们创建表示<strong>各种策略的对象和一个行为随着策略对象改变而改变的 context 对象</strong>。策略对象改变 context 对象的执行算法。</li>
<li>策略模式的核心思想是<strong>在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去</strong>，从而使得<strong>新增策略不必修改原有逻辑</strong>。</li>
<li>这算法体现了几个设计原则：<ol>
<li>把变化的代码从不变的代码中分离出来</li>
<li>第二、针对接口编程而不是具体类（定义了策略接口）</li>
<li>第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）。</li>
</ol>
</li>
</ol>
<h3 id="25-2、策略模式的原理结构图-uml类图"><a href="#25-2、策略模式的原理结构图-uml类图" class="headerlink" title="25.2、策略模式的原理结构图-uml类图"></a>25.2、策略模式的原理结构图-uml类图</h3><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的<strong>重心</strong>不是如何实现算法，而<strong>是如何组织这些算法</strong>，从而让程序结构更加灵活，具有更好的维护性和扩展性。</p>
<h4 id="25-2-1、模式的结构"><a href="#25-2-1、模式的结构" class="headerlink" title="25.2.1、模式的结构"></a>25.2.1、模式的结构</h4><p>策略模式的主要角色如下：</p>
<ol>
<li><strong>抽象策略（Strategy）</strong>类：定义了一个<strong>公共接口</strong>，<strong>各种不同的算法以不同的方式实现这个接口</strong>，<strong>环境角色使用这个接口调用不同的算法</strong>，一般使用<strong>接口或抽象类</strong>实现。</li>
<li><strong>具体策略（Concrete Strategy）</strong>类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li><strong>环境（Context）</strong>类：<strong>持有一个策略类的引用</strong>，最终给客户端调用。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418225857983.png" alt="image-20210418225857983"></p>
<h4 id="25-3-2、代码实现"><a href="#25-3-2、代码实现" class="headerlink" title="25.3.2、代码实现"></a>25.3.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s = <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略C的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyD</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略D的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> Strategy1 strategy1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-3、应用举例"><a href="#25-3、应用举例" class="headerlink" title="25.3、应用举例"></a>25.3、应用举例</h3><p>编写鸭子项目，具体要求如下:</p>
<ol>
<li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)</li>
<li>显示鸭子的信息</li>
</ol>
<h4 id="25-3-1、使用传统方式解决需求"><a href="#25-3-1、使用传统方式解决需求" class="headerlink" title="25.3.1、使用传统方式解决需求"></a>25.3.1、使用传统方式解决需求</h4><p>传统的设计方案(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230442078.png" alt="image-20210418230442078"></p>
<p>传统的方式实现的问题分析和解决方案：</p>
<ol>
<li>其它鸭子，都继承了 Duck 类，所以 fly 让所有子类都会飞了，这是不正确的</li>
<li>上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应</li>
<li>为了改进 1 问题，我们可以通过覆盖 fly 方法来解决 =&gt; 覆盖解决</li>
<li>问题又来了，如果我们有一个玩具鸭子 ToyDuck, 这样就需要 <strong>ToyDuck</strong> 去覆盖 <strong>Duck</strong> 的所有实现的方法 =&gt; 解决思路 -》 策略模式 (strategy pattern)</li>
</ol>
<h4 id="25-3-2、使用策略模式解决需求"><a href="#25-3-2、使用策略模式解决需求" class="headerlink" title="25.3.2、使用策略模式解决需求"></a>25.3.2、使用策略模式解决需求</h4><p>思路分析(类图)：</p>
<p>策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p>
<p>原则就是： 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230737776.png" alt="image-20210418230737776"></p>
<p>代码实现：</p>
<p>FlyBehavior：飞行。（QuackBehavior：叫行为。等等其它抽象策略与其具体实现类类似）<strong>抽象策略（Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 子类具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoodFlyBehavior：飞行技术高超。（BadFlyBehavior：飞行技术一般、NoFlyBehavior：不会飞行等等类似）<strong>具体策略（Concrete Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 飞翔技术高超 ~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duck：鸭子抽象类。<strong>环境（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//属性, 策略接口</span></span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	<span class="comment">//其它属性&lt;-&gt;策略接口</span></span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子嘎嘎叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//改进</span></span><br><span class="line">		<span class="keyword">if</span>(flyBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">			flyBehavior.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WildDuck：野鸭具体类，继承了鸭子抽象类。（PekingDuck：北京鸭，飞行技术一般、ToyDuck：玩具鸭，不会飞行类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器，传入FlyBehavor 的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 这是野鸭 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WildDuck wildDuck = <span class="keyword">new</span> WildDuck();</span><br><span class="line">		wildDuck.fly();</span><br><span class="line">		ToyDuck toyDuck = <span class="keyword">new</span> ToyDuck();</span><br><span class="line">		toyDuck.fly();</span><br><span class="line">		PekingDuck pekingDuck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">		<span class="comment">//动态改变某个对象的行为, 北京鸭 不能飞</span></span><br><span class="line">		pekingDuck.setFlyBehavior(<span class="keyword">new</span> NoFlyBehavior());</span><br><span class="line">		System.out.println(<span class="string">&quot;北京鸭的实际飞翔能力&quot;</span>);</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-4、策略模式在JDK的应用与源码"><a href="#25-4、策略模式在JDK的应用与源码" class="headerlink" title="25.4、策略模式在JDK的应用与源码"></a>25.4、策略模式在JDK的应用与源码</h3><p>JDK 的 Arrays 的 Comparator 就使用了策略模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001920044.png" alt="image-20210419001920044"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//数组</span></span><br><span class="line">		Integer[] data = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">		<span class="comment">// 实现降序排序，返回-1放左边，1放右边，0保持不变</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span></span><br><span class="line">		<span class="comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了 策略接口 的对象</span></span><br><span class="line">		<span class="comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span></span><br><span class="line">		Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class="line"><span class="comment">		        if (c == null) &#123;</span></span><br><span class="line"><span class="comment">		            sort(a); //默认方法</span></span><br><span class="line"><span class="comment">		        &#125; else &#123; </span></span><br><span class="line"><span class="comment">		            if (LegacyMergeSort.userRequested)</span></span><br><span class="line"><span class="comment">		                legacyMergeSort(a, c); //使用策略对象c</span></span><br><span class="line"><span class="comment">		            else</span></span><br><span class="line"><span class="comment">		            	// 使用策略对象c</span></span><br><span class="line"><span class="comment">		                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">		        &#125;</span></span><br><span class="line"><span class="comment">		    &#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//方式1 </span></span><br><span class="line">		Arrays.sort(data, comparator);</span><br><span class="line">		System.out.println(Arrays.toString(data)); <span class="comment">// 降序排序</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//方式2- 同时lambda 表达式实现 策略模式</span></span><br><span class="line">		Integer[] data2 = &#123; <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">13</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(data2, (var1, var2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(var1.compareTo(var2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		System.out.println(<span class="string">&quot;data2=&quot;</span> + Arrays.toString(data2));	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator<T>：是一个接口，其中有一个compare的核心方法：告诉代码应该怎么去比较两个实例，然后根据比较结果进行排序</T></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419000512228.png" alt="image-20210419000512228"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001129754.png" alt="image-20210419001129754"></p>
<p>Array的sort排序方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001333373.png" alt="image-20210419001333373"></p>
<h3 id="25-5、-策略模式总结"><a href="#25-5、-策略模式总结" class="headerlink" title="25.5、 策略模式总结"></a>25.5、 策略模式总结</h3><p>主要优点如下：</p>
<ol>
<li>多重条件语句不易维护，而<strong>使用策略模式可以避免使用多重条件语句</strong>，如 if…else 语句、switch…case 语句。</li>
<li>策略模式提供了<strong>一系列的可供重用的算法族</strong>，<strong>恰当使用继承可以把算法族的公共代码转移到父类里面</strong>，从而避免重复的代码。</li>
<li>策略模式可以<strong>提供相同行为的不同实现</strong>，<strong>客户可以根据不同时间或空间要求选择不同的实现</strong>。</li>
<li>策略模式提供了<strong>对开闭原则的完美支持</strong>，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把<strong>算法的使用放到环境类</strong>中，而<strong>算法的实现移到具体策略类</strong>中，<strong>实现了二者的分离</strong>。</li>
</ol>
<p>其主要缺点如下：</p>
<ol>
<li>所有策略类都需要对外暴露。<strong>客户端必须理解所有策略算法的区别</strong>，以便适时选择恰当的算法类。</li>
<li>策略模式造成<strong>很多的策略类，增加维护难度</strong>。</li>
</ol>
<p>策略模式的应用场景：</p>
<p>策略模式在很多地方用到，如 <strong>Java SE 中的容器布局管理</strong>就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p>
<ol>
<li><strong>一个系统需要动态地在几种算法中选择一种</strong>时，可将每个算法封装到策略类中。</li>
<li>一个类定义了<strong>多种行为</strong>，并且<strong>这些行为在这个类的操作中以多个条件语句的形式出现</strong>，可<strong>将每个条件分支移入它们各自的策略类中以代替这些条件语句</strong>。</li>
<li>系统中<strong>各算法彼此完全独立</strong>，且<strong>要求对客户隐藏具体算法的实现细节</strong>时。</li>
<li>系统要求<strong>使用算法的客户不应该知道其操作的数据</strong>时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li><strong>多个类只区别在表现行为不同</strong>，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ol>
<h3 id="25-6、策略模式扩展（策略模式-工厂模式）"><a href="#25-6、策略模式扩展（策略模式-工厂模式）" class="headerlink" title="25.6、策略模式扩展（策略模式+工厂模式）"></a>25.6、策略模式扩展（策略模式+工厂模式）</h3><p>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果<strong>在环境类中使用策略工厂模式来管理这些策略类</strong>将大大减少客户端的工作复杂度，其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418232858259.png" alt="image-20210418232858259"></p>
<h3 id="25-7、进阶阅读"><a href="#25-7、进阶阅读" class="headerlink" title="25.7、进阶阅读"></a>25.7、进阶阅读</h3><p>如果您想深入了解策略模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8481.html">《使用策略模式实现电商多种促销优惠方案选择》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8482.html">《使用策略模式实现支付方式选择场景》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8483.html">《策略模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8484.html">《策略模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="25-8、相关设计模式"><a href="#25-8、相关设计模式" class="headerlink" title="25.8、相关设计模式"></a>25.8、相关设计模式</h3><ul>
<li><p>Flyweight模式</p>
<p>有时会使用Flyweight模式让多个地方可以共用ConcreteStrategy角色。</p>
</li>
<li><p>Abstract Factory模式</p>
<p>使用Strategy模式可以整体地替换算法。</p>
<p>使用Abstract Factory模式则可以整体地替换具体工厂、零件和产品。</p>
</li>
<li><p>State 模式</p>
<p>使用Strategy模式和State模式都可以替换被委托对象，而且它们的类之间的关系也很相似。但是两种模式的目的不同。</p>
<p>在Strategy模式中，ConcreteStrategy 角色是表示算法的类。在Strategy模式中，可以替换被委托对象的类。当然如果没有必要，也可以不替换。</p>
<p>而在State模式中，ConcreteState角色是表示“状态”的类。在State模式中，每次状态变化时，被委托对象的类都必定会被替换。</p>
</li>
</ul>
<h3 id="25-9、策略模式的注意事项与细节"><a href="#25-9、策略模式的注意事项与细节" class="headerlink" title="25.9、策略模式的注意事项与细节"></a>25.9、策略模式的注意事项与细节</h3><ol>
<li>策略模式的关键是：<strong>分析项目中变化部分与不变部分</strong></li>
<li>策略模式的核心思想是：<strong>多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</strong></li>
<li><strong>体现了“对修改关闭，对扩展开放”原则</strong>，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，<strong>避免了使用多重转移语句（if..else if..else）</strong></li>
<li>提供了可以<strong>替换继承关系</strong>的办法： 策略模式将算法封装在独立的 Strategy 类中使得你可以独立于其 Context 改变它，使它易于切换、易于理解、易于扩展</li>
<li>需要注意的是：每添加一个策略就要增加一个类，当<strong>策略过多是会导致类数目庞大</strong></li>
<li>如果一个系统的策略多于四个，就需要考虑<strong>使用混合模式（策略模式+工厂模式）</strong>，解决策略类膨胀的问题。</li>
</ol>
<h2 id="26、职责链模式Chain-of-Responsibility（行为型模式）"><a href="#26、职责链模式Chain-of-Responsibility（行为型模式）" class="headerlink" title="26、职责链模式Chain of Responsibility（行为型模式）"></a>26、职责链模式Chain of Responsibility（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419002157100.png" alt="image-20210419002157100"></p>
<h3 id="26-1、基本介绍"><a href="#26-1、基本介绍" class="headerlink" title="26.1、基本介绍"></a>26.1、基本介绍</h3><ol>
<li>职责链模式（Chain of Responsibility Pattern）, 又叫<strong>责任链模式</strong>，为<strong>请求创建了一个接收者对象的链</strong>。这种模式对<strong>请求的发送者和接收者进行解耦</strong>。</li>
<li>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</li>
<li>职责链模式通常<strong>每个接收者都包含对另一个接收者的引用（形成闭环）</strong>。如果<strong>一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</li>
<li>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong></li>
</ol>
<h3 id="26-2、职责链模式的原理结构图-uml类图"><a href="#26-2、职责链模式的原理结构图-uml类图" class="headerlink" title="26.2、职责链模式的原理结构图-uml类图"></a>26.2、职责链模式的原理结构图-uml类图</h3><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p>
<h4 id="26-2-1、模式的结构"><a href="#26-2-1、模式的结构" class="headerlink" title="26.2.1、模式的结构"></a>26.2.1、模式的结构</h4><p>职责链模式主要包含以下角色：</p>
<ol>
<li><strong>抽象处理者（Handler）</strong>角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接Handler对象。</li>
<li><strong>具体处理者（Concrete Handler）</strong>角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。从而形成一个职责链。</li>
<li><strong>请求类（Request）</strong>角色 ， 含义很多属性，表示一个请求</li>
<li><strong>客户类（Client）</strong>角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419020914621.png" alt="image-20210419020914621"></p>
<p>客户端可按下图所示设置责任链：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419021241297.png" alt="image-20210419021241297"></p>
<h4 id="26-2-2、代码实现"><a href="#26-2-2、代码实现" class="headerlink" title="26.2.2、代码实现"></a>26.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们把消息硬编码为 String 类型，而在真实业务中，消息是具备多样性的，可以是 int、String 或者自定义类型。因此，在上面代码的基础上，可以<strong>对消息类型进行抽象 Request，增强了消息的兼容性</strong>。</p>
<h3 id="26-3、应用举例"><a href="#26-3、应用举例" class="headerlink" title="26.3、应用举例"></a>26.3、应用举例</h3><p>学校 OA 系统的采购审批项目：需求是</p>
<p>采购员采购教学器材</p>
<ol>
<li>如果金额 小于等于 5000, 由教学主任审批 （0&lt;=x&lt;=5000）</li>
<li>如果金额 小于等于 10000, 由院长审批 (5000&lt;x&lt;=10000)</li>
<li>如果金额 小于等于 30000, 由副校长审批 (10000&lt;x&lt;=30000)</li>
<li>如果金额 超过 30000 以上，有校长审批 ( 30000&lt;x)</li>
</ol>
<p>请设计程序完成采购审批项目</p>
<h4 id="26-3-1、使用传统方法解决需求"><a href="#26-3-1、使用传统方法解决需求" class="headerlink" title="26.3.1、使用传统方法解决需求"></a>26.3.1、使用传统方法解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022414374.png" alt="image-20210419022414374"></p>
<p>传统方案解决 OA 系统审批问题分析：</p>
<p>传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver (审批人)完成审批。</p>
<p>传统方式的问题分析 : </p>
<ol>
<li>客户端这里会<strong>使用到分支判断(比如 switch) 来对不同的采购请求处理</strong>， 这样就存在如下问题：<ol>
<li> 如果各个级别的人员审批金额发生变化，在客户端的也需要变化</li>
<li>客户端必须明确的知道 有多少个审批级别和访问</li>
</ol>
</li>
<li>这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代码的扩展和维护</li>
<li>解决方案 =》 职责链模式</li>
</ol>
<h4 id="26-3-2、使用职责链模式解决需求"><a href="#26-3-2、使用职责链模式解决需求" class="headerlink" title="26.3.2、使用职责链模式解决需求"></a>26.3.2、使用职责链模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022837598.png" alt="image-20210419022837598"></p>
<p>代码实现：</p>
<p>PurchaseRequest：采购请求。<strong>请求类（Request）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Approver：<strong>抽象处理者（Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	Approver approver;  <span class="comment">//下一个处理者</span></span><br><span class="line">	String name; <span class="comment">// 名字	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下一个处理者</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver approver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.approver = approver;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DepartmentApprover：教学主任处理类。（其中CollegeApprover：院长处理类（5000&lt;x&lt;=10000）、ViceSchoolMasterApprover：副校长处理类（10000&lt;x&lt;=30000）、SchoolMasterApprover：院长处理类（30000&lt;x）类似）<strong>具体处理者（Concrete Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：<strong>客户类（Client）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个请求</span></span><br><span class="line">		PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">31000</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//创建相关的审批人</span></span><br><span class="line">		DepartmentApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">&quot;张主任&quot;</span>);</span><br><span class="line">		CollegeApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">&quot;李院长&quot;</span>);</span><br><span class="line">		ViceSchoolMasterApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">&quot;王副校&quot;</span>);</span><br><span class="line">		SchoolMasterApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">&quot;佟校长&quot;</span>);</span><br><span class="line">		<span class="comment">//需要将各个审批级别的下一个设置好 (处理人构成环形: )</span></span><br><span class="line">		departmentApprover.setApprover(collegeApprover);</span><br><span class="line">		collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">		viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">		schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line">		</span><br><span class="line">		departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">		viceSchoolMasterApprover.processRequest(purchaseRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-4、职责链模式在SpringMVC框架的应用与源码"><a href="#26-4、职责链模式在SpringMVC框架的应用与源码" class="headerlink" title="26.4、职责链模式在SpringMVC框架的应用与源码"></a>26.4、职责链模式在SpringMVC框架的应用与源码</h3><p>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</p>
<p>SpringMVC 请求流程简图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419011833309.png" alt="image-20210419011833309"></p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012005876.png" alt="image-20210419012005876"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExecutionChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponsibilityChain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// DispatcherServlet 	</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 *  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></span><br><span class="line"><span class="comment">		 *   HandlerExecutionChain mappedHandler = null; </span></span><br><span class="line"><span class="comment">		 *   mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象</span></span><br><span class="line"><span class="comment">		 *    //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor</span></span><br><span class="line"><span class="comment">		 *    //调用了拦截器的  interceptor.preHandle</span></span><br><span class="line"><span class="comment">		 *   if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></span><br><span class="line"><span class="comment">					return;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">			  //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用 </span></span><br><span class="line"><span class="comment">			  //拦截器的  interceptor.postHandle(request, response, this.handler, mv);</span></span><br><span class="line"><span class="comment">			 mappedHandler.applyPostHandle(processedRequest, response, mv);</span></span><br><span class="line"><span class="comment">		 *  &#125;</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  //说明：在  mappedHandler.applyPreHandle内部中，</span></span><br><span class="line"><span class="comment">		 *  还调用了  triggerAfterCompletion 方法，该方法中调用了  </span></span><br><span class="line"><span class="comment">		 *  HandlerInterceptor interceptor = getInterceptors()[i];</span></span><br><span class="line"><span class="comment">			try &#123;</span></span><br><span class="line"><span class="comment">				interceptor.afterCompletion(request, response, this.handler, ex);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			catch (Throwable ex2) &#123;</span></span><br><span class="line"><span class="comment">				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC中的最重要的DispatcherServlet类，当中有一个核心方法：doDispatcher方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012029050.png" alt="image-20210419012029050"></p>
<p>在doDispatcher方法中一开始就获取了HandlerExecutionChain对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012220314.png" alt="image-20210419012220314"></p>
<p>调用preHandle方法：</p>
<p>在得到HandlerExecutionChain对象后调用了其applyPreHandle()方法，在其内部得到了HandlerInterceptor interceptor拦截器并调用了拦截器的interceptor.preHandle方法。调用成功就返回。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012326046.png" alt="image-20210419012326046"></p>
<p>在applyPreHandle()中通过getInterceptors( ) [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的preHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012558289.png" alt="image-20210419012558289"></p>
<p>调用postHandle方法：</p>
<p>在doDispatcher方法的applyPreHandle()下面：HandlerExecutionChain对象还调用了其applyPostHandle()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210419013424983.png" alt="image-20210419013424983"></p>
<p>在applyPostHandle()中通过getInterceptors() [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的postHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419013555142.png" alt="image-20210419013555142"></p>
<p>调用afterCompletion方法：</p>
<p>triggerAfterCompletion方法中得到了拦截器HandlerInterceptor并调用了拦截器的interceptor.afterCompletion方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014131628.png" alt="image-20210419014131628"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014819146.png" alt="image-20210419014819146"></p>
<p>对源码总结</p>
<ol>
<li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等</li>
<li>在处理 SpringMvc 请求时，使用到职责链模式还使用到适配器模式</li>
<li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li>
<li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器.</li>
</ol>
<h3 id="26-5、职责链模式总结"><a href="#26-5、职责链模式总结" class="headerlink" title="26.5、职责链模式总结"></a>26.5、职责链模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了对象之间的耦合度</strong>。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li><strong>增强了系统的可扩展性</strong>。可以根据需要增加新的请求处理类，<strong>满足开闭原则</strong>。</li>
<li><strong>增强了给对象指派职责的灵活性</strong>。当工作流程发生变化，可以<strong>动态地改变链内的成员或者调动它们的次序</strong>，也可<strong>动态地新增或者删除责任</strong>。</li>
<li><strong>责任链简化了对象之间的连接</strong>。<strong>每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用</strong>，这<strong>避免了使用众多的 if 或者 if···else 语句</strong>。</li>
<li><strong>责任分担</strong>。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，<strong>符合类的单一职责原则</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>不能保证每个请求一定被处理</strong>。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，<strong>该请求可能一直传到链的末端都得不到处理</strong>。所以最好形成闭环调用，保证请求一定可以得到调用。</li>
<li>对比较长的职责链，<strong>请求的处理可能涉及多个处理对象</strong>，<strong>系统性能将受到一定影响</strong>。</li>
<li>职责链建立的合理性<strong>要靠客户端来保证，增加了客户端的复杂性</strong>，可能会由于职责链的<strong>错误设置而导致系统出错</strong>，如可能会造成<strong>循环调用</strong>。</li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li><strong>多个对象可以处理一个请求</strong>，但具体由哪个对象处理该请求在运行时自动确定。</li>
<li>可<strong>动态指定一组对象处理请求</strong>，或<strong>添加新的处理者</strong>。</li>
<li>需要<strong>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>JS 中的事件冒泡。</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理</li>
<li>Struts2 的拦截器</li>
<li>jsp servlet 的 Filter</li>
<li>责任链模式经常用在拦截、预处理请求等。</li>
</ol>
<h3 id="26-6、职责链模式扩展"><a href="#26-6、职责链模式扩展" class="headerlink" title="26.6、职责链模式扩展"></a>26.6、职责链模式扩展</h3><p>职责链模式存在以下两种情况：</p>
<ol>
<li><strong>纯的职责链模式</strong>：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li><strong>不纯的职责链模式</strong>：允许出现某一个具体处理者对象<strong>在承担了请求的一部分责任后又将剩余的责任传给下家</strong>的情况，且<strong>一个请求可以最终不被任何接收端对象所接收</strong>。</li>
</ol>
<h3 id="26-7、进阶阅读"><a href="#26-7、进阶阅读" class="headerlink" title="26.7、进阶阅读"></a>26.7、进阶阅读</h3><p>如果您想深入了解责任链模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8487.html">《使用责任链模式实现热插拔权限控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8488.html">《责任链模式和建造者模式结合使用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8489.html">《责任链模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="26-8、相关设计模式"><a href="#26-8、相关设计模式" class="headerlink" title="26.8、相关设计模式"></a>26.8、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>Handler角色经常会使用Composite模式。</p>
</li>
<li><p>Command模式</p>
<p>有时会使用Command模式向Handler角色发送请求。</p>
</li>
</ul>
<h3 id="26-9、职责链模式的注意事项与细节"><a href="#26-9、职责链模式的注意事项与细节" class="headerlink" title="26.9、职责链模式的注意事项与细节"></a>26.9、职责链模式的注意事项与细节</h3><ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此<strong>需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量</strong>，<strong>在 setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</strong></li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web 中 Tomcat对 Encoding 的处理、拦截器</li>
</ol>
<h2 id="27、创建型模式的特点和分类"><a href="#27、创建型模式的特点和分类" class="headerlink" title="27、创建型模式的特点和分类"></a>27、创建型模式的特点和分类</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象</strong>？”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种：</p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式</p>
<h2 id="28、结构型模式概述（结构型模式的分类）"><a href="#28、结构型模式概述（结构型模式的分类）" class="headerlink" title="28、结构型模式概述（结构型模式的分类）"></a>28、结构型模式概述（结构型模式的分类）</h2><p>结构型模式描述<strong>如何将类或对象按某种布局组成更大的结构</strong>。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，<strong>前者采用继承机制来组织接口和类</strong>，<strong>后者釆用组合或聚合来组合对象</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性</strong>。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<strong>适配器模式分为类结构型模式和对象结构型模式两种</strong>，<strong>其他的全部属于对象结构型模式</strong>。</p>
<h2 id="29、行为型模式概述（行为型模式的分类）"><a href="#29、行为型模式概述（行为型模式的分类）" class="headerlink" title="29、行为型模式概述（行为型模式的分类）"></a>29、行为型模式概述（行为型模式的分类）</h2><p>行为型模式用于<strong>描述程序在运行时复杂的流程控制</strong>，即<strong>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。</p>
<p><strong>行为型模式分为类行为模式和对象行为模式</strong>，<strong>前者采用继承机制来在类间分派行为</strong>，<strong>后者采用组合或聚合在对象间分配行为</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</strong></p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了<strong>模板方法模式和解释器模式是类行为型模式</strong>，<strong>其他的全部属于对象行为型模式</strong>。</p>
<h2 id="30、一句话归纳设计模式"><a href="#30、一句话归纳设计模式" class="headerlink" title="30、一句话归纳设计模式"></a>30、一句话归纳设计模式</h2><table>
<thead>
<tr>
<th>分类</th>
<th>设计模式</th>
<th>简述</th>
<th>一句话归纳</th>
<th>目的</th>
<th>生活案例</th>
</tr>
</thead>
<tbody><tr>
<td>创建型设计模式 （简单来说就是用来创建对象的）</td>
<td>工厂模式（Factory Pattern）</td>
<td>不同条件下创建不同实例</td>
<td>产品标准化，生产更高效</td>
<td>封装创建细节</td>
<td>实体工厂</td>
</tr>
<tr>
<td>单例模式（Singleton Pattern）</td>
<td>保证一个类仅有一个实例，并且提供一个全局访问点</td>
<td>世上只有一个我</td>
<td>保证独一无二</td>
<td>CEO</td>
<td></td>
</tr>
<tr>
<td>原型模式（Prototype Pattern）</td>
<td>通过拷贝原型创建新的对象</td>
<td>拔一根猴毛，吹出千万个</td>
<td>高效创建对象</td>
<td>克隆</td>
<td></td>
</tr>
<tr>
<td>建造者模式（Builder Pattern）</td>
<td>用来创建复杂的复合对象</td>
<td>高配中配和低配，想选哪配就哪配</td>
<td>开放个性配置步骤</td>
<td>选配</td>
<td></td>
</tr>
<tr>
<td>结构型设计模式 （关注类和对象的组合）</td>
<td>代理模式（Proxy Pattern）</td>
<td>为其他对象提供一种代理以控制对这个对象的访问</td>
<td>没有资源没时间，得找别人来帮忙</td>
<td>增强职责</td>
<td>媒婆</td>
</tr>
<tr>
<td>外观模式（Facade Pattern）</td>
<td>对外提供一个统一的接口用来访问子系统</td>
<td>打开一扇门，通向全世界</td>
<td>统一访问入口</td>
<td>前台</td>
<td></td>
</tr>
<tr>
<td>装饰器模式（Decorator Pattern）</td>
<td>为对象添加新功能</td>
<td>他大舅他二舅都是他舅</td>
<td>灵活扩展、同宗同源</td>
<td>煎饼</td>
<td></td>
</tr>
<tr>
<td>享元模式（Flyweight Pattern）</td>
<td>使用对象池来减少重复对象的创建</td>
<td>优化资源配置，减少重复浪费</td>
<td>共享资源池</td>
<td>全国社保联网</td>
<td></td>
</tr>
<tr>
<td>组合模式（Composite Pattern）</td>
<td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td>
<td>人在一起叫团伙，心在一起叫团队</td>
<td>统一整体和个体</td>
<td>组织架构树</td>
<td></td>
</tr>
<tr>
<td>适配器模式（Adapter Pattern）</td>
<td>将原来不兼容的两个类融合在一起</td>
<td>万能充电器</td>
<td>兼容转换</td>
<td>电源适配</td>
<td></td>
</tr>
<tr>
<td>桥接模式（Bridge Pattern）</td>
<td>将两个能够独立变化的部分分离开来</td>
<td>约定优于配置</td>
<td>不允许用继承</td>
<td>桥</td>
<td></td>
</tr>
<tr>
<td>行为型设计模式 （关注对象之间的通信）</td>
<td>模板模式（Template Pattern）</td>
<td>定义一套流程模板，根据需要实现模板中的操作</td>
<td>流程全部标准化，需要微调请覆盖</td>
<td>逻辑复用</td>
<td>把大象装进冰箱</td>
</tr>
<tr>
<td>策略模式（Strategy Pattern）</td>
<td>封装不同的算法，算法之间能互相替换</td>
<td>条条大道通罗马，具体哪条你来定</td>
<td>把选择权交给用户</td>
<td>选择支付方式</td>
<td></td>
</tr>
<tr>
<td>责任链模式（Chain of Responsibility Pattern）</td>
<td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td>
<td>各人自扫门前雪，莫管他们瓦上霜</td>
<td>解耦处理逻辑</td>
<td>踢皮球</td>
<td></td>
</tr>
<tr>
<td>迭代器模式（Iterator Pattern）</td>
<td>提供一种方法顺序访问一个聚合对象中的各个元素</td>
<td>流水线上坐一天，每个包裹扫一遍</td>
<td>统一对集合的访问方式</td>
<td>逐个检票进站</td>
<td></td>
</tr>
<tr>
<td>命令模式（Command Pattern）</td>
<td>将请求封装成命令，并记录下来，能够撤销与重做</td>
<td>运筹帷幄之中，决胜千里之外</td>
<td>解耦请求和处理</td>
<td>遥控器</td>
<td></td>
</tr>
<tr>
<td>状态模式（State Pattern）</td>
<td>根据不同的状态做出不同的行为</td>
<td>状态驱动行为，行为决定状态</td>
<td>绑定状态和行为</td>
<td>订单状态跟踪</td>
<td></td>
</tr>
<tr>
<td>备忘录模式（Memento Pattern）</td>
<td>保存对象的状态，在需要时进行恢复</td>
<td>失足不成千古恨，想重来时就重来</td>
<td>备份、后悔机制</td>
<td>草稿箱</td>
<td></td>
</tr>
<tr>
<td>中介者模式（Mediator Pattern）</td>
<td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td>
<td>联系方式我给你，怎么搞定我不管</td>
<td>统一管理网状资源</td>
<td>朋友圈</td>
<td></td>
</tr>
<tr>
<td>解释器模式（Interpreter Pattern）</td>
<td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td>
<td>我想说”方言“，一切解释权都归我</td>
<td>实现特定语法解析</td>
<td>摩斯密码</td>
<td></td>
</tr>
<tr>
<td>观察者模式（Observer Pattern）</td>
<td>状态发生改变时通知观察者，一对多的关系</td>
<td>到点就通知我</td>
<td>解耦观察者与被观察者</td>
<td>闹钟</td>
<td></td>
</tr>
<tr>
<td>访问者模式（Visitor Pattern）</td>
<td>稳定数据结构，定义新的操作行为</td>
<td>横看成岭侧成峰，远近高低各不同</td>
<td>解耦数据结构和数据操作</td>
<td>KPI考核</td>
<td></td>
</tr>
<tr>
<td></td>
<td>委派模式（Delegate Pattern）</td>
<td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td>
<td>这个需求很简单，怎么实现我不管</td>
<td>只对结果负责</td>
<td>授权委托书</td>
</tr>
</tbody></table>
<h2 id="31、其他设计模式（不属于23种）"><a href="#31、其他设计模式（不属于23种）" class="headerlink" title="31、其他设计模式（不属于23种）"></a>31、其他设计模式（不属于23种）</h2><ol>
<li><p>MVC 模式：Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><p><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</p>
</li>
<li><p><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</p>
</li>
<li><p><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419025540539.png" alt="image-20210419025540539"></p>
</li>
</ul>
</li>
<li><p>业务代表模式（Business Delegate Pattern）：用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体：</p>
<ul>
<li><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。</li>
<li><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li>
<li><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li>
<li><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。</li>
</ul>
</li>
<li><p>组合实体模式（Composite Entity Pattern）：用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者：</p>
<ul>
<li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li>
<li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li>
<li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li>
<li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。</li>
</ul>
</li>
<li><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式：用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者：</p>
<ul>
<li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li>
<li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li>
<li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。</li>
</ul>
</li>
<li><p>前端控制器模式（Front Controller Pattern）：是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li>
<li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li>
<li><strong>视图（View）</strong> - 视图是为请求而创建的对象。</li>
</ul>
</li>
<li><p>拦截过滤器模式（Intercepting Filter Pattern）：用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li>
<li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li>
<li><strong>Target</strong> - Target 对象是请求处理程序。</li>
<li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li>
<li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。</li>
</ul>
</li>
<li><p>服务定位器模式（Service Locator Pattern）：用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体：</p>
<ul>
<li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li>
<li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li>
<li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li>
<li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li>
<li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。</li>
</ul>
</li>
<li><p>传输对象模式（Transfer Object Pattern）：用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体：</p>
<ul>
<li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li>
<li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li>
<li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。</li>
</ul>
</li>
<li><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p>
<p>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
</li>
</ol>
<h2 id="32、设计模式相关的网站"><a href="#32、设计模式相关的网站" class="headerlink" title="32、设计模式相关的网站"></a>32、设计模式相关的网站</h2><ul>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science)">Wiki Page for Design Patterns</a> - 以一种非常通用的方式检查设计模式。</li>
<li><a target="_blank" rel="noopener" href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns">Java Programming/Design Patterns</a> - 一篇关于设计模式的好文章。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/docs/books/tutorial/index.html">The JavaTM Tutorials</a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.4.2/docs/index.html">JavaTM 2 SDK, Standard Edition </a>- JavaTM 2 SDK, Standard Edition 的官网。</li>
</ul>
<h2 id="0、延伸"><a href="#0、延伸" class="headerlink" title="0、延伸"></a>0、延伸</h2><h3 id="1、各种生成实例的方法的介绍"><a href="#1、各种生成实例的方法的介绍" class="headerlink" title="1、各种生成实例的方法的介绍"></a>1、各种生成实例的方法的介绍</h3><p>在Java中可以使用下面这些方法生成实例。</p>
<h4 id="1、new"><a href="#1、new" class="headerlink" title="1、new"></a>1、new</h4><p>一般我们使用Java关键字new生成实例。</p>
<p>可以像下面这样生成Something类的实例并将其保存在obj变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something obj = <span class="keyword">new</span> Something(); </span><br></pre></td></tr></table></figure>

<p>这时， 类名（此处的Something)会出现在代码中 。（即形成强耦合关系）</p>
<h4 id="2、clone"><a href="#2、clone" class="headerlink" title="2、clone"></a>2、clone</h4><p>我们也可以使用在Prototype模式中学习过的clone方法， 根据现有 的实例复制出一个新的实例。</p>
<p>我们可以像下面这样根据自身来复制出新的实例（不过不会调用构造函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123; </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Something <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Something obj = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            obj = (Something) clone(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、new-Instance"><a href="#3、new-Instance" class="headerlink" title="3、new Instance"></a>3、new Instance</h4><p>使用java.lang.Class类的newinstance方法可以通过Class类的实例生成出Class类所表示的类0的实例（会调用无参构造函数）。</p>
<p>下面我们再看一个例子。 假设我们现在已经有了Something类的实例someobj， 通过下面的表达式可以生成另外一个 Something类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someobj.getClass().newinstance() </span><br></pre></td></tr></table></figure>

<p>实际上， 调用newinstance方法可能会导致抛出InstantiationException异常或是 illegalAccessException异常， 因此需要将其置千try…catch语句块中或是用throws关键字指定调用newinstance方法的方法可能会抛出的异常。</p>
<h3 id="2、类名是束缚吗"><a href="#2、类名是束缚吗" class="headerlink" title="2、类名是束缚吗"></a>2、类名是束缚吗</h3><p>话说回来， 在源程序中使用类名到底会有什么问题呢？在代码中出现要使用的类的名字不是理 所当然的吗？</p>
<p>这里， 让我们再回忆一下面向对象编程的目标之一，即“作为组件复用” 。</p>
<p>在代码中出现要使用的类的名字并非总是坏事。 不过 ，<strong>—旦在代码中出现要使用的类的名字， 就无法与该类分离开来， 也就无法实现复用</strong>。</p>
<p>当然 ， 可以通过替换源代码或是改变类名来解决这个问题。 但是， 此处说的“作为组件复用”中不包含替换源代码。 以Java来说， 重要的是当手边只有class文件(.class)时， 该类能否被复用。 <strong>即使没有Java文件(.java)也能复用该类才是关键。</strong></p>
<p>当多个类必须紧密结合时， 代码中出现这些类的名字是没有问题的。但是如果那些需要被独立 出来作为组件复用的类的名字出现在代码中， 那就有问题了。</p>
<h3 id="3、类的层次与抽象类"><a href="#3、类的层次与抽象类" class="headerlink" title="3、类的层次与抽象类"></a>3、类的层次与抽象类</h3><p>父类对子类的要求：</p>
<p>我们在理解类的层次时 ， 通常是站在子类的角度进行思考的。也就是说 ， 很容易着眼千以 下几点：</p>
<ul>
<li>在子类中可以使用父类中定义的方法</li>
<li>可以通过在子类中增加方法以实现新的功能</li>
<li>在子类中重写父类的方法可以改变程序的行为</li>
</ul>
<p>现在 ， 让我们稍微改变一下立场 ， 站在父类的角度进行思考。在父类中， 我们声明了抽象方法、而将该方法的实现交给了子类。换言之 ， 就程序而言，声明抽象方法是希望达到以下目的：</p>
<ul>
<li>期待子类去实现抽象方法</li>
<li>要求子类去实现抽象方法</li>
</ul>
<p>也就是说 ，子类具有实现在父类中所声明的抽象方法的责任。因此，这种责任被称为 “子类责任”(subclass responsibility）。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟驿站-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">廖雪峰-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64b7b86a3ee">面向对象的七大设计原则</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">设计模式之七大基本原则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before规则相关</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/18369201">详解Java中的clone方法 – 原型模式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/12952063">java提高篇（五）—–使用序列化实现对象的拷贝</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149775781">动态代理的几种实现方式及优缺点</a></p>
<p>有关于Copy-on-write代理：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>相关书籍：</p>
<p>《图解设计模式》</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">http://xgh-user.github.io/2021/04/19/设计模式/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/19/JVM/" rel="prev" title="JVM">
      <i class="fa fa-chevron-left"></i> JVM
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/19/VUE/" rel="next" title="Vue">
      Vue <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">23种设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%BC%95%E5%AD%90"><span class="nav-number">1.1.</span> <span class="nav-text">1、引子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%87%87%E7%94%A8%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、设计模式采用的七大原则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、设计模式的重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%B2%E8%A7%A3%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、设计模式的讲解过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%88%E5%8D%95%E6%8E%A5%E4%BE%9D%E9%87%8C%E5%BC%80%E8%BF%AA%E5%90%88%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">2、设计模式七大原则（单接依里开迪合）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1、设计模式的目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 、设计模式七大原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-Single-Responsibility-Principle"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3、单一职责原则(Single Responsibility Principle)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2.3.3、单一职责原则注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-Interface-Segregation-Principle"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 、接口隔离原则(Interface Segregation Principle)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3%E3%80%81%E5%BA%94%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3、应传统方法的问题和使用接口隔离原则改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">2.4.4、接口隔离原则注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99-Dependence-Inversion-Principle"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 、依赖倒转原则(Dependence Inversion Principle)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.5.1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2.5.2、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3%E3%80%81-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">2.5.3、 依赖关系传递的三种方式和应用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-1%E3%80%81%E6%8E%A5%E5%8F%A3%E4%BC%A0%E9%80%92"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">2.5.3.1、接口传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-2%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92"><span class="nav-number">1.2.5.3.2.</span> <span class="nav-text">2.5.3.2、构造方法传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-3%E3%80%81setter-%E6%96%B9%E5%BC%8F%E4%BC%A0%E9%80%92"><span class="nav-number">1.2.5.3.3.</span> <span class="nav-text">2.5.3.3、setter 方式传递</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-4%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">2.5.4、依赖倒转原则的注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-Liskov-Substitution-Principle"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6、里氏替换原则(Liskov Substitution Principle)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1%E3%80%81OO-%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1、OO 中的继承性的思考和说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2%E3%80%81-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2.6.2、 基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3%E3%80%81-%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E6%80%9D%E8%80%83"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">2.6.3、 一个程序引出的问题和思考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">2.6.4、解决方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7%E3%80%81%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-Principle%EF%BC%89"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7、开闭原则（Open Closed Principle）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">2.7.1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2%E3%80%81%E7%9C%8B%E4%B8%8B%E9%9D%A2%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2.7.2、看下面一段代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3%E3%80%81%E6%96%B9%E5%BC%8F-1-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">2.7.3、方式 1 的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-4%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">2.7.4、改进的思路分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-5%E3%80%81%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">2.7.5、开闭原则注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8%E3%80%81%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-Demeter-Principle"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8、迪米特法则(Demeter Principle)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">2.8.1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">2.8.2、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">2.8.3、应用实例改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-4%E3%80%81%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.8.4.</span> <span class="nav-text">2.8.4、迪米特法则注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9%E3%80%81%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88Composite-Reuse-Principle%EF%BC%89"><span class="nav-number">1.2.9.</span> <span class="nav-text">2.9、合成复用原则（Composite Reuse Principle）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">2.9.1、基本介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.10.</span> <span class="nav-text">2.10、设计原则核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.11.</span> <span class="nav-text">2.11、设计七大原则总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81UML-%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.3.</span> <span class="nav-text">3、UML 类图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81UML-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1、UML 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81UML-%E5%9B%BE"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2、UML 图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81UML-%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3、UML 类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%88Dependence%EF%BC%89"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4、类图—依赖关系（Dependence）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization%EF%BC%89"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5、类图—泛化关系(generalization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%EF%BC%88Implementation%EF%BC%89"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6、类图—实现关系（Implementation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%EF%BC%88Association%EF%BC%89"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7、类图—关联关系（Association）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%88Aggregation%EF%BC%89"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8、类图—聚合关系（Aggregation）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">3.8.1、基本介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9%E3%80%81%E7%B1%BB%E5%9B%BE%E2%80%94%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%88Composition%EF%BC%89"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.9、类图—组合关系（Composition）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">3.9.1、基本介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.</span> <span class="nav-text">4、设计模式概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1、设计模式介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2、设计模式类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FSingleton%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">5、单例设计模式Singleton（创建型设计模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1、单例设计模式介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2、单例设计模式八种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E4%B8%A4%E7%A7%8D%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3、饿汉式（两种）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">5.3.1、饿汉式（静态常量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">5.3.2、饿汉式（静态代码块）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4、懒汉式（三种）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">5.4.1、懒汉式(线程不安全)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">5.4.2、懒汉式(线程安全，同步方法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">5.4.3、懒汉式(同步代码块)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5%E3%80%81%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5、双重检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6、静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.5.7.</span> <span class="nav-text">5.7、枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8-JDK-%E5%BA%94%E7%94%A8%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.5.8.</span> <span class="nav-text">5.8、单例模式在 JDK 应用的源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.9.</span> <span class="nav-text">5.9、单例模式总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-1%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.9.1.</span> <span class="nav-text">5.9.1、单例模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-2%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.9.2.</span> <span class="nav-text">5.9.2、单例模式的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-3%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.9.3.</span> <span class="nav-text">5.9.3、单例模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-4%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.9.4.</span> <span class="nav-text">5.9.4、相关的设计模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-5%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="nav-number">1.5.9.5.</span> <span class="nav-text">5.9.5、单例模式注意事项和细节说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-6%E3%80%81%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.5.9.6.</span> <span class="nav-text">5.9.6、反射与反序列化破坏单例模式的方法及解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-9-6-1%E3%80%81%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.9.6.1.</span> <span class="nav-text">5.9.6.1、反射破坏单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-9-6-2%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.9.6.2.</span> <span class="nav-text">5.9.6.2、反序列化破坏单例模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-9-7%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.5.9.7.</span> <span class="nav-text">5.9.7、单例模式的扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">6、工厂模式（创建型设计模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FSimpleFactory"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1、简单工厂模式SimpleFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">6.1.1、简单工厂模式介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">6.1.2、模式的结构与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">6.1.3、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">6.1.4、简单工厂模式（静态工厂模式）的相关说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FFactory-Method"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2、工厂方法模式Factory Method</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">6.2.1、工厂方法模式介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">6.2.2、模式的结构与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-2-1-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">6.2.2.1. 模式的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.2.2.2.</span> <span class="nav-text">6.2.2.2、模式的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">6.2.3、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">6.2.4、工厂方法模式的相关说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%99%BB%E5%9C%BA%E8%A7%92%E8%89%B2%E8%A1%A5%E5%85%85%EF%BC%88%E6%9D%A5%E8%87%AA%E3%80%8A%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%EF%BC%89"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.2.6、相关的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FAbstract-Factory"><span class="nav-number">1.6.5.</span> <span class="nav-text">6.3、抽象工厂模式Abstract Factory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">6.3.1、抽象工厂模式介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">6.3.2、模式的结构与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.5.2.1.</span> <span class="nav-text">6.3.2.1、模式的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9B%BE%EF%BC%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="nav-number">1.6.5.2.2.</span> <span class="nav-text">6.3.2.2、模式的实现类图（具体代码）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">6.3.3、应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.5.4.</span> <span class="nav-text">6.3.4、抽象工厂模式的相关说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-5%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.5.5.</span> <span class="nav-text">6.3.5、相关的设计模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9C%A8-JDK-Calendar-%E5%BA%94%E7%94%A8%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.6.6.</span> <span class="nav-text">6.4、工厂模式在 JDK-Calendar 应用的源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.7.</span> <span class="nav-text">6.5、工厂模式小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FProtoType%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">7、原型模式ProtoType（创建型设计模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml-%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2、原型模式原理结构图-uml 类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1%E3%80%81%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%85%8B%E9%9A%86%E7%BE%8A%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">7.3.1、传统方式解决克隆羊问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-1-1%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.7.3.1.1.</span> <span class="nav-text">7.3.1.1、思路分析(类图)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-1-2%E3%80%81%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%EF%BC%9A%EF%BC%88%E5%9C%A8Client%E4%B8%AD%EF%BC%89"><span class="nav-number">1.7.3.1.2.</span> <span class="nav-text">7.3.1.2、相关代码：（在Client中）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-1-3%E3%80%81%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.3.1.3.</span> <span class="nav-text">7.3.1.3、传统的方式的优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-1-4%E3%80%81%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95%EF%BC%88%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.7.3.1.4.</span> <span class="nav-text">7.3.1.4、改进方法（使用原型模式）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%85%8B%E9%9A%86%E7%BE%8A%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">7.3.2、原型模式解决克隆羊问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.7.4.</span> <span class="nav-text">7.4、浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">7.4.1、浅拷贝的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">7.4.2、深拷贝基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-3%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">7.4.3、深拷贝应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-3-1%E3%80%81%E4%BD%BF%E7%94%A8-%E9%87%8D%E5%86%99-clone-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.7.4.3.1.</span> <span class="nav-text">7.4.3.1、使用 重写 clone 方法实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.7.4.3.2.</span> <span class="nav-text">7.4.3.2、使用序列化来实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-3-3%E3%80%81%E5%AF%B9%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%BA%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="nav-number">1.7.4.3.3.</span> <span class="nav-text">7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-4%E3%80%81%E5%AF%B9%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84clone%E6%96%B9%E6%B3%95%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">7.4.4、对于深拷贝的clone方法与序列化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-4-1%E3%80%81clone%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.4.4.1.</span> <span class="nav-text">7.4.4.1、clone方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-4-2%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.4.4.2.</span> <span class="nav-text">7.4.4.2、序列化方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.5.</span> <span class="nav-text">7.5、原型模式在 Spring 框架中源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6%E3%80%81new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8Cclone%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.6.</span> <span class="nav-text">7.6、new一个对象的过程和clone一个对象的过程区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.7.</span> <span class="nav-text">7.7、原型模式的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.7.8.</span> <span class="nav-text">7.8、原型模式的扩展（带原型管理器的原型模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.7.9.</span> <span class="nav-text">7.9、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.10.</span> <span class="nav-text">7.10、相关的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-11%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.7.11.</span> <span class="nav-text">7.11、原型模式的注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8FBuilder%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">8、建造者模式Builder（创建型设计模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2、建造者模原理结构图-uml类图与模板实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A7%92%E8%89%B2"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">8.2.1、建造者模式的四个角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">8.2.2、建造者模式原理类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3%E3%80%81%E7%B1%BB%E5%9B%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">8.2.3、类图的模板代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.8.3.</span> <span class="nav-text">8.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1%E3%80%81%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">8.3.1、传统方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%9B%96%E6%88%BF%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">8.3.2、建造者模式解决盖房子问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.8.4.</span> <span class="nav-text">8.4、建造者模式在JDK中的应用与源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.5.</span> <span class="nav-text">8.5、建造者模式与工厂模式对区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.6.</span> <span class="nav-text">8.6、建造者模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.8.7.</span> <span class="nav-text">8.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.8.</span> <span class="nav-text">8.8、相关的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-9%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.8.9.</span> <span class="nav-text">8.9、建造者模式的注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8FAdapter%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">9、适配器模式Adapter（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.9.1.</span> <span class="nav-text">9.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.9.2.</span> <span class="nav-text">9.2、适配器模式原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1%E3%80%81%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">9.2.1、类适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2%E3%80%81%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">9.2.2、对象适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3%E3%80%81%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">9.2.3、接口适配器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3%E3%80%81%E4%B8%89%E7%A7%8D%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.9.3.</span> <span class="nav-text">9.3、三种适配器模式的基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-1%E3%80%81%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">9.3.1、类适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-2%E3%80%81%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">9.3.2、对象适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-3%E3%80%81%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">9.3.3、接口适配器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.9.4.</span> <span class="nav-text">9.4、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-1%E3%80%81%E4%BD%BF%E7%94%A8%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">9.4.1、使用类适配器模式实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">9.4.2、使用对象适配器模式实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-3%E3%80%81%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.9.4.3.</span> <span class="nav-text">9.4.3、接口适配器模式应用实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring-MVC%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.9.5.</span> <span class="nav-text">9.5、适配器模式在Spring MVC的应用与源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.6.</span> <span class="nav-text">9.6、适配器模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.9.7.</span> <span class="nav-text">9.7、适配器模式的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.9.8.</span> <span class="nav-text">9.8、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-9%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.9.</span> <span class="nav-text">9.9、相关的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-10%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.9.10.</span> <span class="nav-text">9.10、适配器模式的注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8FBridge%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">10、桥接模式Bridge（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.10.1.</span> <span class="nav-text">10.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.10.2.</span> <span class="nav-text">10.2、桥接模式原结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1%E3%80%81-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">10.2.1、 模式的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.10.3.</span> <span class="nav-text">10.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">10.3.1、使用传统方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">10.3.2、使用桥接模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8JDBC%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.10.4.</span> <span class="nav-text">10.4、桥接模式在JDBC的应用与源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.10.5.</span> <span class="nav-text">10.5、桥接模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.10.6.</span> <span class="nav-text">10.6、桥接模式的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.10.7.</span> <span class="nav-text">10.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.8.</span> <span class="nav-text">10.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-9%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.10.9.</span> <span class="nav-text">10.9、桥接模式的注意事项和细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8FDecorator%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.11.</span> <span class="nav-text">11、装饰者模式Decorator（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.11.1.</span> <span class="nav-text">11.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.11.2.</span> <span class="nav-text">11.2、装饰者模式原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">11.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2%E3%80%81%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">11.2.2、实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.11.3.</span> <span class="nav-text">11.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%881%EF%BC%88%E8%BE%83%E5%B7%AE%EF%BC%89%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">11.3.1、使用方案1（较差）解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%882%EF%BC%88%E8%BE%83%E5%A5%BD%EF%BC%89%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">11.3.2、使用方案2（较好）解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3%E3%80%81%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">11.3.3、使用装饰者模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8IO%E7%BB%93%E6%9E%84%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.11.4.</span> <span class="nav-text">11.4、装饰者模式在IO结构的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.11.5.</span> <span class="nav-text">11.5、装饰者模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.11.6.</span> <span class="nav-text">11.6、装饰者模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-6-1%E3%80%81%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6%E8%80%8C%E6%B2%A1%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%9E%84%E4%BB%B6%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%8A%BD%E8%B1%A1%E8%A3%85%E9%A5%B0%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6"><span class="nav-number">1.11.6.1.</span> <span class="nav-text">11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-6-2%E3%80%81%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%8A%BD%E8%B1%A1%E8%A3%85%E9%A5%B0%E5%92%8C%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E5%90%88%E5%B9%B6"><span class="nav-number">1.11.6.2.</span> <span class="nav-text">11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.11.7.</span> <span class="nav-text">11.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.11.8.</span> <span class="nav-text">11.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-9%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.11.9.</span> <span class="nav-text">11.9、装饰者模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8FComposite%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">12、组合模式Composite（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.12.1.</span> <span class="nav-text">12.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.12.2.</span> <span class="nav-text">12.2、组合模式的原理结构图-uml类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.12.3.</span> <span class="nav-text">12.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-1%E3%80%81%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%A1%88%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">12.3.1、传统方案解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-2%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6%E9%9C%80%E6%B1%82"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">12.3.2、组合模式进阶需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.12.4.</span> <span class="nav-text">12.4、组合模式在JDK的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.12.5.</span> <span class="nav-text">12.5、组合模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.12.6.</span> <span class="nav-text">12.6、组合模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.12.7.</span> <span class="nav-text">12.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.12.8.</span> <span class="nav-text">12.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-9%E3%80%81%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.12.9.</span> <span class="nav-text">12.9、组合模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FFacade%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.13.</span> <span class="nav-text">13、外观模式Facade（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.13.1.</span> <span class="nav-text">13.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.13.2.</span> <span class="nav-text">13.2、外观模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">13.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">13.2.2、模式的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.13.3.</span> <span class="nav-text">13.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">13.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.13.3.2.</span> <span class="nav-text">13.3.2、使用外观模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%9C%A8Mybatis%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.13.4.</span> <span class="nav-text">13.4、外观模式在Mybatis的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-5%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.13.5.</span> <span class="nav-text">13.5、外观模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-6%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.13.6.</span> <span class="nav-text">13.6、外观模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.13.7.</span> <span class="nav-text">13.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.13.8.</span> <span class="nav-text">13.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-9%E3%80%81%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.13.9.</span> <span class="nav-text">13.9、外观模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8FFlyweight%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.14.</span> <span class="nav-text">14、享元模式Flyweight（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.14.1.</span> <span class="nav-text">14.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.14.2.</span> <span class="nav-text">14.2、享元模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-1%E3%80%81%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">14.2.1、内部状态与外部状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">14.2.2、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.14.2.3.</span> <span class="nav-text">14.2.3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.14.3.</span> <span class="nav-text">14.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.14.3.1.</span> <span class="nav-text">14.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.14.3.2.</span> <span class="nav-text">14.3.2、使用享元模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK-Integer%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.14.4.</span> <span class="nav-text">14.4、享元模式在JDK-Integer的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.14.5.</span> <span class="nav-text">14.5、享元模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.14.6.</span> <span class="nav-text">14.6、享元模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-1%E3%80%81%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.14.6.1.</span> <span class="nav-text">14.6.1、单纯享元模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-2%E3%80%81%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.14.6.2.</span> <span class="nav-text">14.6.2、复合享元模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.14.7.</span> <span class="nav-text">14.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.14.8.</span> <span class="nav-text">14.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.14.9.</span> <span class="nav-text">14.9、享元模式的注意事项与细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-10%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.10.</span> <span class="nav-text">14.10、享元模式与单例模式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FProxy%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.15.</span> <span class="nav-text">15、代理模式Proxy（结构型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.15.1.</span> <span class="nav-text">15.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.15.2.</span> <span class="nav-text">15.2、代理模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-1%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">15.2.1、静态代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.2.2.</span> <span class="nav-text">15.2.2、JDK动态代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-3%E3%80%81Cglib%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.2.3.</span> <span class="nav-text">15.2.3、Cglib代理模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.15.3.</span> <span class="nav-text">15.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">15.3.1、使用静态代理模式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.15.3.2.</span> <span class="nav-text">15.3.2、使用动态代理模式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-3%E3%80%81%E4%BD%BF%E7%94%A8cglib%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.15.3.3.</span> <span class="nav-text">15.3.3、使用cglib代理模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.15.4.</span> <span class="nav-text">15.4、代理模式总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-1%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.15.4.1.</span> <span class="nav-text">15.4.1、静态代理优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.15.4.2.</span> <span class="nav-text">15.4.2、JDK动态代理优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-3%E3%80%81Cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.15.4.3.</span> <span class="nav-text">15.4.3、Cglib动态代理优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-4%E3%80%81%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88JDK-VS-CGLIB%EF%BC%89"><span class="nav-number">1.15.4.4.</span> <span class="nav-text">15.4.4、两种动态代理模式的对比（JDK VS CGLIB）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-5%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.15.4.5.</span> <span class="nav-text">15.4.5、代理模式总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.15.5.</span> <span class="nav-text">15.5、代理模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.15.6.</span> <span class="nav-text">15.6、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.7.</span> <span class="nav-text">15.7、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-8%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.8.</span> <span class="nav-text">15.8、代理模式与其他模式的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-8-1%E3%80%81Proxy%E6%A8%A1%E5%BC%8FVSDecorator%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.8.1.</span> <span class="nav-text">15.8.1、Proxy模式VSDecorator模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-8-2%E3%80%81Proxy%E6%A8%A1%E5%BC%8FVSAdapter%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.8.2.</span> <span class="nav-text">15.8.2、Proxy模式VSAdapter模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-9%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.15.9.</span> <span class="nav-text">15.9、代理模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FTemplate-Method%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.16.</span> <span class="nav-text">16、模板方法模式Template Method（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.16.1.</span> <span class="nav-text">16.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.16.2.</span> <span class="nav-text">16.2、模板方法模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.16.2.1.</span> <span class="nav-text">16.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.16.2.2.</span> <span class="nav-text">16.2.2、模式的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.16.3.</span> <span class="nav-text">16.3、应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-4%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.16.4.</span> <span class="nav-text">16.4、模板方法模式在Spring框架的应用与源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-4-1%E3%80%81%E8%AF%B4%E6%98%8E%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.16.4.1.</span> <span class="nav-text">16.4.1、说明类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-4-2%E3%80%81%E8%A7%92%E8%89%B2%E5%88%86%E6%9E%90"><span class="nav-number">1.16.4.2.</span> <span class="nav-text">16.4.2、角色分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-4-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.16.4.3.</span> <span class="nav-text">16.4.3、代码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-5%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.16.5.</span> <span class="nav-text">16.5、模板方法模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-6%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.16.6.</span> <span class="nav-text">16.6、模板方法模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.16.7.</span> <span class="nav-text">16.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.16.8.</span> <span class="nav-text">16.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-9%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.16.9.</span> <span class="nav-text">16.9、模板方法模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8FCommand%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.17.</span> <span class="nav-text">17、命令模式Command（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.17.1.</span> <span class="nav-text">17.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.17.2.</span> <span class="nav-text">17.2、命令模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">17.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#173-2-2%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.17.2.2.</span> <span class="nav-text">173.2.2、模式的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.17.3.</span> <span class="nav-text">17.3、应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-4%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.17.4.</span> <span class="nav-text">17.4、命令模式在Spring框架的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.17.5.</span> <span class="nav-text">17.5、命令模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-6%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.17.6.</span> <span class="nav-text">17.6、命令模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.17.7.</span> <span class="nav-text">17.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.17.8.</span> <span class="nav-text">17.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-9%E3%80%81%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.17.9.</span> <span class="nav-text">17.9、命令模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8FVisitor%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.18.</span> <span class="nav-text">18、访问者模式Visitor（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.18.1.</span> <span class="nav-text">18.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.18.2.</span> <span class="nav-text">18.2、访问者模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.18.2.1.</span> <span class="nav-text">18.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.18.2.2.</span> <span class="nav-text">18.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.18.3.</span> <span class="nav-text">18.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.18.3.1.</span> <span class="nav-text">18.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.18.3.2.</span> <span class="nav-text">18.3.2、使用访问者模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4%E3%80%81%E5%8F%8C%E5%88%86%E6%B4%BE"><span class="nav-number">1.18.4.</span> <span class="nav-text">18.4、双分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-5%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.18.5.</span> <span class="nav-text">18.5、访问者模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-6%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.18.6.</span> <span class="nav-text">18.6、访问者模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.18.7.</span> <span class="nav-text">18.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.18.8.</span> <span class="nav-text">18.8、相关设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8FIterator%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.19.</span> <span class="nav-text">19、迭代器模式Iterator（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#19-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.19.1.</span> <span class="nav-text">19.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.19.2.</span> <span class="nav-text">19.2、迭代器模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#19-2-1%E3%80%81-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.19.2.1.</span> <span class="nav-text">19.2.1、 模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.19.2.2.</span> <span class="nav-text">19.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.19.3.</span> <span class="nav-text">19.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#19-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.19.3.1.</span> <span class="nav-text">19.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.19.3.2.</span> <span class="nav-text">19.3.2、使用迭代器模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-4%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.19.4.</span> <span class="nav-text">19.4、迭代器模式在JDK的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-5%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.19.5.</span> <span class="nav-text">19.5、迭代器模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.19.6.</span> <span class="nav-text">19.6、迭代器模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.19.7.</span> <span class="nav-text">19.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.19.8.</span> <span class="nav-text">19.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-9%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.19.9.</span> <span class="nav-text">19.9、迭代器模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FObserver%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.20.</span> <span class="nav-text">20、观察者模式Observer（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.20.1.</span> <span class="nav-text">20.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-2%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.20.2.</span> <span class="nav-text">20.2、观察者模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.20.2.1.</span> <span class="nav-text">20.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.20.2.2.</span> <span class="nav-text">20.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.20.3.</span> <span class="nav-text">20.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.20.3.1.</span> <span class="nav-text">20.3.1、使用传统方法解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.20.3.2.</span> <span class="nav-text">20.3.2、使用观察者模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-4%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.20.4.</span> <span class="nav-text">20.4、观察者模式在JDK的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-5%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.20.5.</span> <span class="nav-text">20.5、观察者模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-6%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.20.6.</span> <span class="nav-text">20.6、观察者模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-6-1%E3%80%81-Observable%E7%B1%BB"><span class="nav-number">1.20.6.1.</span> <span class="nav-text">20.6.1、 Observable类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-6-2%E3%80%81-Observer-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.20.6.2.</span> <span class="nav-text">20.6.2、 Observer 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-6-3%E3%80%81%E5%AF%B9%E5%BA%94%E4%BE%8B%E5%AD%90"><span class="nav-number">1.20.6.3.</span> <span class="nav-text">20.6.3、对应例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-6-4%E3%80%81java-util-Observer%E6%8E%A5%E5%8F%A3%E5%92%8Cjava-util-Observable%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A7%A3%E6%9E%90"><span class="nav-number">1.20.6.4.</span> <span class="nav-text">20.6.4、java. util.Observer接口和java. util . Observable类的相关解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.20.7.</span> <span class="nav-text">20.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.20.8.</span> <span class="nav-text">20.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-9%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.20.9.</span> <span class="nav-text">20.9、观察者模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8FMediator%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.21.</span> <span class="nav-text">21、中介者模式Mediator（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.21.1.</span> <span class="nav-text">21.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-2%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.21.2.</span> <span class="nav-text">21.2、中介者模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.21.2.1.</span> <span class="nav-text">21.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.21.2.2.</span> <span class="nav-text">21.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.21.3.</span> <span class="nav-text">21.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.21.3.1.</span> <span class="nav-text">21.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.21.3.2.</span> <span class="nav-text">21.3.2、使用中介者模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-4%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.21.4.</span> <span class="nav-text">21.4、中介者模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-5%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.21.5.</span> <span class="nav-text">21.5、中介者模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-6%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.21.6.</span> <span class="nav-text">21.6、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-7%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.21.7.</span> <span class="nav-text">21.7、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-8%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.21.8.</span> <span class="nav-text">21.8、中介者模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8FMemento%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.22.</span> <span class="nav-text">22、备忘录模式Memento（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#22-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.22.1.</span> <span class="nav-text">22.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.22.2.</span> <span class="nav-text">22.2、备忘录模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#22-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.22.2.1.</span> <span class="nav-text">22.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.22.2.2.</span> <span class="nav-text">22.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.22.3.</span> <span class="nav-text">22.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.22.3.1.</span> <span class="nav-text">22.3.1、使用传统模式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.22.3.2.</span> <span class="nav-text">22.3.2、使用备忘录模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-4%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.22.4.</span> <span class="nav-text">22.4、备忘录模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-5%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.22.5.</span> <span class="nav-text">22.5、备忘录模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#22-5-1%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.22.5.1.</span> <span class="nav-text">22.5.1、备忘录模式 + 原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-5-2%E3%80%81%E5%85%B3%E4%BA%8E%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%BA%90%E7%A0%81%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.22.5.2.</span> <span class="nav-text">22.5.2、关于备忘录模式在源码当中的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-6%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.22.6.</span> <span class="nav-text">22.6、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-7%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.22.7.</span> <span class="nav-text">22.7、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-8%E3%80%81%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.22.8.</span> <span class="nav-text">22.8、备忘录模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8FInterpreter%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.23.</span> <span class="nav-text">23、解释器模式Interpreter（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#23-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.23.1.</span> <span class="nav-text">23.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-2%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%AD%E7%9A%84%E2%80%9C%E6%96%87%E6%B3%95%E3%80%81%E5%8F%A5%E5%AD%90%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%91%E2%80%9D%E7%AD%89%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.23.2.</span> <span class="nav-text">23.2、编译原理中的“文法、句子、语法树”等相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#23-2-1%E3%80%81%E6%96%87%E6%B3%95"><span class="nav-number">1.23.2.1.</span> <span class="nav-text">23.2.1、文法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-2-2%E3%80%81%E5%8F%A5%E5%AD%90"><span class="nav-number">1.23.2.2.</span> <span class="nav-text">23.2.2、句子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-2-3%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="nav-number">1.23.2.3.</span> <span class="nav-text">23.2.3、语法树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.23.3.</span> <span class="nav-text">23.3、解释器模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#23-3-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.23.3.1.</span> <span class="nav-text">23.3.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-3-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.23.3.2.</span> <span class="nav-text">23.3.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-4%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.23.4.</span> <span class="nav-text">23.4、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#23-4-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.23.4.1.</span> <span class="nav-text">23.4.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-4-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.23.4.2.</span> <span class="nav-text">23.4.2、使用解释器模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-5%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.23.5.</span> <span class="nav-text">23.5、解释器模式在Spring框架的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-6%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.23.6.</span> <span class="nav-text">23.6、解释器模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-7%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.23.7.</span> <span class="nav-text">23.7、解释器模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-8%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.23.8.</span> <span class="nav-text">23.8、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-9%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.23.9.</span> <span class="nav-text">23.9、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-10%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.23.10.</span> <span class="nav-text">23.10、解释器模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8FState%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.24.</span> <span class="nav-text">24、状态模式State（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#24-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.24.1.</span> <span class="nav-text">24.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-2%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.24.2.</span> <span class="nav-text">24.2、状态模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#24-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.24.2.1.</span> <span class="nav-text">24.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.24.2.2.</span> <span class="nav-text">24.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.24.3.</span> <span class="nav-text">24.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#24-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.24.3.1.</span> <span class="nav-text">24.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.24.3.2.</span> <span class="nav-text">24.3.2、使用状态模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-4%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE-%E5%80%9F%E8%B4%B7%E5%B9%B3%E5%8F%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.24.4.</span> <span class="nav-text">24.4、状态模式在实际项目-借贷平台源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-5%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.24.5.</span> <span class="nav-text">24.5、状态模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-6%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.24.6.</span> <span class="nav-text">24.6、状态模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#24-6-1%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.24.6.1.</span> <span class="nav-text">24.6.1、状态模式 + 享元模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-6-2%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.24.6.2.</span> <span class="nav-text">24.6.2、状态模式与责任链模式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-6-3%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.24.6.3.</span> <span class="nav-text">24.6.3、状态模式与策略模式的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.24.7.</span> <span class="nav-text">24.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.24.8.</span> <span class="nav-text">24.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-9%E3%80%81%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.24.9.</span> <span class="nav-text">24.9、状态模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FStrategy%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.25.</span> <span class="nav-text">25、策略模式Strategy（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#25-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.25.1.</span> <span class="nav-text">25.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-2%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.25.2.</span> <span class="nav-text">25.2、策略模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#25-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.25.2.1.</span> <span class="nav-text">25.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-3-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.25.2.2.</span> <span class="nav-text">25.3.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.25.3.</span> <span class="nav-text">25.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#25-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.25.3.1.</span> <span class="nav-text">25.3.1、使用传统方式解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.25.3.2.</span> <span class="nav-text">25.3.2、使用策略模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.25.4.</span> <span class="nav-text">25.4、策略模式在JDK的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-5%E3%80%81-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.25.5.</span> <span class="nav-text">25.5、 策略模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-6%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95%EF%BC%88%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.25.6.</span> <span class="nav-text">25.6、策略模式扩展（策略模式+工厂模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.25.7.</span> <span class="nav-text">25.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.25.8.</span> <span class="nav-text">25.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-9%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.25.9.</span> <span class="nav-text">25.9、策略模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8FChain-of-Responsibility%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.26.</span> <span class="nav-text">26、职责链模式Chain of Responsibility（行为型模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#26-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.26.1.</span> <span class="nav-text">26.1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE-uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">1.26.2.</span> <span class="nav-text">26.2、职责链模式的原理结构图-uml类图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#26-2-1%E3%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.26.2.1.</span> <span class="nav-text">26.2.1、模式的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.26.2.2.</span> <span class="nav-text">26.2.2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-3%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.26.3.</span> <span class="nav-text">26.3、应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#26-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.26.3.1.</span> <span class="nav-text">26.3.1、使用传统方法解决需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9C%80%E6%B1%82"><span class="nav-number">1.26.3.2.</span> <span class="nav-text">26.3.2、使用职责链模式解决需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-4%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%9C%A8SpringMVC%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="nav-number">1.26.4.</span> <span class="nav-text">26.4、职责链模式在SpringMVC框架的应用与源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-5%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.26.5.</span> <span class="nav-text">26.5、职责链模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-6%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">1.26.6.</span> <span class="nav-text">26.6、职责链模式扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-7%E3%80%81%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB"><span class="nav-number">1.26.7.</span> <span class="nav-text">26.7、进阶阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-8%E3%80%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.26.8.</span> <span class="nav-text">26.8、相关设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-9%E3%80%81%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="nav-number">1.26.9.</span> <span class="nav-text">26.9、职责链模式的注意事项与细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%88%86%E7%B1%BB"><span class="nav-number">1.27.</span> <span class="nav-text">27、创建型模式的特点和分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">1.28.</span> <span class="nav-text">28、结构型模式概述（结构型模式的分类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">1.29.</span> <span class="nav-text">29、行为型模式概述（行为型模式的分类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30%E3%80%81%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%BD%92%E7%BA%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.30.</span> <span class="nav-text">30、一句话归纳设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31%E3%80%81%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%B1%9E%E4%BA%8E23%E7%A7%8D%EF%BC%89"><span class="nav-number">1.31.</span> <span class="nav-text">31、其他设计模式（不属于23种）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BD%91%E7%AB%99"><span class="nav-number">1.32.</span> <span class="nav-text">32、设计模式相关的网站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0%E3%80%81%E5%BB%B6%E4%BC%B8"><span class="nav-number">1.33.</span> <span class="nav-text">0、延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%90%84%E7%A7%8D%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.33.1.</span> <span class="nav-text">1、各种生成实例的方法的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81new"><span class="nav-number">1.33.1.1.</span> <span class="nav-text">1、new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81clone"><span class="nav-number">1.33.1.2.</span> <span class="nav-text">2、clone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81new-Instance"><span class="nav-number">1.33.1.3.</span> <span class="nav-text">3、new Instance</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%90%8D%E6%98%AF%E6%9D%9F%E7%BC%9A%E5%90%97"><span class="nav-number">1.33.2.</span> <span class="nav-text">2、类名是束缚吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.33.3.</span> <span class="nav-text">3、类的层次与抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="nav-number">1.34.</span> <span class="nav-text">参考链接：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
