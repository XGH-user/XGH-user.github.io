<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] 第一章 操作系统引论及概述  1.1.1、概念、功能与目标 定义： 操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。  操作系统是系统资源的管理者，负责管理协调硬件、软件等计算机资源的工作 向上层的应用程序、用户提供方便易用">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] 第一章 操作系统引论及概述  1.1.1、概念、功能与目标 定义： 操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。  操作系统是系统资源的管理者，负责管理协调硬件、软件等计算机资源的工作 向上层的应用程序、用户提供方便易用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog/XGH-blog/source_posts/操作系统/01.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/08.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/09.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/30.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/16.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/17.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/18.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/19.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/25.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/24.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/27.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/29.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/28.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/31.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/32.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/36.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/34.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/35.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/37.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/33.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/38.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/39.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Users/风间&琉璃/AppData/Roaming/Typora/typora-user-images/image-20210408200659340.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/41.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/42.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/21.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/22.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/23.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/43.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/45.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/46.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/44.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/47.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/49.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/50.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/48.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/51.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/52.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/53.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/54.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/55.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/56.png">
<meta property="article:published_time" content="2021-04-18T19:26:19.000Z">
<meta property="article:modified_time" content="2021-04-18T19:26:37.268Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog/XGH-blog/source_posts/操作系统/01.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-19 03:26:19 / 修改时间：03:26:37" itemprop="dateCreated datePublished" datetime="2021-04-19T03:26:19+08:00">2021-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h2 id="第一章-操作系统引论及概述"><a href="#第一章-操作系统引论及概述" class="headerlink" title="第一章 操作系统引论及概述"></a><strong>第一章 操作系统引论及概述</strong></h2><hr>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\XGH-blog\source_posts\操作系统\01.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-1、概念、功能与目标"><a href="#1-1-1、概念、功能与目标" class="headerlink" title="1.1.1、概念、功能与目标"></a>1.1.1、概念、功能与目标</h3><ol>
<li><p>定义：</p>
<p>操作系统（Operating System，OS）是指<strong>控制和管理</strong>整个计算机系统的<strong>硬件</strong>和<strong>软件</strong>资源，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的<strong>系统软件</strong>。</p>
<ol>
<li>操作系统是系统资源的管理者，负责管理协调硬件、软件等计算机资源的工作</li>
<li>向上层的应用程序、用户提供方便易用的服务</li>
<li>操作系统是最接近硬件的一层软件，是系统软件不是硬件</li>
</ol>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.png" alt="image-20210406102804945"></p>
</li>
<li><p>功能与目标</p>
<ol>
<li><p><strong>操作系统是系统资源的管理者</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.png" alt="image-20210406102859419"></p>
</li>
<li><p><strong>向上层提供方便易用的服务</strong></p>
<ul>
<li><p>命令接口</p>
<ul>
<li><p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口</p>
<p>特点：<strong>用户说一句，系统跟着做一句</strong></p>
</li>
<li><p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口</p>
<p>使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。</p>
<p>特点：<strong>用户说一堆，系统跟着做一堆</strong></p>
</li>
</ul>
</li>
<li><p>程序接口</p>
<p>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。</p>
<p>如C盘Windows\System32中有很多的*.dll文件。程序员在程序中调用（该调用过程即为<strong>系统调用</strong>）即可实现创建窗口等功能。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.png" alt="image-20210406104140771"></p>
</li>
<li><p>GUI：图形用户界面（Graphical User Interface）</p>
<p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>例子：在Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.png" alt="image-20210406104309877"></p>
</li>
<li><p><strong>操作系统是最接近硬件的一层软件</strong></p>
<p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.png" alt="image-20210406104343359"></p>
</li>
</ol>
</li>
<li><p>脑图</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/08.png" alt="image-20210406104426461"></p>
</li>
</ol>
<h3 id="1-1-2、操作系统的四个特征"><a href="#1-1-2、操作系统的四个特征" class="headerlink" title="1.1.2、操作系统的四个特征"></a>1.1.2、操作系统的四个特征</h3><ol>
<li><p>并发</p>
<p>并发与并行的区别：</p>
<ul>
<li>并发：两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。</li>
<li>并行：指两个或多个事件<strong>在同一时刻同时发生</strong>。</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/09.png" alt="image-20210406111514894"></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。</p>
<p>操作系统就是伴随着“多道程序技术”而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong>。</p>
<p>注意：</p>
<ul>
<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</li>
<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
</li>
<li><p>共享</p>
<p><strong>共享即资源共享</strong>，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li><p>互斥共享方式：</p>
<p>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li><p>同时共享方式:</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：</p>
<ul>
<li>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li>
<li>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li>
</ul>
<p><strong>并发与共享是操作系统最基本的两个特征，两者互为存在条件</strong></p>
<ul>
<li>并发性指计算机系统中同时存在着多个运行着的程序。</li>
<li>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.png" alt="image-20210406112122162"></p>
</li>
<li><p>虚拟</p>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>虚拟技术</p>
<ul>
<li>空分复用技术（如虚拟存储器技术）：实际只有4GB的内存，在用户看来似乎远远大于4GB</li>
<li>时分复用技术（如虚拟处理器）：微观上处理机在各个微小的时间段内交替着为各个进程服务</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong></p>
</li>
<li><p>异步</p>
<p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性。</strong></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.png" alt="image-20210406112516655"></p>
<h3 id="1-1-3、操作系统的发展与分类"><a href="#1-1-3、操作系统的发展与分类" class="headerlink" title="1.1.3、操作系统的发展与分类"></a>1.1.3、操作系统的发展与分类</h3><p>操作系统的发展：</p>
<ol>
<li><p>手工操作阶段</p>
<p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p>
</li>
<li><p>批处理阶段</p>
<ol>
<li><p>单道批处理系统</p>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由**监督程序(操作系统的雏形)**负责控制作业的输入、输出</p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>
<p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
</li>
<li><p>多道批处理系统</p>
<p><strong>操作系统正式诞生</strong>，用于支持多道程序并发运行</p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</p>
<p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）</p>
</li>
</ol>
</li>
<li><p>分时操作系统</p>
<p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/ 作业服务一个时间片，不区分任务的紧急性</p>
</li>
<li><p>实时操作系统</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性</strong>和<strong>可靠性</strong>。</p>
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理。如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统：能接受偶尔违反时间规定。如：12306火车订票系统</li>
</ul>
<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>
</li>
</ol>
<p>操作系统的分类</p>
<ol>
<li><p>网络操作系统</p>
<p>伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
</li>
<li><p>分布式操作系统</p>
<p>主要特点是<strong>分布性</strong>和<strong>并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
</li>
<li><p>个人计算机操作系统</p>
<p>如 Windows XP、MacOS，方便个人使用</p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.png" alt="image-20210406115156103"></p>
<h3 id="1-1-4、操作系统的运行机制与体系结构"><a href="#1-1-4、操作系统的运行机制与体系结构" class="headerlink" title="1.1.4、操作系统的运行机制与体系结构"></a>1.1.4、操作系统的运行机制与体系结构</h3><ol>
<li><p>运行机制</p>
<ul>
<li><p>两种指令</p>
<ul>
<li>特权指令：不允许用户程序使用。如内存清零指令</li>
<li>非特权指令：如普通的运算指令</li>
</ul>
</li>
<li><p>两种处理器状态</p>
<ul>
<li>用户态（目态）：此时CPU只能执行非特权指令</li>
<li>核心态（管态）：特权指令、非特权指令都能执行</li>
</ul>
<p>两种处理器状态用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态，如0表示用户态，1表示核心态。</p>
</li>
<li><p>两种程序</p>
<ul>
<li><p>内核程序</p>
<p>操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p>
</li>
<li><p>应用程序</p>
<p>为了保证系统的安全运行，普通应用程序只能执行非特权指令，运行在用户态。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/14.png" alt="image-20210406125651838"></p>
</li>
<li><p>操作系统内核</p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分</p>
<p>实现操作系统内核功能的那些程序就是<strong>内核程序</strong></p>
<ul>
<li>时钟管理：实现计时管理</li>
<li>中断处理：负责实现中断机制</li>
<li>原语<ul>
<li>是一种特殊的程序</li>
<li>处于操作系统最底层，是最接近硬件的部分</li>
<li>这种程序的运行具有<strong>原子性</strong>，其运行只能一气呵成，不可中断</li>
<li>运行时间短，调用频繁</li>
</ul>
</li>
<li>对系统资源进行管理的功能（有的操作系统不把这部分功能归为“内核功能”。也就是说，不同的操作系统，对内核功能的划分可能并不一样）<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
<li><p>体系结构</p>
<ul>
<li><p>大内核</p>
<p>将操作系统的主要功能都作为系统内核运行在核心态</p>
<p>优点：高性能</p>
<p>缺点：内核代码大，结构混乱，难以维护</p>
<p>典型的大内核/宏内核/单内核操作系统：Linux、UNIX</p>
</li>
<li><p>微内核</p>
<p>只把最基本的功能保留在内核</p>
<p>优点：内核功能少，结构清晰，方便维护</p>
<p>缺点：需要频繁地在核心态与用户态之间切换，性能低</p>
<p>典型的微内核操作系统：Windows NT</p>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/30.png" alt="image-20210408192745129"></p>
<p>类比：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/16.png" alt="image-20210406131034245"></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/15.png" alt="image-20210406130802115"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13.png" alt="image-20210406115337381"></p>
<h3 id="1-1-5、中断与异常"><a href="#1-1-5、中断与异常" class="headerlink" title="1.1.5、中断与异常"></a>1.1.5、中断与异常</h3><ol>
<li><p>中断机制的诞生</p>
<p>在早期的计算机没有中断机制，各个程序只能串行执行，系统资源的利用率低。</p>
<p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p>
<p>本质：<strong>发生中断就意味着需要操作系统介入，开展管理工作</strong></p>
</li>
<li><p>中断的概念与作用</p>
<ul>
<li>当<strong>中断发生</strong>时，CPU立即进入<strong>核心态</strong></li>
<li>当中断发生后，当前运行的进程暂停运行，并有操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p>发生中断就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断</strong>可以使CPU从<strong>用户态切换为核心态</strong>，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p>
<p><strong>中断是实现CPU从用户态切换到核心态的唯一途径</strong>。通过<strong>执行一个特权指令</strong>，将程序状态字（PSW）对标志位设置为“用户态”。</p>
</li>
<li><p>中断（广义的中断）的分类</p>
<ul>
<li>内中断（也称“异常、例外、陷入”）：与当前执行的指令有关，中断信号来源于CPU内部<ul>
<li>自愿中断：指令中断（如：系统调用时使用的访管指令（又叫陷入指令、trap指令））</li>
<li>强迫中断<ul>
<li>硬件故障（如：缺页）</li>
<li>软件故障（如：整数除0）</li>
</ul>
</li>
</ul>
</li>
<li>外中断（也称“中断（狭义的中断）”）：与当前执行的指令无关，中断信号来源于CPU外部<ul>
<li>外设请求（如：I/O操作完成发出的中断信号）</li>
<li>人工干预（如：用户强行终止一个进程）</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/17.png" alt="image-20210406134755249"></p>
<p>另一种分类方式：</p>
<ul>
<li>内中断（也称“异常、例外、陷入”）：与当前执行的指令有关，中断信号来源于CPU内部<ul>
<li>陷阱、陷入（trap）：有意而为之的异常，如系统调用</li>
<li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修<br>复故障后会把CPU使用权还给应用程序，让它继续执行下去。如：缺页故障。</li>
<li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令。</li>
</ul>
</li>
<li>外中断（也称“中断（狭义的中断）”）：与当前执行的指令无关，中断信号来源于CPU外部<ul>
<li>外设请求（如：I/O操作完成发出的中断信号）</li>
<li>人工干预（如：用户强行终止一个进程）</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/18.png" alt="image-20210406135217118"></p>
</li>
<li><p>外中断的处理过程</p>
<ol>
<li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)</li>
<li>根据中断信号类型转入相应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
</li>
<li><p>中断机制的基本原理</p>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p>显然，中断处理程序一定是内核程序，需要运行在“内核态”</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20.png" alt="image-20210406135456448"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/19.png" alt="image-20210406135343449"></p>
<h3 id="1-1-6、系统调用"><a href="#1-1-6、系统调用" class="headerlink" title="1.1.6、系统调用"></a>1.1.6、系统调用</h3><ol>
<li><p>什么是系统调用</p>
<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，<strong>程序接口</strong>由一组<strong>系统调用</strong>组成。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.png" alt="image-20210408185305701"></p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务。</strong></p>
</li>
<li><p>系统调用与库函数调用的区别</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/25.png" alt="image-20210408190637741"></p>
</li>
<li><p>为什么系统调用是必须的</p>
<p>生活场景：去学校打印店打印论文，你按下了WPS 的“打印”选项，打印机开始工作。<br>你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到WPS 和Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。<strong>内核会对各个请求进行协调处理</strong>。</p>
</li>
<li><p>什么功能要用系统调用实现</p>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/24.png" alt="image-20210408190445658"></p>
</li>
<li><p>系统调用的过程</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26.png" alt="image-20210408191025687"></p>
<ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行相应的内请求核程序处理系统调用（核心态）</li>
<li>返回应用程序</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/27.png" alt="image-20210408191123343"></p>
<h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/29.png" alt="image-20210408192546560"></p>
<h2 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 <strong>进程与线程</strong></h2><hr>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/28.png" alt="在这里插入图片描述"></p>
<h3 id="2-1-1、进程的概念、组成与特征"><a href="#2-1-1、进程的概念、组成与特征" class="headerlink" title="2.1.1、进程的概念、组成与特征"></a>2.1.1、进程的概念、组成与特征</h3><h4 id="1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？"><a href="#1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？" class="headerlink" title="1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？"></a>1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？</h4><h5 id="1、进程的发展"><a href="#1、进程的发展" class="headerlink" title="1、进程的发展"></a>1、进程的发展</h5><p>在早期的计算机中，只支持单道程序。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/31.png" alt="image-20210408193824213"></p>
<p>在引入多道程序技术之后（操作系统）</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/32.png" alt="image-20210408193938895"></p>
<p>进程与程序的区别：</p>
<ul>
<li>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</li>
<li>进程（Process）：是动态的，是程序的一次执行过程</li>
</ul>
<p>同一个程序多次执行会对应多个进程。</p>
<h5 id="2、进程的定义"><a href="#2、进程的定义" class="headerlink" title="2、进程的定义"></a>2、进程的定义</h5><p>**程序段、数据段、PCB三部分组成了进程实体(进程映像)**。一般情况下，我们把进程实体就简称为进程例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p>注意：<strong>PCB是进程存在的唯一标志！</strong></p>
<p>从不同的角度，进程有不同的定义，比较传统典型的定义有：（强调“动态性”）进程的<code>进</code>：<code>正在进行</code></p>
<ol>
<li>进程是程序的<strong>一次执行过程</strong>。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li>
<li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<p>引入进程实体的概念后，可把进程定义为：</p>
<p><strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p>
<p>注：严格来说，进程实体和进程并不一样，<strong>进程实体是静态的</strong>，<strong>进程则是动态的</strong>。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“<strong>进程由程序段、数据段、PCB三部分组成</strong>”</p>
<h4 id="2、组成——每个进程由哪些部分组成"><a href="#2、组成——每个进程由哪些部分组成" class="headerlink" title="2、组成——每个进程由哪些部分组成"></a>2、组成——每个进程由哪些部分组成</h4><ol>
<li><p>PCB（Process Control Block）:<strong>操作系统使用的</strong>。进程的管理者（操作系统）所需的数据都在PCB当中</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/36.png" alt="image-20210408195302165"></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/34.png" alt="image-20210408195101713"></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/35.png" alt="image-20210408195206139"></p>
</li>
<li><p>程序段：<strong>进程自己使用的</strong>。程序本身的运行所需的数据</p>
<p>存放要执行的代码</p>
</li>
<li><p>数据段：<strong>进程自己使用的</strong>。程序本身的运行所需的数据</p>
<p>存放程序运行过程中处理的各种数据</p>
</li>
</ol>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/37.png" alt="image-20210408195916760"></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/33.png" alt="image-20210408194909291"></p>
<h4 id="3、组织方式——系统中的各个进程之间是如何被组织起来的"><a href="#3、组织方式——系统中的各个进程之间是如何被组织起来的" class="headerlink" title="3、组织方式——系统中的各个进程之间是如何被组织起来的"></a>3、组织方式——系统中的各个进程之间是如何被组织起来的</h4><p>在一个系统中，通常有数十数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PVB组织起来。</p>
<p>注意：进程的组成讨论的是一个<strong>进程内部</strong>的由哪些部分构成的问题，而<strong>进程的组织</strong>讨论的是<strong>多个进程之间</strong>的组织方式的问题。</p>
<ul>
<li><p>链接方式</p>
<p>按照进程状态将PCB分为多个队列</p>
<p>操作系统持有指向各个队列的指针</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/38.png" alt="image-20210408200538083"></p>
</li>
<li><p>索引方式</p>
<p>根据进程状态的不同，建立几张索引表</p>
<p>操作系统持有指向各个索引表的指针</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/39.png" alt="image-20210408200615846"></p>
</li>
</ul>
<h4 id="4、特征——相比于程序，进程有什么特征"><a href="#4、特征——相比于程序，进程有什么特征" class="headerlink" title="4、特征——相比于程序，进程有什么特征"></a>4、特征——相比于程序，进程有什么特征</h4><ul>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可以并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接收调度的基本单位</li>
<li>异步性：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供”<strong>进程同步机制</strong>“来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210408200659340.png" alt="image-20210408200659340"></p>
<h4 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40.png" alt="image-20210408200752313"></p>
<h3 id="2-1-2、进程的状态与转换"><a href="#2-1-2、进程的状态与转换" class="headerlink" title="2.1.2、进程的状态与转换"></a>2.1.2、进程的状态与转换</h3><h4 id="1、进程的状态"><a href="#1、进程的状态" class="headerlink" title="1、进程的状态"></a>1、进程的状态</h4><p>进程是程序的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各种进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<p>进程有五种状态，其中有三种基本状态</p>
<p>三种基本状态：</p>
<ul>
<li><p>运行态(Running)：占有CPU，并在CPU上运行</p>
<p>注意：在单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态）</p>
</li>
<li><p>就绪态(Ready)：已经具备运行条件，但由于你没有空闲的CPU，而暂时不能运行</p>
<p>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠CPU</p>
</li>
<li><p>阻塞态(Waiting/Blocked,又称：等待态)：硬=因等待某一事件而暂时不能运行</p>
<p>如：等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p>
</li>
</ul>
<p>剩余的两种状态：</p>
<ul>
<li><p>创建状态(New,又称：新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB</p>
<p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p>
</li>
<li><p>终止状态(Terminated,又称：结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p>
<p>进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误，除数为0等等），需要撤销进程。</p>
<p>操作系统需要完成撤销进程的相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作。</p>
</li>
</ul>
<h4 id="2、进程状态间的转换"><a href="#2、进程状态间的转换" class="headerlink" title="2、进程状态间的转换"></a>2、进程状态间的转换</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/41.png" alt="image-20210408210631200"></p>
<ul>
<li>就绪态 =&gt; 运行态</li>
<li>运行态 =&gt; 就绪态</li>
<li>运行态 =&gt; 阻塞态</li>
<li>阻塞态 =&gt; 就绪态</li>
</ul>
<p>注意：不能有阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
<h4 id="脑图-1"><a href="#脑图-1" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/42.png" alt="image-20210408210724237"></p>
<h3 id="2-1-3、进程控制"><a href="#2-1-3、进程控制" class="headerlink" title="2.1.3、进程控制"></a>2.1.3、进程控制</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><h5 id="1、什么是进程控制"><a href="#1、什么是进程控制" class="headerlink" title="1、什么是进程控制"></a>1、什么是进程控制</h5><p>进程控制的主要功能是<strong>对系统中的所有进程实施有效的管理</strong>，它具有<strong>创建新进程</strong>、<strong>撤销已有进程</strong>、<strong>实现进程状态转换</strong>等功能。</p>
<p>简化理解：反正进程控制就是要<strong>实现进程状态转换</strong>。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/21.png" alt="image-20210408223038360"></p>
<h5 id="2、如何实现进程控制——原语"><a href="#2、如何实现进程控制——原语" class="headerlink" title="2、如何实现进程控制——原语"></a>2、如何实现进程控制——<code>原语</code></h5><p><strong>原语</strong>是一种特殊的程序，它的<strong>执行具有原子性</strong>。也就是说，这段程序的<strong>运行必须一气呵成，不可中断</strong>。</p>
<p>如果不能“一气呵成”，就有可能导致<strong>操作系统中的某些关键数据结构信息不统一</strong>的情况，这会影响操作系统进行别的管理工作。</p>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。可以用“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”这两个<strong>特权指令</strong>实现<strong>原子性</strong>。</p>
<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</p>
<p>CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行<strong>开中断指令</strong>之后才会恢复检查。</p>
<p>这样，<strong>关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”。</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/22.png" alt="image-20210408223258148"></p>
<h4 id="2、进程控制相关的原语"><a href="#2、进程控制相关的原语" class="headerlink" title="2、进程控制相关的原语"></a>2、进程控制相关的原语</h4><p>学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标准、简化运行环境保存到PCB、从PCB恢复运行环境）<ol>
<li>所有的进程控制原语一定都会修改进程状态标准</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复其运行环境</li>
</ol>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<ul>
<li><p>进程的创建</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/23.png" alt="image-20210408223606502"></p>
</li>
<li><p>进程的终止</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/43.png" alt="image-20210408223742379"></p>
</li>
<li><p>进程的阻塞与唤醒</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/45.png" alt="image-20210408224532652"></p>
</li>
<li><p>进程的切换</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/46.png" alt="image-20210408224604511"></p>
</li>
</ul>
<h4 id="脑图-2"><a href="#脑图-2" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/44.png" alt="image-20210408223947869"></p>
<h3 id="2-1-4、进程通信"><a href="#2-1-4、进程通信" class="headerlink" title="2.1.4、进程通信"></a>2.1.4、进程通信</h3><p>什么是进程通信？</p>
<p>顾名思义，进程通信就是指进程之间的<strong>信息交换</strong>。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立</strong>。为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。如下：</p>
<h4 id="1、共享存储"><a href="#1、共享存储" class="headerlink" title="1、共享存储"></a>1、共享存储</h4><p>两个进程对共享空间的访问必须是<strong>互斥的</strong>（互斥访问通过操作系统提供的工具实现）。<br>操作系统只负责提供<strong>共享空间</strong>和<strong>同步互斥工具（如P、V操作）</strong></p>
<ul>
<li><p>基于数据结构的共享：</p>
<p>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级</strong>通信方式</p>
</li>
<li><p>基于存储区的共享：</p>
<p>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级</strong>通信方式。</p>
</li>
</ul>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/47.png" alt="image-20210409014400967"></p>
<h4 id="2、消息传递"><a href="#2、消息传递" class="headerlink" title="2、消息传递"></a>2、消息传递</h4><p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p>格式化的信息包含消息头和消息体。在消息头中包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<ul>
<li><p>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/49.png" alt="image-20210409015008639"></p>
</li>
<li><p>间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/50.png" alt="image-20210409015029868"></p>
</li>
</ul>
<h4 id="3、管道通信"><a href="#3、管道通信" class="headerlink" title="3、管道通信"></a>3、管道通信</h4><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/48.png" alt="image-20210409014459852"></p>
<ol>
<li>管道只能采用<strong>半双工通</strong>信，某一时间段内只能实现单向的传输。如果<strong>要实现双向同时通信</strong>，则需要<strong>设置两个管道</strong>。</li>
<li>各进程要<strong>互斥地</strong>访问管道。</li>
<li>数据以<strong>字符流</strong>的形式写入管道，当<strong>管道写满</strong>时，<strong>写进程</strong>的write()系统调用将<strong>被阻塞</strong>，等待读进程将数据取走。当读进程将数据<strong>全部取走</strong>后，<strong>管道变空</strong>，此时<strong>读进程</strong>的read()系统调用将<strong>被阻塞</strong>。</li>
<li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li>
<li><strong>数据一旦被读出，就从管道中被抛弃</strong>，这就意味着<strong>读进程最多只能有一个</strong>，否则可能会有读错数据的情况。</li>
</ol>
<h4 id="脑图-3"><a href="#脑图-3" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/51.png" alt="image-20210409015059025"></p>
<h3 id="2-1-6、线程的概念、特点与多线程模型"><a href="#2-1-6、线程的概念、特点与多线程模型" class="headerlink" title="2.1.6、线程的概念、特点与多线程模型"></a>2.1.6、线程的概念、特点与多线程模型</h3><h4 id="1、什么是线程？为什么要引入线程？"><a href="#1、什么是线程？为什么要引入线程？" class="headerlink" title="1、什么是线程？为什么要引入线程？"></a>1、什么是线程？为什么要引入线程？</h4><p>进程是程序的一次执行。同一进程里不同的功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行（qq当中的视频、文字聊天、传送文件）。而且，当切换进程时，需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/52.png" alt="image-20210409021721725"></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/53.png" alt="image-20210409021850582"></p>
<h4 id="2、与进程相比，线程有什么特点？"><a href="#2、与进程相比，线程有什么特点？" class="headerlink" title="2、与进程相比，线程有什么特点？"></a>2、与进程相比，线程有什么特点？</h4><ul>
<li><p>可以把线程理解为“轻量级进程”。</p>
</li>
<li><p>引入线程前，<strong>进程既是资源分配的基本单位，也是调度的基本单位</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程是资源分配的基本单位</strong>，<strong>线程是调度的基本单位</strong>。<strong>线程也有运行态、就绪态、阻塞态</strong></p>
</li>
<li><p>在<strong>多CPU</strong>环境下，各个线程也可以分派到<strong>不同的CPU上并行</strong>地执行。</p>
</li>
<li><p><strong>线程是一个基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程是资源分配的基本单位</strong>。而<strong>线程几乎不拥有资源</strong>，只拥有极少量的资源（<strong>线程控制块TCB（Thread Control Block）、寄存器信息、堆栈等</strong>）</p>
</li>
<li><p>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p>
</li>
<li><p>进程间并发，开销很大。线程间并发，开销更小。进程间通信必须请求操作系统服务（CPU要切换到核心态），开销大。同进程下的线程间通信，无需操作系统干预，开销更小。<strong>引入线程机制后，并发带来的系统开销降低，系统并发性提升。</strong></p>
<p>注意：从属于不同进程的线程间切换，也必须请求操作系统服务！也会导致进程的切换！开销也大</p>
<p>当切换进程时，需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）</p>
<p>同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力。</p>
</li>
<li><p>从属<strong>同一进程的各个线程共享进程拥有的资源</strong>。</p>
</li>
<li><p>各个进程的内存地址空间相互独立，只能通过请求操作系统内核的帮助来完成进程间通信。</p>
</li>
<li><p>同一进程下的各个线程间共享内存地址空间，可以直接通过读/写内存空间进行通信。</p>
</li>
</ul>
<p>总结：</p>
<p>线程最小执行单位，进程最小分配资源单位。</p>
<p>进程是可拥有资源的基本单位，频繁创建撤销进程会造成很大时空开销；而线程只是独立调度和分派的基本单位，共享进程的系统资源，线程被频繁创建和撤销也不会造成太大的时空开销。那仍然是执行的一个进程，只不过同时执行一个进程里面的多个线程。有些程序语言里还有更更轻量的<strong>协程</strong>，都是为了降低并发的代价。</p>
<h4 id="3、引入线程机制后，有什么变化？"><a href="#3、引入线程机制后，有什么变化？" class="headerlink" title="3、引入线程机制后，有什么变化？"></a>3、引入线程机制后，有什么变化？</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/54.png" alt="image-20210409023101820"></p>
<p>类比：</p>
<p>切换进程运行环境：有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上<br>同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走。</p>
<h4 id="4、线程有哪些重要的属性？"><a href="#4、线程有哪些重要的属性？" class="headerlink" title="4、线程有哪些重要的属性？"></a>4、线程有哪些重要的属性？</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/55.png" alt="image-20210409023226229"></p>
<h4 id="5、线程的实现方式"><a href="#5、线程的实现方式" class="headerlink" title="5、线程的实现方式"></a>5、线程的实现方式</h4><ul>
<li><p>用户级线程（User-Level Thread, ULT）</p>
<p>用户级线程由应用程序通过线程库实现。</p>
<p>所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</p>
<p>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</p>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（<strong>用户级线程对用户不透明，对操作系统透明</strong>）</p>
<p>可以这样理解，<strong>“用户级线程”就是“从用户视角看能看到的线程”</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png" alt="image-20210409024313592"></p>
</li>
<li><p>内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）</p>
<p>内核级<strong>线程的管理工作</strong>由<strong>操作系统内核完成</strong>。</p>
<p>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</p>
<p>可以这样理解，<strong>“内核级线程”就是“从操作系统内核视角看能看到的线程”</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png" alt="image-20210409024248522"></p>
</li>
</ul>
<p>线程的实现方式：</p>
<p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：<strong>将n个用户级线程映射到m个内核级线程上（n &gt;= m）</strong></p>
<p><strong>重点重点重点：</strong> <strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<p>例如：下边这个模型中，该进程由两个内核级线程，三个用户级线程，在<strong>用户</strong>看来，这个进程中有<strong>三个线程</strong>。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到<strong>两个核</strong>，最多只能有两个用户线程并行执行。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png" alt="image-20210409024124625"></p>
<h4 id="6、多线程模型"><a href="#6、多线程模型" class="headerlink" title="6、多线程模型"></a>6、多线程模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p>
<ul>
<li><p>多对一模型：</p>
<p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png" alt="image-20210409024313592"></p>
</li>
<li><p>一对一模型：</p>
<p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png" alt="image-20210409024248522"></p>
</li>
<li><p>多对多模型</p>
<p>n 用户及线程映射到m 个内核级线程（n &gt;= m）。每个用户进程对应m 个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png" alt="image-20210409024124625"></p>
</li>
</ul>
<h4 id="脑图："><a href="#脑图：" class="headerlink" title="脑图："></a>脑图：</h4><p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/56.png" alt="image-20210409024100247"></p>
<h3 id="2-2-1、处理机调度的概念、层次"><a href="#2-2-1、处理机调度的概念、层次" class="headerlink" title="2.2.1、处理机调度的概念、层次"></a>2.2.1、处理机调度的概念、层次</h3><p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH">bilibili王道考研</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gl620321/article/details/107128661">操作系统思维导图—（零基础—思维导图详细版本及知识点）</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">http://xgh-user.github.io/2021/04/19/操作系统/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%E5%8F%8A%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第一章 操作系统引论及概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1%E3%80%81%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="nav-number">1.1.</span> <span class="nav-text">1.1.1、概念、功能与目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="nav-number">1.2.</span> <span class="nav-text">1.1.2、操作系统的四个特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">1.1.3、操作系统的发展与分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">1.1.4、操作系统的运行机制与体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">1.5.</span> <span class="nav-text">1.1.5、中断与异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-6%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">1.1.6、系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">第一章总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">第二章 进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E4%B8%8E%E7%89%B9%E5%BE%81"><span class="nav-number">2.1.</span> <span class="nav-text">2.1.1、进程的概念、组成与特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E2%80%94%E2%80%94%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B8%8A%EF%BC%8C%E2%80%9D%E8%BF%9B%E7%A8%8B%E2%80%9D%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E8%80%8C%E8%A2%AB%E5%BC%95%E5%85%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1、进程的发展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2、进程的定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BB%84%E6%88%90%E2%80%94%E2%80%94%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、组成——每个进程由哪些部分组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、组织方式——系统中的各个进程之间是如何被组织起来的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E7%9B%B8%E6%AF%94%E4%BA%8E%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E5%BE%81"><span class="nav-number">2.1.4.</span> <span class="nav-text">4、特征——相比于程序，进程有什么特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%91%E5%9B%BE"><span class="nav-number">2.1.5.</span> <span class="nav-text">脑图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">2.1.2、进程的状态与转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、进程状态间的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%91%E5%9B%BE-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">脑图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">2.1.3、进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">1、什么是进程控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94%E5%8E%9F%E8%AF%AD"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">2、如何实现进程控制——原语</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="nav-number">2.3.2.</span> <span class="nav-text">2、进程控制相关的原语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%91%E5%9B%BE-2"><span class="nav-number">2.3.3.</span> <span class="nav-text">脑图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">2.4.</span> <span class="nav-text">2.1.4、进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、共享存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、消息传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、管道通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%91%E5%9B%BE-3"><span class="nav-number">2.4.4.</span> <span class="nav-text">脑图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-6%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%89%B9%E7%82%B9%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">2.1.6、线程的概念、特点与多线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">1、什么是线程？为什么要引入线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E6%AF%94%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">2.5.2.</span> <span class="nav-text">2、与进程相比，线程有什么特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E5%90%8E%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="nav-number">2.5.3.</span> <span class="nav-text">3、引入线程机制后，有什么变化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="nav-number">2.5.4.</span> <span class="nav-text">4、线程有哪些重要的属性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.5.5.</span> <span class="nav-text">5、线程的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.6.</span> <span class="nav-text">6、多线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%91%E5%9B%BE%EF%BC%9A"><span class="nav-number">2.5.7.</span> <span class="nav-text">脑图：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="nav-number">2.6.</span> <span class="nav-text">2.2.1、处理机调度的概念、层次</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
