<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] JVM上篇：内存与垃圾回收1、JVM与Java体系结构1、关于Java与JVMJava：跨平台的语言  JVM：跨语言的平台  2、字节码随着JDK7.0的正式发布，JVM平台上运行非Java语言编写的程序。 JVM根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://xgh-user.github.io/2021/04/19/JVM/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] JVM上篇：内存与垃圾回收1、JVM与Java体系结构1、关于Java与JVMJava：跨平台的语言  JVM：跨语言的平台  2、字节码随着JDK7.0的正式发布，JVM平台上运行非Java语言编写的程序。 JVM根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420004314261.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420010019562.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420011524768.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420013453679.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420231839277.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420161504521.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420232214018.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420232257344.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210420234046557.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421005041972.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421005632840.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421012614177.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421011954294.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421103744316.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421105124634.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421112837894.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421113146594.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421114556021.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422000432697.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421201053065.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422001738599.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422001753431.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421202826450.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422005102514.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422012357234.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422013552022.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422013326303.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422014055436.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422014347776.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/blog/XGH-blog/source_posts/JVM/image-20210422014445720.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422014706947.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422013442292.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A0%88%E6%A1%A2.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422173049395.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422180804881.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422181213595.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422181755767.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422182334511.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422193112649.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422193542032.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422200200175.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422201450476.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422202145932.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422204325546.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422211053093.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422210316458.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422210545629.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422210620080.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422210641231.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422210655579.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422213416813.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422225120851.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422225328056.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422225533000.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210422225747189.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423004042185.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423090739894.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423094103986.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423155400525.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423160441505.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423165450302.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E8%8A%82.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423173418189.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423181733858.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423191247043.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423192127797.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210423195836487.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_TLAB.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424010349347.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424010520101.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424010921229.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424014427319.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424014940690.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424015216603.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424020826940.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424020942369.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424024056293.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424024352733.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424030341079.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424030544494.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424165338137.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424165401780.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424165459908.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82-hotspot.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424172219770.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC09%E7%AB%A0_%E5%B0%8F%E7%BB%93.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424193206898.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%9B%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424190106896.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424225618054.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424225837934.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424231245461.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210424231440926.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425022648722.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425005150269.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425005213179.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425005819291.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-1619284091715.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425020914156.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425021622259.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425022648722.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425024022961.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425024857559.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425031931789.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425030403484.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425030645445.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425213811970.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425214013347.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425215451317.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425221328973.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425221607026.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425221622886.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210425221651006.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426012219855.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426020658942.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426022637283.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426022851422.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426032250932.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426032752667.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426115438284.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426180331460.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426203337926.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426204015295.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426210515944.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426210824260.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426214539114.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426220319212.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426220439764.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426221159953.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426223157917.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426223406880.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/blog/XGH-blog/source_posts/JVM/image-20210426223532525.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426223639192.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426224059101.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426224309986.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/blog/XGH-blog/source_posts/JVM/image-20210426224832591.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210426225204897.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427010211524.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427023448226.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427112323264.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427230217504.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427231222179.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427231302158.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427231437839.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427231919364.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427233208635.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428093616812.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428093737403.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428111017627.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428111338892.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428111925067.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210428112108819.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429023423991.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429024547757.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429023609239.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429085028563.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429085347499.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429090344976.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429095659541.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429235305962.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430001836775.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430002300492.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429185519798.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/blog/XGH-blog/source_posts/JVM/image-20210430003324501.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430003008242.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429194133565.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430011457790.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430011551243.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430012224983.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429231614446.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430015133115.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430015758548.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210430015925777.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429233231323.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210504004503138.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210504005333757.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518205703047.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518205820353.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518205932030.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518205941131.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518215156842.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518215729244.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518215755492.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518220102931.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210518221159306.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210504010005360.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210519000727861.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210519001523659.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210519001835589.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210519012259460.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210519013853054.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1598773300484.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1598773308492.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/FA74699C-FC7C-4A8D-AAA9-989BDD67D75A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/53F23FBD-4E40-40C7-BC77-5E3E90AC27A1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520022957097.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520023638002.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520023707476.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520024314713.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520024520373.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520024729855.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520024834421.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520025014700.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520030031188.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520030243299.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520031140075.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520222930557.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520222944844.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520223454201.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520223508191.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520224306556.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210520234851493.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/566B9397-5AFE-4A3F-9E17-9EBF504DFC80.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/B59702D2-4C93-44DF-87F1-01A5DFE53B61.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521000606437.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/DD6CCB19-DEDB-426F-815A-A5769ED22E62-1621527103113.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521002838645.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/83FDD717-E615-45C8-B2E2-31C5CEB2BA4E.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521004835960.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521005146519.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A54C2AC8-DD36-49F4-A49D-9AFD725E8365.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C43C0407-020F-4EC4-BD27-E4C109640B39.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/04282DF1-4E52-4C3D-A47B-84023159B624.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521011319549.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521014725284.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521020635532.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521031608842.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521032029716.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521033428524.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521034806188.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521171308285.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521171926923.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521200452707.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521200909546.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521223947568.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521230336692.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521232741411.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210521234455626.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522000649232.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522001143999.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522002407044.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522001304745.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522003748294.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522004730384.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522005055555.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522005743194.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522014446997.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CB2FC208-C399-498F-A44E-60E015AAA9A8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522014923019.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/89118A6D-DA70-49FA-8E4C-703C21994488.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522020333543.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522021858220.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/5CBBB95D-5AFB-4876-BF22-D846C36D942D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522024144096.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EBE13A8E-3107-47D5-9296-C66C49553C0A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9AClass%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E7%9A%84%E6%A3%80%E6%9F%A5.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522144342032.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210522204628093.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E899EC31-01FB-484E-9894-40E777C0B08A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523011825913.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A45F46DE-73EC-4B6B-BCD1-9BAB9DE15C51.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/4D382A73-1DF4-4223-9CB9-C7B45D8071A9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523150158667.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523150646271.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523152412581.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523152438385.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C38CE122-2D25-4E14-B5BE-220FDBDEF84A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C9DD335C-6A70-45A3-9091-431DA8C2FBCD.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523152834151.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523155350716.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/15C91D65-CF15-467B-877A-FBF37796246D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/DE7EBEFA-D191-4069-B6C9-B88FE6071584.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/blog/XGH-blog/source_posts/JVM/image-20210523155305052.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/54EBA795-A6B6-42D4-AEA2-97DB51CBBC26.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523193421376.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/20200924233838830.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2020092423393671.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/20200924234038891.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210523221840016.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/0979521B-B4F6-4FA9-AE69-99F740449416.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210421103744316.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524135243252.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524154710225.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/d62a6059252dd42a4c0e5baa0c9d2bb3c8eab8dc.jpeg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/902397dda144ad34bc59b9aadd047cf230ad8561.jpeg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/72f082025aafa40f5bae9f15a6c2734979f0193d.jpeg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/dbb44aed2e738bd4035b63a7ac2df7d0267ff95f.jpeg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%83%AD%E6%9B%BF%E6%8D%A2.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524160050558.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524160203739.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524160319450.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524160541465.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524172221156.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/29CF69BE-5F92-444B-82CE-6B1AE51C023D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524173906468.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524174130765.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210524174026119.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712014649029.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712021836021.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712021909775.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024008753.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024035710.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024528755.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024311552.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024430556.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024613610.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712024715127.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712025059507.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712025219254.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712022534826.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C0FE3B08-B6B9-4FF1-AB1A-CEEDCB5EFECF.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712225650046.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231844604.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712234001136.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712234235632.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231535247.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231557164.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712230907909.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712230944650.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231131085.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231246385.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CB135068-C793-480B-9070-B48159AC6BC1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210712231441369.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713000744298.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/4512D1D8-6DD0-4602-A589-8F076993F3AB.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/0FD1835A-DCB5-436F-9D51-650D789F530F.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001051530.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001449847.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001553125.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001642300.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001929389.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713003354636.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713010601073.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713012001093.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713012319564.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713012602069.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713012043421.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713012836602.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713015031277.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713020055637.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713020318845.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713020411853.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713022747670.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713023139008.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713025908544.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713030226778.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713030341435.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713030512538.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713034508974.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CAAD6BF7-147F-4BA5-9FCF-D2C3CE80AEB4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/jstatd%E7%9A%84%E7%90%86%E8%A7%A3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A0E6C592-F80C-46EF-9CD8-23255A6B1345.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/868C881D-5F82-440F-B003-DD32C76BFF1D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D561C7B9-0F68-4DFC-AEB1-5F2526224F7D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/BE7AB453-2FD4-4173-A849-7D3848CB8076.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/325B8E74-20E5-4289-A7C6-145D73501D7E.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716160243770.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1F2A8CD4-75F7-48CF-8009-88508BDAB8C9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E617AFA7-4D51-41B9-97D4-2DA665C649B0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/799061CC-841C-475A-8B05-9DB923786A25.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713172559297.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713173016278.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/7A9DB07F-B142-443B-AE82-3D622F681CBB.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2E657142-FEFF-46CA-9772-630EF5F6625B.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/341C9DA7-8275-45B7-B3E3-4FBF924B3C14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CE28D8DD-9A19-493F-95F7-9BD7B90988F3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CBC75128-C200-4DE3-A4B0-5DB55CB31DB5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C05DD49F-02F5-4718-87FD-0FB5823860BD.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A441FACD-AAB9-4EC2-B81E-3413BF211421.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/ED1AC2B2-9CF5-41BD-A261-9C7685316D70-1626169886879.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716164337161.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1FCBDF6F-9E41-4631-A0F8-9032E3B610F7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EBBFD997-9D8C-4B7C-BEAE-763BD685E5C3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/77171DE3-C335-4934-B071-4567BCB30DB9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E882B309-4E74-4877-B6F0-D6A0EE176B71.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716162615803.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716163047115.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716163251126.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716163651100.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716163925557.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713175646382.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713175744891.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713180221126.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713180452468.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716175656605.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716175803107.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716180242326.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716180320235.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/B41B4FEA-D55D-442D-A163-E5D7F1BFC720.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EC747FF8-CCC3-4F57-8C68-59E5819C76A4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D4FED4A9-A16E-4E4A-9ECB-69986F952F89.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716183006378.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716181822026.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716182152051.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716182746036.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716182455029.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/87E5409D-B6AA-40E5-B033-6E92EB196C96.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/287C8259-7835-4EF6-A81E-7C369B8D3336.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716223222052.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716223315860.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716223613860.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716223803061.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716224553500.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716225637523.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716230023991.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716230040409.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E9E4312D-A369-4C56-B612-DF6C90BD9A18.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/9D534AD4-631B-4D78-865B-C793FC61B7C6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716232006164.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/ECADFB9B-708C-4CCC-82C5-8ECDFC6C8E98.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/F9D58850-F866-4BA6-B5FB-B8508276B4C6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1EE1EDA8-FE05-4FBA-8D19-2518FCFCFD32.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/9BA2E3BF-8700-4610-8A4D-45A3B662ACB1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713181653120.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713182436604.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713182530946.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/69656EBC-5090-4781-A02A-E1584AC06230.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713185747798.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210714000259424.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210714000337354.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717034430939.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717034529989.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717034627788.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717034749850.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717034836025.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C5ECFB6C-0D51-4735-964B-53A8E96BA1FB.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D6A4483C-4844-4025-A499-C0A2AAC65C9E.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2E17C8C1-34ED-48A7-BDAA-3CB7AC33C1A6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/57EE2C6A-DB93-46D3-9BD4-36799EA74836.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210716181538800.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717185256510.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717190718552.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717195706559.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/53F0D68B-B76A-42C8-B206-FBFBD8E96F86.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/7CCE5194-2D54-498E-A2B7-F2C52CB9FA44.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2A83AB30-9586-4BA2-83C3-2CACA634B79B.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2E384249-A75D-4F05-8921-D09FD08873D9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/B8B68437-CC8B-4DA5-A498-4F8F784656B6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/74BCBC29-1574-45C9-9DAD-B02B2D93493C.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A496B566-DFF9-41E6-9F7E-C4665BF3D95C.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D2914CF9-9808-4C59-BADE-9C9ADBCAB41E.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/947592B8-3F3F-4A6F-93BD-5443EB76F603.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D3C2F36C-E12B-45D2-8FA4-F9D8E4F95625.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717220513329.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717221829151.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/85704C41-F30E-4ED9-B48B-605C3102B485.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717192307939.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717223524175.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C1C2C2AB-C31F-41A5-B0D2-7335030ECD2A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/64A630C1-126E-4C35-8088-4EEDDCF63FAE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/1677A939-BCE7-45BC-901F-9BDA9846910D.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/A3E2654E-81FF-4912-A588-549D817C69E0.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717224343240.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717224827793.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717225913334.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/01B9832E-145E-485B-A877-6B6395B7FAA1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/5FC6EA0C-FAF0-455C-94B6-8D9736E52657.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/510A019F-0C86-47FD-AC0B-CFEBC1B6C91C.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/62CB25DD-4C43-4B99-ADA7-00D4C52B1130.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C7A7BFF7-D6E6-49D4-8718-4AADD60A24B3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E54DCC19-FD9D-4BC6-8A3A-45CED67B278B.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/6D1D07AA-AC1C-4F26-8321-3A554F3B2F86.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/F80A4EC9-9AF9-4DA1-8DDE-7442F34754CE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/3A3BE60F-7FC9-473B-B793-9B9C12186B0C.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CC9DBA1E-B6B1-4497-A27F-A2043E47E6B8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C2335263-0DE6-4351-9B4A-F2DACE4AEDC3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718010802170.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718010823344.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718011032691.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718011406059.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718011816040.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718012104569.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718012307430.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718012842725.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718014201542.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718004243898.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718014942945.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718015103331.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718021714996.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718022620212.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/71F5A9C6-31CB-44AA-9414-D64D25F5098E.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/5CCE5317-A223-4B43-8A31-4CC35A5F0EC4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/44614069-2B6C-46F1-BC08-8CEDB3552550.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/56BF6BA6-FBD4-4C2A-B38C-26DD8CD63E8F.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/E8EE12B7-FE3F-4D17-ACB6-7D9C7E06AB59.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EF74F519-69A7-4D42-B255-1B7FF4F59208.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718170905047.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718171442960.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718171510051.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EE0FD730-64E5-4F07-8D0B-CF2B7F6ECA8A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/71F0F847-36CE-409F-8690-4D69E5ADB552.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CE8E8DE1-00EC-45C4-AE5C-7B6E888F3748.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/F2A47ADC-177C-4723-923E-48D654D2CCA9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/DA9DF354-EF7F-481E-B1EA-C45D418E9327.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/CEF36242-1EB0-44E8-96E9-60E3A729C56F.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/5F2A69FF-BDBE-44D2-912E-81CB6E7782A2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718172030880.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210427230217504.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717171640356.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717180541120.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717181048650.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717181439315.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717182307112.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210717182357403.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/C4BC430D-C575-40EC-81F0-44DE723F0EAD.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718175015752.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718175046637.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/BD46C8BE-6B93-4AE0-B6D0-C54B879E31AB.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718175909651.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/D8A89BF9-18A3-4BB3-AB4F-7AD2D776F826.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/61F43F0D-E803-40ED-8D01-3C51769DD3EE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/963D0947-69DB-4F67-B746-3E2670B13071.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210718181620379.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/098406BB-FB1F-4DC0-AE87-81C6ECBE6B00.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/EA52A159-CB0B-4104-9C2C-86579C2B2F3A.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/8432A5D7-B42B-4DD9-AADD-AC996FD9BE0B.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/0C60AA58-6366-4085-BA1D-FF92EA6AF335.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001449847.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/10326F84-0DAE-4D29-867E-C38676FC36D5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210713001051530.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429024547757.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429023609239.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210429023609239.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719003357660.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719003357660.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719003601948.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2B360717-915B-414F-8897-127B432CD616.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/96A76B65-8305-4A60-A695-F7079E5BAE03.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/2C4F1339-2902-48E6-B298-B5F19C8C93D7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/DCEA1B70-2B04-4F80-9425-9F037465D0BB.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719004842828.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719011748465.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719011823127.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719011929852.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719012024393.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719024156110.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719025413453.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/04/19/JVM/image-20210719025515161.png">
<meta property="article:published_time" content="2021-04-18T19:10:19.000Z">
<meta property="article:modified_time" content="2021-07-18T19:14:36.412Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg">

<link rel="canonical" href="http://xgh-user.github.io/2021/04/19/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 03:10:19" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-19 03:14:36" itemprop="dateModified" datetime="2021-07-19T03:14:36+08:00">2021-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="上篇：内存与垃圾回收"><a href="#上篇：内存与垃圾回收" class="headerlink" title="上篇：内存与垃圾回收"></a>上篇：内存与垃圾回收</h2><h3 id="1、JVM与Java体系结构"><a href="#1、JVM与Java体系结构" class="headerlink" title="1、JVM与Java体系结构"></a>1、JVM与Java体系结构</h3><h4 id="1、关于Java与JVM"><a href="#1、关于Java与JVM" class="headerlink" title="1、关于Java与JVM"></a>1、关于Java与JVM</h4><p>Java：跨平台的语言</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<p>JVM：跨语言的平台</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<h4 id="2、字节码"><a href="#2、字节码" class="headerlink" title="2、字节码"></a>2、字节码</h4><p>随着JDK7.0的正式发布，JVM平台上运行非Java语言编写的程序。</p>
<p>JVM根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含JVM的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong>。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联， Class文件中包含了JVM指令集(或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。</p>
<h4 id="3、多语言混合编程"><a href="#3、多语言混合编程" class="headerlink" title="3、多语言混合编程"></a>3、多语言混合编程</h4><p><strong>Java平台上的多语言混合编程</strong>正成为主流，<strong>通过特定领域的语言去解决特定领域的问题</strong>是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>例如：在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</strong>。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进(如DaVinci Machine项目、 Nashorn引擎、InvokeDynamic指令、java. lang. invoke包等)，<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展</strong>。</p>
<h4 id="4、虚拟机与JVM（java虚拟机）"><a href="#4、虚拟机与JVM（java虚拟机）" class="headerlink" title="4、虚拟机与JVM（java虚拟机）"></a>4、虚拟机与JVM（java虚拟机）</h4><h5 id="1、什么是虚拟机"><a href="#1、什么是虚拟机" class="headerlink" title="1、什么是虚拟机"></a>1、什么是虚拟机</h5><p>所谓虚拟机(Virtual Machine)，就是一台虚拟的计算机，它是<strong>一款软件</strong>，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>大名鼎鼎的Visual Box, VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它<strong>专门为执行单个计算机程序而设计</strong>，在Java虛拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>但无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h5 id="2、JVM（java虚拟机）"><a href="#2、JVM（java虚拟机）" class="headerlink" title="2、JVM（java虚拟机）"></a>2、JVM（java虚拟机）</h5><p>JVM是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享JVM带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p><strong>Java技术的核心就是Java虚拟机</strong>(JVM，Java Virtual Machine) ,因为所有的Java程序都运行在JVM内部。</p>
<h5 id="3、JVM的作用"><a href="#3、JVM的作用" class="headerlink" title="3、JVM的作用"></a>3、JVM的作用</h5><p><strong>JVM就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h5 id="4、JVM的特点"><a href="#4、JVM的特点" class="headerlink" title="4、JVM的特点"></a>4、JVM的特点</h5><ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p>带来的好处：</p>
<ul>
<li>从代码层面：降低了内存泄漏与内存溢出的风险</li>
<li>从程序员层面：让程序员将自己对重心放在业务层面，不用再去手动地进行垃圾回收</li>
</ul>
<p>带来的坏处：</p>
<ul>
<li>降低了对程序员对要求，当出现内存方面的问题时不能有效解决。</li>
</ul>
<h5 id="5、JVM的位置"><a href="#5、JVM的位置" class="headerlink" title="5、JVM的位置"></a>5、JVM的位置</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt="第01章_JVM所处位置"></p>
<p><strong>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</strong></p>
<p><strong>JVM模拟的是系统</strong>，在不同系统之上，构建了一个统一的系统平台。所以在安装JDK的时候要关注JDK是安装在哪个操作系统上，因为不同的操作系统上安装的JVM是不同的。</p>
<p>JDK的构成：下图来自JDK8官网。</p>
<p><img src="/2021/04/19/JVM/image-20210420004314261.png" alt="image-20210420004314261"></p>
<p>java程序想要正确运行需要经历两个过程：</p>
<ul>
<li>java文件 –(编译)–&gt; class字节码文件：使用的编译器为：前端编译器。典型：javac</li>
<li>class字节码文件–(解释)–&gt; 二进制文件：运行。解释会用到：Java SE API 还有后端编译器（将class字节码文件编译为二进制文件）（后端编译器在JVM当中）</li>
</ul>
<h4 id="5、JVM的整体结构"><a href="#5、JVM的整体结构" class="headerlink" title="5、JVM的整体结构"></a>5、JVM的整体结构</h4><p>HotSpotVM是目前市面上高性能虚拟机的代表作之一。</p>
<p>它采用<strong>解释器与即时编译器并存的架构</strong>。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C+ +程序一较高下的地步。</p>
<p>JVM的架构简图：程序的解释运行图</p>
<p><img src="/2021/04/19/JVM/image-20210420010019562.png" alt="第02章_JVM架构-简图"></p>
<p>其中将其分成三层：</p>
<ol>
<li><p>上层：class字节码文件进入类装载器子系统（Class loader），将class字节码文件加载到内存当中，生成一个大的class对象。这个过程中会涉及到：</p>
<ol>
<li>加载</li>
<li>链接（分成三步）</li>
<li>初始化</li>
</ol>
</li>
<li><p>中层：</p>
<ul>
<li><strong>方法区和栈是多线程共享</strong></li>
<li><strong>（Java栈（本地方法栈），本地方法栈，程序计数器是每个线程独有一份</strong></li>
</ul>
</li>
<li><p>下层：把字节码文件加载到内存以后，就可以进行解释运行了。执行引擎（Execution Engine），有三部分内容：</p>
<ol>
<li><p>解释器（Interpreter）：<strong>负责字节码文件的解释运行</strong>。<strong>主要保证程序执行的响应时间</strong></p>
</li>
<li><p>及时编译器（JIT Compiler）：对于反复运行的热点代码进行提前的<strong>编译缓存</strong>。及时编译器又叫做<strong>后端编译器</strong>，用来<strong>将字节码文件字节码指令编译成操作系统能读懂的机器指令</strong>。（高级语言-&gt;机器语言）<strong>主要负责程序的执行性能</strong>。</p>
</li>
<li><p>垃圾回收器（Garbage Collection，简称GC）：实现<strong>垃圾的自动回收</strong></p>
<p><img src="/2021/04/19/JVM/image-20210420011524768.png" alt="image-20210420011524768"></p>
</li>
</ol>
</li>
</ol>
<h4 id="6、Java代码的执行流程"><a href="#6、Java代码的执行流程" class="headerlink" title="6、Java代码的执行流程"></a>6、Java代码的执行流程</h4><p><img src="/2021/04/19/JVM/image-20210420013453679.png" alt="image-20210420013453679"></p>
<h4 id="7、JVM的架构模型"><a href="#7、JVM的架构模型" class="headerlink" title="7、JVM的架构模型"></a>7、JVM的架构模型</h4><p>Java编译器输入的指令流基本上分为两种：</p>
<ul>
<li>是一种<strong>基于栈的指令集架构</strong></li>
<li>另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</li>
</ul>
<p>两种架构的区别：</p>
<ul>
<li>基于栈式架构的特点：<ul>
<li>设计和实现更简单，<strong>适用于资源受限的系统</strong>；</li>
<li>避开了寄存器的分配难题：使用<strong>零地址指令方式分配</strong>;</li>
<li>指令流中的指令<strong>大部分是零地址指令</strong>，其执行过程依赖于操作栈。<strong>指令集更小</strong>，编译器容易实现。</li>
<li><strong>不需要硬件支持，可移植性更好，更好实现跨平台</strong></li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虛拟机；</li>
<li>指令集架构则<strong>完全依赖硬件，可移植性差</strong></li>
<li><strong>性能优秀</strong>和<strong>执行更高效</strong>;</li>
<li>花费<strong>更少的指令去完成一项操作</strong>。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<ul>
<li>优点是<strong>跨平台， 指令集小，编译器容易实现</strong></li>
<li>缺点是<strong>性能下降，实现同样的功能需要更多的指令</strong></li>
</ul>
</li>
<li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了(准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了)，那么为什么不将架构更换为基于寄存器的架构呢?<ol>
<li>基于栈式的架构<strong>在设计与实现上</strong>比基于寄存器架构的设计要<strong>简单</strong></li>
<li>基于栈式的架构<strong>在非资源受限的场景当中也是可以使用</strong>的</li>
<li>主要还是因为<strong>栈式架构可以实现跨平台</strong>，而基于寄存器架构由于与硬件的耦合度太高，不能实现跨平台。</li>
</ol>
</li>
</ul>
<h4 id="8、JVM的生命周期"><a href="#8、JVM的生命周期" class="headerlink" title="8、JVM的生命周期"></a>8、JVM的生命周期</h4><h5 id="1、虚拟机的启动"><a href="#1、虚拟机的启动" class="headerlink" title="1、虚拟机的启动"></a>1、虚拟机的启动</h5><p>Java虛拟机的启动是通过<strong>引导类加载器(bootstrap class loader) 创建一个初始类(initial class) 来完成</strong>的，这个类是由虚拟机的具体实现指定的。</p>
<p>程序的执行：主方法（main）所在类加载到内存当中。而自定义的类的加载是通过系统类加载器（应用类加载器）实现的。由于<strong>父类的加载要早于子类</strong>，这就导致了java虚拟机的启动，创建一个初始类(initial class) ,然后调用初始类（initial class）当中的main方法，在这main方法当中使用其他的一些类来相继地加载后继的所有类。</p>
<p>类加载器分成：</p>
<ul>
<li>引导类加载器（负责超类的加载（如Object））</li>
<li>扩展类加载器</li>
<li>系统类加载器（负责自定义类的类加载）</li>
<li>启动类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
<h5 id="2、虚拟机的执行"><a href="#2、虚拟机的执行" class="headerlink" title="2、虚拟机的执行"></a>2、虚拟机的执行</h5><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：<strong>执行Java程序</strong>。</li>
<li><strong>程序开始执行</strong>时他才<strong>运行</strong>，<strong>程序结束</strong>时他就<strong>停止</strong>。</li>
<li>执行一个所谓的Java程序的时候，真真正正在<strong>执行的是一个叫做Java虛拟机的进程</strong>。</li>
</ul>
<h5 id="3、虚拟机的退出"><a href="#3、虚拟机的退出" class="headerlink" title="3、虚拟机的退出"></a>3、虚拟机的退出</h5><p>有如下的几种情况：</p>
<ul>
<li>程序<strong>正常执行结束</strong></li>
<li>程序<strong>在执行过程中遇到了异常或错误</strong>而异常终止</li>
<li>由于<strong>操作系统出现错误而导致Java虛拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或System类的exit方法</strong>，或<strong>Runtime类的halt方法</strong>，并且<strong>Java安全管理器也允许这次exit或halt操作</strong>。</li>
<li>除此之外，JNI ( Java Native Interface) 规范描述了<strong>用JNI Invocation API来加载或卸载Java虚拟机</strong>时，Java虚拟机的退出情况。</li>
</ul>
<h4 id="9、JVM的发展历程"><a href="#9、JVM的发展历程" class="headerlink" title="9、JVM的发展历程"></a>9、JVM的发展历程</h4><h5 id="1、Sun-Classic-VM（SUN）"><a href="#1、Sun-Classic-VM（SUN）" class="headerlink" title="1、Sun Classic VM（SUN）"></a>1、Sun Classic VM（SUN）</h5><p>Sun公司发布的<strong>世界上第一款商用Java虚拟机</strong>，在JDK1.4时被完全淘汰。</p>
<p>这款虚拟机内部<strong>只提供解释器</strong>。</p>
<p>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。（<strong>两者只能存一</strong>）</p>
<ul>
<li>只使用解释器：当代码中重复的代码多（如循环等等）的时候执行效率低</li>
<li>只使用JIT编译器：由于将字节码文件当中字节码指令编译成机器指令进行缓存也是需要时间的。这就导致了程序启动时间过长，加上占用的缓存空间有限。</li>
</ul>
<p>现在<strong>hotspot内置了此虚拟机</strong>。</p>
<h5 id="2、Exact-VM（SUN）"><a href="#2、Exact-VM（SUN）" class="headerlink" title="2、Exact VM（SUN）"></a>2、Exact VM（SUN）</h5><p>为了解决上一个虚拟机问题，JDK1.2时， sun提供了此虚拟机。</p>
<p>Exact Memory Management：<strong>准确式内存管理</strong></p>
<ul>
<li>也可以叫Non-Conservative/ Accurate Memory Management</li>
<li><strong>虚拟机可以知道内存中某个位置的数据具体是什么类型。</strong></li>
</ul>
<p>具备现代高性能虚拟机的雏形</p>
<ul>
<li><strong>热点探测</strong></li>
<li><strong>编译器与解释器混合工作模式</strong></li>
</ul>
<p>只在Solaris平台短暂使用，其他平台上还是classic vm。最终被Hotspot虚拟机替代</p>
<h5 id="3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）"><a href="#3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）" class="headerlink" title="3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）"></a>3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）</h5><p>JDK1.3时，HotSpot VM成为默认虚拟机</p>
<p>目前<strong>Hotspot占有绝对的市场地位</strong>：</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是<br>HotSpot</li>
<li>Sun/Oracle JDK和OpenJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虛拟机都是HotSpot，相关机制也主要是指<strong>HotSpot的GC机</strong><br><strong>制</strong>。(比如<strong>其他两个商用虚拟机都没有方法区的概念</strong>)</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li><strong>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</strong></li>
<li>通过<strong>编译器与解释器协同工作</strong>，<strong>在最优化的程序响应时间与最佳执行性能中取得平衡</strong></li>
</ul>
<h5 id="4、JRockit（三大虚拟机之一）（BEA-Oracle）"><a href="#4、JRockit（三大虚拟机之一）（BEA-Oracle）" class="headerlink" title="4、JRockit（三大虚拟机之一）（BEA\Oracle）"></a>4、JRockit（三大虚拟机之一）（BEA\Oracle）</h5><p><strong>专注于服务器端应用</strong></p>
<ul>
<li>它可以不太关注程序启动速度，因此<strong>JRockit内部不包含解析器实现</strong>，全部代码<strong>都靠即时编译器编译</strong>后执行。</li>
</ul>
<p>大量的行业基准测试显示，<strong>JRockit JVM是 世界上最快的JVM</strong>。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50号)</li>
</ul>
<p>优势：<strong>全面的Java运行时解决方案组合</strong></p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案：<strong>JRockit Real Time</strong>提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li><strong>MissionControl服务套件</strong>：它是一组以极低的开销来监控、管理和分析生产<br>环境中的应用程序的工具。<ul>
<li>JDK Mission Control（JMC）（Oracle公司整合）(主要是用来监控内存泄漏)<ul>
<li>内存泄漏监测器</li>
<li>JVM运行时分析器</li>
<li>管理的控制台</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2008年，BEA被Oracle收购。</p>
<p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<h5 id="5、J9（三大虚拟机之一）（IBM）"><a href="#5、J9（三大虚拟机之一）（IBM）" class="headerlink" title="5、J9（三大虚拟机之一）（IBM）"></a>5、J9（三大虚拟机之一）（IBM）</h5><p>全称: IBM Technology for Java Virtual Machine， 简称IT4J，内部代号: J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等<strong>多用途VM</strong>，广泛用于IBM的各种Java产品。</p>
<p>目前，<strong>有影响力的三大商用服务器之一</strong>，也号称是世界上最快的Java虚拟机（在使用自己家产品时）。</p>
<p>2017年左右，IBM发布了开源J9 VM，命名为openJ9，交给Eclipse基金会管理，也称为Ecilpse OpenJ9</p>
<h5 id="6、KVM和CDC-CLDC-Hotspot"><a href="#6、KVM和CDC-CLDC-Hotspot" class="headerlink" title="6、KVM和CDC/ CLDC Hotspot"></a>6、KVM和CDC/ CLDC Hotspot</h5><p>Oracle在Java ME产品线上的两款虚拟机为: CDC/CLDC HotSpot Implementation VM</p>
<p>KVM (Kilobyte)是CLDC- HI早期产品</p>
<p>目前移动领域地位尴尬，智能手机被Android和iOS二分天下。</p>
<p>KVM简单、轻量、高度可移植，而向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p><strong>所有的虚拟机的原则：一次编译，到处运行</strong>。</p>
<h5 id="7、Azul-VM（Azul-Systems）"><a href="#7、Azul-VM（Azul-Systems）" class="headerlink" title="7、Azul VM（Azul Systems）"></a>7、Azul VM（Azul Systems）</h5><p>前而三大“高性能Java虚拟机”使用在<strong>通用硬件平台</strong>上</p>
<p>这里Azul VM和BEA Liquid VM是与<strong>特定硬件平台绑定、软硬件配合的专有虚拟机</strong>（高性能Java虚拟机中的战斗机）<br>Azul VM是Azul Systems 公司在HotSpot基础上进行大量改进，运行于Azul Systems 公司的专有硬件Vega系统上的Java虚拟机。</p>
<p><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线</strong><br><strong>程调度等优秀特性。</strong></p>
<p>2010年，Azul Systems 公司开始从硬件转向软件，发布了自己的<strong>Zing JVM</strong>，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h5 id="8、Liquid-VM（BEA）"><a href="#8、Liquid-VM（BEA）" class="headerlink" title="8、Liquid VM（BEA）"></a>8、Liquid VM（BEA）</h5><p>高性能Java虚拟机中的战斗机</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上</p>
<p>Liquid VM即是现在的JRockit VM（Virtual Edition），<strong>Liquid VM不需要成操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</p>
<p>随着JRockit虚拟机终止开发，Liquid VM项目也停止了。</p>
<h5 id="9、Apache-Harmony（IBM和Inter）"><a href="#9、Apache-Harmony（IBM和Inter）" class="headerlink" title="9、Apache Harmony（IBM和Inter）"></a>9、Apache Harmony（IBM和Inter）</h5><p>Apache Harmony是IBM和Inter联合开发的开源JVM，受到同样开源的OpenJDK的压制。</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h5 id="10、Microsoft-JVM（Microsoft）"><a href="#10、Microsoft-JVM（Microsoft）" class="headerlink" title="10、Microsoft JVM（Microsoft）"></a>10、Microsoft JVM（Microsoft）</h5><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在Window平台下运行。但确实是当时Windows下性能最好的Java VM。</p>
<p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h5 id="11、TaobaoJVM（Alibaba）"><a href="#11、TaobaoJVM（Alibaba）" class="headerlink" title="11、TaobaoJVM（Alibaba）"></a>11、TaobaoJVM（Alibaba）</h5><p>Alibaba基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于OpenJDK HotSpot VM发布的<strong>国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机</strong>。</p>
<ul>
<li>创新GCIH （GC invisible heap）技术实现了off-heap，<strong>即将生命周期较长的java对象从heap中移到heap之外，并且GC不能管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li>
<li>GCIH中的<strong>对象还能够在多个java虚拟机进程中实现共享</strong>。</li>
<li>使用crc32指令顺序JVM intrinsic降低JNI 的调用开销</li>
<li>PMU hardware的java profiling tool 的诊断协助功能</li>
<li>针对大数据场景的ZenGC</li>
</ul>
<p>taobao NM应用在阿里产品上性能高，<strong>硬件严重依赖Intel的CPU，损失了兼容性，但提高 了性能</strong>。</p>
<p>目前已经在淘宝、天猫上线，把Oracle官方版本全部替换了。</p>
<h5 id="12、Dalvik-VM（Google）"><a href="#12、Dalvik-VM（Google）" class="headerlink" title="12、Dalvik VM（Google）"></a>12、Dalvik VM（Google）</h5><p>谷歌开发的，应用与Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik VM只能称作虚拟机，而不能称作”Java 虚拟机”，它<strong>没有遵循Java虚拟机规范</strong></p>
<p><strong>不能执行Java的Class文件</strong></p>
<p><strong>基于寄存器架构，不是jvm的栈架构</strong></p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语法编写的应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android5.0使用支持提前编译（Ahead of Time Compila，AOT）的ART VM替换了Dalvik VM</p>
<h5 id="13、Graal-VM"><a href="#13、Graal-VM" class="headerlink" title="13、Graal VM"></a>13、Graal VM</h5><p>2018年4月，Oracle Labs公开了Graal VM，号称”<strong>Run Programs Faster Anywhere</strong>“。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>Graal VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机</strong>，<strong>可以作为”任何语言”的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等。</p>
<p>支持不同语言中混合对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理：将这些语言的源代码或源代码编译后的中间格式，通过解释器转换成能被Graal VM接收的中间表示。Graal VM通过Truffle工具快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>。但是Java的软件生态没有丝毫变化。</p>
<h5 id="14、其他虚拟机"><a href="#14、其他虚拟机" class="headerlink" title="14、其他虚拟机"></a>14、其他虚拟机</h5><ul>
<li>Java Card VM</li>
<li>Squawk VM</li>
<li>JavaInJava</li>
<li>Maxine VM</li>
<li>Jikes RVM</li>
<li>IKVM.NET</li>
<li>Jam VM</li>
<li>Cacao VM</li>
<li>Sable VM</li>
<li>Kaffe</li>
<li>Jelatine JVM</li>
<li>Nano VM</li>
<li>MRP</li>
<li>Moxie JVM</li>
</ul>
<hr>
<h3 id="2、类加载器子系统（Class-Loader）"><a href="#2、类加载器子系统（Class-Loader）" class="headerlink" title="2、类加载器子系统（Class Loader）"></a>2、类加载器子系统（Class Loader）</h3><h4 id="1、内部结构概述"><a href="#1、内部结构概述" class="headerlink" title="1、内部结构概述"></a>1、内部结构概述</h4><h5 id="1、类加载器子系统作用"><a href="#1、类加载器子系统作用" class="headerlink" title="1、类加载器子系统作用"></a>1、类加载器子系统作用</h5><ul>
<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息存放与一块称为方法区的内存空间。除了类信息以外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）常量池在运行过程中加载到内存里，叫运行时常量池。</li>
</ul>
<h5 id="2、类加载器ClassLoader角色"><a href="#2、类加载器ClassLoader角色" class="headerlink" title="2、类加载器ClassLoader角色"></a>2、类加载器ClassLoader角色</h5><p><img src="/2021/04/19/JVM/image-20210420231839277.png" alt="image-20210420231839277"></p>
<ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来，根据这个文件实例化出n个一模一样的实例。</li>
<li>class file 加载到JVM中,被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt; JVM -&gt;最终成为元数据模板,此过程就要一个运输工具(类装载器Class Loader) ,扮演一个快递员的角色。</li>
</ol>
<h4 id="2、类加载器与类的加载过程"><a href="#2、类加载器与类的加载过程" class="headerlink" title="2、类加载器与类的加载过程"></a>2、类加载器与类的加载过程</h4><h5 id="1、JVM架构"><a href="#1、JVM架构" class="headerlink" title="1、JVM架构"></a>1、JVM架构</h5><p>JVM架构-简图：<br><img src="/2021/04/19/JVM/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"></p>
<p>JVM架构-详细图解（中英文）：</p>
<p><img src="/2021/04/19/JVM/image-20210420161504521.png" alt="image-20210420161504521"></p>
<h5 id="2、类加载的过程"><a href="#2、类加载的过程" class="headerlink" title="2、类加载的过程"></a>2、类加载的过程</h5><p>类加载的过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232214018.png" alt="image-20210420232214018"></p>
<p>程序加载过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232257344.png" alt="image-20210420232257344"></p>
<h5 id="3、类加载的三个阶段"><a href="#3、类加载的三个阶段" class="headerlink" title="3、类加载的三个阶段"></a>3、类加载的三个阶段</h5><h6 id="1、阶段一：Loading（加载）"><a href="#1、阶段一：Loading（加载）" class="headerlink" title="1、阶段一：Loading（加载）"></a>1、阶段一：Loading（加载）</h6><p>加载：</p>
<ol>
<li>通过一个类的<strong>全限定类名</strong>获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>。</li>
<li><strong>在内存中生成一个代表这个类的java. lang.Class对象</strong>， 作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>补充:加载.class文件的方式：</p>
<ul>
<li>从<strong>本地系统</strong>中直接加载</li>
<li>通过<strong>网络</strong>获取，典型场景: Web Applet</li>
<li>从<strong>zip压缩包</strong>中读取，成为日后jar、war格式的基础</li>
<li><strong>运行时计算生成</strong>，使用最多的是：动态代理技术（java.lang.reflect.proxy）</li>
<li>由<strong>其他文件生成</strong>，典型场景：JSP应用</li>
<li>从<strong>专有数据库</strong>中提取.class文件,比较少见</li>
<li>从<strong>加密文件</strong>中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h6 id="2、阶段二：Linking（链接）"><a href="#2、阶段二：Linking（链接）" class="headerlink" title="2、阶段二：Linking（链接）"></a>2、阶段二：Linking（链接）</h6><p><strong>验证(Verify) :</strong></p>
<ul>
<li><p>目的在于<strong>确保Class文件的字节流中包含信息符合当前虚拟机要求</strong>，<strong>保证被加载类的正确性</strong>，不会危害虚拟机自身安全。</p>
</li>
<li><p>主要包括四种验证</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
<li><p>例如：class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）</p>
<p><img src="/2021/04/19/JVM/image-20210420234046557.png" alt="image-20210420234046557"></p>
</li>
</ul>
<p><strong>准备(Prepare) ：</strong></p>
<ul>
<li>为<strong>类变量分配内存并且设置该类变量的默认初始值</strong>，即零值。</li>
<li>这里<strong>不包含用final修饰的static（即：常量）</strong>，因为final在编译的时候就会分配了，准备阶段会显式初始化。</li>
<li>这里<strong>不会为实例变量分配初始化</strong>，<strong>类变量会分配在方法区</strong>中，而<strong>实例变量是会随着对象一起分配到Java堆</strong>中。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prepare: a = 0 ---&gt; Initialization : a = 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中数据类型不同，默认初始值也就不同：</p>
<ul>
<li>整型（byte\short\int\long）：0</li>
<li>浮点型（float\double）:0.0f</li>
<li>字符型（char）：\u0000</li>
<li>布尔型（boolean）：false</li>
<li>引用类型：null</li>
</ul>
<p><strong>解析(Resolve) :</strong></p>
<ul>
<li>将<strong>常量池内的符号引用转换为直接引用</strong>的过程。</li>
<li>事实上，解析操作往往会伴随着<strong>JVM在执行完初始化之后</strong>再执行。</li>
<li>符号引用就是<strong>一组符号来描述所引用的目标</strong>。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。</li>
<li>解析动作主要针对<strong>类</strong>或<strong>接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>等。对应常量池中的CONSTANT_ Class_ info、CONSTANT Fieldref_ info、 CONSTANT Methodref_ info等。</li>
</ul>
<h6 id="3、阶段三：Initialization（初始化）"><a href="#3、阶段三：Initialization（初始化）" class="headerlink" title="3、阶段三：Initialization（初始化）"></a>3、阶段三：Initialization（初始化）</h6><p>初始化：</p>
<ul>
<li><p><strong>初始化阶段就是执行类构造器方法<clinit>()的过程</clinit></strong>。</p>
</li>
<li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并而来。</p>
<p>当不涉及到类变量的赋值动作与有关静态static（包括静态代码快、静态构造器，静态变量等等）的动作时，类构造器方法<clinit>()不会创建。</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任何一个类声明以后，内部至少存在一个类的构造器&lt;init&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210421005041972.png" alt="image-20210421005041972"></p>
</li>
<li><p>构造器方法中<strong>指令按语句在源文件中出现的顺序执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// 赋值</span></span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;  <span class="comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><clinit> ()不同于类的构造器</clinit></strong>。(关联: 构造器是虚拟机视角下的<init> ())</init></p>
<p>任何一个类声明以后，内部至少存在一个类的构造器<init>（可以是自己声明的，也可以说系统默认提供的）</init></p>
<p><img src="/2021/04/19/JVM/image-20210421005632840.png" alt="image-20210421005632840"></p>
</li>
<li><p>若该类具有父类，JVM会保证<strong>子类的<clinit> ()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载Father类，其次加载Son类。</span></span><br><span class="line">        System.out.println(Son.B);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟机必须保证<strong>一个类的<clinit>()方法在多线程下被同步加锁</clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 若一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</span></span><br><span class="line">            <span class="comment">// 那么这里的打印代码就只会执行一次</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<blockquote>
<p>线程2开始<br>线程1开始<br>线程2初始化当前类</p>
</blockquote>
<p>一个类只需要往内存中加载一次就可以了，加载之后将其放在方法区（方法区在JDK7之前被称为永久代，JDK7之后被称为源空间），源空间其实使用的是本地内存，即类加载到内存之后是使用直接内存进行缓存。若以后使用到该类，那么使用的都是内存中已经存在的类本身。所以，<strong>虚拟机在加载类的时候只会调用一次<clinit>方法</clinit></strong>。</p>
</li>
</ul>
<h4 id="3、类加载器分类"><a href="#3、类加载器分类" class="headerlink" title="3、类加载器分类"></a>3、类加载器分类</h4><h5 id="1、类加载器分类"><a href="#1、类加载器分类" class="headerlink" title="1、类加载器分类"></a>1、类加载器分类</h5><p>JVM支持<strong>两种类型的类加载器</strong>，分别为<strong>引导类加载器( Bootstrap ClassLoader)**和</strong>自定义类加载器(User-Defined ClassLoader)** 。</p>
<ul>
<li><p>引导类加载器( Bootstrap ClassLoader)：</p>
<ul>
<li>本身不是使用java语言编写，而是使用C与C++进行编写</li>
</ul>
</li>
<li><p>自定义类加载器(User-Defined ClassLoader)</p>
<ul>
<li><p>使用java语言编写</p>
</li>
<li><p>派生于抽象类ClassLoader。所以扩展类加载器（Extinction Class Loader）与系统类加载器（System Class Loader）都属于自定义类加载器</p>
<p>其中sun.misc.Launcher它是一个java虚拟机的入口应用</p>
<p><img src="/2021/04/19/JVM/image-20210421012614177.png" alt="image-20210421012614177"></p>
</li>
</ul>
</li>
</ul>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个：</p>
<p><img src="/2021/04/19/JVM/image-20210421011954294.png" alt="image-20210421011954294"></p>
<p>这里的四者之间的关系是<strong>包含关系</strong>。不是上层下层，也不是子父类的继承关系。</p>
<p>对于引导类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）与系统类加载器（System Class Loader）三者的关系：</p>
<ul>
<li>系统类加载器（System Class Loader）的上层就是扩展类加载器（Extension Class Loader）：对于用户自定义类来说：默认使用系统类加载器进行加载</li>
<li>扩展类加载器（Extension Class Loader）的上层是引导类加载器（Bootstrap Class Loader）</li>
<li>引导类加载器（Bootstrap Class Loader）是最高层的类加载器：<strong>Java的核心类库</strong>都是使用引导类加载器进行加载的。并且我们获取不到引导类加载器。因为引导类加载器并不是所以java语言进行编写的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）"><a href="#2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）"></a>2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）</h5><ul>
<li>这个类加载<strong>使用C/C++语言实现</strong>的，嵌套在JVM内部，是JVM的一部分。</li>
<li>它用来<strong>加载Java的核心库</strong>(JAVA HOME/jre/lib/rt.jar、resources. jar或sun.boot.class.path路径下的内容) , 用于<strong>提供JVM自身需要的类</strong></li>
<li>并<strong>不继承自java. lang .ClassLoader</strong>,<strong>没有父加载器</strong>。</li>
<li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong>。</li>
<li>出于安全考虑，Bootstrap启动类加载器<strong>只加载包名为java、javax、sun等开头的类</strong></li>
</ul>
<h5 id="3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）"><a href="#3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）"></a>3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><p><strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</p>
</li>
<li><p><strong>派生于ClassLoader类</strong></p>
</li>
<li><p><strong>父类加载器为启动类加载器</strong></p>
</li>
<li><p>从java. ext. dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。</p>
<p><strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</strong></p>
</li>
<li><p><strong>JDK9以后</strong>扩展类加载器改为<strong>平台类加载器</strong></p>
</li>
</ul>
<h5 id="4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）"><a href="#4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）" class="headerlink" title="4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）"></a>4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><strong>java语言编写</strong>，由sun.misc.Launcher$AppClassLoader实现</li>
<li><strong>派生于ClassLoader类</strong></li>
<li><strong>父类加载器为扩展类加载器</strong></li>
<li>它负责<strong>加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li>
<li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，<strong>Java应用的类都是由它来完成加载</strong></li>
<li><strong>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</strong></li>
</ul>
<h5 id="5、用户自定义类加载器"><a href="#5、用户自定义类加载器" class="headerlink" title="5、用户自定义类加载器"></a>5、用户自定义类加载器</h5><ul>
<li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li><p>为什么要自定义类加载器：</p>
<ul>
<li><p><strong>隔离加载类</strong>：</p>
<p>在某些框架中需要使用中间件，然而中间件与应用模块是隔离的。所以需要把类加载到不同的环境当中，确保应用当中引用到的框架的jar包与中间件的jar包是不冲突的（冲突：框架与中间件的某些类的类名一样，路径也相同）。</p>
<p>所以需要做一个类的仲裁。一般主流的容器类框架都会自定义类加载器，让本身与不同中间件之间是隔离的，避免类的冲突。</p>
</li>
<li><p><strong>修改类加载的方式</strong>：</p>
<p>除了引导类加载器，其他类加载器都可以在需要的时候进行动态加载</p>
</li>
<li><p><strong>扩展加载源</strong>：</p>
<p>可以从数据库当中，或者电视机的机饼盒等等加载字节码文件的来源</p>
</li>
<li><p><strong>防止源码泄漏</strong>：</p>
<p>对字节码文件进行加密，防止被反编译篡改。</p>
<p>加密之后运行代码时就需要进行解密，这时候就可以通过自定义加载器的方式进行解密</p>
</li>
</ul>
</li>
<li><p>用户自定义类加载器实现步骤：</p>
<ol>
<li><p>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求；</p>
</li>
<li><p>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是<strong>在JDK1.2之后</strong>已不再建议用户去覆盖loadClass()方法，而是<strong>建议把自定义的类加载逻辑写在findClass()方法中</strong>。（findClass()方法与defineClass()方法配合使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,result,<span class="number">0</span>,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>,<span class="keyword">true</span>,customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编写自定义类加载器时，<strong>如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就<strong>可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</strong>。</p>
</li>
</ol>
</li>
</ul>
<h4 id="4、Class-Loader的使用说明"><a href="#4、Class-Loader的使用说明" class="headerlink" title="4、Class Loader的使用说明"></a>4、Class Loader的使用说明</h4><p>ClassLoader类，它是一个<strong>抽象类</strong>，其后<strong>所有的类加载器都继承自ClassLoader</strong> (不包括启动类加载器）</p>
<p>相关方法与描述：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法名称</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中的内容转换为一个Java类,返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的途径:</p>
<ol>
<li><p>获取当前类的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前线程上下文的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取系统的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取调用者的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5、双亲委派机制"><a href="#5、双亲委派机制" class="headerlink" title="5、双亲委派机制"></a>5、双亲委派机制</h4><h5 id="1、什么是双亲委派机制"><a href="#1、什么是双亲委派机制" class="headerlink" title="1、什么是双亲委派机制"></a>1、什么是双亲委派机制</h5><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即<strong>把请求交由父类处理</strong>，它是一种任务委派模式。</p>
<h5 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h5><ol>
<li>如果一个类加载器收到类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210421103744316.png" alt="image-20210421103744316"></p>
<h5 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h5><p><img src="/2021/04/19/JVM/image-20210421105124634.png" alt="image-20210421105124634"></p>
<ul>
<li>SPI接口是由引导类加载器加载的</li>
<li>具体接口的实现类由于使用了第三方jdbc.jar，所以是由线程上下文类加载器加载的，而线程上下文类加载器的默认就是系统类加载器。（反向委派）</li>
</ul>
<h5 id="4、优势"><a href="#4、优势" class="headerlink" title="4、优势"></a>4、优势</h5><ul>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang,ShkStart</li>
</ul>
</li>
</ul>
<p>在src目录下新建java.lang.String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>在类 java.lang.String 中找不到 main 方法</p>
</blockquote>
<p>在src目录下新建java.lang并在该包下编写自定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：java.lang.SecurityException：Prohibited package name：java.lang</p>
</blockquote>
<p><strong>沙箱安全机制</strong>：</p>
<p>自定义String类，但是在加载自定义String类的时候会率先随意引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h4 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h4><h5 id="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"><a href="#1、在JVM中表示两个class对象是否为同一个类存在两个必要条件" class="headerlink" title="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"></a>1、在JVM中表示两个class对象是否为同一个类存在两个必要条件</h5><ul>
<li><strong>类的完整类名必须一致，包括包名</strong>。</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li>
</ul>
<p>换句话说：在JVM中，既使这两个类对象（class对象）来源于同一个Class文件，被同一个虚拟机所加载，但<strong>只要加载它们的ClassLoader实例对象不同</strong>，那么这两个类对象也是<strong>不相等</strong>的。</p>
<h5 id="2、对类加载器的引用"><a href="#2、对类加载器的引用" class="headerlink" title="2、对类加载器的引用"></a>2、对类加载器的引用</h5><p>JVM必须知道一个类型是由启动类加载器加载的还是有用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h5 id="3、类的主动使用与被动使用"><a href="#3、类的主动使用与被动使用" class="headerlink" title="3、类的主动使用与被动使用"></a>3、类的主动使用与被动使用</h5><p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li><p>主动使用，又分为七种情况：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName(“com.atguigu.Test”)）</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK7开始通过动态语言支持：</p>
<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ul>
</li>
<li><p>被动使用：除了上述七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
</li>
</ul>
<hr>
<h3 id="3、运行时数据区概述及线程"><a href="#3、运行时数据区概述及线程" class="headerlink" title="3、运行时数据区概述及线程"></a>3、运行时数据区概述及线程</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、经典的JVM内存布局"><a href="#1、经典的JVM内存布局" class="headerlink" title="1、经典的JVM内存布局"></a>1、经典的JVM内存布局</h5><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局：</p>
<p><img src="/2021/04/19/JVM/image-20210421112837894.png" alt="image-20210421112837894"></p>
<p>其中：方法区在JVM规范中是一个逻辑概念，由虚拟机自己进行具体实现。</p>
<ul>
<li><strong>HotSpot7和以前的版本</strong>用的是堆上的<strong>永久代</strong>实现方法区</li>
<li><strong>HotSpot8之后</strong>使用<strong>元数据区</strong>实现方法区</li>
<li><strong>常量池</strong>在jdk8以后也被放到了堆中</li>
</ul>
<h5 id="2、进程同步与线程同步："><a href="#2、进程同步与线程同步：" class="headerlink" title="2、进程同步与线程同步："></a>2、进程同步与线程同步：</h5><p>Java虚拟机定义了若干种程序运行期间会使用到的<strong>运行时数据区</strong>，其中有一些会<strong>随着虚拟机启动而创建，随着虚拟机退出而销毁(进程同步)**。另外一些则是</strong>与线程一一对应的<strong>，这些</strong>与线程对应的数据区域会随着线程开始和结束而创建和销毁**。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即:</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>每个进程：<strong>线程间共享</strong>，堆、堆外内存(永久代或元空间、代码缓存)（问题：怎么保证线程安全）</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421113146594.png" alt="image-20210421113146594"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="第03章_线程共享和私有的结构"></p>
<p>​    其中：（一个线程一份）</p>
<ul>
<li>PC：程序计数器</li>
<li>VMS：虚拟机栈</li>
<li>NMS：本地方法栈</li>
</ul>
<h5 id="3、关于线程间共享的说明："><a href="#3、关于线程间共享的说明：" class="headerlink" title="3、关于线程间共享的说明："></a>3、关于线程间共享的说明：</h5><p><img src="/2021/04/19/JVM/image-20210421114556021.png" alt="image-20210421114556021"></p>
<p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框（运行时数据区(Runtime Data Area)）：运行时环境。</p>
<h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><h5 id="1、关于线程"><a href="#1、关于线程" class="headerlink" title="1、关于线程"></a>1、关于线程</h5><p><strong>线程是一个程序里的运行单元</strong>。JVM允许<strong>一个应用有多个线程并行</strong>的执行。</p>
<p>在Hotspot JVM里，<strong>每个线程都与操作系统的本地线程直接映射</strong>。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<h5 id="2、线程的分类"><a href="#2、线程的分类" class="headerlink" title="2、线程的分类"></a>2、线程的分类</h5><ul>
<li>普通线程</li>
<li>守护线程</li>
</ul>
<h5 id="3、JVM的系统线程"><a href="#3、JVM的系统线程" class="headerlink" title="3、JVM的系统线程"></a>3、JVM的系统线程</h5><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。</p>
<p>这些<strong>后台线程不包括</strong>调用public static void main (String[])的<strong>main线程以及所有这个main线程自己创建的线程</strong>。</p>
<p>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：</p>
<ul>
<li><p><strong>虚拟机线程</strong>：</p>
<p>这种线程的操作是需要<strong>JVM达到安全点</strong>才会出现。这些操作必须<strong>在不同的线程中发生的原因是他们都需要JVM达到安全点</strong>，这样堆才不会变化。这种线程的执行类型包括**”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销**。</p>
</li>
<li><p><strong>周期任务线程</strong>：</p>
<p>这种线程是<strong>时间周期事件的体现(比如中断)**，他们</strong>一般用于周期性操作的调度执行**。</p>
</li>
<li><p><strong>GC线程</strong>：</p>
<p>这种线程<strong>对在JVM里不同种类的垃圾收集行为提供了支持</strong>。</p>
</li>
<li><p><strong>编译线程</strong>：</p>
<p>这种线程在运行时会<strong>将字节码编译成到本地代码</strong>。</p>
</li>
<li><p><strong>信号调度线程</strong>：</p>
<p>这种线程接收信号并<strong>发送给JVM</strong>， <strong>在它内部通过调用适当的方法进行处理</strong>。</p>
</li>
</ul>
<hr>
<h3 id="4、程序计数器（PC寄存器）"><a href="#4、程序计数器（PC寄存器）" class="headerlink" title="4、程序计数器（PC寄存器）"></a>4、程序计数器（PC寄存器）</h3><h4 id="1、PC-Register介绍"><a href="#1、PC-Register介绍" class="headerlink" title="1、PC Register介绍"></a>1、PC Register介绍</h4><p><img src="/2021/04/19/JVM/image-20210422000432697.png" alt="image-20210422000432697"></p>
<p>JVM中的程序计数寄存器(Program Counter Register) 中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。<strong>CPU只有把数据装载到寄存器才能够运行</strong>。</p>
<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</p>
<p><strong>作用</strong>：</p>
<p>PC寄存器<strong>用来存储指向下一条指令的地址</strong>，也即将要执行的指令代码。<strong>由执行引擎读取下一条指令</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210421201053065.png" alt="image-20210421201053065"></p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li>
<li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的</strong>，<strong>生命周期与线程的生命周期保持一致</strong>。</li>
<li><strong>任何时间一个线程都只有一个方法在执行</strong>，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，<strong>如果是在执行native方法，则是未指定值(undefned)</strong></li>
<li><strong>它是程序控制流的指示器</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li><strong>字节码解释器</strong>工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。</li>
<li>它<strong>不存在垃圾回收</strong>问题。</li>
<li>它是<strong>唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域</strong>。</li>
<li>即：<strong>无GC，无OOM</strong></li>
</ul>
<h4 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h4><p><img src="/2021/04/19/JVM/image-20210422001738599.png" alt="image-20210422001738599"></p>
<p><img src="/2021/04/19/JVM/image-20210422001753431.png" alt="image-20210422001753431"></p>
<p>针对<code>5</code>进行举例：（PC寄存器的意义或者作用）</p>
<ol>
<li>指令地址<code>5</code>就是PC寄存器里面存放的值</li>
<li>执行引擎会在PC寄存器里面获取指令地址对应的操作指令（istore_2）</li>
<li>执行引擎得到操作指令后会执行下面两个操作：<ol>
<li>操作虚拟机栈（如局部变量表、操作数栈等等），实现数据的存取操作以及一些求和运算等等。</li>
<li>把字节码指令翻译为机器指令</li>
</ol>
</li>
<li>机器指令可以让对应的CPU做运算</li>
</ol>
<h4 id="3、两个常见问题"><a href="#3、两个常见问题" class="headerlink" title="3、两个常见问题"></a>3、两个常见问题</h4><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>因为CPU需要不停的切换各个进程，这时候切换回来以后，就得知道从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="第04章_PC寄存器"></p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p>我们都知道所谓的<strong>多线程在一个特定的时间段内只会执行其中某一个线程的方法</strong>，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，<strong>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况</strong>。</p>
<p>由于<strong>CPU时间片轮限制</strong>，众多线程在并发执行过程中，任何一个确定的时刻，<strong>一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</strong>。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p><strong>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响</strong>。</p>
</li>
</ol>
<h4 id="4、CPU时间片"><a href="#4、CPU时间片" class="headerlink" title="4、CPU时间片"></a>4、CPU时间片</h4><p><strong>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片</strong>。</p>
<p>在<strong>宏观</strong>上：我们可以<strong>同时打开多个应用程序，每个程序并行不悖，同时运行</strong>。</p>
<p>但在<strong>微观</strong>上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平？一种方法就是<strong>引入时间片，每个程序轮流执行</strong>。</p>
<p>并行与并发：</p>
<ul>
<li>并行就是两个核同时算</li>
<li>并发就是一个核算两个一人一段。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421202826450.png" alt="image-20210421202826450"></p>
<hr>
<h3 id="5、虚拟机栈"><a href="#5、虚拟机栈" class="headerlink" title="5、虚拟机栈"></a>5、虚拟机栈</h3><h4 id="1、虚拟机栈概述"><a href="#1、虚拟机栈概述" class="headerlink" title="1、虚拟机栈概述"></a>1、虚拟机栈概述</h4><h5 id="1、虚拟机栈出现的背景"><a href="#1、虚拟机栈出现的背景" class="headerlink" title="1、虚拟机栈出现的背景"></a>1、虚拟机栈出现的背景</h5><p>由于跨平台性的设计，<strong>Java的指令都是根据栈来设计</strong>的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>跨平台</li>
<li>指令集小</li>
<li>编译器容易实现</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>性能下降</li>
<li>实现同样的功能需要更多的指令</li>
</ul>
<h5 id="2、内存中的栈与堆"><a href="#2、内存中的栈与堆" class="headerlink" title="2、内存中的栈与堆"></a>2、内存中的栈与堆</h5><p>栈：</p>
<ul>
<li><strong>栈是运行时的单位</strong></li>
<li><strong>栈解决程序的运行问题</strong>，即程序如何执行，或者说如何处理数据</li>
</ul>
<p>堆：</p>
<ul>
<li><strong>堆是存储的单位</strong></li>
<li><strong>堆解决的是数据存储的问题</strong>，即数据怎么放、放在哪里。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422005102514.png" alt="image-20210422005102514"></p>
<h5 id="3、虚拟机栈基本内容"><a href="#3、虚拟机栈基本内容" class="headerlink" title="3、虚拟机栈基本内容"></a>3、虚拟机栈基本内容</h5><p>Java虚拟机栈是什么?</p>
<p>Java虚拟机栈(Java Virtual Machine Stack) ，早期也叫Java栈。<strong>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧</strong>(Stack Frame) （栈存储数据的基本单位），<strong>对应着一次次的Java方法调用</strong>。</p>
<ul>
<li>是线程私有的</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422012357234.png" alt="image-20210422012357234"></p>
<p>Java虚拟机栈生命周期：</p>
<ul>
<li><strong>生命周期和线程一致</strong>。</li>
</ul>
<p>Java虚拟机栈作用：</p>
<ul>
<li>主管Java程序的运行，它保存方法的**局部变量(8种基本数据类型、对象的引用)**、部分结果，并参与方法的调用和返回。</li>
</ul>
<p>栈的特点(优点)：</p>
<ul>
<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li><p>JVM直接对Java栈的操作只有两个:</p>
<ul>
<li>每个方法执行，伴随着进栈(入栈、压栈)</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li><p>对于栈来说<strong>不存在垃圾回收问题</strong>，但是存在内存溢出的情况。</p>
</li>
<li><p>即：<strong>无GC，有OOM</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422013552022.png" alt="image-20210422013552022"></p>
</li>
</ul>
<p>栈中可能存在的异常：</p>
<p>Java虚拟机规范<strong>允许Java栈的大小是动态的或者是固定不变</strong>的。</p>
<ul>
<li><p>如果采用<strong>固定大小</strong>的Java虚拟机栈，那<strong>每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定</strong>。如果<strong>线程请求分配的栈容量超过Java虚拟机栈允许的最大容量</strong>，Java虚拟机将会抛出一个<strong>StackOverflowError异常</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210422013326303.png" alt="image-20210422013326303"></p>
</li>
<li><p>如果Java虚拟机栈可以<strong>动态扩展</strong>，并且<strong>在尝试扩展的时候无法申请到足够的内存</strong>，或者<strong>在创建新的线程时没有足够的内存去创建对应的虚拟机栈</strong>，那Java虚拟机将会抛出一个<strong>OutOfMemoryError异常</strong>。</p>
</li>
</ul>
<p>设置栈内存大小：</p>
<p>我们可以使用<strong>参数-Xss选项来设置线程的最大栈空间</strong>，**栈的大小直接决定了函数调用的最大可达<code>深度</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210422014055436.png" alt="image-20210422014055436"></p>
<p>设置步骤：</p>
<ol>
<li><p>在IDEA点开<code>Run</code></p>
<p><img src="/2021/04/19/JVM/image-20210422014347776.png" alt="image-20210422014347776"></p>
</li>
<li><p>在Run下面有选项<code>Edit Configurations...</code></p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210422014445720.png" alt="image-20210422014445720"></p>
</li>
<li><p>在当前类下的<code>VM options</code>中进行参数设置。（参数参考上-Xss的设置）程序调优的一种方案：<strong>参数调优</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422014706947.png" alt="image-20210422014706947"></p>
</li>
</ol>
<p>参数设置后的测试方法：</p>
<p><img src="/2021/04/19/JVM/image-20210422013442292.png" alt="image-20210422013442292"></p>
<h4 id="2、栈的存储单位"><a href="#2、栈的存储单位" class="headerlink" title="2、栈的存储单位"></a>2、栈的存储单位</h4><h5 id="1、栈中存储什么"><a href="#1、栈中存储什么" class="headerlink" title="1、栈中存储什么?"></a>1、栈中存储什么?</h5><ul>
<li><strong>每个线程都有自己的栈</strong>，栈中的数据都是<strong>以栈帧(Stack Frame)为基本存储单位</strong>的格式存在。</li>
<li>在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧(Stack Frame)</strong></li>
<li>栈帧是一个<strong>内存区块</strong>，是一个<strong>数据集</strong>，<strong>维系着方法执行过程中的各种数据信息</strong>。</li>
</ul>
<h5 id="2、栈的运行原理"><a href="#2、栈的运行原理" class="headerlink" title="2、栈的运行原理"></a>2、栈的运行原理</h5><ul>
<li><p>JVM直接对Java栈的操作只有两个，就是<strong>对栈帧的压栈和出栈</strong>，<strong>遵循“先进后出”/“后进先出”原则</strong>。</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈项栈帧)是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong> ，与当前栈帧相对应的方法就是<strong>当前方法(Current Method)**，定义这个方法的类就是</strong>当前类(Current Class)** 。</p>
</li>
<li><p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong>。</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A0%88%E6%A1%A2.jpg" alt="第05章_方法与栈桢"></p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧之中引用另外一个线程的栈帧</strong>。</p>
</li>
<li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
</li>
<li><p>Java方法有两种返回函数的方式：</p>
<ul>
<li><strong>正常的函数返回，使用return指令</strong></li>
<li><strong>抛出异常</strong></li>
</ul>
<p>不管使用哪种方式，都会导致<strong>栈帧被弹出</strong>。</p>
</li>
</ul>
<h5 id="3、栈帧的内部结构"><a href="#3、栈帧的内部结构" class="headerlink" title="3、栈帧的内部结构"></a>3、栈帧的内部结构</h5><p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表(Local Variables：LV)</strong></li>
<li><strong>操作数栈(Operand Stack) (或表达式栈)</strong></li>
<li>动态链接(Dynamic Linking) ( 或指向运行时常量池的方法引用) </li>
<li>方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="第05章_栈桢内部结构"></p>
<p><img src="/2021/04/19/JVM/image-20210422173049395.png" alt="image-20210422173049395"></p>
<h4 id="3、局部变量表-Local-Variables"><a href="#3、局部变量表-Local-Variables" class="headerlink" title="3、局部变量表( Local Variables)"></a>3、局部变量表( Local Variables)</h4><h5 id="1、局部变量表的概述"><a href="#1、局部变量表的概述" class="headerlink" title="1、局部变量表的概述"></a>1、局部变量表的概述</h5><ul>
<li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括<strong>各类基本数据类型</strong>、<strong>对象引用(reference)</strong> ，以及<br><strong>return Address类型</strong>。（因为各类数据类型都可以通过<strong>数字</strong>来表示）</li>
<li>由于局部变量表是建立在<strong>线程的栈上</strong>，是<strong>线程的私有数据</strong>，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来</strong>的，并<strong>保存在方法的Code属性的maximum local variables数据项</strong>中。 在方法<strong>运行期间是不会改变</strong>局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</li>
</ul>
<h5 id="2、对程序编译后的字节码文件的查看方法"><a href="#2、对程序编译后的字节码文件的查看方法" class="headerlink" title="2、对程序编译后的字节码文件的查看方法"></a>2、对程序编译后的字节码文件的查看方法</h5><p>程序代码：（以main方法为例，其他方法类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210422180804881.png" alt="image-20210422180804881"></p>
<p><img src="/2021/04/19/JVM/image-20210422181213595.png" alt="image-20210422181213595"></p>
<p><img src="/2021/04/19/JVM/image-20210422181755767.png" alt="image-20210422181755767"></p>
<p><img src="/2021/04/19/JVM/image-20210422182334511.png" alt="image-20210422182334511"></p>
<p><img src="/2021/04/19/JVM/image-20210422193112649.png" alt="image-20210422193112649"></p>
<p><img src="/2021/04/19/JVM/image-20210422193542032.png" alt="image-20210422193542032"></p>
<h5 id="3、关于Slot的理解"><a href="#3、关于Slot的理解" class="headerlink" title="3、关于Slot的理解"></a>3、关于Slot的理解</h5><ul>
<li><p><strong>参数值的存放总是在局部变量数组的index0开始</strong>，到数组长度-1的索引结束。</p>
</li>
<li><p><strong>局部变量表的最基本的存储单元是Slot (变量槽)</strong></p>
</li>
<li><p><strong>局部变量：表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</strong></p>
</li>
<li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot (包括returnAddress类型)，64位的类型(long和double)占用两个slot</strong>。</p>
<ul>
<li>byte、short 、char、在存储前被转换为int，boolean 也被转换为int，0表示false，非0表示true，float、<strong>引用数据类型的引用</strong></li>
<li>long和double则占据两个Slot。</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的基本变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个Slot上</p>
</li>
<li><p><strong>如果需要访问局部变量表中一个64bit的基本变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或double类型变量）</p>
<p><img src="/2021/04/19/JVM/image-20210422200200175.png" alt="image-20210422200200175"></p>
</li>
<li><p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，那么<strong>该<code>对象引用this</code>将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
</li>
<li><p><strong>在静态(static)方法中不能引用this</strong>：因为this变量不存在于静态方法的局部变量表中！！</p>
<p><img src="/2021/04/19/JVM/image-20210422201450476.png" alt="image-20210422201450476"></p>
</li>
</ul>
<h5 id="4、Slot的重复利用"><a href="#4、Slot的重复利用" class="headerlink" title="4、Slot的重复利用"></a>4、Slot的重复利用</h5><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<p>变量c使用之前已经销毁的变量b占据的slot的位置：</p>
<p><img src="/2021/04/19/JVM/image-20210422202145932.png" alt="image-20210422202145932"></p>
<h5 id="5、静态变量与局部变量的对比"><a href="#5、静态变量与局部变量的对比" class="headerlink" title="5、静态变量与局部变量的对比"></a>5、静态变量与局部变量的对比</h5><p><strong>变量的分类</strong>：</p>
<ul>
<li>按照数据类型分：<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量（static修饰）： linking的prepare阶段：给类变量默认赋值  —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li>
<li>实例变量（没有static修饰）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li>
</ul>
</li>
</ul>
<p><strong>静态变量（类变量）与局部变量对比</strong>：</p>
<ul>
<li><p>参数表分配完毕之后，再<strong>根据方法体内定义的变量的顺序和作用域分配</strong>。</p>
</li>
<li><p>我们知道<strong>类变量</strong>表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对<strong>类变量设置零值</strong>，另一次则是在“<strong>初始化</strong>”阶段，赋予<strong>程序员在代码中定义的初始值</strong>。</p>
</li>
<li><p>和类变量初始化不同的是，<strong>局部变量表**</strong>不存在系统初始化<strong>的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 报错：没有赋值不能够使用。</span></span><br><span class="line">    System.out.println(i).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6、补充说明："><a href="#6、补充说明：" class="headerlink" title="6、补充说明："></a>6、补充说明：</h5><ul>
<li>在栈帧中，与<strong>性能调优</strong>关系最为密切的部分就是<strong>局部变量表</strong>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><strong>局部变量表中的变量也是重要的<code>垃圾回收根节点</code>（根搜索算法\可达性分析），只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</li>
</ul>
<h4 id="4、操作数栈-Operand-Stack"><a href="#4、操作数栈-Operand-Stack" class="headerlink" title="4、操作数栈(Operand Stack)"></a>4、操作数栈(Operand Stack)</h4><ul>
<li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<strong>后进先出(Last- In-First-Out：LIFO)的操作数栈</strong>，也可以称之为<strong>表达式栈(Expression Stack)</strong> 。</p>
</li>
<li><p><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push) /出栈(pop)。</strong></p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p>
</li>
<li><p>比如：执行复制、交换、求和等操作</p>
<p><img src="/2021/04/19/JVM/image-20210422204325546.png" alt="image-20210422204325546"></p>
</li>
</ul>
</li>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量<code>临时</code>的存储空间</strong>。</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</p>
</li>
<li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其<strong>所需的最大深度在编译期就定义好了</strong>，在方法<strong>运行期间是不会改变</strong>操作数栈的大小的。保存在方法的<code>Code</code>属性中，为<code>max_ stack</code>的值。</p>
</li>
<li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p>
<ul>
<li><strong>32bit</strong>的类型占用<strong>一个</strong>栈单位深度</li>
<li><strong>64bit</strong>的类型占用<strong>两个</strong>栈单位深度</li>
</ul>
</li>
<li><p>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是<strong>只能通过标准的入栈(push)和出栈(pop) 操作</strong>来完成一次数据访问。</p>
</li>
<li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p><img src="/2021/04/19/JVM/image-20210422211053093.png" alt="image-20210422211053093"></p>
</li>
<li><p><strong>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配</strong>，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是<strong>操作数栈</strong>。</p>
</li>
</ul>
<h4 id="5、代码跟踪"><a href="#5、代码跟踪" class="headerlink" title="5、代码跟踪"></a>5、代码跟踪</h4><h5 id="1、对操作数栈相关知识点的代码分析"><a href="#1、对操作数栈相关知识点的代码分析" class="headerlink" title="1、对操作数栈相关知识点的代码分析"></a>1、对操作数栈相关知识点的代码分析</h5><p><img src="/2021/04/19/JVM/image-20210422210316458.png" alt="image-20210422210316458"></p>
<p><img src="/2021/04/19/JVM/image-20210422210545629.png" alt="image-20210422210545629"></p>
<p><img src="/2021/04/19/JVM/image-20210422210620080.png" alt="image-20210422210620080"></p>
<p><img src="/2021/04/19/JVM/image-20210422210641231.png" alt="image-20210422210641231"></p>
<p><img src="/2021/04/19/JVM/image-20210422210655579.png" alt="image-20210422210655579"></p>
<h5 id="2、面试问题：i-VS-i"><a href="#2、面试问题：i-VS-i" class="headerlink" title="2、面试问题：i++ VS ++i"></a>2、面试问题：i++ VS ++i</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第1类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        i1++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">10</span>;</span><br><span class="line">        ++i2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = i3++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i6 = ++i5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i7 = <span class="number">10</span>;</span><br><span class="line">        i7 = i7++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">10</span>;</span><br><span class="line">        i8 = ++i8;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第4类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i9 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i10 = i9++ + ++i9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一类问题：两种没什么区别，都是实现变量的加1操作</p>
<h4 id="6、栈顶缓存技术"><a href="#6、栈顶缓存技术" class="headerlink" title="6、栈顶缓存技术"></a>6、栈顶缓存技术</h4><p>前面提过，基于栈式架构的虛拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派( instruction dispatch) 次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了<strong>栈顶缓存(ToS，Top-of-stack Cashing) 技术</strong>，<strong>将栈顶元素全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<h4 id="7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）"><a href="#7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）" class="headerlink" title="7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）"></a>7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）</h4><ul>
<li><p>每一个栈帧内部都包含一个指向**<code>运行时常量池</code><strong>中</strong>该栈帧所属方法的引用<strong>。包含这个引用的目的就是为了</strong>支持当前方法的代码能够实现动态链接(Dynamic Linking)** 。比如: invokedynamic指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用</strong>(Symbolic Reference) <strong>保存在class文件的常量池里</strong>。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了<strong>将这些符号引用转换为调用方法的直接引用</strong>。（多态也是通过动态链接实现的）</p>
</li>
<li><p>类被加载之后，Class文件中的常量池会被复制一份到方法区，成为“运行时常量池”</p>
<p><img src="/2021/04/19/JVM/image-20210422213416813.png" alt="image-20210422213416813"></p>
</li>
<li><p>为什么需要常量池呢?      常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
</li>
</ul>
<h4 id="8、方法的调用：解析与分派"><a href="#8、方法的调用：解析与分派" class="headerlink" title="8、方法的调用：解析与分派"></a>8、方法的调用：解析与分派</h4><h5 id="1、静态链接与动态链接"><a href="#1、静态链接与动态链接" class="headerlink" title="1、静态链接与动态链接"></a>1、静态链接与动态链接</h5><p>在JVM中，将符号引用转换为调用方法的直接引用与<strong>方法的绑定机制</strong>相关。</p>
<ul>
<li><p>静态链接：<br>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且<strong>运行期保持不变</strong>时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</li>
<li><p>动态链接：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<h5 id="2、方法的绑定机制"><a href="#2、方法的绑定机制" class="headerlink" title="2、方法的绑定机制"></a>2、方法的绑定机制</h5><p>对应的方法的绑定机制为：<strong>早期绑定(Early Binding) 和晚期绑定(Late Binding)</strong> 。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用</strong>的过程，这<strong>仅仅发生一次</strong>。</p>
<ul>
<li><p>早期绑定：</p>
<p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p>晚期绑定：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<h5 id="3、虚方法与非虚方法"><a href="#3、虚方法与非虚方法" class="headerlink" title="3、虚方法与非虚方法"></a>3、虚方法与非虚方法</h5><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p>
<p>Java中<strong>任何一个普通的方法其实都具备虚函数的特征</strong>，它们相当于C++语言中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中<strong>不希望某个方法拥有虛函数的特征</strong>时，则可以<strong>使用关键字final来标记这个方法</strong>。（通过final修饰不能重写）</p>
<p>子类对象的多态性的使用前提（多态 &lt;–&gt; 虚方法）</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p>非虚方法：</p>
<ul>
<li><strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</strong>。这样的方法称为<strong>非虚方法</strong>。</li>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法（因为java没有多继承所以调用父类的方法是非虚方法：super.xxx()可以找到调用的是哪个方法）都是非虚方法</strong>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p><strong>虚拟机中提供了以下几条方法调用指令</strong>：</p>
<ul>
<li>普通调用指令：<ol>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、 私有及父类方法，解析阶段确定唯一方法版本</init></strong></li>
<li>invokevirtual：调用所有虛方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令:<ol start="5">
<li>invokedynamic: 动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p><strong>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本</strong>。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虛方法，其余的(final修饰的除外)称为虚方法</strong>。</p>
<h5 id="4、关于invokedynamic"><a href="#4、关于invokedynamic" class="headerlink" title="4、关于invokedynamic"></a>4、关于invokedynamic</h5><ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<strong>Java为了实现「动态类型语言」支持而做的一种改进</strong>。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式</strong>。</li>
<li>Java7中增加的动态语言类型支持的本质是<strong>对Java虚拟机规范的修改，而不是对Java语言规则的修改</strong>，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是<strong>运行在Java平台的动态语言的编译器</strong>。</li>
<li>动态类型语言和静态类型语言：<ul>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者（编译期）就是静态类型语言，反之（运行期）是动态类型语言。</li>
<li>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息</strong>；<strong>动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。</li>
</ul>
</li>
</ul>
<h5 id="5、方法重写的本质"><a href="#5、方法重写的本质" class="headerlink" title="5、方法重写的本质"></a>5、方法重写的本质</h5><p><strong>Java语言中方法重写的本质</strong>： </p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作<code>C</code>。</li>
<li>如果在类型<code>C</code>中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则<strong>返回这个方法的直接引用</strong>，查找过程结束；如果不通过，则<strong>返回java.lang.illegalAccessError异常</strong>。</li>
<li>否则，<strong>按照继承关系从下往上依次对<code>C</code>的各个父类进行第2步的搜索和验证过程</strong>。</li>
<li>如果始终没有找到合适的方法，则<strong>抛出java.lang.AbstractMethodError异常</strong>。</li>
</ol>
<p><strong>IllegalAccessError介绍</strong>：</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h5 id="6、虚方法表"><a href="#6、虚方法表" class="headerlink" title="6、虚方法表"></a>6、虚方法表</h5><ul>
<li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，<strong>JVM采用在类的方法区建立一个虚方法表(virtual method table) (非虚方法不会出现在表中)来实现。使用索引表来代替查找</strong>。</p>
</li>
<li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li><p>那么虚方法表什么时候被创建?</p>
<p>虚方法表会在类加载的链接阶段（解析Resolve）被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</li>
</ul>
<p>每个类有一个虚方法表，使用某方法时直接在这表里查找该方法在哪个类里了。</p>
<p>没有虚方法表的情况下，需要在当前类查找，找不到再去父类查找。</p>
<p><img src="/2021/04/19/JVM/image-20210422225120851.png" alt="image-20210422225120851"></p>
<p><img src="/2021/04/19/JVM/image-20210422225328056.png" alt="image-20210422225328056"></p>
<p><img src="/2021/04/19/JVM/image-20210422225533000.png" alt="image-20210422225533000"></p>
<p><img src="/2021/04/19/JVM/image-20210422225747189.png" alt="image-20210422225747189"></p>
<h4 id="9、方法返回地址-Return-Address"><a href="#9、方法返回地址-Return-Address" class="headerlink" title="9、方法返回地址(Return Address)"></a>9、方法返回地址(Return Address)</h4><ul>
<li><strong>存放调用该方法的pc寄存器的值</strong>。</li>
<li>一个方法的结束，有两种方式：<ul>
<li><strong>正常执行完成</strong></li>
<li><strong>出现未处理的异常，非正常退出</strong></li>
</ul>
</li>
<li>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。方法<strong>正常退出</strong>时，<strong>调用者的pc计数器的值作为返回地址</strong>，即<strong>调用该方法的指令的下一条指令的地址</strong>。而通过<strong>异常退出</strong>的，返回地址是要<strong>通过异常表来确定，栈帧中一般不会保存这部分信息</strong>。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令(return) ，会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含<code>ireturn</code> (当返回值是boolean、 byte、char、short和int类型时使用)、<code>lreturn</code>、 <code>freturn</code>、<code>dreturn</code>以及<code>areturn</code>，另外还有一个<code>return</code>指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
</li>
<li><p>在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p><strong>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表</strong>，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="/2021/04/19/JVM/image-20210423004042185.png" alt="image-20210423004042185"></p>
</li>
</ol>
<p>本质上，<strong>方法的退出就是当前栈帧出栈</strong>的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h4 id="10、一些附加信息"><a href="#10、一些附加信息" class="headerlink" title="10、一些附加信息"></a>10、一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对<strong>程序调试提供支持的信息</strong>。</p>
<h4 id="11、栈的相关面试题"><a href="#11、栈的相关面试题" class="headerlink" title="11、栈的相关面试题"></a>11、栈的相关面试题</h4><ul>
<li><p>举例栈溢出的情况? (StackOverflowError)</p>
<ul>
<li>通过-Xss设置栈的大小OOM</li>
</ul>
</li>
<li><p>调整栈大小，就能保证不出现溢出吗?</p>
<ul>
<li>不能</li>
</ul>
</li>
<li><p>分配的栈内存越大越好吗?</p>
<ul>
<li>不是!</li>
</ul>
</li>
<li><p>垃圾回收是否会涉及到虚拟机栈?</p>
<ul>
<li>不会的!</li>
</ul>
</li>
<li><p>方法中定义的局部变量是否线程安全?</p>
<ul>
<li>具体问题具体分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 7:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="12、关于运行时数据区的五大部分的OOM与GC问题"><a href="#12、关于运行时数据区的五大部分的OOM与GC问题" class="headerlink" title="12、关于运行时数据区的五大部分的OOM与GC问题"></a>12、关于运行时数据区的五大部分的OOM与GC问题</h4><table>
<thead>
<tr>
<th>运行时数据区</th>
<th>GC</th>
<th>OOM</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器（PC寄存器）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>方法区</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<hr>
<h3 id="6、本地方法接口"><a href="#6、本地方法接口" class="headerlink" title="6、本地方法接口"></a>6、本地方法接口</h3><p><img src="/2021/04/19/JVM/image-20210423090739894.png" alt="image-20210423090739894"></p>
<h4 id="1、什么是本地方法"><a href="#1、什么是本地方法" class="headerlink" title="1、什么是本地方法?"></a>1、什么是本地方法?</h4><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>在定义一个native method时， 并不提供实现体(有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是<strong>融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</strong>。</p>
<p><strong>标识符native可以与所以其它的java标识符连用，但是<code>abstract</code>除外</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native 与 public、void</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 static</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// native 与 private、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 默认</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、为什么要使用Native-Method"><a href="#2、为什么要使用Native-Method" class="headerlink" title="2、为什么要使用Native Method?"></a>2、为什么要使用Native Method?</h4><p>Java使用起来非常方便，然而有些层次的任务用<strong>Java实现起来不容易</strong>，或者我们<strong>对程序的效率很在意</strong>时，问题就来了。</p>
<ul>
<li>与Java环境外交互：<br>有时<strong>Java应用需要与Java外面的环境交互</strong>，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li>与操作系统交互：<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过<strong>使用本地方法我们得以用Java实现了jre的与底层系统的交互</strong>，<strong>甚至JVM的一些部分就是用c写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li>Sun’s Java<br><strong>Sun的解释器是用C实现的</strong>，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API。 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。</li>
</ul>
<h4 id="3、现状"><a href="#3、现状" class="headerlink" title="3、现状"></a>3、现状</h4><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<hr>
<h3 id="7、本地方法栈-Native-Method-Stack"><a href="#7、本地方法栈-Native-Method-Stack" class="headerlink" title="7、本地方法栈(Native Method Stack)"></a>7、本地方法栈(Native Method Stack)</h3><ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</p>
</li>
<li><p>本地方法栈，也是<strong>线程私有</strong>的。</p>
</li>
<li><p>允许被实现成<strong>固定或者是可动态扩展的内存大小</strong>。(在内存溢出方面是相同的)</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虛拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的。</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p><img src="/2021/04/19/JVM/image-20210423094103986.png" alt="image-20210423094103986"></p>
</li>
<li><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。<strong>它和虚拟机拥有同样的权限</strong>。</p>
<ul>
<li>本地方法可以通过<code>本地方法接口</code>来<strong>访问虛拟机内部的运行时数据区</strong>。</li>
<li>它甚至可以<strong>直接使用本地处理器中的寄存器</strong></li>
<li><strong>直接从本地内存的堆中分配任意数量的内存</strong>。</li>
</ul>
</li>
<li><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。(这里存在本地方法栈只是对于HotSpot JVM而言)</p>
</li>
<li><p>在HotSpot JVM中，直接将<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
</li>
</ul>
<hr>
<h3 id="8、堆（Heap）"><a href="#8、堆（Heap）" class="headerlink" title="8、堆（Heap）"></a>8、堆（Heap）</h3><h4 id="1、堆的核心概述"><a href="#1、堆的核心概述" class="headerlink" title="1、堆的核心概述"></a>1、堆的核心概述</h4><ul>
<li><p><strong>一个JVM实例只存在一个堆内存，堆也是Java<code>内存管理</code>的核心区域</strong>。</p>
</li>
<li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是<strong>JVM管理的最大一块内存空间</strong>。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间</strong>中，但<strong>在逻辑上</strong>它应该被视为<strong>连续</strong>的。</p>
<p>这里涉及到对象实例在堆内存中的存储方式，<strong>物理内存连续的采用指针碰撞</strong>，<strong>不连续的采用动态链表</strong></p>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Al location Buffer, <strong>TLAB</strong>) 。</p>
</li>
<li><p>《Java虛拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p>
<ul>
<li>The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li>
<li>我要说的是：“<strong>几乎</strong>”所有的对象实例都在这里分配内存。——从实际使用角度看的。</li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用</strong>，<strong>这个引用指向对象或者数组在堆中的位置</strong>。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
</li>
<li><p><strong>堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210423155400525.png" alt="image-20210423155400525"></p>
</li>
<li><p>内存细分：</p>
<p>现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为：</p>
<ul>
<li><strong>Java 7</strong>及之前堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>永久区</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分 为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/Tenure</li>
<li>Permanent Space    永久区    Perm</li>
</ul>
</li>
<li><strong>Java 8</strong>及之后堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>元空间</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/ Tenure</li>
<li>Meta Space     元空间    Meta</li>
</ul>
</li>
</ul>
<p>约定：</p>
<ul>
<li>新生区 &lt;=&gt; 新生代 &lt;=&gt; 年轻代</li>
<li>养老区 &lt;=&gt; 老年区 &lt;=&gt; 老年代</li>
<li>永久区 &lt;=&gt; 永久代</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
<p>堆空间的内部结构：</p>
<p><img src="/2021/04/19/JVM/image-20210423160441505.png" alt="image-20210423160441505"></p>
</li>
</ul>
<h4 id="2、设置堆内存大小与OOM"><a href="#2、设置堆内存大小与OOM" class="headerlink" title="2、设置堆内存大小与OOM"></a>2、设置堆内存大小与OOM</h4><ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”<code>-Xmx</code>“和”``-Xms`”来进行设置。<ul>
<li><strong>“<code>-Xms</code>“用于表示堆区（年轻代+老年代）的<code>起始内存</code>，等价于-XX: InitialHeapSize</strong><ul>
<li>-X是JVM的运行参数</li>
<li>ms是memory start</li>
</ul>
</li>
<li><strong>“<code>-Xmx</code>”则用于表示堆区（年轻代+老年代）的<code>最大内存</code>，等价于-XX :MaxHeapSize</strong></li>
</ul>
</li>
<li>查看设置的参数：<ol>
<li>jps /  jstat -gc 进程id</li>
<li>-XX:+PrintGCDetails</li>
</ol>
</li>
<li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</li>
<li>开发中建议将初始堆内存和最大的堆内存设置成相同的值。即将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能，避免系统压力</strong>。</li>
<li>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 手动设置600M之后：575M</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210423165450302.png" alt="image-20210423165450302"></p>
<p>结论：<strong>新生代的存储总量为一个伊甸园区加一个幸存者区</strong>(1或2，不能并存)，所以虽然设置了600M，但是实际上为575M。</p>
<p><strong>关于异常（Exception）与错误（Error）</strong>：</p>
<p>Java 语言规范将派生于 Error 类或 RuntimeException 类的所有异常称为非检查型（unchecked）异常，所有其他的异常称为检查型（checked）异常</p>
<h4 id="3、年轻代与老年代"><a href="#3、年轻代与老年代" class="headerlink" title="3、年轻代与老年代"></a>3、年轻代与老年代</h4><ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以划分为<strong>年轻代</strong>(YoungGen)和<strong>老年代</strong>(OldGen)</p>
</li>
<li><p>其中年轻代又可以划分为<strong>Eden空间</strong>、 <strong>Survivor0空间</strong>和<strong>Survivor1空间</strong>(有时也叫做<strong>from区</strong>、<strong>to区</strong>)</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E8%8A%82.jpg" alt="第08章_堆空间细节"></p>
</li>
<li><p>相关的参数设置与默认值（在开发中一般不会改变）</p>
<ul>
<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比。<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改- XX: NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
</li>
<li>-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例。默认值是8<ul>
<li>在HotSpot中， Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。</li>
<li>当然开发人员可以通过选项“-XX:SurvivorRatio””调整这个空间比例。比如-XX: SurvivorRatio=8</li>
<li>但在实际测试当中发现其实JVM分配Eden空间和两个Survivor空间的时候比例为6:1:1，即默认值为6而不是8，但是java官方表示的默认值就是8。如果要将比例修改为8:1:1，需要设置：<ul>
<li>-XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）（但发现没用，还是6:1:1）</li>
<li>-XX: SurvivorRatio=8，手动设置SurvivorRatio为8。（这还算什么默认值。。。）</li>
</ul>
</li>
</ul>
</li>
<li>-Xmn：设置新生代的空间的大小。（一般不设置）<ul>
<li>但一般新生代与老年代的空间分配是-XX:NewRatio设置的，默认为2。</li>
<li>当设置了-Xmn的时候，就与-XX:NewRatio冲突了</li>
<li>这时候JVM使用的是-Xmn设置的值（JDK8下测试）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>几乎所有</code>的Java对象都是在Eden区被new出来的</strong>。</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
</ul>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小。</p>
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423173418189.png" alt="image-20210423173418189"></p>
</li>
</ul>
<h4 id="4、图解大小分配过程"><a href="#4、图解大小分配过程" class="headerlink" title="4、图解大小分配过程"></a>4、图解大小分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中停生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li><p>当<strong>伊甸园的空间填满</strong>时，程序又需要创建对象，JVM的垃圾回收器**(Minor GC)将对伊甸园区进行垃圾回收**，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区（to区）。</p>
</li>
<li><p>如果再次触发垃圾回收，此时JVM的垃圾回收器(Minor GC)对伊甸园区进行垃圾回收（<strong>主动：伊甸园区满即触发</strong>），会放到幸存者1区（to区）。以及同时上次幸存下来的放到幸存者0区（from区）的，如果没有回收，也会放到幸存者1区（to区）。（被动：就算幸存者1区（to区）满了也不触发Minor GC垃圾回收器）</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li><p>啥时候能去养老区呢?可以设置次数。<strong>默认是<code>15</code>次</strong>。</p>
<p>可以设置参数: -XX:MaxTenuringThreshold=<N>进行设置。</N></p>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC， 进行养老区的内存清理。</p>
</li>
<li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常：<br> java. lang.OutOfMemoryError：Java heap space</p>
<p><img src="/2021/04/19/JVM/image-20210423181733858.png" alt="image-20210423181733858"></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to。</li>
<li>关于垃圾回收:频繁在新生区收集，<strong>很少在养老区收集</strong>，<strong>几乎不在永久区/元空间收集</strong>。</li>
</ul>
<p>对象分配流程图（含特殊情况）：</p>
<p><img src="/2021/04/19/JVM/image-20210423191247043.png" alt="image-20210423191247043"></p>
<p>VisualVM状态图分析：</p>
<p><img src="/2021/04/19/JVM/image-20210423192127797.png" alt="image-20210423192127797"></p>
<p>常用的调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Eclipse : Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h4 id="5、minor-GC、Major-GC、Full-GC"><a href="#5、minor-GC、Major-GC、Full-GC" class="headerlink" title="5、minor GC、Major GC、Full GC"></a>5、minor GC、Major GC、Full GC</h4><h5 id="1、GC的分类"><a href="#1、GC的分类" class="headerlink" title="1、GC的分类"></a>1、GC的分类</h5><ul>
<li>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</li>
<li>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集(Minor GC / Young GC)：只是新生代（Eden/S0、S1）的垃圾收集</li>
<li>老年代收集(MajorGC/Old GC)：只是老年代的垃圾收集。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><strong>注意，很多时候Major GC会和Fu1l GC混淆使用，需要具体分辨是老年代回收还是整堆回收</strong>。</li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Full GC)：收集整个java堆和方法区的垃圾收集。</li>
</ul>
</li>
</ul>
<h5 id="2、最简单的分代式GC策略的触发条件"><a href="#2、最简单的分代式GC策略的触发条件" class="headerlink" title="2、最简单的分代式GC策略的触发条件"></a>2、最简单的分代式GC策略的触发条件</h5><ul>
<li><p>年轻代GC(Minor GC)触发机制：</p>
<ul>
<li>当年轻代空间不足时， 就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)</li>
<li>因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423195836487.png" alt="image-20210423195836487"></p>
</li>
<li><p>老年代GC (Major GC/Full GC)触发机制:</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>MajorGC的速度一般会比MinorGC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</li>
<li><p>Full GC触发机制：(后面细讲)</p>
<ul>
<li>触发Full GC执行的情况有如下五种：<ol>
<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0 (From Space)区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
</li>
<li>说明: <strong>full gc是开发或调优中尽量要避免的。这样暂时时间会短一些</strong>。</li>
</ul>
</li>
</ul>
<h4 id="6、堆空间分代思想"><a href="#6、堆空间分代思想" class="headerlink" title="6、堆空间分代思想"></a>6、堆空间分代思想</h4><p>为什么需要把java堆分代?不分代就不能正常工作了吗?</p>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor (又称为from/to， s0/s1)构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。</p>
<p>而很多对象都是<strong>朝生夕死</strong>的，如果分代的话，把新创建的对象放到某一地方， 当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<h4 id="7、内存分配策略-或对象提升-Promotion-规则"><a href="#7、内存分配策略-或对象提升-Promotion-规则" class="headerlink" title="7、内存分配策略(或对象提升(Promotion)规则)"></a>7、内存分配策略(或对象提升(Promotion)规则)</h4><p>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对 象年龄设为1。对象在Survivor区中每熬过一次MinorGC ，年龄就增加1 岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、 每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项<code>-XX: MaxTenuringThreshold</code>来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li><strong>大对象直接分配到老年代</strong><ul>
<li>尽量避免程序中出现过多的大对象（特别是朝生夕死的大对象），防止过多的STW</li>
</ul>
</li>
<li><strong>长期存活(15岁)的对象分配到老年代</strong></li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX: HandlePromotionFailure</code> </li>
</ul>
</li>
</ul>
<h4 id="8、为对象分配内存：TLAB"><a href="#8、为对象分配内存：TLAB" class="headerlink" title="8、为对象分配内存：TLAB"></a>8、为对象分配内存：TLAB</h4><h5 id="1、为什么有TLAB-Thread-Local-Allocation-Buffer"><a href="#1、为什么有TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="1、为什么有TLAB ( Thread Local Allocation Buffer ) ?"></a>1、为什么有TLAB ( Thread Local Allocation Buffer ) ?</h5><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此<strong>在并发环境下从堆区中划分内存空间是线程不安全</strong>的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h5 id="2、什么是TLAB？"><a href="#2、什么是TLAB？" class="headerlink" title="2、什么是TLAB？"></a>2、什么是TLAB？</h5><ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM<strong>为每个线程分配了一个私有缓存区域</strong>，它<strong>包含在Eden空间</strong>内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_TLAB.jpg" alt="第08章_TLAB"></p>
<h5 id="3、TLAB相关说明"><a href="#3、TLAB相关说明" class="headerlink" title="3、TLAB相关说明"></a>3、TLAB相关说明</h5><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li>
<li>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启TLAB空间。<strong>默认为开启</strong>。</li>
<li>默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项“<code>-XX:TLABWasteTargetPercent</code>”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而<strong>直接在Eden空间中分配内存</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg" alt="第08章_对象分配过程"></p>
<h4 id="9、小结堆空间的常用的JVM参数设置"><a href="#9、小结堆空间的常用的JVM参数设置" class="headerlink" title="9、小结堆空间的常用的JVM参数设置"></a>9、小结堆空间的常用的JVM参数设置</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官网说明</a>：</p>
<ul>
<li>-XX: +PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX: +PrintFlagsFinal：查看所有的参数的最终值(可能会存在修改，不再是初始值)</li>
<li>-Xms：初始堆空间内存 (默认为物理内存的1/64)</li>
<li>-Xmx：最大堆空间内存(默认为物理内存的1/4)</li>
<li>-Xmn：设置新生代的大小。(初始值及最大值)</li>
<li>-XX:NewRatio: 配置新生代与老年代在堆结构的占比</li>
<li>-XX: SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX: MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX: +PrintGCDetails：输出详细的GC处理日志<ul>
<li>打印gc简要信息：</li>
<li>-XX: +PrintGC</li>
<li>-verbose: gc </li>
</ul>
</li>
<li>XX: HandlePromotionFailure：是否设置空间分配担保</li>
</ul>
<p>在发生MinorGC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX: HandlePromotionFailure设置值是否允许担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会<strong>继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Full GC。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24（JDK7）之后，HandlePromotionFailure参数不会再影响到虛拟机的空间分配担保策略，观察0penJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小就会进行Minor GC</strong>， 否则将进行Full GC。</p>
<h4 id="10、堆是分配对象的唯一选择吗？"><a href="#10、堆是分配对象的唯一选择吗？" class="headerlink" title="10、堆是分配对象的唯一选择吗？"></a>10、堆是分配对象的唯一选择吗？</h4><h5 id="1、堆是分配对象的唯一选择吗？"><a href="#1、堆是分配对象的唯一选择吗？" class="headerlink" title="1、堆是分配对象的唯一选择吗？"></a>1、堆是分配对象的唯一选择吗？</h5><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着<strong>JIT编译期的发展</strong>与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</p>
<p>此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<h5 id="2、逃逸分析概述"><a href="#2、逃逸分析概述" class="headerlink" title="2、逃逸分析概述"></a>2、逃逸分析概述</h5><h6 id="1、什么是逃逸分析？"><a href="#1、什么是逃逸分析？" class="headerlink" title="1、什么是逃逸分析？"></a>1、什么是逃逸分析？</h6><ul>
<li><p>如何将堆上的对象分配到栈，需要使用<strong>逃逸分析手段</strong>。</p>
</li>
<li><p>这是一种可以有效减少Java程序中<strong>同步负载</strong>和<strong>内存堆分配压力</strong>的<strong>跨函数全局数据流分析算法</strong>。</p>
</li>
<li><p>通过逃逸分析，Java HotSpot编译器能够分析出<strong>一个新的对象的引用的使用范围</strong>从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p>当<strong>一个对象在方法中被定义</strong>后，<strong>对象只在方法内部使用</strong>，则认为<strong>没有发生逃逸</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">//use v</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p>
</blockquote>
</li>
<li><p>当<strong>一个对象在方法中被定义</strong>后，它<strong>被外部方法所引用</strong>，则认为<strong>发生逃逸</strong>。例如作为<strong>调用参数</strong>传递到其他地方中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer() ;</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append (s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发生了逃逸的对象StringBuffer，作为返回值被返回回去了，在方法外可以被调用</p>
</blockquote>
<p>改进代码，让StringBuffer sb逃不出去：（转换为String类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1) ;</span><br><span class="line">    sb.append(s2) ;</span><br><span class="line">    <span class="keyword">return</span> sb.toString() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="2、逃逸分析的几种情况："><a href="#2、逃逸分析的几种情况：" class="headerlink" title="2、逃逸分析的几种情况："></a>2、逃逸分析的几种情况：</h6><p>如何快速的判断是否发生了逃逸分析，大家就看**<code>new的对象实体</code>是否有可能在方法外被调用**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">    //思考：如果当前的obj引用声明为static的？</span></span><br><span class="line"><span class="comment">    		仍然会发生逃逸。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、逃逸分析相关的参数设置："><a href="#3、逃逸分析相关的参数设置：" class="headerlink" title="3、逃逸分析相关的参数设置："></a>3、逃逸分析相关的参数设置：</h6><ul>
<li>在JDK 6u23（JDK7）版本之后，<strong>HotSpot中默认就已经开启了逃逸分析</strong>。</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“<code>-XX: +DoEscapeAnalysis</code>“显式开启逃逸分析</li>
<li>通过选项“<code>-XX: +PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<h6 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论:"></a>4、结论:</h6><p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
<h6 id="5、逃逸分析的代码优化"><a href="#5、逃逸分析的代码优化" class="headerlink" title="5、逃逸分析的代码优化"></a>5、逃逸分析的代码优化</h6><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>。<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
<li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么<strong>对于这个对象的操作可以不考虑同步</strong>。</li>
<li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是<strong>存储在CPU寄存器</strong>中。</li>
</ol>
<h6 id="6、代码优化之栈上分配"><a href="#6、代码优化之栈上分配" class="headerlink" title="6、代码优化之栈上分配"></a>6、代码优化之栈上分配</h6><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果<strong>一个对象并没有逃逸出方法的话，就可能被优化成栈上分配</strong>。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的栈上分配的场景<ul>
<li>在逃逸分析中，已经说明了。分别是<strong>给成员变量赋值</strong>、<strong>方法返回值</strong>、<strong>实例引用传递</strong>。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx256 -Xms256 -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 先关闭逃逸分析：-XX:-DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 在打开逃逸分析：-XX:+DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭逃逸分析的时候：代码执行时间：55ms，发生了GC</p>
<p>在开启逃逸分析的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<p>逃逸分析优化了对非逃逸对象的内存分配，实现了栈上分配。加快了程序的执行效率，并消除了GC，没有了STW，用户线程不会被阻碍。</p>
<h6 id="7、代码优化之同步省略（锁消除）"><a href="#7、代码优化之同步省略（锁消除）" class="headerlink" title="7、代码优化之同步省略（锁消除）"></a>7、代码优化之同步省略（锁消除）</h6><ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的<br>同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫<strong>同步省略</strong>，也叫<strong>锁消除</strong>。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。（在字节码文件下依旧存在synchronized的身影，即：字节码当中的monitorenter与monitorexit中间包裹的部分，只是在运行阶段进行了代码优化）</p>
<p>优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object() ;</span><br><span class="line">    System.out.println(hollis) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8、代码优化之标量替换"><a href="#8、代码优化之标量替换" class="headerlink" title="8、代码优化之标量替换"></a>8、代码优化之标量替换</h6><p>**标量(Scalar)**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现<strong>一个对象不会被外界访问</strong>的话，那么经过JIT优化，就会把这个<strong>对象拆解成若干个其中包含的若干个成员变量来代替</strong>。这个过程就是<strong>标量替换</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 先关闭标量替换：-XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 在打开标量替换：-XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭标量替换的时候：代码执行时间：57ms，发生了GC</p>
<p>在开启标量替换的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<ul>
<li><p>代码优化：（在alloc()方法中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Uesr这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个标量了。</p>
<p>那么标量替换有什么好处呢?</p>
<p>就是可以<strong>大大减少堆内存的占用</strong>。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p><strong>标量替换为栈上分配提供了很好的基础。</strong></p>
</li>
<li><p>另外，在开启<code>-XX:+DoEscapeAnalysis</code>即逃逸分析，同时关闭标量替换的时候为什么还会存在GC？</p>
<p>可以理解为（弹幕，不一定对）：</p>
<ul>
<li>栈上分配是要基于标量替换，即使开启了逃逸分析但是没有开启标量替换，他还是会在堆上分配。</li>
<li>对象未发生逃逸 + 开启标量替换 = 栈上分配 </li>
<li>可以将“栈上分配”理解为1个概念，具体要通过逃逸分析和标量替换两个参数决定</li>
</ul>
</li>
<li><p>标量替换参数设置：</p>
<p>参数<code>-XX: +EliminateAllocations</code>：开启了标量替换(默认打开)，允许将对象打散分配在栈上。</p>
</li>
<li><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。 使用如下参数运行上述代码：（逃逸分析在JDK7之后已经自动添加，这里针对的是服务器端）</p>
<ul>
<li>-server</li>
<li>-Xmx100m</li>
<li>-Xms100m</li>
<li>-XX: +DoEscapeAnalysis</li>
<li>-XX: +PrintGC</li>
<li>-XX: +EliminateAllGcations</li>
</ul>
<p>这里使用参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为<strong>在Server模式下，才可以启用逃逸分析</strong>。（java的JVM默认就是一个Server模式，不用我们手动开启）</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-xx: +PrintGC：将打印GC日志。</li>
<li>参数-XX:+E1 iminateAllocations：开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</li>
</ul>
</li>
</ul>
<h6 id="9、逃逸分析总结"><a href="#9、逃逸分析总结" class="headerlink" title="9、逃逸分析总结"></a>9、逃逸分析总结</h6><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，<strong>intern字符串缓存和静态变量</strong>并不是被转移到元数据区，而是<strong>直接在堆上分配</strong>，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</li>
</ul>
<h4 id="11、堆总结"><a href="#11、堆总结" class="headerlink" title="11、堆总结"></a>11、堆总结</h4><ul>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者Ful1GC。一般的，MinorGC 的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>
<hr>
<h3 id="9、方法区（Method-Area）"><a href="#9、方法区（Method-Area）" class="headerlink" title="9、方法区（Method Area）"></a>9、方法区（Method Area）</h3><h4 id="1、栈、堆、方法区的交互关系"><a href="#1、栈、堆、方法区的交互关系" class="headerlink" title="1、栈、堆、方法区的交互关系"></a>1、栈、堆、方法区的交互关系</h4><p>从线程是否共享的角度来看</p>
<p><img src="/2021/04/19/JVM/image-20210424010349347.png" alt="image-20210424010349347"></p>
<p>从代码看出栈、堆、方法区的交互关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210424010520101.png" alt="image-20210424010520101"></p>
<h4 id="2、方法区的理解"><a href="#2、方法区的理解" class="headerlink" title="2、方法区的理解"></a>2、方法区的理解</h4><h5 id="1、官方文档："><a href="#1、官方文档：" class="headerlink" title="1、官方文档："></a>1、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">官方文档</a>：</h5><p><img src="/2021/04/19/JVM/image-20210424010921229.png" alt="image-20210424010921229"></p>
<h5 id="2、方法区的位置"><a href="#2、方法区的位置" class="headerlink" title="2、方法区的位置"></a>2、方法区的位置</h5><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫做**Non-Heap (非堆)**，目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<h5 id="3、方法区和基本理解"><a href="#3、方法区和基本理解" class="headerlink" title="3、方法区和基本理解"></a>3、方法区和基本理解</h5><ul>
<li>方法区(Method Area) 与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</li>
<li>方法区在<strong>JVM启动的时候被创建</strong>，并且它的实际的<strong>物理内存空间</strong>中和Java堆区一样都<strong>可以是不连续</strong>的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li><strong>方法区的大小决定了系统可以保存多少个类</strong>，如果系统定义了太多的类，导致方法区溢出，虛拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:<strong>PermGen space</strong> （JDK7）或者 java.lang.OutOfMemoryError: <strong>Metaspace</strong>（JDK8）<ul>
<li><strong>加载大量的第三方的jar包；Tomcat 部署的工程过多(30-50个)，大量动态的生成反射类</strong></li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h5 id="4、Hotspot中方法区的演进"><a href="#4、Hotspot中方法区的演进" class="headerlink" title="4、Hotspot中方法区的演进"></a>4、Hotspot中方法区的演进</h5><ul>
<li><p>在<strong>JDK7及以前</strong>，习惯上把方法区，称为<strong>永久代</strong>。<strong>JDK8</strong>开始，使用<strong>元空间</strong>取代了永久代。</p>
<blockquote>
<p>In JDK8,classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
</li>
<li><p>本质上，<strong>方法区和永久代并不等价</strong>。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。 例如: <strong>BEA JRockit/ IBM J9中不存在永久代</strong>的概念。</p>
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM (超过-XX : MaxPermSize上限)</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
</li>
<li><p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间( Metaspace)来代替。</p>
<p><img src="/2021/04/19/JVM/image-20210424014427319.png" alt="image-20210424014427319"></p>
</li>
<li><p>元空间的本质和永久代类似，都是<strong>对JVM规范中方法区的实现</strong>。不过元空间与永久代最大的区别在于：<strong>元空间不在虛拟机设置的内存中，而是使用本地内存</strong>。</p>
</li>
<li><p>永久代、元空间二者并不只是名字变了，内部结构也调整了。</p>
<ul>
<li>根据《Java虚拟机规范》的规定，如果<strong>方法区</strong>无法满足新的内存分配需求时，将抛出<strong>OOM异常</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3、设置方法区大小与OOM"><a href="#3、设置方法区大小与OOM" class="headerlink" title="3、设置方法区大小与OOM"></a>3、设置方法区大小与OOM</h4><ul>
<li><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
</li>
<li><p>JDK7及以前：</p>
<ul>
<li><p>通过<code>-XX:PermSize</code>来设置永久代<strong>初始</strong>分配空间。<strong>默认值是20.75M</strong></p>
</li>
<li><p><code>-XX:MaxPermSize</code>来设定永久代<strong>最大</strong>可分配空间。<strong>32位机器默认是64M</strong>，<strong>64位机器模式是82M</strong></p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError : PermGen space</p>
<p><img src="/2021/04/19/JVM/image-20210424014940690.png" alt="image-20210424014940690"></p>
</li>
</ul>
</li>
<li><p>jdk8及以后:</p>
<ul>
<li><p>元数据区大小可以使用参数<code>-XX :MetaspaceSize</code>和<code>-XX :MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</p>
</li>
<li><p><strong>默认值依赖于平台</strong>。<strong>windows下，-XX:MetaspaceSize是21M， -XX: MaxMetaspaceSize的值是-1， 即没有限制</strong>。</p>
</li>
<li><p>参数设置方法：</p>
<ul>
<li>jdk7及以前：-XX:PermSize=100m -XX:MaxPermSize=100m</li>
<li>jdk8及以后：-XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m(这个一般不会改)</li>
</ul>
</li>
<li><p>与永久代不同，<strong>如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存</strong>。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace</p>
</li>
<li><p><code>-XX : MetaspaceSize</code>：<br><strong>设置初始的元空间大小</strong>。对于一个<strong>64位的服务器端JVM</strong>来说，其默认的-XX :MetaspaceSize值为<strong>21MB</strong>。这就是<strong>初始的高水位线</strong>，一 旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活)，然后这个高水位线将会重置。<strong>新的高水位线的值取决于GC后释放了多少元空间</strong>。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p><img src="/2021/04/19/JVM/image-20210424015216603.png" alt="image-20210424015216603"></p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议<strong>将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4、如何解决OOM"><a href="#4、如何解决OOM" class="headerlink" title="4、如何解决OOM"></a>4、如何解决OOM</h4><ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是<strong>确认内存中的对象是否是必要</strong>的，也就是要先分清楚到底是<strong>出现了内存泄漏(MemoryLeak)**还是</strong>内存溢出(Memory Overflow)<strong>。</strong>内存泄漏堆积会导致内存溢出<strong>，所以</strong>判断内存溢出第一步是查看内存是否泄漏**。</li>
<li>如果是<strong>内存泄漏</strong>，可进一步通过工具<strong>查看泄漏对象到GC Roots的引用链</strong>。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当<strong>检查虚拟机的堆参数</strong>(-Xmx与-Xms) ，<strong>与机器物理内存对比看是否还可以调大</strong>，从<strong>代码</strong>上检查<strong>是否存在某些对象生命周期过长、持有状态时间过长</strong>的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h4 id="5、方法区的内部结构"><a href="#5、方法区的内部结构" class="headerlink" title="5、方法区的内部结构"></a>5、方法区的内部结构</h4><p><img src="/2021/04/19/JVM/image-20210424020826940.png" alt="image-20210424020826940"></p>
<h5 id="1、方法区存储的内容"><a href="#1、方法区存储的内容" class="headerlink" title="1、方法区存储的内容"></a>1、方法区存储的内容</h5><p>《深入理解Java虚拟机》书中对方法区(Method Area)存储内容描述如下：</p>
<p>它用于存储已<strong>被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/2021/04/19/JVM/image-20210424020942369.png" alt="image-20210424020942369"></p>
<h5 id="2、方法区和内部结构"><a href="#2、方法区和内部结构" class="headerlink" title="2、方法区和内部结构"></a>2、方法区和内部结构</h5><h6 id="1、类型信息"><a href="#1、类型信息" class="headerlink" title="1、类型信息"></a>1、类型信息</h6><p>对每个加载的类型( 类calss、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的<strong>完整有效名称</strong>(全名=包名.类名)</li>
<li>这个类型<strong>直接父类的完整有效名</strong>(对于interface或是java. lang.object， 都没有父类)</li>
<li>这个类型的<strong>修饰符</strong>(public, abstract, final的某个子集)</li>
<li>这个类型<strong>直接接口的一个有序列表</strong></li>
</ol>
<h6 id="2、域（Field）信息"><a href="#2、域（Field）信息" class="headerlink" title="2、域（Field）信息"></a>2、域（Field）信息</h6><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符：public，private，protected，static，final，volatile，transient的某个子集</li>
</ul>
<h6 id="3、方法（Method）信息"><a href="#3、方法（Method）信息" class="headerlink" title="3、方法（Method）信息"></a>3、方法（Method）信息</h6><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的一个子集)</li>
<li>方法的字节码 (bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</li>
<li>异常表(abstract和native方法除外)<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h6 id="4、non-final的类变量"><a href="#4、non-final的类变量" class="headerlink" title="4、non-final的类变量"></a>4、non-final的类变量</h6><ul>
<li>静态变量和类关联在一起，<strong>随着类的加载而加载</strong>，它们成为类数据在逻辑上的一部分。</li>
<li><strong>类变量被类的所有实例共享，即使没有类实例时你也可以访问它</strong>。</li>
<li><clinit> javac编译器自动搜集字节码中的类变量的赋值动作和静态代码块组成的语句</clinit></li>
</ul>
<h6 id="5、全局常量：static-final"><a href="#5、全局常量：static-final" class="headerlink" title="5、全局常量：static final"></a>5、全局常量：static final</h6><p><strong>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424024056293.png" alt="image-20210424024056293"></p>
<h5 id="3、运行时常量池-VS-常量池"><a href="#3、运行时常量池-VS-常量池" class="headerlink" title="3、运行时常量池 VS 常量池"></a>3、运行时常量池 VS 常量池</h5><p><img src="/2021/04/19/JVM/image-20210424024352733.png" alt="image-20210424024352733"></p>
<ul>
<li><p><strong>方法区</strong>，内部包含了<strong>运行时常量池</strong>。</p>
</li>
<li><p><strong>字节码文件</strong>，内部包含了<strong>常量池</strong>。</p>
</li>
<li><p>方法区的运行时常量池就是class字节码文件中的常量池经过类加载器进行加载之后存放进内存之后得到。</p>
<p>但由于方法区的运行时常量池是具备动态性，所以可能比字节码文件里的常量池要大。</p>
</li>
<li><p>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</p>
</li>
<li><p>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">官网描述如下</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210424030341079.png" alt="image-20210424030341079"></p>
</li>
<li><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是<strong>常量池表(Constant Pool Table)</strong> ，**包括各种字面量和对类型、域和方法的<code>符号引用</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210424030544494.png" alt="image-20210424030544494"></p>
</li>
</ul>
<h5 id="4、为什么需要常量池？"><a href="#4、为什么需要常量池？" class="headerlink" title="4、为什么需要常量池？"></a>4、为什么需要常量池？</h5><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，<strong>这个字节码包含了指向常量池的<code>引用</code>**。在</strong>动态链接的时候会用到运行时常量池**。</p>
<p>比如如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHel1o</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object obj = new Object();经过编译之后会生成如下字节码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:	new #2				&#x2F;&#x2F; Class java&#x2F; lang&#x2F; object</span><br><span class="line">1:	dup</span><br><span class="line">2:	invokespecial #3	&#x2F;&#x2F; Method java&#x2F; lang&#x2F;object &quot;&lt;init&gt;&quot;( ) V</span><br></pre></td></tr></table></figure>

<p>虽然编译过后的class文件只有194字节，但是里面却使用了String、System、 PrintStream及object等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多!这里就需要常量池了!</p>
<h5 id="5、常量池中的内容"><a href="#5、常量池中的内容" class="headerlink" title="5、常量池中的内容"></a>5、常量池中的内容</h5><p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<h5 id="6、常量池小结"><a href="#6、常量池小结" class="headerlink" title="6、常量池小结"></a>6、常量池小结</h5><p><strong>常量池</strong>，可以看做是<strong>一张表</strong>，虚拟机指令根据这张常量表<strong>找到要执行的类名、方法名、参数类型、字面量等类型</strong>。</p>
<h5 id="7、运行时常量池"><a href="#7、运行时常量池" class="headerlink" title="7、运行时常量池"></a>7、运行时常量池</h5><ul>
<li><strong>运行时常量池</strong>( Runtime Constant Pool) 是<strong>方法区的一部分</strong>。</li>
<li><strong>常量池表</strong>( Constant Pool Table) 是<strong>Class文件的一部分</strong>，<strong>用于存放<code>编译期</code>生成的<code>各种字面量与符号引用</code>**，</strong>这部分内容将在<code>类加载后</code>存放到方法区的运行时常量池中**。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过**<code>索引访问</code>**的。</li>
<li>运行时常量池中包含多种不同的常量，<strong>包括编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong>。此时不再是常量池中的符号地址了，这里换为<code>真实地址</code>。<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：**<code>具备动态性</code>**。<ul>
<li>String. intern( )</li>
</ul>
</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表(symboltable)，但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</li>
</ul>
<h4 id="6、方法区使用举例"><a href="#6、方法区使用举例" class="headerlink" title="6、方法区使用举例"></a>6、方法区使用举例</h4><p><img src="/2021/04/19/JVM/image-20210424165338137.png" alt="image-20210424165338137"></p>
<p><img src="/2021/04/19/JVM/image-20210424165401780.png"></p>
<p><img src="/2021/04/19/JVM/image-20210424165459908.png" alt="image-20210424165459908"></p>
<h4 id="7、方法区的演进细节"><a href="#7、方法区的演进细节" class="headerlink" title="7、方法区的演进细节"></a>7、方法区的演进细节</h4><h5 id="1、方法区的演进"><a href="#1、方法区的演进" class="headerlink" title="1、方法区的演进"></a>1、方法区的演进</h5><p>首先明确：<strong>只有HotSpot才有永久代</strong>。</p>
<p>BEA JRockit、 IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jdk1.6及之前</td>
<td>有永久代(permanent generation)，静态变量存放在永久代上</td>
</tr>
<tr>
<td>jdk1.7</td>
<td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>jdk1.8及之后</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</td>
</tr>
</tbody></table>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82-hotspot.jpg" alt="第08章_方法区的演进细节-hotspot"></p>
<h5 id="2、元空间-VS-永久代"><a href="#2、元空间-VS-永久代" class="headerlink" title="2、元空间 VS 永久代"></a>2、元空间 VS 永久代</h5><p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">永久代为什么要被元空间替换</a>？</p>
<ul>
<li><p>随着Java8 的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间(Metaspace)。</p>
</li>
<li><p>由于类的元数据分配在<strong>本地内存</strong>中，<strong>元空间的最大可分配空间就是系统可用内存空间</strong>。</p>
</li>
<li><p>这项改动是很有必要的，原因有:</p>
<ol>
<li><p><strong>为永久代设置空间大小是很难确定的</strong>。</p>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread ‘dubbo client x.x connector’ java.lang OutOfMemoryError: PermGen space</p>
<p>而元空间和永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li><p>对<strong>永久代进行调优是很困难</strong>的。</p>
</li>
</ol>
</li>
</ul>
<h5 id="3、StringTable的调整"><a href="#3、StringTable的调整" class="headerlink" title="3、StringTable的调整"></a>3、StringTable的调整</h5><p>StringTable为什么要调整?</p>
<p><strong>jdk7</strong>中将StringTable放到了<strong>堆空间</strong>中。因为<strong>永久代的回收效率很低</strong>，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就<strong>导致StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h5 id="4、静态变量的位置"><a href="#4、静态变量的位置" class="headerlink" title="4、静态变量的位置"></a>4、静态变量的位置</h5><p>结论：<strong>静态引用对应的对象实体始终都存在堆空间</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>staticObj（静态变量）</strong>随着Test的类型信息存放在<strong>方法区</strong>，<strong>instanceObj（实例变量）</strong>随着Test的对象实例存放在<strong>Java堆</strong>，<strong>localObject（局部变量）</strong>则是存放在foo( )方法栈帧的<strong>局部变量表</strong>中。</p>
<p>三个对象的数据在<strong>内存中的地址</strong>都落在<strong>Eden区范围内</strong>。</p>
<p>所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<p>接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：</p>
<p><img src="/2021/04/19/JVM/image-20210424172219770.png" alt="image-20210424172219770"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有<strong>Class相关的信息都应该存放在方法区</strong>之中，但方法区该如何实现，《Java虚拟机规范》 并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。</p>
<p>JDK 7及其以后版本的HotSpot虚拟机选择把<strong>静态变量</strong>与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点。</p>
<h4 id="8、方法区的垃圾回收"><a href="#8、方法区的垃圾回收" class="headerlink" title="8、方法区的垃圾回收"></a>8、方法区的垃圾回收</h4><p>有些人认为方法区如HotSpot虚拟机中的元空间或者永久代)是没有垃圾收集行为的，其实不然。《Java虚拟机规范》 对方法区的约束是非常宽松的，提到过<strong>可以不要求虚拟机在方法区中实现垃圾收集</strong>。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK11时期的ZGC收集器就不支持类卸载)。</p>
<p><strong>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的</strong>。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虛拟机对此区域未完全回收而导致内存泄漏。</p>
<p>**方法区的垃圾收集主要回收两部分内容：<code>常量池中废弃的常量</code>和<code>不再使用的类型</code>**。</p>
<ul>
<li>先来说说方法区内**常量池之中主要存放的两大类常量：<code>字面量</code>和<code>符号引用</code>**。<br>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</li>
<li>而符号引用则属于编译原理方面的概念，包括下面三类常量：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要<strong>常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>判定<strong>一个常量是否“废弃”</strong>还是相对简单，而要判定<strong>一个类型是否属于“不再被使用的类”</strong>的条件就比较苛刻了。需要同时满足下面三个条件：<ol>
<li>该类所有的实例都已经被回收，也就是<strong>Java堆中不存在该类及其任何派生子类的实例</strong>。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong>。</li>
</ol>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“<strong>被允许</strong>”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX: +TraceClass-Loading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h4 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC09%E7%AB%A0_%E5%B0%8F%E7%BB%93.jpg" alt="第09章_小结"></p>
<h4 id="10、常见面试题"><a href="#10、常见面试题" class="headerlink" title="10、常见面试题"></a>10、常见面试题</h4><ul>
<li>百度:<ul>
<li>三面：说一下JVM内存模型吧，有哪些区?分别干什么的?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么?</li>
<li>一面: JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么两个survivor区?</li>
<li>二面: Eden和Survior的比例分配</li>
</ul>
</li>
<li>小米:<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>二面: Java的内存分区</li>
<li>二面:讲讲jvm运行时数据库区</li>
<li>什么时候对象会进入老年代?</li>
</ul>
</li>
<li>京东:<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面: JVM的内存模型，Java8做了什么修改</li>
</ul>
</li>
<li>拼多多:<ul>
<li>JVM 内存分哪几个区，每个区的作用是什么?</li>
</ul>
</li>
<li>美团:<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗?</li>
<li>一面: jvm内存分区，为什么要有新生代和老年代?</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、对象的实例化、内存布局与访问定位"><a href="#10、对象的实例化、内存布局与访问定位" class="headerlink" title="10、对象的实例化、内存布局与访问定位"></a>10、对象的实例化、内存布局与访问定位</h3><h4 id="1、对象的实例化"><a href="#1、对象的实例化" class="headerlink" title="1、对象的实例化"></a>1、对象的实例化</h4><h5 id="1、大厂面试题"><a href="#1、大厂面试题" class="headerlink" title="1、大厂面试题"></a>1、大厂面试题</h5><ul>
<li>美团:<ul>
<li>对象在JVM中是怎么存储的?</li>
<li>对象头信息里面有哪些东西?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>二面: java对象头里有什么</li>
</ul>
</li>
</ul>
<h5 id="2、对象实例化"><a href="#2、对象实例化" class="headerlink" title="2、对象实例化"></a>2、对象实例化</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg" alt="第10章_对象的实例化"></p>
<p>创建对象的字节码解析：</p>
<p><img src="/2021/04/19/JVM/image-20210424193206898.png" alt="image-20210424193206898"></p>
<p>创建步骤：</p>
<ol>
<li><p>判断对象对应的类是否加载、链接、初始化</p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。( 即<strong>判断类元信息是否存在</strong>)。如果没有，那么在<strong>双亲委派模式</strong>下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。</p>
</li>
<li><p>为对象分配内存</p>
<p>首先<strong>计算对象占用空间大小</strong>，接着在堆中划分一块内存给新对象。</p>
<p><strong>如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</strong>。</p>
<ul>
<li><p>如果内存规整，使用<strong>指针碰撞</strong>：</p>
<p>如果内存是规整的，那么虚拟机将采用的是**指针碰撞法(Bump The Pointer)**来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>如果内存不规整，虚拟机需要维护-一个列表，使用<strong>空闲列表分配</strong>：</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是<strong>虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表(Free List)“。</p>
</li>
</ul>
<p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。</p>
</li>
<li><p>处理并发安全问题</p>
<p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p>
<ol>
<li>CAS ( Compare And Swap )失败重试、区域加锁：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲区</strong>，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过<code>-XX: +/-UseTLAB</code>参数来设定（’+’：打开 ‘-‘：关闭）。</li>
</ol>
</li>
<li><p>初始化分配到的空间</p>
<p>内存分配结束，虚拟机将分配到的内存空间都**初始化为零值(不包括对象头)**。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>设置对象的对象头</p>
<p>将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p>执行init方法进行初始化</p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说(由字节码中是否跟随有invokespecial指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样<strong>一个真正可用的对象才算完全创建</strong>出来。</p>
</li>
</ol>
<h4 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_内存布局"></p>
<p>小结：图示</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%9B%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_图示对象的内存布局"></p>
<h4 id="3、对象的访存定位"><a href="#3、对象的访存定位" class="headerlink" title="3、对象的访存定位"></a>3、对象的访存定位</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="第10章_对象访问定位"></p>
<p>图示：JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p>
<p><img src="/2021/04/19/JVM/image-20210424190106896.png" alt="image-20210424190106896"></p>
<h5 id="1、句柄访问"><a href="#1、句柄访问" class="headerlink" title="1、句柄访问"></a>1、句柄访问</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式1：句柄访问"></p>
<p>好处：reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍)时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p>
<h5 id="2、直接指针（HotSpot采用）"><a href="#2、直接指针（HotSpot采用）" class="headerlink" title="2、直接指针（HotSpot采用）"></a>2、直接指针（HotSpot采用）</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式2：使用直接指针访问"></p>
<hr>
<h3 id="11、直接内存-Direct-Memory"><a href="#11、直接内存-Direct-Memory" class="headerlink" title="11、直接内存(Direct Memory)"></a>11、直接内存(Direct Memory)</h3><h4 id="1、直接内存概述"><a href="#1、直接内存概述" class="headerlink" title="1、直接内存概述"></a>1、直接内存概述</h4><ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li><strong>直接内存是在Java堆外</strong>的、<strong>直接向系统申请的内存区间</strong>。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常，<strong>访问直接内存的速度会优于Java堆。即读写性能高。</strong><ul>
<li>因此出于性能考虑，<strong>读写频繁的场合可能会考虑使用直接内存</strong>。</li>
<li><strong>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</strong></li>
</ul>
</li>
</ul>
<h4 id="2、IO-VS-NIO"><a href="#2、IO-VS-NIO" class="headerlink" title="2、IO VS NIO"></a>2、IO VS NIO</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IO</th>
<th align="center">NIO (New IO / Non-Blocking IO：非阻塞IO)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现</td>
<td align="center">byte[] / char[]</td>
<td align="center">Buffer（缓存区）</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">Stream（流）</td>
<td align="center">Channel（管道）</td>
</tr>
</tbody></table>
<h4 id="3、直接缓存区（IO）-VS-非直接缓存区（NIO）"><a href="#3、直接缓存区（IO）-VS-非直接缓存区（NIO）" class="headerlink" title="3、直接缓存区（IO） VS 非直接缓存区（NIO）"></a>3、直接缓存区（IO） VS 非直接缓存区（NIO）</h4><p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。</p>
<p>使用IO，见下图。这<strong>里需要两份内存存储重复数据，效率低</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225618054.png" alt="image-20210424225618054"></p>
<p>使用NIO时，如下图。</p>
<p><strong>操作系统划出的直接缓存区可以被java代码直接访问，只有一份。 NIO适合对大文件的读写操作</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225837934.png" alt="image-20210424225837934"></p>
<h4 id="4、直接内存的OOM异常"><a href="#4、直接内存的OOM异常" class="headerlink" title="4、直接内存的OOM异常"></a>4、直接内存的OOM异常</h4><ul>
<li><p><strong>直接内存也可能导致OutOfMemoryError异常</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231245461.png" alt="image-20210424231245461"></p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是<strong>系统内存是有限</strong>的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>缺点</p>
<ul>
<li><strong>分配回收成本较高</strong></li>
<li><strong>不受JVM内存回收管理</strong></li>
</ul>
</li>
<li><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置</p>
</li>
<li><p>如果不指定，<strong>默认与堆的最大值-Xmx参数值一致</strong></p>
</li>
</ul>
<p>简单理解：</p>
<p><strong>java process memory = java heap + native memory</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231440926.png" alt="image-20210424231440926"></p>
<hr>
<h3 id="12、执行引擎"><a href="#12、执行引擎" class="headerlink" title="12、执行引擎"></a>12、执行引擎</h3><h4 id="1、执行引擎概述"><a href="#1、执行引擎概述" class="headerlink" title="1、执行引擎概述"></a>1、执行引擎概述</h4><h5 id="1、执行引擎的作用"><a href="#1、执行引擎的作用" class="headerlink" title="1、执行引擎的作用"></a>1、执行引擎的作用</h5><ul>
<li>执行引擎是Java虛拟机<strong>核心</strong>的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此<strong>可以不受物理条件制约地定制指令集与执行引擎的结构体系</strong>，能够<strong>执行那些不被硬件直接支持的指令集格式</strong>。</li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令</strong>才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ul>
<h5 id="2、执行引擎的工作过程"><a href="#2、执行引擎的工作过程" class="headerlink" title="2、执行引擎的工作过程"></a>2、执行引擎的工作过程</h5><ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令<strong>完全依赖于PC寄存器</strong>。</li>
<li>每当执行完一项指令操作后，PC寄存器就会<strong>更新下一条需要被执行的指令地址</strong>。</li>
<li>当前方法在执行的过程中，<strong>执行引擎</strong>有可能会<strong>通过</strong>存储在局部变量表中的<strong>对象引用准确定位</strong>到存储在Java堆区中的<strong>对象实例信息</strong>，以及<strong>通过对象头中的元数据指针定位到目标对象的类型信息</strong>。</li>
</ul>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：<strong>输入的是字节码二进制流</strong>，处理过程是<strong>字节码解析执行的等效过程</strong>，<strong>输出的是执行结果</strong>。</p>
<h4 id="2、Java代码编译和执行过程"><a href="#2、Java代码编译和执行过程" class="headerlink" title="2、Java代码编译和执行过程"></a>2、Java代码编译和执行过程</h4><p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005150269.png" alt="image-20210425005150269"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005213179.png" alt="image-20210425005213179"></p>
<p>问题1：什么是解释器( Interpreter)，什么是JIT编译器? </p>
<ul>
<li>解释器：当Java虛拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT (Just In Time Compiler) 编译器：就是虚拟机将<strong>源代码直接编译成和本地机器平台相关的机器语言</strong>。</li>
<li>解释器：边逐行翻译边运行</li>
<li>编译器：一起编译好再执行</li>
</ul>
<p>问题2：为什么说Java是半编译半解释型语言?</p>
<ul>
<li><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
</li>
<li><p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来</strong>进行。</p>
</li>
<li><p>经过编译器编译之后可以在方法区中进行缓存（热点代码）</p>
<p><img src="/2021/04/19/JVM/image-20210425005819291.png" alt="image-20210425005819291"></p>
</li>
</ul>
<h4 id="3、机器码、指令、汇编语言"><a href="#3、机器码、指令、汇编语言" class="headerlink" title="3、机器码、指令、汇编语言"></a>3、机器码、指令、汇编语言</h4><h5 id="1、理解执行引擎"><a href="#1、理解执行引擎" class="headerlink" title="1、理解执行引擎"></a>1、理解执行引擎</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg" alt="第12章_理解执行引擎"></p>
<h5 id="2、机器码"><a href="#2、机器码" class="headerlink" title="2、机器码"></a>2、机器码</h5><ul>
<li>各种用二进制编码方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，<strong>执行速度最快</strong>。</li>
<li>机器指令与CPU紧密相关，所以<strong>不同种类的CPU所对应的机器指令也就不同</strong>。</li>
</ul>
<h5 id="3、指令与指令集"><a href="#3、指令与指令集" class="headerlink" title="3、指令与指令集"></a>3、指令与指令集</h5><ul>
<li>指令<ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的0和1序列，简化成对应的指令(一般为英文简写，如mov,inc等)，可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比如mov)，对应的机器码也可能不同。</li>
</ul>
</li>
<li>指令集<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、汇编语言"><a href="#4、汇编语言" class="headerlink" title="4、汇编语言"></a>4、汇编语言</h5><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<strong>助记符</strong>(Mnemonics)代替<strong>机器指令的操作码</strong>，用<strong>地址符号</strong>(Symbol) 或<strong>标号</strong>(Label)代替<strong>指令或操作数的地址</strong>。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用<strong>汇编语言编写的程序还必须翻译成机器指令码</strong>，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h5 id="5、高级语言"><a href="#5、高级语言" class="headerlink" title="5、高级语言"></a>5、高级语言</h5><ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<strong>更接近人的语言</strong>。</li>
<li>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做<strong>解释程序</strong>或<strong>编译程序</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-1619284091715.jpg" alt="第12章_机器语言、汇编、高级语言"></p>
<h5 id="6、字节码"><a href="#6、字节码" class="headerlink" title="6、字节码"></a>6、字节码</h5><ul>
<li>字节码是一种**中间状态(中间码)的二进制代码(文件)**，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。（<strong>实现跨平台</strong>）</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<h5 id="7、C-C-源程序执行过程"><a href="#7、C-C-源程序执行过程" class="headerlink" title="7、C/C++源程序执行过程"></a>7、C/C++源程序执行过程</h5><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<ul>
<li><strong>编译过程</strong>：是读取源程序(字符流)，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li>
<li><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210425020914156.png" alt="image-20210425020914156"></p>
<h4 id="4、解释器"><a href="#4、解释器" class="headerlink" title="4、解释器"></a>4、解释器</h4><h5 id="1、解释器概述"><a href="#1、解释器概述" class="headerlink" title="1、解释器概述"></a>1、解释器概述</h5><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p>为什么需要字节码文件作为中间过渡，而不是采用将java源文件直接编译成对应的不同操作系统的机器指令的方式（此方式也可以实现跨平台）？</p>
<p>字节码文件是<strong>为了提高编译器的效率</strong>，同时也是Java虚拟机被称为<strong>跨语言的平台</strong>的基础。</p>
<p><img src="/2021/04/19/JVM/image-20210425021622259.png" alt="image-20210425021622259"></p>
<h5 id="2、解释器的工作机制（或工作任务）"><a href="#2、解释器的工作机制（或工作任务）" class="headerlink" title="2、解释器的工作机制（或工作任务）"></a>2、解释器的工作机制（或工作任务）</h5><ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
<h5 id="3、解释器分类"><a href="#3、解释器分类" class="headerlink" title="3、解释器分类"></a>3、解释器分类</h5><p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<ul>
<li>字节码解释器在执行时通过<strong>纯软件代码模拟字节码的执行</strong>，效率非常低下。</li>
<li>模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由<strong>Interpreter模块</strong>和<strong>Code模块</strong>构成。<ul>
<li>Interpreter模块：实现了解释器的<strong>核心功能</strong></li>
<li>Code模块：用于<strong>管理</strong>HotSpot VM在运行时生成的<strong>本地机器指令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、解释器现状"><a href="#4、解释器现状" class="headerlink" title="4、解释器现状"></a>4、解释器现状</h5><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些<br>C/C++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作<strong>即时编译</strong>的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h4 id="5、JIT编译器"><a href="#5、JIT编译器" class="headerlink" title="5、JIT编译器"></a>5、JIT编译器</h4><h5 id="1、Java代码的执行分类"><a href="#1、Java代码的执行分类" class="headerlink" title="1、Java代码的执行分类"></a>1、Java代码的执行分类</h5><ol>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行(直接编译成机器码)。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT, Just In Time）将方法编译成机器码后再执行</p>
<p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
</li>
</ol>
<ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用<strong>解释器与即时编译器并存</strong>的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代<br>码的时间和直接解释执行代码的时间。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一 较高下的地步。</li>
</ul>
<h5 id="2、为什么需要解释器？"><a href="#2、为什么需要解释器？" class="headerlink" title="2、为什么需要解释器？"></a>2、为什么需要解释器？</h5><p>有些开发人员会感觉到诧异，既然HotSpot VM中 已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢?比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确：</p>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>总结成一句话：<strong>解释器的响应速度快，执行速度慢；而编译器的响应速度慢，执行速度快。</strong></p>
<p>所以：</p>
<p>尽管JRockit VM中程序的执行性能会非常高效，但<strong>程序在启动时必然需要花费更长的时间来进行编译</strong>。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率</strong>。</p>
<p>同时，<strong>解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”</strong>。</p>
<h5 id="3、HotSpot-JVM-的执行方式"><a href="#3、HotSpot-JVM-的执行方式" class="headerlink" title="3、HotSpot JVM 的执行方式"></a>3、HotSpot JVM 的执行方式</h5><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且<strong>随着程序运行时间的推移，即时编译器逐渐发挥作用</strong>，根据<strong>热点探测功能</strong>，将<strong>有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</strong>。</p>
<p>相关案例：</p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态可以承受的负载要大于冷机状态</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>热机状态：已经启动很长时间；冷机状态：刚刚启动</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机,此故障说明了JIT的存在。——阿里团队</p>
<p><img src="/2021/04/19/JVM/image-20210425024022961.png" alt="image-20210425024022961"></p>
<h5 id="4、JIT即时编译器"><a href="#4、JIT即时编译器" class="headerlink" title="4、JIT即时编译器"></a>4、JIT即时编译器</h5><h6 id="1、概念解释"><a href="#1、概念解释" class="headerlink" title="1、概念解释"></a>1、概念解释</h6><ul>
<li>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器(其实叫“ 编译器的前端”更准确一些)把. java文件转变成.class文件的过程；</li>
<li>也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器 (AOT编译器，Ahead Of Time Compiler) 直接把.java文件编译成本地机器代码的过程。</li>
</ul>
<p>相关的编译器：</p>
<ul>
<li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器( ECJ)</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器</li>
<li>AOT编译器：GNU Compiler for the Java (GCJ)、Excelsior JET。</li>
</ul>
<h6 id="2、是否选择使用编译器"><a href="#2、是否选择使用编译器" class="headerlink" title="2、是否选择使用编译器"></a>2、是否选择使用编译器</h6><p>热点代码及探测方式</p>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被<strong>调用执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<h6 id="3、热点代码及探测方式"><a href="#3、热点代码及探测方式" class="headerlink" title="3、热点代码及探测方式"></a>3、热点代码及探测方式</h6><ul>
<li><p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过<strong>JIT编译器编译为本地机器指令</strong>。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为<strong>OSR (On Stack Replacement)编译</strong>。</p>
</li>
<li><p>一个方法究竟<strong>要被调用多少次</strong>，或者<strong>一个循环体究竟需要执行多少次</strong>循环才可以达到这个标准?</p>
<p>必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</p>
</li>
<li><p><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</p>
</li>
<li><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>(Invocation Counter)和<strong>回边计数器</strong>(BackEdge Counter) 。</p>
<ul>
<li><strong>方法调用计数器用于统计方法的调用次数</strong></li>
<li><strong>回边计数器则用于统计循环体执行的循环次数</strong></li>
</ul>
</li>
</ul>
<h6 id="4、方法调用计数器"><a href="#4、方法调用计数器" class="headerlink" title="4、方法调用计数器"></a>4、方法调用计数器</h6><ul>
<li><p>这个计数器就用于<strong>统计方法被调用的次数</strong>，它的默认阈值<strong>在Client模式下是1500次</strong>，<strong>在Server 模式下是10000 次</strong>。超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>这个阈值可以通过虛拟机参数<code>-XX:CompileThreshold</code>来人为设定。</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
</li>
<li><p>方法调用计数器的工作流程图：</p>
<p><img src="/2021/04/19/JVM/image-20210425024857559.png" alt="image-20210425024857559"></p>
<p>简化版本：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_方法调用计数器"></p>
</li>
<li><p>热度衰减</p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过<strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为<strong>方法调用计数器热度的衰减</strong>(Counter Decay) ，而这段时间就称为此方法统计的<strong>半衰周期</strong>(Counter Half Life Time) 。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用<code>-XX:CounterHalfLifeTime</code> 参数设置半衰周期的时间，单位是秒。</li>
</ul>
</li>
</ul>
<h6 id="5、回边计数器"><a href="#5、回边计数器" class="headerlink" title="5、回边计数器"></a>5、回边计数器</h6><ul>
<li><p>它的作用是统计一个方法中<strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边” (Back Edge) 。显然，建立回边计数器统计的目的就是为了<strong>触发OSR编译</strong>。</p>
</li>
<li><p>回边计数器的执行流程图：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_回边计数器"></p>
</li>
</ul>
<h6 id="6、HotSpot-VM可以设置程序执行方式"><a href="#6、HotSpot-VM可以设置程序执行方式" class="headerlink" title="6、HotSpot VM可以设置程序执行方式"></a>6、HotSpot VM可以设置程序执行方式</h6><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用解释器执行</strong>，还是<strong>完全采用即时编译器执行</strong>。如下所示：</p>
<ul>
<li><p><code>-Xint</code>：完全采用解释器模式执行程序；</p>
</li>
<li><p><code>-Xcomp</code>： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</p>
</li>
<li><p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。（默认）</p>
<p><img src="/2021/04/19/JVM/image-20210425031931789.png" alt="image-20210425031931789"></p>
</li>
</ul>
<h6 id="7、HotSpot-VM中JIT分类"><a href="#7、HotSpot-VM中JIT分类" class="headerlink" title="7、HotSpot VM中JIT分类"></a>7、HotSpot VM中JIT分类</h6><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为<strong>C1编译器</strong>和<strong>C2编译器</strong>。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><p><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p>
<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，<strong>耗时短</strong>。以达到更快的编译速度。</li>
</ul>
</li>
<li><p><code>-server</code>：指定Java虚拟机运行在Server模式下，并使用C2编译器。（对于84位的操作系统默认就是Srver模式，不能修改）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官方</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425030403484.png" alt="image-20210425030403484"></p>
<p><img src="/2021/04/19/JVM/image-20210425030645445.png" alt="image-20210425030645445"></p>
<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<p><strong>分层编译(Tiered Compilation)策略</strong>：程序解释执行(不开启性能监控)可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p><strong>C1和C2编译器不同的优化策略：</strong></p>
<ul>
<li>在不同的编译器上有不同的优化策略，C1骗译器上主要有<strong>方法内联</strong>，<strong>去虚拟化</strong>、<strong>冗余消除</strong>。<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<p>总结:</p>
<ul>
<li>一般来讲，<strong>JIT编译出来的机器码性能比解释器高</strong>。</li>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h6 id="8、最后补充"><a href="#8、最后补充" class="headerlink" title="8、最后补充"></a>8、最后补充</h6><ul>
<li>关于C1与C2：<ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器：<strong>Graal编译器</strong>。</li>
<li>编译效果短短几年时间就追评了C2编译器。未来可期。</li>
<li>目前，带着“实验状态”标签，需要使用开关参数去激活，才可以使用。<ul>
<li><code>-XX: +UnlockExperimentalVMOptions</code> </li>
<li><code>-XX: +UseJVMCICompiler</code></li>
</ul>
</li>
</ul>
</li>
<li>关于AOT编译器：（AOT VS JIT）<ul>
<li>jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)</li>
<li>Java 9引入了实验性AOT编译工具<strong>jaotc</strong>。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在<strong>程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在<strong>程序运行之前</strong>，便将字节码转换为机器码的过程。<ul>
<li>.java -&gt; .class -(jaotc)-&gt; .so(机器指令)</li>
</ul>
</li>
<li>最大好处：Java虛拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>缺点:<ul>
<li>破坏了java“一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。</li>
<li><strong>降低了Java链接过程的动态性</strong>，加载的代码在编译期就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="13、String-Table"><a href="#13、String-Table" class="headerlink" title="13、String Table"></a>13、String Table</h3><h4 id="1、String的基本特性"><a href="#1、String的基本特性" class="headerlink" title="1、String的基本特性"></a>1、String的基本特性</h4><ul>
<li><p>String：字符串，使用一对<code>&quot;&quot;</code>引起来表示。</p>
<ul>
<li><pre><code class="java">// 字面量的方式
String str = &quot;Hello&quot;;
// new的方式
String string = new String(&quot;Hi&quot;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- String声明为final的，**不可被继承**</span><br><span class="line"></span><br><span class="line">- String实现了Serializable接口：表示字符串是**支持序列化**的</span><br><span class="line"></span><br><span class="line">- String实现了Comparable接口：表示String可以**比较大小**</span><br><span class="line"></span><br><span class="line">- String在JDK8及以前内部定义了final char[] value用于存储字符串数据。**JDK9时改为byte[]**</span><br><span class="line"></span><br><span class="line">  - [官方](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;254</span><br><span class="line">    )：</span><br><span class="line"></span><br><span class="line">    ![image-20210425194526787](JVM&#x2F;image-20210425194526787.png)</span><br><span class="line"></span><br><span class="line">    ![image-20210425201622470](JVM&#x2F;image-20210425201622470.png)</span><br><span class="line"></span><br><span class="line">- String：代表不可变的字符序列。简称：不可变性</span><br><span class="line"></span><br><span class="line">  - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"></span><br><span class="line">- 通过字面量的方式（区别与new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span><br><span class="line"></span><br><span class="line">- 字符串常量池中是不会存储相同内容的字符串的</span><br><span class="line"></span><br><span class="line">  - String的String Pool时一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长。而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</span><br><span class="line">  - 使用&#96;-XX: StringTableSize&#96;可设置StringTable的长度</span><br><span class="line">  - 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多的就会导致效率下降很快。StringTableSize设置没有要求</span><br><span class="line">  - 在JDK7中，StringTable的长度默认值是60013，StringTableSize设置没有要求</span><br><span class="line">  - 在JDK8开始，设置StringTable的长度的话，1009是可设置的最小值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、String的内存分配</span><br><span class="line"></span><br><span class="line">- 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</span><br><span class="line"></span><br><span class="line">- 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，**String类型的常量池比较特殊。它的主要使用方法有两种**：</span><br><span class="line"></span><br><span class="line">  - 直接使用双引号&#96;&quot;&quot;&#96;声明出来的String对象会直接存储在常量池中。</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String info &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>如果不是用双引号<code>&quot;&quot;</code>声明的String对象，可以使用String提供的intern()方法。</p>
</li>
</ul>
</li>
<li><p><strong>Java6及以前，字符串常量池存放在永久代</strong>。</p>
</li>
<li><p>Java7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong>。</p>
<ul>
<li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
</li>
<li><p>字符串常量池概念原本使用比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()。</p>
</li>
<li><p>Java8元空间，字符串常量池在堆</p>
<p><img src="/2021/04/19/JVM/image-20210425213811970.png" alt="image-20210425213811970"></p>
</li>
</ul>
</li>
<li><p>为什么StringTable要调整？</p>
<ul>
<li>permSize默认比较小</li>
<li>永久代垃圾回收的频率低</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes">官网</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425214013347.png" alt="image-20210425214013347"></p>
</li>
</ul>
<h4 id="3、String的基本操作"><a href="#3、String的基本操作" class="headerlink" title="3、String的基本操作"></a>3、String的基本操作</h4><p>Java语言规范里要求<strong>完全相同的字符串字面量</strong>，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且<strong>必须是指向同一个String类实例</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425215451317.png" alt="image-20210425215451317"></p>
<p>A string is created in line 7.it goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.</p>
<h4 id="4、字符串拼接操作"><a href="#4、字符串拼接操作" class="headerlink" title="4、字符串拼接操作"></a>4、字符串拼接操作</h4><ol>
<li>常量与插入的拼接结果在常量池，原理是<strong>编译期优化</strong></li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆（非字符串常量池）中。变量拼接原理是<strong>StringBuilder</strong>（底层新建了一个StringBuilder对象进行字符串拼接）</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li>
</ol>
<p>相关案例：</p>
<p>总结：</p>
<ul>
<li><p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>
</li>
<li><p>intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</p>
</li>
<li><p>如下的s1 + s2 的执行细节：(变量s是我临时定义的）</p>
<ul>
<li><p>StringBuilder s = new StringBuilder();</p>
</li>
<li><p>s.append(“a”)</p>
</li>
<li><p>s.append(“b”)</p>
</li>
<li><p>s.toString()  –&gt; 约等于 new String(“ab”)</p>
<p>StringBuilder的toString()方法的new里面放的是char数组，不会在常量池创建对，而new String(“ab”)这里放的是字面量，会先在常量池创对象</p>
</li>
</ul>
<p>补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</p>
</li>
<li><p>字符串拼接操作不一定使用的是StringBuilder!</p>
<ul>
<li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</li>
</ul>
</li>
<li><p>针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</p>
<p>final修饰的变量一旦赋值后就不能再次赋值，所以可以做编译期优化，但是如果使用final String s = new String(“a”)；则不会做编译期优化，必须运行时才能确定。</p>
</li>
<li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p>
<ul>
<li><p>详情：</p>
<ul>
<li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li>
<li>使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</li>
<li>使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</li>
</ul>
</li>
<li><p>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</p>
<p>StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</p>
</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">           使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span></span><br><span class="line"><span class="comment">               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425221328973.png" alt="image-20210425221328973"></p>
<p><img src="/2021/04/19/JVM/image-20210425221607026.png" alt="image-20210425221607026"></p>
<p><img src="/2021/04/19/JVM/image-20210425221622886.png" alt="image-20210425221622886"></p>
<p><img src="/2021/04/19/JVM/image-20210425221651006.png" alt="image-20210425221651006"></p>
<p>StringBuilder执行拼接操作：</p>
<ul>
<li>好处：从始至终就创建了一个stringBuilder对象去执行append操作</li>
<li>改进空间：<ul>
<li>可以使用StringBuilder的带参数的构造器，指定大小</li>
<li>如果调用默认构造器，初始容量16，进行大量存储操作时，会导致频繁扩容(数组大小是不可变的,所以得新建数组，然后进行数组间的copy，中间也会产生垃级对象，耗时耗力。</li>
</ul>
</li>
</ul>
<h4 id="5、intern-的使用"><a href="#5、intern-的使用" class="headerlink" title="5、intern()的使用"></a>5、intern()的使用</h4><h5 id="1、Java-lang-String-intern-的相关解释"><a href="#1、Java-lang-String-intern-的相关解释" class="headerlink" title="1、Java.lang.String.intern()的相关解释"></a>1、Java.lang.String.intern()的相关解释</h5><p><img src="/2021/04/19/JVM/image-20210426012219855.png" alt="image-20210426012219855"></p>
<h5 id="2、intern-的使用"><a href="#2、intern-的使用" class="headerlink" title="2、intern()的使用"></a>2、intern()的使用</h5><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<ul>
<li><p>比如：</p>
<ul>
<li><pre><code class="java">String myInfo = new String(&quot;I love atguigu&quot;).intern();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    (&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() &#x3D;&#x3D; &quot;abc&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool)。</p>
</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426020658942.png" alt="image-20210426020658942"></p>
<ul>
<li>如何保证变量s指向的是字符串常量池中的数据呢？<ul>
<li>有两种方式：<ul>
<li>方式一： String s = “shkstart”;//字面量定义的方式</li>
<li>方式二： 调用intern()<ul>
<li><pre><code>    String s = new String(&quot;shkstart&quot;).intern();</code></pre>
</li>
<li><pre><code>    String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢"><a href="#3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢" class="headerlink" title="3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?"></a>3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str = new String(&quot;ab&quot;);</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目： new String(“ab”) 会创建几个对象?</p>
<ul>
<li>new String(“ab”)会创建几个对象？看字节码，就知道是两个。<ul>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
</ul>
</li>
</ul>
<p>拓展: new String(“a”) + new String (“b”)呢?</p>
<ul>
<li>看字节码，知道是五个对象<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2： new String(“a”)</li>
<li>对象3： 常量池中的”a”</li>
<li>对象4： new String(“b”)</li>
<li>对象5： 常量池中的”b”</li>
</ul>
</li>
<li>深入剖析： StringBuilder的toString():<ul>
<li>对象6 ：new String(“ab”)</li>
</ul>
</li>
<li>强调一下，toString()的调用（底层用的是char[]数组创建的字符串），在字符串常量池中，没有生成”ab”</li>
</ul>
<h5 id="4、intern-的使用-jdk6-vs-jdk7-8"><a href="#4、intern-的使用-jdk6-vs-jdk7-8" class="headerlink" title="4、intern()的使用: jdk6 vs jdk7/8"></a>4、intern()的使用: jdk6 vs jdk7/8</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">                                            <span class="comment">//         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于s3 == s4在JDK6 与 JDK7/8中答案不同的解析：</p>
<ul>
<li><p>JDK6：在JDK6中，字符串常量池是放在永久代中</p>
<ul>
<li><p>执行到String s3 = new String(“1”) + new String(“1”);的时候，程序在堆空间创建了一片空间用来存放字符串”11”，局部变量s3里存放着字符串”11”在堆空间当中的地址。</p>
<p>注意：此时的字符串常量池中并不存在字符串”11”（底层调用了StringBuilder的toString()方法，其中的new String使用char[]数组的方式创建了字符串”11”）</p>
</li>
<li><p>执行到s3.intern();的时候，intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。然而字符串常量池当中并不存在字符串”11”。所以，程序在字符串常量池中生成”11”对象。</p>
</li>
<li><p>执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址）</p>
</li>
<li><p>由于变量s3的引用是堆当中字符串对象”11”的地址，而变量s4的引用是字符串常量池中字符串”11”的地址。两者并不相等。</p>
</li>
</ul>
</li>
<li><p>JDK7/8：在JDK7/8中，字符串常量池放在堆中</p>
<ul>
<li>执行String s3 = new String(“1”) + new String(“1”);与上面描述的一样</li>
<li>执行到s3.intern();的时候，由于字符串常量池是存放在堆空间当中，而字符串”11”对象也在堆空间，所以intern()方法在字符串常量池中创建字符串”11”的时候，直接将堆空间中的字符串”11”的地址存放进了字符串常量池的字符串”11”对象当中，即字符串常量池中存放的是堆空间中字符串”11”的引用。即变量s3的引用也指向了字符串常量池的字符串”11”</li>
<li>代码执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址），然而字符串常量池中的字符串”11”存放的是堆空间的字符串”11”的地址。即：变量s4的引用也指向了堆空间在的字符串”11”的地址</li>
<li>这样一来堆空间与字符串常量池存放的字符串”11”为同一个对象。因此变量s3与变量s4指向的都是同一个地址，使用两者相等。</li>
</ul>
</li>
</ul>
<p>JDK6的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022637283.png" alt="image-20210426022637283"></p>
<p>JDK7的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022851422.png" alt="image-20210426022851422"></p>
<p>对上面案例在进行扩展：</p>
<p>代码：将 String s4 = “11”; 与 String s5 = s3.intern(); 执行顺序进行互换，并使用s5接收返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringIntern.java中练习的拓展：</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">        String s5 = s3.intern();<span class="comment">//intern方法会从字符串常量池中查询当前字符串是否存在，若存在就会返回该字符串的引用(地址)</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、总结String的intern-方法的使用"><a href="#5、总结String的intern-方法的使用" class="headerlink" title="5、总结String的intern()方法的使用"></a>5、总结String的intern()方法的使用</h5><ul>
<li>jdk1. 6中,将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，会把<strong>此对象复制一份</strong>(<strong>新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的对象地址</li>
</ul>
</li>
<li>Jdk1.7起，将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，则会<strong>把对象的引用地址复制一份</strong>(<strong>没有新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的引用地址</li>
</ul>
</li>
</ul>
<h5 id="6、关于intern-方法的两道练习"><a href="#6、关于intern-方法的两道练习" class="headerlink" title="6、关于intern()方法的两道练习"></a>6、关于intern()方法的两道练习</h5><h6 id="1、练习1"><a href="#1、练习1" class="headerlink" title="1、练习1:"></a>1、练习1:</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String x = &quot;ab&quot;;</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032250932.png" alt="image-20210426032250932"></p>
<p>放开 String x = “ab”; 注释之后的图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032752667.png" alt="image-20210426032752667"></p>
<h6 id="2、练习2"><a href="#2、练习2" class="headerlink" title="2、练习2"></a>2、练习2</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池和堆空间中都会生成&quot;ab&quot;，不同对象。s1指向的是堆空间当中的字符串&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，在堆空间中会生成字符串&quot;abc&quot;，但不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//在jdk7：false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、使用intern-测试执行效率：空间角度的使用上"><a href="#7、使用intern-测试执行效率：空间角度的使用上" class="headerlink" title="7、使用intern()测试执行效率：空间角度的使用上"></a>7、使用intern()测试执行效率：空间角度的使用上</h5><p>两种方式创建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length]));</span><br><span class="line"></span><br><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure>

<p>结论：对于程序中<strong>大量存在的字符串</strong>，尤其其中存在很多<strong>重复</strong>字符串时，<strong>使用intern()可以节省内存空间</strong>。</p>
<p>应用场景：</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储:北京市、海淀区等信息。这时候如果字符串都调用intern()方法，就会明显降低内存的大小。</p>
<h4 id="6、StringTable的垃圾回收"><a href="#6、StringTable的垃圾回收" class="headerlink" title="6、StringTable的垃圾回收"></a>6、StringTable的垃圾回收</h4><p>使用new String()的方式和使用new String().intern()的方式创建字符串都会在堆与字符串常量池创建字符串对象，但是为什么在存在大量重复的字符串的时候使用intern()会更节省内存空间呢？ =》 答案：StringTable存在垃圾回收。</p>
<ul>
<li>使用new String()的方式创建字符串不仅仅会在字符串常量池当中创建字符串对象（不重复），还会在堆空间当中创建大量的字符串对象（存在重复），这些堆空间的字符串对象都有一个变量的引用指向，GC不会进行垃圾回收。</li>
<li>使用new String().intern()的方式创建字符串虽然也会在堆空间和字符串常量池创建字符串对象，但是局部变量的指向的是字符串常量池的字符串对象，堆空间的字符串对象虽然也被创建了，但是没有变量的引用指向，会被GC回收。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426115438284.png" alt="image-20210426115438284"></p>
<h4 id="7、G1的String去重操作"><a href="#7、G1的String去重操作" class="headerlink" title="7、G1的String去重操作"></a>7、G1的String去重操作</h4><p><a target="_blank" rel="noopener" href="http://openjdk.java.netjeps/192">官网</a></p>
<ul>
<li>背景：对许多Java应用(有大的也有小的)做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：string1.equals(string2)=true。<strong>堆上存在重复的String对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
<li>实现<ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li>
<li>如果是，把这个对象的一个引用插入到<strong>队列</strong>中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个<strong>hashtable来记录所有的被String对象使用的不重复的char数组</strong>。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，<strong>char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了</strong>。</li>
</ul>
</li>
<li>命令行选项<ul>
<li>UseStringDeduplication(bool)：开启String去重，<strong>默认是不开启的，需要手动开启</strong>。</li>
<li>PrintStringDeduplicationStatistics(bool)：打印详细的去重统计信息</li>
<li>StringDeduplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14、垃圾回收概述"><a href="#14、垃圾回收概述" class="headerlink" title="14、垃圾回收概述"></a>14、垃圾回收概述</h3><ul>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>哪些内存需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<strong>极大地提高了开发效率</strong>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li>
</ul>
<h4 id="1、什么是垃圾"><a href="#1、什么是垃圾" class="headerlink" title="1、什么是垃圾"></a>1、什么是垃圾</h4><ul>
<li>什么是垃圾( Garbage) 呢<ul>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文: An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
</ul>
</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出</strong>。</li>
<li>内存溢出：存在引用指向不再被使用的对象，导致该对象无法被回收。比如匿名内部类存在指向外部类的引用等等。</li>
</ul>
<h4 id="2、为什么需要GC"><a href="#2、为什么需要GC" class="headerlink" title="2、为什么需要GC"></a>2、为什么需要GC</h4><ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行。</strong>而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
<h4 id="3、早期的垃圾回收"><a href="#3、早期的垃圾回收" class="headerlink" title="3、早期的垃圾回收"></a>3、早期的垃圾回收</h4><ul>
<li><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代<br>码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;Register(kDestroy) != NO_ERROR)</span><br><span class="line">	<span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式可以<strong>灵活控制内存释放的时间</strong>，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回<br>收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，<strong>垃圾对象所耗内存可能持续上升</strong>，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>在有了垃圾回收机制后，，上述代码块极有可能变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p>
</li>
</ul>
<h4 id="4、java垃圾回收机制"><a href="#4、java垃圾回收机制" class="headerlink" title="4、java垃圾回收机制"></a>4、java垃圾回收机制</h4><ul>
<li><p>自动内存管理无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄漏问题让你头疼不已。</li>
</ul>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<strong>更专心地专注于业务开发</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">oracle官网关于垃圾回收的介绍</a></p>
</li>
<li><p>对于Java开发人员而言自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</p>
</li>
<li><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地<strong>根据错误异常日志定位问题和解决问题</strong>。</p>
</li>
<li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术**实施必要的<code>监控</code>和<code>调节</code>**。</p>
</li>
<li><p>垃圾回收的区域：**<code>堆</code>(Heap)与<code>方法区</code>(Method Area)**</p>
<p><img src="/2021/04/19/JVM/image-20210426180331460.png" alt="image-20210426180331460"></p>
</li>
<li><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p>
<ul>
<li>其中，**<code>Java堆</code>是垃圾收集器的工作重点**。</li>
</ul>
</li>
<li><p>从次数上讲：</p>
<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不动方法区（Perm区或元空间）</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="15、垃圾回收相关算法"><a href="#15、垃圾回收相关算法" class="headerlink" title="15、垃圾回收相关算法"></a>15、垃圾回收相关算法</h3><ul>
<li>判断对象存活<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当<strong>一个对象已经不再被任何的存活对象继续引用</strong>时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：**<code>引用计数算法</code><strong>和</strong><code>可达性分析算法</code>**。</li>
</ul>
</li>
<li>回收垃圾<ul>
<li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是<strong>执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</strong>。</li>
<li>目前在JVM中比较常见的三种垃圾收集算法是：**<code>标记一清除算法(Mark-Sweep)</code><strong>、</strong><code>复制算法(Copying)</code><strong>、</strong><code>标记-压缩算法(Mark-Compact)</code>**。</li>
</ul>
</li>
</ul>
<h4 id="1、标记阶段：引用计数算法"><a href="#1、标记阶段：引用计数算法" class="headerlink" title="1、标记阶段：引用计数算法"></a>1、标记阶段：引用计数算法</h4><h5 id="1、引用计数算法概述"><a href="#1、引用计数算法概述" class="headerlink" title="1、引用计数算法概述"></a>1、引用计数算法概述</h5><ul>
<li><strong>引用计数算法</strong>(Reference Counting)比较简单，对<strong>每个对象保存一个整型的引用计数器属性</strong>。<strong>用于记录对象被引用的情况</strong>。</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：<ul>
<li><strong>实现简单，垃圾对象便于辨识</strong>；</li>
<li><strong>判定效率高，回收没有延迟性</strong>。</li>
</ul>
</li>
<li>缺点:<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致<strong>在Java的垃圾回收器中没有使用这类算法</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、循环引用"><a href="#2、循环引用" class="headerlink" title="2、循环引用"></a>2、循环引用</h5><p><img src="/2021/04/19/JVM/image-20210426203337926.png" alt="image-20210426203337926"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动断开各自reference的引用</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？能 -&gt; java使用的不是引用计数算法</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426204015295.png" alt="image-20210426204015295"></p>
<h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用?<ul>
<li><strong>手动解除</strong>：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用<strong>弱引用weakref</strong>，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
<h4 id="2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集"><a href="#2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集" class="headerlink" title="2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)"></a>2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)</h4><ul>
<li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是<strong>Java、C#**选择的。这种类型的垃圾收集通常也叫作</strong>追踪性垃圾收集**(Tracing GarbageCollection)。</p>
</li>
<li><p>所谓”GC Roots”根集合就是<strong>一组必须活跃的引用</strong>。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合(GC Roots) 为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)</li>
<li>如果<strong>目标对象没有任何引用链相连，则是不可达的</strong>，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
<li><p>图示</p>
<p><img src="/2021/04/19/JVM/image-20210426210515944.png" alt="image-20210426210515944"></p>
</li>
<li><p>在Java语言中，GC Roots包括以下几类元素：</p>
<ul>
<li><strong>虚拟机栈中引用的对象</strong><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><strong>本地方法栈内JNI (通常说的本地方法)引用的对象</strong></li>
<li>方法区中<strong>类静态属性引用的对象</strong><ul>
<li>比如: Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中<strong>常量引用的对象</strong><ul>
<li>比如：<strong>字符串常量池(String Table)里的引用</strong></li>
</ul>
</li>
<li><strong>所有被同步锁synchronized持有的对象</strong></li>
<li>Java虚拟机内部的引用。<ul>
<li><strong>基本数据类型对应的Class对象</strong>，<strong>一些常驻的异常对象</strong>(如:NullPointerException、OutOfMemoryError) ，<strong>系统类加载器</strong>。</li>
</ul>
</li>
<li><strong>反映java虛拟机内部情况的JMXBean</strong>、<strong>JVMTI中注册的回调</strong>、<strong>本地代码缓存</strong>等。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426210824260.png" alt="image-20210426210824260"></p>
</li>
<li><p>除了这些固定的GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和<strong>局部回收(Partial GC)</strong></p>
<ul>
<li>如果<strong>只针对Java堆中的某一块区域进行垃圾回收</strong>(比如：<strong>典型的只针对新生代</strong>)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的<strong>对象完全有可能被其他区域的对象所引用</strong>，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li><p>小技巧：</p>
<ul>
<li>由于<strong>Root采用栈方式存放变量和指针</strong>，所以<strong>如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</strong>。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个<strong>能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须”<code>Stop The World</code>“的一个重要原因。<ul>
<li>即使是号称(几乎)不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、对象的finalization机制"><a href="#3、对象的finalization机制" class="headerlink" title="3、对象的finalization机制"></a>3、对象的finalization机制</h4><ul>
<li>Java语言提供了对象终止(finalization)机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：<strong>垃圾回收此对象之前，总会先调用这个对象的finalize()方法</strong>。</li>
<li>finalize()方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中<strong>进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接</strong>等。</li>
<li><strong>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用</strong>。理由包括下面三点：<ul>
<li>在finalize() 时<strong>可能会导致对象复活</strong>。</li>
<li>finalize() 方法的<strong>执行时间是没有保障的，它完全由GC线程决定</strong>，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li><strong>一个糟糕的finalize()会严重影响GC的性能</strong>。</li>
</ul>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</li>
<li>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。</li>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件（finalize()方法）下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li><strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li>
</ul>
</li>
<li>以上3种状态中，是由于finalize()方法的存在进行的区分。<strong>只有在对象不可触及时才可以被回收</strong>。</li>
<li>判定一个对象objA是否可回收，至少要经历两次标记过程，具体过程：<ul>
<li><strong>如果对象objA到GC Roots没有引用链，则进行第一次标记</strong>。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ul>
<li>如果<strong>对象objA没有重写finalize()方法</strong>，或者<strong>finalize()方法已经被虚拟机调用过</strong>，则虚拟机视为“没有必要执行”，<strong>objA被判定为不可触及</strong>的。</li>
<li>如果<strong>对象objA重写了finalize()方法，且还未执行过</strong>，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个<strong>虚拟机自动创建的、<code>低优先级</code>的Finalizer线程</strong>触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong>。如果<strong>objA在finalize()方法中与引用链上的任何一个对象建立了联系</strong>，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成<strong>不可触及</strong>的状态，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、MAT与JProfiler的GC-Roots溯源"><a href="#4、MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4、MAT与JProfiler的GC Roots溯源"></a>4、MAT与JProfiler的GC Roots溯源</h4><h5 id="1、MAT概述"><a href="#1、MAT概述" class="headerlink" title="1、MAT概述"></a>1、MAT概述</h5><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
<p>大家可以在<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/">官网</a>下载并使用MAT。</p>
<h5 id="2、获取dump文件"><a href="#2、获取dump文件" class="headerlink" title="2、获取dump文件"></a>2、获取dump文件</h5><ol>
<li><p>命令行使用jmap</p>
<p><img src="/2021/04/19/JVM/image-20210426214539114.png" alt="image-20210426214539114"></p>
</li>
<li><p>使用JVisualVM导出</p>
<ul>
<li>捕获的heap dump文件是一个临时文件，关闭JVisua1VM后自动删除，若要保留，需要将其另存为文件。</li>
<li>可通过以下方法捕获heap dump：<ul>
<li>在左侧”Application”(应用程序)子窗口中右击相应的应用程序，选择Heap Dump(堆Dump)。</li>
<li>在Monitor (监视)子标签页中点击Heap Dump (堆Dump)按钮。</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的Application (应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择save as (另存为)即可将heap dump保存到本地。</li>
</ul>
</li>
</ol>
<h5 id="3、使用MAT打开heap-dump文件-hprof"><a href="#3、使用MAT打开heap-dump文件-hprof" class="headerlink" title="3、使用MAT打开heap dump文件.hprof"></a>3、使用MAT打开heap dump文件.hprof</h5><ol>
<li><p>File -&gt; Open File -&gt; 找到对应的.hprof文件导入</p>
</li>
<li><p>导入后图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426220319212.png" alt="image-20210426220319212"></p>
</li>
<li><p>在MAT中查看GC Roots的方法</p>
<p><img src="/2021/04/19/JVM/image-20210426220439764.png" alt="image-20210426220439764"></p>
</li>
<li><p>GC Roots的相关展示：详情可查看<a target="_blank" rel="noopener" href="https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/concepts/gcroots.html">官网</a></p>
<p><img src="/2021/04/19/JVM/image-20210426221159953.png" alt="image-20210426221159953"></p>
</li>
</ol>
<h5 id="4、使用Profiler进行GC-Roots溯源"><a href="#4、使用Profiler进行GC-Roots溯源" class="headerlink" title="4、使用Profiler进行GC Roots溯源"></a>4、使用Profiler进行GC Roots溯源</h5><ol>
<li><p>Live memory -&gt; All Objects -&gt; View -&gt; Mark Current Values (查看当前对象的个数)（光标变绿）</p>
<p><img src="/2021/04/19/JVM/image-20210426223157917.png" alt="image-20210426223157917"></p>
<p><img src="/2021/04/19/JVM/image-20210426223406880.png" alt="image-20210426223406880"></p>
</li>
<li><p>选择其中一个占内存较多的类 -&gt; Show Selection In Heap Walker -&gt; References(查看当前类的相关引用)</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426223532525.png" alt="image-20210426223532525"></p>
<p><img src="/2021/04/19/JVM/image-20210426223639192.png" alt="image-20210426223639192"></p>
</li>
<li><p>查看哪个对象在哪里被关联（用来解决内存泄漏问题：查看内存泄漏的相关对象在哪里被引用）</p>
<p><img src="/2021/04/19/JVM/image-20210426224059101.png" alt="image-20210426224059101"></p>
<p><img src="/2021/04/19/JVM/image-20210426224309986.png" alt="image-20210426224309986"></p>
</li>
</ol>
<h5 id="5、使用Profiler分析OOM"><a href="#5、使用Profiler分析OOM" class="headerlink" title="5、使用Profiler分析OOM"></a>5、使用Profiler分析OOM</h5><ol>
<li><p>可以在代码中使用参数：<code>-XX: +HeapDumpOnOutOfMemoryError</code>，当程序出现OOM的时候在当前目录下自动生成Heap Dump文件</p>
</li>
<li><p>Heap Walker -&gt; Current Object Set -&gt; Biggest Objects查看是否存在占用内存的超大对象</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426224832591.png" alt="image-20210426224832591"></p>
</li>
<li><p>在Thread Dump处查看哪个线程的哪个位置出现了OOM</p>
<p><img src="/2021/04/19/JVM/image-20210426225204897.png" alt="image-20210426225204897"></p>
</li>
</ol>
<h4 id="5、清除阶段：标记-清除算法"><a href="#5、清除阶段：标记-清除算法" class="headerlink" title="5、清除阶段：标记-清除算法"></a>5、清除阶段：标记-清除算法</h4><ul>
<li><p>背景：</p>
<ul>
<li>标记一清除算法( Mark-Sweep )是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</li>
</ul>
</li>
<li><p>执行过程：</p>
<p>当<strong>堆中的有效内存空间(available memory)被耗尽</strong>的时候，就会<strong>停止整个程序</strong>(也被称为stop the world) ，然后进行两项工作，第一项则是<strong>标记</strong>，第二项则是<strong>清除</strong>。</p>
<ul>
<li>标记：Collector<strong>从引用根节点开始遍历，标记<code>所有被引用的对象</code>**。一般是</strong>在对象的Header中记录为<code>可达对象</code>**。</li>
<li>清除：Collector对<strong>堆内存从头到尾进行线性的遍历</strong>，如果发现<strong>某个对象在其Header中没有标记为可达对象</strong>，则将其<strong>回收</strong>。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-清除算法"></p>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>效率不算高</strong></li>
<li>在<strong>进行GC</strong>的时候，需要<strong>停止整个应用程序</strong>，导致<strong>用户体验差</strong></li>
<li>这种方式清理出来的<strong>空闲内存是不连续的</strong>，<strong>产生内存碎片</strong>。</li>
<li>需要<strong>维护一个空闲列表</strong></li>
</ul>
</li>
<li><p>注意：何为清除(<strong>透明覆盖</strong>)</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是<strong>把需要清除的对象地址保存在空闲的地址列表里</strong>。</li>
<li>下次<strong>有新对象需要加载</strong>时，<strong>判断垃圾的位置空间</strong>是否够，如果够，就存放。</li>
</ul>
</li>
</ul>
<h4 id="6、清除阶段：复制算法"><a href="#6、清除阶段：复制算法" class="headerlink" title="6、清除阶段：复制算法"></a>6、清除阶段：复制算法</h4><ul>
<li><p>背景：</p>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，”使用双存储区的Lisp语言垃圾收集器CALISP Garbage Collector Algorithm Using Serial Secondary Storage)”M.L.Minsky在该论文中描述的算法被人们称为复制(Copying) 算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
</li>
<li><p>核心思想：</p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的<strong>存活对象复制</strong>到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="第14章_复制算法"></p>
</li>
<li><p>优点：</p>
<ul>
<li>没有标记和清除的过程，<strong>实现简单，运行高效</strong></li>
<li>复制过去以后<strong>保证空间的连续性，不会出现”碎片”问题</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>需要两倍的内存空间</strong></li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
</li>
<li><p>特别的：</p>
<ul>
<li>如果系统中的<strong>垃圾对象很多</strong>，复制算法不会很理想。复制算法需要<strong>复制的存活对象数量要求不要太多</strong>，或者说<strong>非常少</strong>才行。</li>
<li>即<strong>特别适合垃圾对象很多，存活对象很少</strong>的场景；例如：Young区的Survivor0和Survivor1区</li>
</ul>
</li>
<li><p>应用场景：</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99%的内存空间。</p>
<p>回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="/2021/04/19/JVM/image-20210427010211524.png" alt="image-20210427010211524"></p>
</li>
</ul>
<h4 id="7、清除阶段：标记-压缩算法"><a href="#7、清除阶段：标记-压缩算法" class="headerlink" title="7、清除阶段：标记-压缩算法"></a>7、清除阶段：标记-压缩算法</h4><ul>
<li><p>背景：</p>
<ul>
<li><strong>复制算法的高效性是建立在存活对象少、垃圾对象多的前提</strong>下的。这种情况在新生代经常发生，但是在<strong>老年代</strong>，更常见的情况是<strong>大部分对象都是存活对象</strong>。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法</strong>。</li>
<li>标记-清除算法的确可以应用在老年代中，但是该算法不仅<strong>执行效率低下</strong>，而且在<strong>执行完内存回收后还会产生内存碎片</strong>，所以JVM的设计者需要在此基础之上进行改进。标记-压缩(Mark一Compact) 算法由此诞生。</li>
<li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
</li>
<li><p>执行过程：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按<strong>顺序</strong>排放。</li>
<li>之后，清理边界外所有的空间。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-压缩算法"></p>
</li>
<li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩(Mark- Sweep- Compact)算法</strong>。</p>
</li>
<li><p>二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法</strong>，<strong>标记-压缩是移动式的</strong>。<strong>是否移动回收后的存活对象</strong>是一项优缺点并存的风险决策。</p>
<ul>
<li>风险：<strong>所有引用到存活对象的引用都需要修改</strong></li>
</ul>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要<strong>给新对象分配内存时，JVM只需要持有一个内存的起始地址</strong>即可，这比维护一个空闲列表显然少了许多开销。</p>
</li>
<li><p>指针碰撞：</p>
<ul>
<li>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，<strong>彼此之间维系着一个记录下一次分配起始点的标记指针</strong>，当为新对象分配内存时，只需要通过<strong>修改指针的偏移量将新对象分配在第一个空闲内存位置</strong>上，这种分配方式就叫做指针碰撞(Bump the Pointer) 。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><strong>消除了</strong>标记-清除算法当中<strong>内存区域分散的缺点</strong>，我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可</strong>。</li>
<li><strong>消除了</strong>复制算法当中，<strong>内存减半的高额代价</strong>。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>从效率上来说，<strong>标记-整理算法要低于复制算法</strong>。</li>
<li>移动对象的同时，如果<strong>对象被其他对象引用，则还需要调整引用的地址</strong>。</li>
<li>移动过程中，需要全程暂停用户应用程序。即: <strong>STW</strong></li>
</ul>
</li>
</ul>
<h4 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h4><p>对比三种清除算法</p>
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不会堆积碎片）</td>
<td>通常需要活对象的两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>再分配对象空间使用</td>
<td>空闲列表</td>
<td>指针碰撞</td>
<td>指针碰撞</td>
</tr>
</tbody></table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h4 id="9、分代收集算法"><a href="#9、分代收集算法" class="headerlink" title="9、分代收集算法"></a>9、分代收集算法</h4><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Session对象、线程、Socket连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String对象</strong>， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的GC都是采用分代收集( Generational Collecting) 算法执行垃圾回收的</strong>。</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代(Young Gen)<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，<strong>回收频繁</strong>。</li>
<li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而<strong>复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</strong>。</li>
</ul>
</li>
<li>老年代(Tenured Gen)<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，<strong>回收不及年轻代频繁</strong>。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是<strong>由标记-清除或者是标记-清除与标记-整理的混合实现</strong>。<ul>
<li>Mark阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
<li>Sweep阶段的<strong>开销与所管理区域的大小成正比</strong>。</li>
<li>Compact阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以HotSpot中的<strong>CMS回收器</strong>为例，CMS是<strong>基于Mark- Sweep实现</strong>的，对于对象的回收效率很高。而对于碎片问题，CMS采用<strong>基于Mark-Compact算法的Serial Old回收器作为补偿措施</strong>：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用<strong>Serial Old执行Full GC以达到对老年代内存的整理</strong>。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="10、增量收集算法、分区算法"><a href="#10、增量收集算法、分区算法" class="headerlink" title="10、增量收集算法、分区算法"></a>10、增量收集算法、分区算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World(SWT)状态</strong>下，应用程序所有的线程都会挂起，暂停切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<strong>严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集( Incremental Collecting) 算法的诞生。</p>
<p><strong>基本思想：</strong></p>
<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以<strong>让垃圾收集线程和应用程序线程交替执行</strong>。<strong>每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。（<strong>并发思想</strong>）</li>
<li>总的来说，<strong>增量收集算法的基础仍是传统的标记-清除和复制算法</strong>。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能<strong>减少系统的停顿时间</strong>。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的<strong>总体成本上升</strong>，造成<strong>系统吞吐量的下降</strong>。</li>
</ul>
<p><strong>分区算法</strong>：</p>
<ul>
<li><p>一般来说，<strong>在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长</strong>。</p>
</li>
<li><p>为了更好地<strong>控制GC产生的停顿时间</strong>，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
</li>
<li><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。</p>
</li>
<li><p>每一个小区间都独立使用，独立回收。这种算法的好处是<strong>可以控制一次回收多少个小区间</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427023448226.png" alt="image-20210427023448226"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.jpg" alt="第14章_分区算法"></p>
</li>
</ul>
<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<hr>
<h3 id="16、垃圾回收相关概念"><a href="#16、垃圾回收相关概念" class="headerlink" title="16、垃圾回收相关概念"></a>16、垃圾回收相关概念</h3><h4 id="1、System-gc-的理解"><a href="#1、System-gc-的理解" class="headerlink" title="1、System.gc()的理解"></a>1、System.gc()的理解</h4><ul>
<li>在目录情况下，通过System.gc()或者runtime.getRuntime().gc()的调用，<strong>会显式触发Full GC</strong>，<strong>同时对老年代和新时代进行回收</strong>，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>
<li>JVM实现者可以通过System.gc()调用来觉得JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</li>
</ul>
<p>System.gc()提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc，但是调用System.runFinalization()方法可以强制调用使用引用的对象的finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样</span></span><br><span class="line">        System.runFinalization();<span class="comment">//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.gc()的相关案例：</p>
<p><img src="/2021/04/19/JVM/image-20210427112323264.png" alt="image-20210427112323264"></p>
<p>问题：调用System.gc()无法保证对垃圾收集器的调用，为什么上述案例中，每次调用都会有垃圾回收信息输出?是进行了GC吗?</p>
<h4 id="2、内存溢出-OOM-与内存泄漏-Memory-Leak"><a href="#2、内存溢出-OOM-与内存泄漏-Memory-Leak" class="headerlink" title="2、内存溢出(OOM)与内存泄漏(Memory Leak)"></a>2、内存溢出(OOM)与内存泄漏(Memory Leak)</h4><h5 id="1、内存溢出（OOM）"><a href="#1、内存溢出（OOM）" class="headerlink" title="1、内存溢出（OOM）"></a>1、内存溢出（OOM）</h5><ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
</li>
<li><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</p>
</li>
<li><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存供应用程序继续使用。</p>
</li>
<li><p>javadoc中对OutOfMemoryError的解释是：<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
</li>
<li><p>首先说没有空闲内存的情况:说明Java虛拟机的堆内存不够。原因有二：</p>
<ol>
<li><p><strong>Java虚拟机的堆内存设置不够</strong>。</p>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以<strong>通过参数-Xms、-Xmx来调整</strong>。</p>
</li>
<li><p><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</strong></p>
<p>对于老版本的Oracle JDK， 因为永久代的大小是有限的，并且JVM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型)非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和<strong>永久代</strong>相关：”java.lang.OutOfMemoryError: PermGen space”。</p>
<p>随着<strong>元数据区</strong>的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM的异常信息则变成了：”java.lang.OutOfMemoryError: Metaspace”。 直接内存不足，也会导致OOM。</p>
</li>
</ol>
</li>
<li><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong>等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h5 id="2、内存泄漏（Memory-Leak）"><a href="#2、内存泄漏（Memory-Leak）" class="headerlink" title="2、内存泄漏（Memory Leak）"></a>2、内存泄漏（Memory Leak）</h5><ul>
<li><p>也称作”存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
</li>
<li><p>但实际情况很多时候一些不太好的实践 (或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做**宽泛意义上的”内存泄漏”**。</p>
</li>
<li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p>
</li>
<li><p>注意，这里的存储空间并不是指物理内存，而是指<strong>虚拟内存大小</strong>，这个虚拟内存大小<strong>取决于磁盘交换区设定的大小</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427230217504.png" alt="image-20210427230217504"></p>
</li>
<li><p>举例：</p>
<ol>
<li><p>单例模式：</p>
<p><strong>单例的生命周期和应用程序是一样长</strong>的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
</li>
<li><p>一些<strong>提供close的资源未关闭</strong>导致内存泄漏：</p>
<p>数据库连接(dataSourse . getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3、Stop-The-World"><a href="#3、Stop-The-World" class="headerlink" title="3、Stop The World"></a>3、Stop The World</h4><ul>
<li>Stop-The-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。<ul>
<li><strong>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</strong>。<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，<strong>所有的GC都有STW这个事件</strong>。</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li>
<li>STW是JVM在<strong>后台自动发起和自动完成的</strong>。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li>
<li><strong>开发中不要用System.gc()；会导致Stop-the-world的发生</strong>。</li>
</ul>
<h4 id="4、垃圾回收的并行与并发"><a href="#4、垃圾回收的并行与并发" class="headerlink" title="4、垃圾回收的并行与并发"></a>4、垃圾回收的并行与并发</h4><h5 id="1、并发（Concurrent）"><a href="#1、并发（Concurrent）" class="headerlink" title="1、并发（Concurrent）"></a>1、并发（Concurrent）</h5><ul>
<li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在<strong>同一个处理器</strong>上运行。</li>
<li>并发不是真正意义上的”同时进行”，只是CPU把一个时间段分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，主要时间间隔处理得当，即可让用户感觉是多个应用程序在同时运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231222179.png" alt="image-20210427231222179"></p>
<h5 id="2、并行（Parallel）"><a href="#2、并行（Parallel）" class="headerlink" title="2、并行（Parallel）"></a>2、并行（Parallel）</h5><ul>
<li>当系统有<strong>一个以上CPU</strong>时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程<strong>互不抢占CPU资源</strong>，可以<strong>同时进行</strong>，我们称之为并行（Parallel）。</li>
<li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</li>
<li>适合<strong>科学计算，后台处理等弱交互场景</strong></li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231302158.png" alt="image-20210427231302158"></p>
<h5 id="3、并行-VS-并发"><a href="#3、并行-VS-并发" class="headerlink" title="3、并行 VS 并发"></a>3、并行 VS 并发</h5><p>二者对比：</p>
<ul>
<li><strong>并发</strong>，指的是<strong>多个事情，在同一时间段内同时发生了</strong>。</li>
<li><strong>并行</strong>，指的是<strong>多个事情，在同一时间点上同时发生了</strong>。</li>
</ul>
<ul>
<li><strong>并发</strong>的多个任务之间是<strong>互相抢占资源</strong>的。</li>
<li><strong>并行</strong>的多个任务之间是<strong>不互相抢占资源</strong>的。</li>
</ul>
<ul>
<li>只有在<strong>多CPU或者一个CPU多核</strong>的情况中，才会发生<strong>并行</strong>。</li>
<li>否则，<strong>看似同时发生的事情，其实都是并发执行的</strong>。</li>
</ul>
<h5 id="4、垃圾回收的并发与并行"><a href="#4、垃圾回收的并发与并行" class="headerlink" title="4、垃圾回收的并发与并行"></a>4、垃圾回收的并发与并行</h5><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li><p>并行(Parallel)：指<strong>多条垃圾收集线程并行工作</strong>，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<ul>
<li>如并行的垃圾回收器：ParNew、 Parallel Scavenge、 Parallel Old;</li>
</ul>
</li>
<li><p>串行(Serial)</p>
<ul>
<li>相较于并行的概念，<strong>单线程执行</strong>。</li>
<li><strong>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</strong></li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231437839.png" alt="image-20210427231437839"></p>
</li>
<li><p>并发(Concurrent)：指<strong>用户线程与垃圾收集线程同时执行</strong>(但不一定是并行的，可能会交替执行)，<strong>垃圾回收线程在执行时不会停顿用户程序的运行</strong>。</p>
<ul>
<li><strong>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</strong>；</li>
<li>如: CMS、G1</li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231919364.png" alt="image-20210427231919364"></p>
</li>
</ul>
<h4 id="5、安全点与安全区域"><a href="#5、安全点与安全区域" class="headerlink" title="5、安全点与安全区域"></a>5、安全点与安全区域</h4><h5 id="1、安全点（Safepoint）"><a href="#1、安全点（Safepoint）" class="headerlink" title="1、安全点（Safepoint）"></a>1、安全点（Safepoint）</h5><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为”安全点(Safepoint)”</p>
<p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长</strong>，<strong>如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p>
<p>比如：选择些执行时间较长的指令作为Safe Point，如<strong>方法调用</strong>、<strong>循环跳转</strong>和<strong>异常跳转</strong>等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</p>
<ul>
<li><p><strong>抢先式中断</strong>：(目前没有虚拟机采用了)</p>
<p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
</li>
<li><p><strong>主动式中断</strong>：</p>
<p><strong>设置一个中断标志</strong>，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</li>
</ul>
<h5 id="2、安全区域"><a href="#2、安全区域" class="headerlink" title="2、安全区域"></a>2、安全区域</h5><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?</p>
<p>例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应JVM 的中断请求，”走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把 Safe Region 看做是被扩展了的Safepoint。 </p>
<p>实际执行时：</p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，<strong>JVM会忽略标识为Safe Region状态的线程</strong>;</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了则继续运行，否则<strong>线程必须等待直到收到可以安全离开Safe Region的信号为止</strong>;</li>
</ol>
<h4 id="6、在谈引用"><a href="#6、在谈引用" class="headerlink" title="6、在谈引用"></a>6、在谈引用</h4><p>我们希望能描述这样一类对象：当<strong>内存空间还足够</strong>时，则能<strong>保留在内存</strong>中；如果<strong>内存空间在进行垃圾收集后还是很紧张</strong>，则可以<strong>抛弃</strong>这些对象。</p>
<p>[既<strong>偏门</strong>又<strong>非常高频</strong>的面试题]<code>强引用、软引用、弱引用、虚引用有什么区别?</code> <code>具体使用场景是什么?</code></p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用(StrongReference)</code>、<code>软引用(Soft Reference)</code> 、<code>弱引用(Weak Reference)</code>和<code>虚引用(Phantom Reference)</code> 4种，<strong>这4种引用强度依次逐渐减弱</strong>。（强软弱虚）</p>
<p>除<strong>强引用</strong>外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="/2021/04/19/JVM/image-20210427233208635.png" alt="image-20210427233208635"></p>
<p>Reference子类中只有<strong>终结器引用是包内可见</strong>的，<strong>其他3种引用类型均为public</strong>，可以在应用程序中直接使用</p>
<ul>
<li><strong><code>强引用(StrongReference)</code>**：最传统的“引用”的定义，是指</strong>在程序代码之中普遍存在的引用赋值<strong>，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，</strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象<strong>。（</strong>不回收**）</li>
<li><strong><code>软引用(SoftReference)</code>**：</strong>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常<strong>。（</strong>内存不足即回收**）</li>
<li><strong><code>弱引用(WeakReference)</code>**：</strong>被弱引用关联的对象只能生存到下一次垃圾收集之前<strong>。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。（</strong>发现即回收**）</li>
<li><strong><code>虚引用(PhantomReference)</code>**：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是</strong>能在这个对象被收集器回收时收到一个系统通知<strong>。（</strong>对象回收的跟踪**）</li>
</ul>
<h4 id="7、再谈引用：强引用Strong-Reference（不回收）"><a href="#7、再谈引用：强引用Strong-Reference（不回收）" class="headerlink" title="7、再谈引用：强引用Strong Reference（不回收）"></a>7、再谈引用：强引用Strong Reference（不回收）</h4><p>在Java程序中，最常见的引用类型是强引用(<strong>普通系统99%以上都是强引用</strong>)，也就是我们最常见的普通对象引用，也是<strong>默认的引用类型</strong>。</p>
<p>当在Java语言中<strong>使用new操作符创建一个新的对象</strong>， 并<strong>将其赋值给一个变量</strong>的时候， 这个变量就成为指向该对象的一个强引用。</p>
<p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
<p>强引用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用</p>
<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093616812.png" alt="image-20210428093616812"></p>
<p>此时，如果再运行一个赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>

<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093737403.png" alt="image-20210428093737403"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以<strong>直接访问目标对象</strong>。</li>
<li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong>。</li>
<li>强引用<strong>可能导致内存泄漏</strong>。</li>
</ul>
<h4 id="8、再谈引用：软引用Soft-Reference（内存不足即回收）"><a href="#8、再谈引用：软引用Soft-Reference（内存不足即回收）" class="headerlink" title="8、再谈引用：软引用Soft Reference（内存不足即回收）"></a>8、再谈引用：软引用Soft Reference（内存不足即回收）</h4><p>软引用是用来描述一些<strong>还有用</strong>，但<strong>非必需</strong>的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现<strong>内存敏感的缓存</strong>。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。实例：<strong>Mybatis的一些内部类中就使用了软引用</strong>。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue) 。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在java doc中，软引用是这样描述的：</p>
<blockquote>
<p>虚拟机在抛出 OutOfMemoryError 之前会<strong>保证所有的软引用对象已被清除</strong>。此外，没有任何约束保证软引用将在某个特定的时间点被清除，或者确定一组不同的软引用对象被清除的顺序。不过，虚拟机的具体实现会倾向于<strong>不清除最近创建或最近使用过的软引用</strong>。</p>
</blockquote>
<p>软引用在我们的日常开发中使用的场景很多，比如商城中商品的信息。某个商品可能会被多人访问，此时我们可以把该商品的信息使用软引用保存。当系统内存足够时，可以实现高速查找，当系统内存不足又会被回收，避免<code>OOM</code>的风险。</p>
<p>注意：</p>
<p>尽管软引用会在OOM之前被清理，但是，<strong>这并不表示Full GC会清理软引用对象</strong>。在经过Full GC后我们的软引用对象都放入了old区，由于Full GC的存在，程序大多数情况下并不会OOM。<strong>由于软引用对象占据了老年代的空间，Full GC将执行的更为频繁</strong>。所以还是建议使用弱引用。</p>
<p>当然，我们可以通过参数：<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>来设置当Full GC时回收软引用。其中参数值为Full GC保留的 SoftReference 数量，参数值越大，GC 后保留的软引用对象就越多。设置这个参数值为0时，Full GC就会回收我们的软引用对象了。</p>
<p>在JDK 1.2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>



<h4 id="9、再谈引用：弱引用Weak-Reference（发现即回收）"><a href="#9、再谈引用：弱引用Weak-Reference（发现即回收）" class="headerlink" title="9、再谈引用：弱引用Weak Reference（发现即回收）"></a>9、再谈引用：弱引用Weak Reference（发现即回收）</h4><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong>。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，<strong>通过这个队列可以跟踪对象的回收情况</strong>。</p>
<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>实例：</p>
<ul>
<li>三级缓存（内存(弱引用) -&gt; 本地 -&gt; 网络）</li>
<li><code>ThreadLocal</code>的内部实现就是一个<code>ThreadLocalMap</code>,该<code>map</code>的<code>Entry</code>的<code>key</code>为<code>ThreadLocal</code>本身，<code>value</code>为我们向<code>ThreadLocal</code>对象<code>set</code>的值，其中的<code>key</code>就是弱引用对象</li>
<li>集合<code>WeakHashMap</code>，都是使用了弱引用实现的</li>
</ul>
<p>在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，<strong>当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收</strong>。<strong>弱引用对象更容易、更快被GC回收</strong>。</p>
<p><strong>面试题：你开发中使用过WeakHashMap吗?</strong></p>
<h4 id="10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）"><a href="#10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）" class="headerlink" title="10、再谈引用：虚引用Phantom Reference（对象回收跟踪）"></a>10、再谈引用：虚引用Phantom Reference（对象回收跟踪）</h4><p>也称为“<strong>幽灵引用</strong>”或者“<strong>幻影引用</strong>”，是<strong>所有引用类型中最弱的一个</strong>。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它<strong>不能单独使用</strong>，也<strong>无法通过虚引用来获取被引用的对象</strong>。当试图通过虚引用的get()方法取得对象时，<strong>总是null</strong>。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p><strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以<strong>通知应用程序对象的回收情况</strong>。</p>
<p><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</strong>。</p>
<p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue( );</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>对象回收跟踪的代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程，用来跟踪对象的回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11、再谈引用：终结器引用Final-reference"><a href="#11、再谈引用：终结器引用Final-reference" class="headerlink" title="11、再谈引用：终结器引用Final reference"></a>11、再谈引用：终结器引用Final reference</h4><ul>
<li>它用以<strong>实现对象的finalize()方法</strong>，也可以称为<strong>终结器引用</strong>。</li>
<li>无需手动编码，其<strong>内部配合引用队列</strong>使用。</li>
<li>在GC时，终结器引用入队。由<strong>Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象</strong>。</li>
</ul>
<hr>
<h3 id="17、垃圾回收器"><a href="#17、垃圾回收器" class="headerlink" title="17、垃圾回收器"></a>17、垃圾回收器</h3><h4 id="1、GC分类与性能指标"><a href="#1、GC分类与性能指标" class="headerlink" title="1、GC分类与性能指标"></a>1、GC分类与性能指标</h4><h5 id="1、垃圾回收器概述"><a href="#1、垃圾回收器概述" class="headerlink" title="1、垃圾回收器概述"></a>1、垃圾回收器概述</h5><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<h5 id="2、垃圾回收器分类"><a href="#2、垃圾回收器分类" class="headerlink" title="2、垃圾回收器分类"></a>2、垃圾回收器分类</h5><h6 id="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"><a href="#1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器" class="headerlink" title="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"></a>1、按<strong>线程数</strong>分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></h6><p><img src="/2021/04/19/JVM/image-20210428111017627.png" alt="image-20210428111017627"></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的<code>Client模式</code>下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。</li>
</ul>
<h6 id="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"><a href="#2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器" class="headerlink" title="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"></a>2、按照<strong>工作模式</strong>分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong></h6><ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210428111338892.png" alt="image-20210428111338892"></p>
<h6 id="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"><a href="#3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器" class="headerlink" title="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"></a>3、按<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong></h6><ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
<h6 id="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"><a href="#4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器" class="headerlink" title="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"></a>4、按<strong>工作的内存区间</strong>分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong></h6><h5 id="3、评估GC的性能指标"><a href="#3、评估GC的性能指标" class="headerlink" title="3、评估GC的性能指标"></a>3、评估GC的性能指标</h5><ul>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>
<li>(总运行时间:程序的运行时间十内存回收的时间)</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用：Java堆区所占的内存大小。</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>关于吞吐量、暂停时间与内存占用：</p>
<ul>
<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ul>
<h6 id="1、吞吐量（throughput）"><a href="#1、吞吐量（throughput）" class="headerlink" title="1、吞吐量（throughput）"></a>1、吞吐量（throughput）</h6><ul>
<li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间)</p>
<ul>
<li>比如:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/2021/04/19/JVM/image-20210428111925067.png" alt="image-20210428111925067"></p>
</li>
</ul>
<h6 id="2、暂停时间（pause-time）"><a href="#2、暂停时间（pause-time）" class="headerlink" title="2、暂停时间（pause time）"></a>2、暂停时间（pause time）</h6><ul>
<li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li><p>暂停时间优先，意味着尽可能让单次STW的时间最短: 0.1 + 0.1 + 0.1 + 0.1+0.1=0.5</p>
<p><img src="/2021/04/19/JVM/image-20210428112108819.png" alt="image-20210428112108819"></p>
</li>
</ul>
<h6 id="3、吞吐量-VS-暂停时间"><a href="#3、吞吐量-VS-暂停时间" class="headerlink" title="3、吞吐量 VS 暂停时间"></a>3、吞吐量 VS 暂停时间</h6><ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</strong>。因此，具有低的较大暂停时间是非常重要的，特别是<strong>对于一个交互式应用程序</strong>。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。<ul>
<li>因为如果选择以<strong>吞吐量优先</strong>，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会<strong>导致GC需要更长的暂停时间来执行内存回收</strong>。</li>
<li>相反的，如果选择以<strong>低延迟优先为原则</strong>，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又引起了<strong>年轻代内存的缩减和导致程序吞吐量的下降</strong>。</li>
</ul>
</li>
<li>在设计(或使用) GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间)，或尝试找到一个二者的折衷。</li>
<li>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong>。</li>
</ul>
<h4 id="2、不同的垃圾回收器概述"><a href="#2、不同的垃圾回收器概述" class="headerlink" title="2、不同的垃圾回收器概述"></a>2、不同的垃圾回收器概述</h4><h5 id="1、垃圾回收器发展史"><a href="#1、垃圾回收器发展史" class="headerlink" title="1、垃圾回收器发展史"></a>1、垃圾回收器发展史</h5><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection, 对应的产品我们称为Garbage Collector（GC）。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>—–分水岭——</li>
<li>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为”No-Op (无操作) “回收器。同时引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC (Experimental)。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ul>
<h5 id="2、七款经典的垃圾收集器"><a href="#2、七款经典的垃圾收集器" class="headerlink" title="2、七款经典的垃圾收集器"></a>2、七款<strong>经典</strong>的垃圾收集器</h5><ul>
<li>串行回收器: Serial、Serial Old</li>
<li>并行回收器: ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发回收器: CMS、G1</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429023423991.png" alt="image-20210429023423991"></p>
<p><strong>七款经典收集器与垃圾分代之间的关系</strong></p>
<ul>
<li>新生代收集器: Serial、ParNew、Parallel Scavenge;</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS;</li>
<li>整堆收集器：G1;</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429024547757.png" alt="image-20210429024547757"></p>
<p><strong>垃圾收集器的组合关系</strong>：</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<p>为什么要有很多收集器，一个不够吗?</p>
<p>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是<strong>对具体应用最合适的收集器</strong>。</p>
<p><strong>如何查看默认的垃圾收集器</strong>：</p>
<ul>
<li><code>XX:+PrintCommandLineFlags</code>：查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数进程ID</code></li>
</ul>
<h4 id="3、Serial回收器：串行回收"><a href="#3、Serial回收器：串行回收" class="headerlink" title="3、Serial回收器：串行回收"></a>3、Serial回收器：串行回收</h4><ul>
<li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1. 3之前回收新生代唯一的选择。</p>
</li>
<li><p>Serial收集器作为HotSpot中<strong>Client模式下的默认新生代垃圾收集器</strong>。</p>
</li>
<li><p>Serial收集器采用<strong>复制算法</strong>、<strong>串行回收</strong>和**”Stop-the-World”机制**的方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于<strong>执行老年代垃圾收集</strong>的Serial Old收集器。<strong>Serial Old收集器同样也采用了串行回收和”Stop the World”机制， 只不过内存回收算法使用的是标记-压缩算法</strong>。</p>
<ul>
<li>Serial Old是运行在<strong>Client模式下默认的老年代的垃圾回收器</strong></li>
<li>Serial Old在Server模式下主要有两个用途：<ul>
<li><strong>与新生代的Parallel Scavenge配合使用</strong></li>
<li><strong>作为老年代CMS收集器的后备垃圾收集方案</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束(Stop The World) 。</p>
<p><img src="/2021/04/19/JVM/image-20210429085028563.png" alt="image-20210429085028563"></p>
</li>
<li><p>优势：<strong>简单而高效</strong>(与其他收集器的单线程比)，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在Client模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li><p>在<strong>用户的桌面应用场景</strong>中，可用内存一般不大(几十MB至一两百MB)，可以在较短时间内完成垃圾收集(几十ms至一百多ms) , 只要不频繁发生，使用串行回收器是可以接受的。</p>
</li>
<li><p>在HotSpot虚拟机中，使用<code>-XX: +UseSerialGC</code>参数可以<strong>指定年轻代和老年代都使用串行收集器</strong>。</p>
<ul>
<li>等价于新生代用Serial GC， 且老年代用Serial Old GC</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
</li>
</ul>
<h4 id="4、ParNew回收器：并行回收"><a href="#4、ParNew回收器：并行回收" class="headerlink" title="4、ParNew回收器：并行回收"></a>4、ParNew回收器：并行回收</h4><ul>
<li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是<strong>Serial收集器的多线程版本</strong>。</p>
<ul>
<li>Par是Parallel的缩写，New：只能处理的是<strong>新生代</strong></li>
</ul>
</li>
<li><p>ParNew收集器除了采用<strong>并行回收的方式执行内存回收</strong>外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop-the-World”机制</strong>。</p>
</li>
<li><p>ParNew是很多JVM运行<strong>在Server模式下新生代的默认垃圾收集器</strong>。</p>
</li>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。 (CPU并行需要切换线程，串行可以省去切换线程的资源)</p>
<p><img src="/2021/04/19/JVM/image-20210429085347499.png" alt="image-20210429085347499"></p>
</li>
<li><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效?</p>
<ul>
<li>ParNew<br>收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地<br>做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li><p>因为除Serial外，目前<strong>只有ParNew GC能与CMS收集器配合工作</strong></p>
</li>
<li><p>在程序中，开发人员可以通过选项”<code>-XX: +UseParNewGC</code>“手动指定使用ParNew收集器执行内存回收任务。它表示<strong>年轻代使用</strong>并行收集器，<strong>不影</strong><br><strong>响老年代</strong>。</p>
</li>
<li><p><code>-XX: ParallelGCThreads</code><strong>限制线程数量，默认开启和CPU数据相同的线程数</strong>。(一般不超过CPU的数据)</p>
</li>
</ul>
<h4 id="5、Parallel回收器：吞吐量优先"><a href="#5、Parallel回收器：吞吐量优先" class="headerlink" title="5、Parallel回收器：吞吐量优先"></a>5、Parallel回收器：吞吐量优先</h4><ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>复制算法</strong>、<strong>并行回收</strong>和**”Stop the World”机制**。</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举?</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达至一个<strong>可控制的吞吐量(Throughput)**，它也被称为</strong>吞吐量优先的垃圾收集器**。</li>
<li><strong>自适应调节策略</strong>也是Parallel Scavenge 与ParNew一个重要区别。</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在<strong>服务器环境中</strong>使用。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了<strong>用于执行老年代垃圾收集</strong>的Parallel Old收集器，用来<strong>代替老年代的Serial Old收集器</strong>。</p>
</li>
<li><p>Parallel Old收集器采用了<strong>标记-压缩算法</strong>，但同样也是<strong>基于并行回收</strong>和**”Stop-the-World”机制**。</p>
</li>
<li><p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</p>
</li>
<li><p>在Java8中，<strong>默认是此垃圾收集器</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210429090344976.png" alt="image-20210429090344976"></p>
</li>
<li><p>参数配置：</p>
<ul>
<li><code>-XX: +UseParallelGC</code>：<strong>手动指定年轻代使用Parallel并行收集器执行内存回收任务</strong>。</li>
<li><code>-XX: +UseParallelOldGC</code>：<strong>手动指定老年代都是使用并行回收收集器</strong>。<ul>
<li>分别适用于新生代和老年代。<strong>默认jdk8是开启的</strong>。</li>
<li>上面两个参数，<strong>默认开启一个，另一个也会被开启。 (互相激活)</strong></li>
</ul>
</li>
<li><code>-XX: parallelGCThreads</code>：<strong>设置年轻代并行收集器的线程数</strong>。一般地，<strong>最好与CPU数量相等</strong>，以避免<strong>过多的线程数影响垃圾收集性能</strong>。<ul>
<li>在默认情况下，当CPU数量小于8个， ParallelGCThreads的值等于CPU数量。</li>
<li>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5 * CPU_Count] / 8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPaulseMillis</code>：<strong>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒</strong>。<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li><strong>该参数使用需谨慎</strong>。</li>
</ul>
</li>
<li><code>-XX: GCTimeRatio</code>：<strong>垃圾收集时间占总时间的比例</strong>(= 1 / (N + 1))。用于<strong>衡量吞吐量的大小</strong>。</li>
<li>取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。</li>
<li><strong>与前一个-XX :MaxGCPauseMillis参数有一定矛盾性</strong>。暂停时间越长，Radio参数就容易超过设定的比例。</li>
<li><code>-XX: +UseAdaptiveSizePolilcy</code>：设置Parallel Scavenge收集器<strong>具有自适应调节策略</strong><ul>
<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCT imeRatio)和停顿时间<br>(MaxGCPauseMills)，让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6、CMS回收器：低延迟"><a href="#6、CMS回收器：低延迟" class="headerlink" title="6、CMS回收器：低延迟"></a>6、CMS回收器：低延迟</h4><ul>
<li><p>在JDK 1.5时期，HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent -Mark -Sweep)收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
</li>
<li><p>CMS收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><strong>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</strong>，以给用户带来较好的体验。</li>
<li>CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li><p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会**”Stop-the-world”**</p>
</li>
<li><p>不幸的是，<strong>CMS作为老年代的收集器</strong>，却<strong>无法与</strong>JDK 1.4.0中已经存在的<strong>新生代收集器Parallel Scavenge 配合工作</strong>，所以在JDK 1.5中<strong>使用CMS来收集老年代</strong>的时候，<strong>新生代只能选择ParNew或者Serial收集器中的一个</strong>。在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
</li>
<li><p>CMS的工作原理：</p>
<p><img src="/2021/04/19/JVM/image-20210429095659541.png" alt="image-20210429095659541"></p>
</li>
<li><p>CMS整个过程比之前的收集器要复杂，整个过程分为<strong>4个主要阶段</strong>，即<strong>初始标记阶段</strong>、<strong>并发标记阶段</strong>、<strong>重新标记阶段</strong>和<strong>并发清除阶段</strong>。</p>
<ul>
<li>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li>
<li>并发标记(Concurrent-Mark)阶段：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起<strong>并发运行</strong>。</li>
<li>重新标记(Remark) 阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除(Concurrent-Sweep) 阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时<strong>并发的</strong>。</li>
</ul>
</li>
<li><p>尽管CMS收集器采用的是<strong>并发回收(非独占式)**，但是在其</strong>初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p>
</li>
<li><p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</p>
</li>
<li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以<strong>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当<strong>堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”<strong>Concurrent Mode Failure</strong>“失败，这时虛拟机将启动<strong>后备预案:临时启用Serial Old收集器</strong>来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<strong>产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择<strong>空闲列表(Free List) 执行内存分配</strong>。</p>
</li>
<li><p>既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢?</p>
<ul>
<li>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?</li>
<li>要保证用户线程能继续执行，前提的<strong>它运行的资源不受影响</strong>嘛。Mark Compact更适合“Stop the World”这种场景下使用</li>
</ul>
</li>
<li><p>CMS的优点：</p>
<ul>
<li><strong>并发收集</strong></li>
<li><strong>低延迟</strong></li>
</ul>
</li>
<li><p>CMS的弊端：</p>
<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现”<strong>Concurrent Mode Failure</strong>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ol>
</li>
<li><p>CMS收集器可以设置的参数：</p>
<ul>
<li><code>-XX: +UseConcMarkSweepGC</code>：<strong>手动指定使用CMS收集器执行内存回收任务</strong>。<ul>
<li>开启该参数后会自动将<code>-XX: +UseParNewGC</code>打开。 即：<strong>ParNew (Young区用) +CMS (Old区用) + Serial Old的组合。</strong></li>
</ul>
</li>
<li><code>-XX:CMSlnitiatingOccupancyFraction</code>：<strong>设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</strong>。<ul>
<li><strong>JDK5及以前版本的默认值为<code>68</code>**，即当</strong>老年代的空间<strong>使用率达到68%时，会执行一次CMS回收。</strong>JDK6及 以上版本默认值为92%**</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><code>-XX: +UseCMSCompactAtFullCollection</code>：<strong>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生</strong>。不过由于内存压缩整理过程无法并发执行，所带来的问题就是<strong>停顿时间变得更长</strong>了。</li>
<li><code>-XX: CMSFullGCsBeforeCompaction</code>：<strong>设置在执行多少次Full GC后对内存空间进行压缩整理</strong>。</li>
<li><code>-XX:Parallel CMSThreads</code>：<strong>设置CMS的线程数量</strong>。</li>
<li>CMS默认启动的线程数是<code>(ParallelGCThreads+3) / 4</code>，<strong>ParallelGCThreads是年轻代并行收集器的线程数</strong>。当CPU资源比较紧张时，受到CMs收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢?</li>
<li>请记住以下口令：<ul>
<li>如果你想要<strong>最小化地使用内存和并行开销</strong>，请选<strong>Serial GC</strong>;</li>
<li>如果你想要<strong>最大化应用程序的吞吐量</strong>，请选<strong>Parallel GC</strong>;</li>
<li>如果你想要<strong>最小化GC的中断或停顿时间</strong>，请选<strong>CMS GC</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK后续版本中CMS的变化</p>
<ul>
<li><p>JDK9新特性：<strong>CMS被标记为Deprecate了(JEP291)</strong></p>
<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，<strong>提示CMS未来将会被废弃</strong>。</li>
</ul>
</li>
<li><p>JDK14新特性：<strong>删除CMS垃圾回收器(JEP363)</strong></p>
<ul>
<li><p>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX: +UseConcMarkSweepGC</code>的话，<strong>JVM不会报错，只是给出一个warning信息，但是不会exit</strong>。<strong>JVM会自动回退以默认GC方式启动JVM</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC;support was removed in 14. 0 and the VM will continue execution using the default collector.</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7、G1回收器：区域化分代式"><a href="#7、G1回收器：区域化分代式" class="headerlink" title="7、G1回收器：区域化分代式"></a>7、G1回收器：区域化分代式</h4><h5 id="1、两个问题"><a href="#1、两个问题" class="headerlink" title="1、两个问题"></a>1、两个问题</h5><p>问题1：既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First (G1)GC?</p>
<ul>
<li>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 (Garbage-First) 垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间(pause time) ，同时兼顾良好的吞吐量。</li>
<li><strong>官方给G1设定的目标是<code>在延迟可控的情况下获得尽可能高的吞吐量</code>，所以才担当起”全功能收集器”的重任与期望。</strong></li>
</ul>
<p>问题2：为什么名字叫做Garbage First (G1) 呢?</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region) (物理上不连续的)。使用不同的Region来表示Eden、 幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</strong>。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间(Region) ，所以我们给G1一个名字：<strong>垃圾优先(Garbage First)</strong> 。</li>
</ul>
<h5 id="2、G1概述"><a href="#2、G1概述" class="headerlink" title="2、G1概述"></a>2、G1概述</h5><p>G1 (Garbage-First)是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以<strong>极高概率满足GC停顿时间</strong>的同时，还<strong>兼具高吞吐量</strong>的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，是<strong>JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为“<strong>全功能的垃圾收集器</strong>”。</p>
<p>与此同时，CMS已经在JDK 9中被标记为废弃(deprecated) 。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX: +UseG1GC</code>来启用。</p>
<h5 id="3、G1的特点（优势）与缺点"><a href="#3、G1的特点（优势）与缺点" class="headerlink" title="3、G1的特点（优势）与缺点"></a>3、G1的特点（优势）与缺点</h5><p>与其他GC收集器相比，G1使用了全新的<strong>分区算法</strong>，其特点有如下四点：</p>
<ul>
<li><p><strong>并行与并发</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，<strong>不会出现在整个回收阶段发生完全阻塞应用程序的情况</strong></li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li><p>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p><strong>将堆空间分为若千个区域(Region) ,这些区域中包含了逻辑上的年轻代和老年代</strong>。</p>
</li>
<li><p>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
<p><img src="/2021/04/19/JVM/image-20210429235305962.png" alt="image-20210429235305962"></p>
</li>
</ul>
</li>
<li><p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记-压缩(Mark-Compact )算法</strong>，两种算法都可以<strong>避免内存碎片</strong>。这种特性<strong>有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。尤其是当<strong>Java堆非常大的时候，G1的优势更加明显</strong>。</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型</strong>(即：软实时soft real-time)</p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。(其中吞吐量 = M-N / M)</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，<strong>每次根据允许的收集</strong><br><strong>时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<p>G1收集器的缺点：</p>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是<strong>为了垃圾收集产生的内存占用(Footprint) 还是程序运行时的额外执行负载(Overload)</strong> 都要比CMS要高。</li>
<li>从经验上来说，在<strong>小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势</strong>。<strong>平衡点在6-8GB之间</strong>。</li>
</ul>
<h5 id="4、G1回收器的参数设置"><a href="#4、G1回收器的参数设置" class="headerlink" title="4、G1回收器的参数设置"></a>4、G1回收器的参数设置</h5><ul>
<li><strong><code>-XX: +UseG1GC</code>**：</strong>手动指定使用G1收集器执行内存回收任务**。</li>
<li><strong><code>-XX: G1HeapRegionSize</code>**：</strong>设置每个Region的大小**。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/ 2000。</li>
<li><strong><code>-XX: MaxGCPauseMillis</code>**：</strong>设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms**</li>
<li><code>-XX: ParallelGCThread</code>：<strong>设置STW时GC线程数的值。最多设置为8</strong></li>
<li><code>-XX: ConcGCThreads</code>：<strong>设置并发标记的线程数</strong>。将n设置为<strong>并行垃圾回收线数(ParallelGCThreads)的1/4左右</strong>。</li>
<li><code>-XX: InitiatingHeapoccupancyPercent</code>：<strong>设置触发并发GC周期的Java堆占用率阈值</strong>。超过此值，就触发GC。<strong>默值是45</strong>。堆空间已用占比达到45%，老年代才会并发标记</li>
</ul>
<h5 id="5、G1回收器的常见操作步骤"><a href="#5、G1回收器的常见操作步骤" class="headerlink" title="5、G1回收器的常见操作步骤"></a>5、G1回收器的常见操作步骤</h5><ul>
<li>G1的设计原则就是<strong>简化JVM性能调优</strong>，开发人员只需要简单的三步即可完成调优：<ol>
<li>第一步：<strong>开启G1垃圾收集器</strong></li>
<li>第二步：<strong>设置堆的最大内存</strong></li>
<li>第三步：<strong>设置最大的停顿时间</strong></li>
</ol>
</li>
<li>G1中提供了三种垃圾回收模式：<strong>YoungGC、 Mixed GC和Full GC，在不同的条件下被触发</strong>。</li>
</ul>
<h5 id="6、G1回收器的适用场景"><a href="#6、G1回收器的适用场景" class="headerlink" title="6、G1回收器的适用场景"></a>6、G1回收器的适用场景</h5><ul>
<li><strong>面向服务端应用</strong>，针对具有<strong>大内存、多处理器</strong>的机器。(在普通大小的堆里表现并不惊喜)</li>
<li>最主要的应用是<strong>需要低GC延迟，并具有大堆的应用程序</strong>提供解决方案；</li>
<li>如：在堆大小<strong>约6GB或更大</strong>时，<strong>可预测的暂停时间可以低于0.5秒</strong>；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ol>
<li><strong>超过50%的Java堆被活动数据占用</strong>；</li>
<li><strong>对象分配频率或年代提升频率变化很大</strong>；</li>
<li><strong>GC停顿时间过长</strong>(长于0.5至1秒)</li>
</ol>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用<strong>应用线程承担后台运行的GC工作</strong>，即<strong>当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</strong>。</li>
</ul>
<h5 id="7、分区Region：化整为零"><a href="#7、分区Region：化整为零" class="headerlink" title="7、分区Region：化整为零"></a>7、分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB<br>之间，且为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB, 32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的Region大小相同，且在JVM生命周期内</strong><br><strong>不会被改变</strong>。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实</strong><br><strong>现逻辑上的连续</strong>。</p>
<ul>
<li><strong>如果设置了Region数量，那么Region大小就不是固定的，但是大小肯定是2的幂次方，并且在1-32M之间</strong>；</li>
<li><strong>如果设置了Region大小，那么Region数量就不是固定的，但是肯定是2048附近</strong>；</li>
</ul>
<p>Region只能是Eden、Survivor、 Humongous中的一种，但是它的身份不是固定的，谁来占用那么这个Region就是谁的</p>
<p><img src="/2021/04/19/JVM/image-20210430001836775.png" alt="image-20210430001836775"></p>
<ul>
<li>一个region有可能属于Eden，Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做<strong>Humongous内存区域</strong>，如图中的H块。主要用于<strong>存储大对象</strong>，如果<strong>超过0.5个region，就放到H</strong>。region是可以连续分配的，小于0.5的就用两个连续的region分配</li>
<li>object that is more than half a region size is considered a “Humongous object” ：大于区域大小一半的对象都被视为“巨大对象”</li>
</ul>
<p>设置Humongous的原因：</p>
<p>对于<strong>堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个<strong>Humongous区，它用来专门存放大对象</strong>。如果<strong>一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到<strong>连续的H区</strong>，有时候不得不<strong>启动Full GC</strong>。G1的<strong>大多数行为都把H区作为老年代的一部分来看待</strong>。</p>
<p>关于指针碰撞与空闲列表：</p>
<ul>
<li><p>Bump：单个Region使用指针碰撞的方式来放数据上面allocated是已经使用的内存空间，top就是指针的位置，unallocate是没有使用的内存空间</p>
<ul>
<li>Bump-the-pointer，即：指针碰撞</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210430002300492.png" alt="image-20210430002300492"></p>
</li>
<li><p>TLAB：虽然存在分区Region，但是依然有线程独有的TLAB空间，这样可以保证多个线程对对象修改可以并行操作</p>
<ul>
<li>TLAB，即：空闲列表</li>
</ul>
</li>
</ul>
<h5 id="8、G1回收器垃圾回收过程"><a href="#8、G1回收器垃圾回收过程" class="headerlink" title="8、G1回收器垃圾回收过程"></a>8、G1回收器垃圾回收过程</h5><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程(Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
<li>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</li>
</ul>
<p>顺时针，Young GC -&gt; Young GC +Concurrent Marking -&gt; Mixed GC顺序，进行垃圾回收。</p>
<p><img src="/2021/04/19/JVM/image-20210429185519798.png" alt="image-20210429185519798"></p>
<ul>
<li>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</strong>。</li>
<li>当堆内存使用达到一定值(<strong>默认45%</strong>)时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，<strong>这个老年代Region是和年轻代一起被回收的</strong>。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45号%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ul>
<p><strong>G1回收器垃圾回收过程：Remembered Set</strong></p>
<ul>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代?</p>
<ul>
<li>这样的话会降低Minor GC的效率；</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li><strong>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</strong>：<ul>
<li>每个Region都有一个对应的Remembered Set；</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier 暂时中断操作；</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象)；</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<ul>
<li>卡表是记忆集的一种具体实现方式。 见《深入理解Java虚拟机》</li>
</ul>
</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏；</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210430003324501.png" alt="image-20210430003324501"></p>
</li>
<li><p>上面提到的Remebered Set就是上述Reset，上面提到的Reference类型就是引用类型，其中Reset的作用是记录当前Region中哪些对象被外部引用指向，比如OId区中的对象会指向Eden区的对象，然后当我们要回收某个Region的时候，直接遍历遍历当前Region中的所有对象就可以了，然后针对性的去找到那些指向当前对象的其他对象，最终发现当前对象是否是根可达的，如果不是，那就应该被删除，其实之前的垃圾回收器都涉及到这个问题，当进行Minor GC的时候，通过GC Roots查找的时候还需要遍历Old区的对象，毕竟Old区对象也可能会指向Eden区对象，但是G1通过Rset避免了全堆的扫描，当引用类型数据写操作时，先暂时中断，然后判断当前引用类型数据是否被其他对象所指向，如果不被指向，那就直接放在Region中就可以了；如果被其他对象指向，那么还要判断这个对象是在当前要插入的Region中，还是在其他Region中;如果在其他Region中，那就需要使用CardTable把当前引用类型数据的指向信息放在Rset中，也就是形成上面的虚线连线，如果在当前Region中，那就不需要指向了，毕竟到时候我们会进行遍历查找根可达对象，那肯定会找到的，所以这种情况也是直接放在Region中就可以了。</p>
</li>
</ul>
<h5 id="9、G1回收过程一：年轻代GC"><a href="#9、G1回收过程一：年轻代GC" class="headerlink" title="9、G1回收过程一：年轻代GC"></a>9、G1回收过程一：年轻代GC</h5><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p><strong>年轻代垃圾回收只会回收Eden区和Survivor区</strong>。</p>
<p>首先G1停止应用程序的执行(Stop-The-World)，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="/2021/04/19/JVM/image-20210430003008242.png" alt="image-20210430003008242"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><p>第一阶段，<strong>扫描根</strong>。可以体现Rset作用：<strong>避免全堆扫描</strong></p>
<ul>
<li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li><p>第二阶段，<strong>更新RSet</strong>。 作用：<strong>保证Rset中的数据准确性</strong></p>
<ul>
<li><p>处理dirty card queue中的card，更新RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</strong>。</p>
</li>
<li><p>对dirty card queue (脏卡表队列)的解释：</p>
<ul>
<li>对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。<ul>
<li>其中object.field=object中的第一个object代表老年代中的对象，而第二个object代表Eden区中的对象</li>
</ul>
</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢?<ul>
<li>这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
</li>
</ul>
</li>
<li><p>脏卡表队列作用：</p>
<p>Reset更新需要线程同步，所以开销会很大，因此不能实时更新，因此我们需要把引用对象被其他对象引用的关系放在一个脏卡表队列中，当年轻代回收的时候会进行STW，所以我们也正好把脏卡表队列中的值更新到Rset中，这样不仅没有涉及到开销问题，还可以保证Rset中的数据是准确的。</p>
</li>
</ul>
</li>
<li><p>第三阶段，<strong>处理RSet</strong>。作用：<strong>根可达性遍历的一部分</strong></p>
<ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p>第四阶段，<strong>复制对象</strong>。说明：<strong>新生代使用复制算法</strong></p>
<ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p>第五阶段，<strong>处理引用</strong>。空Eden：<strong>Eden变成空的，那它就变成了无主Region，因此会被记录到空链表中，等待下一次被分配</strong></p>
<ul>
<li>处理Soft，Weak，Phantom， Final， JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
<li>以上回收的都是强引用对象，下面回收软引用对象 (不足回收)、弱引用对象(发现回收)、虚引用对象</li>
</ul>
</li>
</ol>
<h5 id="10、G1回收过程二：并发标记过程"><a href="#10、G1回收过程二：并发标记过程" class="headerlink" title="10、G1回收过程二：并发标记过程"></a>10、G1回收过程二：并发标记过程</h5><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。<strong>这个阶段是STW的，并且会触发一次年轻代GC</strong>。</li>
<li><strong>根区域扫描(Root Region Scanning)**：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。</strong>主要扫描哪些老年代对象是可达的**，毕竟我们进行Young GC的时候会移动Survivor区，移动之后就找不到哪些老年代对象是可达的了</li>
<li><strong>并发标记(Concurrent Marking)**：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，</strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**（实时回收）。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>**再次标记(Remark)**：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning (SATB)。<ul>
<li>原因：并发标记不准确</li>
</ul>
</li>
<li><strong>独占清理(cleanup ,STW)**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。</strong>是STW的<strong>。</strong>其实是一个统计计算过程，不会涉及垃圾清理**<ul>
<li><strong>这个阶段并不会实际上去做垃圾的收集</strong></li>
</ul>
</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。<ul>
<li>并发清理阶段任务：<strong>如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收</strong>。</li>
</ul>
</li>
</ol>
<h5 id="11、G1回收过程三：混合回收"><a href="#11、G1回收过程三：混合回收" class="headerlink" title="11、G1回收过程三：混合回收"></a>11、G1回收过程三：混合回收</h5><p>当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。 这里需要注意：是<strong>一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<strong>Mixed GC并不是Full GC</strong>。 </p>
<p><img src="/2021/04/19/JVM/image-20210429194133565.png" alt="image-20210429194133565"></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</li>
<li>混合回收的回收集(Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收</strong>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。<strong>如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。垃圾占比越多， 回收优先级越高</strong>；如果垃圾不足Region空间的65%，那么将不会进行回收。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。如果垃圾不足Region内存的10%，那么将不会对该老年代Region进行回收，综合上面的来看，只要垃圾占整个老年代Region的比例大于65%，才会对该Region进行回收</li>
</ul>
<h5 id="12、G1回收可选的过程四：Full-GC"><a href="#12、G1回收可选的过程四：Full-GC" class="headerlink" title="12、G1回收可选的过程四：Full GC"></a>12、G1回收可选的过程四：Full GC</h5><ul>
<li><p>G1的初衷就是要避免Fu1l GC的出现。但是如果上述方式不能正常工作，G1会<strong>停止应用程序的执行</strong>(Stop- The-World)，使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
</li>
<li><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?</p>
<ul>
<li>比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
</ul>
</li>
<li><p>导致G1Full GC的原因可能有三个:</p>
<ol>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象；</li>
</ol>
<ul>
<li>解决：加大堆空间</li>
</ul>
<ol start="2">
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<ul>
<li>解决：调小触发并发GC周期的Java堆占用阈值(默认是45%， 在前面参数页有)</li>
</ul>
<ol start="3">
<li>最大GC暂停时间太短，导致在规定的时间间隔内无法完成垃圾回收，也会导致Full GC</li>
</ol>
<ul>
<li>解决：加大最大GC停顿时间</li>
</ul>
</li>
</ul>
<h5 id="13、G1回收过程：补充"><a href="#13、G1回收过程：补充" class="headerlink" title="13、G1回收过程：补充"></a>13、G1回收过程：补充</h5><p>从Oracle官方透露出来的信息可获知，回收阶段( Evacuation)其实本也有想过设计成<strong>与用户程序一起并发执行</strong>，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而<strong>选择把这个特性放到了G1之后出现的低延迟垃圾收集器(即ZGC)中</strong>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h5 id="14、G1回收器优化建议"><a href="#14、G1回收器优化建议" class="headerlink" title="14、G1回收器优化建议"></a>14、G1回收器优化建议</h5><ul>
<li>年轻代大小<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标<ul>
<li>原因：年轻代GC是并行独占式的，所以最好让垃圾回收器自己去调节</li>
</ul>
</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
<li>说明：暂停时间和吞吐量是此消彼长的，所以不要把暂停时间设置的太严格，不然因为这个原因引起Full GC也不太好</li>
</ul>
</li>
</ul>
<h4 id="8、垃圾回收总结"><a href="#8、垃圾回收总结" class="headerlink" title="8、垃圾回收总结"></a>8、垃圾回收总结</h4><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B/S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记-压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段：Serial =&gt; Parallel (并行) =&gt; CMS (并发) =&gt; G1 =&gt; ZGC</p>
<p><strong>怎么选择垃圾回收器?</strong></p>
<ul>
<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>
<li>怎么选择垃圾收集器?<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果<strong>内存小于100M</strong>， 使用<strong>串行收集器</strong></li>
<li>如果是<strong>单核、单机程序，并且没有停顿时间</strong>的要求，<strong>串行收集器</strong></li>
<li>如果是<strong>多CPU</strong>、需要<strong>高吞吐量</strong>、<strong>允许停顿时间超过1秒</strong>，选择<strong>并行</strong>或者<strong>JVM自己选择</strong>.</li>
<li>如果是<strong>多CPU</strong>、<strong>追求低停顿时间</strong>，需<strong>快速响应</strong>(比如延迟不能超过1秒，如互联网应用)，使用并发收集器官方推荐<strong>G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li>
<li>最后需要明确一个观点：<ol>
<li>没有最好的收集器，更没有万能的收集器；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
</li>
</ol>
</li>
<li>面试：<ul>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：<ul>
<li>垃圾收集的算法有哪些?</li>
<li>如何判断一个对象是否可以回收?</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</li>
</ul>
</li>
</ul>
<h4 id="9、GC日志分析"><a href="#9、GC日志分析" class="headerlink" title="9、GC日志分析"></a>9、GC日志分析</h4><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p>
<ul>
<li><p>内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX: +PrintGC</code>：输出Gc日志。类似: -verbose :gc</li>
<li><code>-XX: +PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX: +PrintGCTimeStamjps</code>：输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX: +PrintGCDateStamps</code>：输出GC的时间戳(以日期的形式，如2013-05-04T21 :53:59.234+0800)</li>
<li><code>-XX: + PrintHeapAtGC</code> ：在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc: ../logs/gc.log</code>：日志文件的输出路径</li>
</ul>
</li>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个只会显示总的GC堆的变化， 如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K)，0.0084018secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K (228352K)，0.0184066 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K) ，0.0619261secs ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li>GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代， 老年代。</li>
<li>Allocation Failure: GC发生的原因。</li>
<li>80832K -&gt; 19298K：堆在GC前的大小和GC后的大小。</li>
<li>228840k：现在的堆大小。</li>
<li>0.0084018 secs：GC持续的时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc -XX: +PrintGCDetails</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)[PSYoungGen: 70640K-&gt;10116K(141312K)] 80541K-&gt;20017K (227328K)，0.0172573secs]</span><br><span class="line">[Times: user=0.03 sys=0.00， real=0.02 secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 98859K-&gt;8154K(142336K) ] 108760K-&gt;21261K (228352K)，0.0151573 secs]</span><br><span class="line">[Times: user=0.00 sys=0.01, real=0.02 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 8154K-&gt;0K(142336K) ] [ParOldGen: 13107K-&gt;16809K(62464K)] 21261K -&gt; 16809K (204800K),</span><br><span class="line">[Metaspace: 20599K-&gt;20599K (1067008K)]，0.0639732 secs]</span><br><span class="line">[Times: user=0.14 sys=0.00， real=0.06 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析:</p>
<ul>
<li>GC，Full FC：同样是GC的类型</li>
<li>Allocation Failure：GC原因</li>
<li>PSYoungGen：使用了Parallel Scavenge并 行垃圾收集器的新生代Gc前后大小的变化</li>
<li>ParoldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</li>
<li>Metaspace：元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代</li>
<li>XXX secs：指GC花费的时间</li>
<li>Times: user: 指的是垃圾收集器花费的所有CPU时间，sys: 花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX: +PrintGCDetails -XX: +PrintGCTimeStamps -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-09-24T22:15:24.518+0800:3.287: [GC(Allocation Failure) [ PSYoungGen: 136162K-&gt;5113K (136192K) ] 141425K-&gt;17632K (222208K)，0.0248249 secs] [Times: user=0. 05 sys=0.00，real=0.03 secs]</span><br><span class="line">2019-09-24T22:15:25.559+0800:4.329: [GC (Metadata GC Threshold)[ PSYoungGen:97578K-&gt;10068K(274944K) ] 110096K-&gt;22658K (360960K)，0.0094071 secs] [Times: user=0. 00 sys=0.00，real=0.01 secs]</span><br><span class="line">2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [ PSYoungGen:10068K-&gt;0K(274944K) ] [ParOldGen: 12590K-&gt;13564K (56320K) ] 22658K-&gt;13564K (331264K) ,</span><br><span class="line">[Metaspace: 20590K-&gt;20590K(1067008K)]， 0.0494875 secs]</span><br><span class="line">[Times: user=0.17 sys=0.02，real=0.05 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：带上了日期和时间</p>
</li>
</ul>
<ul>
<li>日志补充说明：<ul>
<li>“ [GC”和” [Full GC” 说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是” [DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成” [ParNew”，意思是”Parallel New Generation”</li>
<li>使用Parallel Scavenge收集器在新生代的名字是” [PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage- first heap”</li>
<li>Allocation Failure：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li>[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K- &gt; 704K (9216K)中<ul>
<li>括号内：GC回收前年轻代大小，回收后大小，( 年轻代总大小)</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，( 年轻代和老年代总大小)</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys 内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间</li>
</ul>
</li>
</ul>
<p>GC日志分析</p>
<p><img src="/2021/04/19/JVM/image-20210430011457790.png" alt="image-20210430011457790"></p>
<p>Minor GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430011551243.png" alt="image-20210430011551243"></p>
<p>Full GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430012224983.png" alt="image-20210430012224983"></p>
<p>如果想把GC日志存到文件的话，是下面这个参数：</p>
<ul>
<li>Xloggc: ./path/to/gc. log</li>
</ul>
<p>GC日志分析工具：</p>
<ul>
<li>可以用一些工具去分析这些gc日志。</li>
<li>常用的日志分析工具有：<strong>GCViewer</strong>、<strong>GCEasy</strong>、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</li>
</ul>
<h4 id="10、垃圾回收器的新发展"><a href="#10、垃圾回收器的新发展" class="headerlink" title="10、垃圾回收器的新发展"></a>10、垃圾回收器的新发展</h4><h5 id="1、垃圾回收器的发展"><a href="#1、垃圾回收器的发展" class="headerlink" title="1、垃圾回收器的发展"></a>1、垃圾回收器的发展</h5><p>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、 Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p>
<p>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在<strong>Serverless等新的应用场景 下，Serial GC找到了新的舞台</strong>。</p>
<p>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p>
<h5 id="2、JDK11的新特性"><a href="#2、JDK11的新特性" class="headerlink" title="2、JDK11的新特性"></a>2、JDK11的新特性</h5><p><img src="/2021/04/19/JVM/image-20210429231614446.png" alt="image-20210429231614446"></p>
<h5 id="3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性"><a href="#3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性" class="headerlink" title="3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)"></a>3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)</h5><ul>
<li><p>现在G1回收器已成为默认回收器好几年了。</p>
</li>
<li><p>我们还看到了引入了两个新的收集器：</p>
<ul>
<li>ZGC( JDK11出现)</li>
<li>Shenandoah(Open JDK12)</li>
<li>主打特点：<strong>低停顿时间</strong></li>
</ul>
</li>
<li><p><strong>Shenandoah，无疑是众多GC中最孤独的一个</strong>。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<strong>旨在针对JVM上的内存回收实现低停顿的需求</strong>。在2014年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat研发Shenandoah团队对外宣称，<strong>Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="/2021/04/19/JVM/image-20210430015133115.png" alt="image-20210430015133115"></p>
</li>
<li><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降王</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
<li>Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前Java12新特性视频里有过介绍。</li>
</ul>
</li>
</ul>
<p>[Java12新特性地址]<br><a target="_blank" rel="noopener" href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a><br>或<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p>
<h5 id="4、令人震惊、革命性的ZGC（JDK14新特性）"><a href="#4、令人震惊、革命性的ZGC（JDK14新特性）" class="headerlink" title="4、令人震惊、革命性的ZGC（JDK14新特性）"></a>4、令人震惊、革命性的ZGC（JDK14新特性）</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">官网地址</a></p>
<ul>
<li><p>ZGC与Shenandoah目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</strong>。</p>
</li>
<li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，(暂时)不设分代的，使用了<code>读屏障</code>、<code>染色指针</code>和<code>内存多重映射</code>等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标的一款垃圾收集器</strong>。</p>
</li>
<li><p>ZGC的工作过程可以分为4个阶段：</p>
<ul>
<li><strong>并发标记</strong></li>
<li><strong>并发预备重分配</strong></li>
<li><strong>并发重分配</strong></li>
<li><strong>并发重映射</strong>等。</li>
</ul>
</li>
<li><p>ZGC几乎在所有地方并发执行的，除了<strong>初始标记的是STW</strong>（10ms以内）的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
</li>
<li><p>测试数据：</p>
<p><img src="/2021/04/19/JVM/image-20210430015758548.png" alt="image-20210430015758548"></p>
<p>低延迟：</p>
<p><img src="/2021/04/19/JVM/image-20210430015925777.png" alt="image-20210430015925777"></p>
</li>
<li><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、958停顿、99%停顿、99. 98停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在10毫秒以内。</p>
</li>
<li><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。</p>
</li>
<li><p><strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器</strong>。</p>
</li>
<li><p>JEP 364: ZGC应用在macOS上</p>
</li>
<li><p>JEP 365: ZGC应用在Windows</p>
<ul>
<li>JDK14之前，ZGC仅Linux才支持。</li>
<li> 尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOs.上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</li>
<li>现在mac或windows.上也能使用zGc了，示例如下：<br>**-XX: +Unloc kExperimentalVMOptions -XX: +UseZGC**</li>
</ul>
</li>
<li><p>其它垃圾回收器: AIiGC</p>
<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆 (LargeHeap)应用场景。指定场景下的对比：</p>
<p><img src="/2021/04/19/JVM/image-20210429233231323.png" alt="image-20210429233231323"></p>
</li>
<li><p>当然，其他厂商也提供了各种独具一格的GC实现， 例如比较有名的低延迟GC：<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail">Zing</a>，有兴趣可以参考提供的链接。</p>
</li>
</ul>
<hr>
<h3 id="18、垃圾回收的相关大厂面试题"><a href="#18、垃圾回收的相关大厂面试题" class="headerlink" title="18、垃圾回收的相关大厂面试题"></a>18、垃圾回收的相关大厂面试题</h3><ul>
<li>蚂蚁金服:<ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1</li>
<li>一面: JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li>
<li>一面: G1回收器讲下回收过程</li>
<li>GC是什么?为什么要有GC?</li>
<li>一面: GC的两种判定方法? CMS收集器与G1收集器的特点。</li>
</ul>
</li>
<li>百度:<ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: jvm GC原理，JVM怎么回收内存</li>
<li>一面: CMS特点，垃圾回收算法有哪些?各自的优缺点，他们共同的缺点是什么?</li>
</ul>
</li>
<li>滴滴:<ul>
<li>一面: java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
</li>
<li>京东:<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</li>
<li>垃圾回收算法的实现原理。</li>
</ul>
</li>
<li>阿里:<ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收?</li>
<li>如何选择合适的垃圾收集算法?</li>
<li>JVM有哪三种垃圾回收器?</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣?</li>
<li>system.gc() 和 runtime.gc() 会做什么事情?</li>
<li>一面: Java GC机制? GC Roots有哪些?</li>
<li>二面: Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="0、其他"><a href="#0、其他" class="headerlink" title="0、其他"></a>0、其他</h3><h4 id="1、label"><a href="#1、label" class="headerlink" title="1、label"></a>1、label</h4><p>官方：</p>
<p>Refactor the code to remove this label and the need for it.</p>
<p>label标签，不属于关键字，类似于c的goto（很少用），用于标记跳转。底层就是goto语句，尽量不要用</p>
<h4 id="2、怎么学习Java的不同版本的新特性"><a href="#2、怎么学习Java的不同版本的新特性" class="headerlink" title="2、怎么学习Java的不同版本的新特性"></a>2、怎么学习Java的不同版本的新特性</h4><p>Java不同版本的新特性：</p>
<ol>
<li>语法层面：Lambda表达式、switch表达式、 自动装箱、自动拆箱、enum关键字、 &lt;&gt;泛式等等</li>
<li>API层面：Stream API、新的日期时间、Optional、 String、 集合框架</li>
<li>底层优化：JVM的优化，GC的变化、元空间、静态域、字符串常量池等</li>
</ol>
<h2 id="中篇：字节码与类的加载器"><a href="#中篇：字节码与类的加载器" class="headerlink" title="中篇：字节码与类的加载器"></a>中篇：字节码与类的加载器</h2><h3 id="1、class文件结构"><a href="#1、class文件结构" class="headerlink" title="1、class文件结构"></a>1、class文件结构</h3><h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、字节码文件的跨平台性"><a href="#1、字节码文件的跨平台性" class="headerlink" title="1、字节码文件的跨平台性"></a>1、字节码文件的跨平台性</h5><ol>
<li><p>Java语言: 跨平台的语言(write once ，run anywhere)</p>
<ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译</li>
<li>这个优势不再那么吸引人了。Python、 PHP、 Perl、 Ruby、 Lisp等有强大的解释器。</li>
<li>跨平台似乎已经快成为一门语言必选的特性。</li>
</ul>
</li>
<li><p>Java虚拟机：跨语言的平台</p>
<ul>
<li><p><strong>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联</strong>。</p>
</li>
<li><p>无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。</p>
</li>
<li><p>可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
</li>
<li><p>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">官方文档</a></p>
</li>
</ul>
</li>
<li><p>想要让一个Java程序正确地运行在JVM中， Java源码就必须要被编译为符合JVM规范的字节码。</p>
<ul>
<li><p><strong>前端编译器的主要任务</strong>就是<strong>负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件</strong>。</p>
</li>
<li><p><strong>javac</strong>一种能够将Java源码编译为字节码的<strong>前端编译器</strong>。</p>
</li>
<li><p>javac编译器在<strong>将Java源码编译为个有效的字节码文件过程中经历了4个步骤，分别是词法解析、语法解析、语义解析以及生成字节码。</strong></p>
<p><img src="/2021/04/19/JVM/image-20210504004503138.png" alt="image-20210504004503138"></p>
</li>
</ul>
</li>
<li><p>Oracle的JDK软件包括两部分内容：</p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实现Java虛拟机的运行时环境</li>
</ul>
</li>
</ol>
<h5 id="2、Java的前端编译器"><a href="#2、Java的前端编译器" class="headerlink" title="2、Java的前端编译器"></a>2、Java的前端编译器</h5><h6 id="1、关于前端编译器与后台编译器在程序编译过程中的作用"><a href="#1、关于前端编译器与后台编译器在程序编译过程中的作用" class="headerlink" title="1、关于前端编译器与后台编译器在程序编译过程中的作用"></a>1、关于前端编译器与后台编译器在程序编译过程中的作用</h6><p><img src="/2021/04/19/JVM/image-20210504005333757.png" alt="image-20210504005333757"></p>
<h6 id="2、前端编译器vs后端编译器"><a href="#2、前端编译器vs后端编译器" class="headerlink" title="2、前端编译器vs后端编译器"></a>2、前端编译器vs后端编译器</h6><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的<strong>javac编译器</strong>。javac是一种能够<strong>将Java源码编译为字节码的前端编译器</strong>。</p>
<p>HotSpotVM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在Java的前端编译器领域，除了javac之外， 还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的<strong>ECJ (Eclipse Compiler for Java )编译器</strong>。和<strong>Javac的全量式编译</strong>不同，<strong>ECI是一种增量式编译器</strong>。</p>
<ul>
<li>在Eclipse中，当开发人员编写完代码后，使用“Ctrl+S”快捷键时，ECI编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此<strong>ECI的编译效率会比javac更加迅速和高效</strong>，当然编译质量和javac相比大致还是一样的。</li>
<li>ECI不仅是Eclipse的默认内置前端编译器，在<strong>Tomcat中同样也是使用ECJ编译器来编译jsp文件</strong>。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA使用javac编译器。(还可以自己设置为AspectJ编译器 ajc)</li>
</ul>
<p><strong>前端编译器并不会直接涉及编译优化</strong>等方面的技术，而是将这些具体<strong>优化细节移交给HotSpot的JIT编译器(后端编译器)负责</strong>。</p>
<p>复习: </p>
<ul>
<li>JIT（及时编译器）</li>
<li>AOT(静态提前编译器，Ahead of Time Compiler)</li>
</ul>
<h5 id="3、透过字节码指令看代码细节"><a href="#3、透过字节码指令看代码细节" class="headerlink" title="3、透过字节码指令看代码细节"></a>3、透过字节码指令看代码细节</h5><p>BAT面试题：</p>
<ol>
<li>类文件结构有几个部分?</li>
<li>知道字节码吗?字节码都有哪些? Integer x = 5;int y = 5;比较x == y都经过哪些步骤?</li>
</ol>
<p>代码举例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);<span class="comment">//true。自动拆箱</span></span><br><span class="line"></span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关字节码1：</p>
<p><img src="/2021/04/19/JVM/image-20210518205703047.png" alt="image-20210518205703047"></p>
<p><img src="/2021/04/19/JVM/image-20210518205820353.png" alt="image-20210518205820353"></p>
<p><img src="/2021/04/19/JVM/image-20210518205932030.png" alt="image-20210518205932030"></p>
<p><img src="/2021/04/19/JVM/image-20210518205941131.png" alt="image-20210518205941131"></p>
<p>代码举例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        String str1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str == str1);<span class="comment">//false</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        System.out.println(str == str2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关字节码2：</p>
<p><img src="/2021/04/19/JVM/image-20210518215156842.png" alt="image-20210518215156842"></p>
<p><img src="/2021/04/19/JVM/image-20210518215729244.png" alt="image-20210518215729244">\</p>
<p><img src="/2021/04/19/JVM/image-20210518215755492.png" alt="image-20210518215755492"></p>
<p>代码举例3：</p>
<p><img src="/2021/04/19/JVM/image-20210518220102931.png" alt="image-20210518220102931"></p>
<p>相关说明：</p>
<ul>
<li>成员变量（非静态的）的赋值过程：<ul>
<li>默认初始化（注意这里会先调用所有父类的构造方法（super））</li>
<li>显式初始化 / 代码块中初始化</li>
<li>构造器中初始化</li>
<li>有了对象之后，可以”对象.属性”或”对象.方法”的方式对成员变量进行赋值。</li>
</ul>
</li>
</ul>
<p>相关字节码3：</p>
<p>对son：</p>
<p><img src="/2021/04/19/JVM/image-20210518221159306.png" alt="image-20210518221159306"></p>
<p>代码的执行过程：</p>
<ol>
<li>执行<code>Father f = new Son();</code></li>
<li>先初始化父类的构造器，在父类的构造器当中调用了print()方法</li>
<li>又因为Son重写了父类Father的print()方法，此时又没有到执行显示初始化的步骤（看上面的字节码文件）</li>
<li>因此打印的是<code>Son.x = 0</code></li>
<li>接着初始化Son本身的构造器，Son本身的构造器当中调用了print()方法</li>
<li>此时已经经历了显示初始化，x被赋予值30（具体看上面的成员变量（非静态的）的赋值过程）</li>
<li>因此打印的是<code>Son.x = 30</code></li>
<li>最后执行<code>System.out.println(f.x);</code></li>
<li>**<code>因为属性不存在多态性！！！</code>**变量f的声明类型是Father，所以它是Father类型的，不是Son类型。</li>
<li>所以f.x中的x也是Father的x，因此打印的才是<code>20</code></li>
</ol>
<h4 id="2、虚拟机的基石：class文件"><a href="#2、虚拟机的基石：class文件" class="headerlink" title="2、虚拟机的基石：class文件"></a>2、虚拟机的基石：class文件</h4><ul>
<li><p>字节码文件里是什么?</p>
<p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种<strong>二进制的类文件</strong>，它的内容是JVM的指令，而不像C、C++经由编译器直接生成<strong>机器码</strong>。</p>
</li>
<li><p>什么是字节码指令(byte code)?<br>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的<strong>操作码</strong>(opcode)以及跟随其后的零至多个代表此操作所需参数的<strong>操作数</strong>(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：操作码 (操作数)</p>
<p><img src="/2021/04/19/JVM/image-20210504010005360.png" alt="image-20210504010005360"></p>
</li>
<li><p>如何解读供虚拟机解释执行的二进制字节码?</p>
<ol>
<li>方式一：一个一个二进制的看。这里用到的是Notepad++,需要安装一个HEX-Editor插件，或者使用Binary Viewer</li>
<li>方式二：使用javap指令：jdk 自带的反解析工具。eg：javap -v IntegerTest.class &gt;IntegerTest.txt</li>
<li><strong>方式三</strong>：使用IDEA插件：jclasslib或jclasslib bytecode viewer客户端工具。(可视化更好)</li>
</ol>
</li>
</ul>
<h4 id="3、class文件结构"><a href="#3、class文件结构" class="headerlink" title="3、class文件结构"></a>3、class文件结构</h4><h5 id="1、关于Class文件"><a href="#1、关于Class文件" class="headerlink" title="1、关于Class文件"></a>1、关于Class文件</h5><ul>
<li><p>相关的官方文档</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">javase8 JVM-ClassFile的相关资料</a></p>
</li>
<li><p>Class类的本质</p>
<ul>
<li>任何一个Class文件都对应着唯一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。</li>
<li>Class 文件是一组以<strong>8位字节</strong>为基础单位的<strong>二进制流</strong>。（该二进制流可以来自于磁盘，也可以来自于网络）</li>
</ul>
</li>
<li><p>Class文件格式</p>
<ul>
<li>Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，<strong>无论是字节顺序还是数量，都是被严格限</strong><br><strong>定的</strong>，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</li>
<li>例子：<ul>
<li>“下雨天留客天留我不留”：</li>
<li>“下雨天，留客天，留我不留?”</li>
<li>“下雨天，留客天，留我不?留!”</li>
<li>“下雨，天留客?天留，我不留!”</li>
</ul>
</li>
<li>目的：压缩字节码文件</li>
</ul>
</li>
<li><p>Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：**<code>无符号数</code><strong>和</strong><code>表</code>**。</p>
<ul>
<li><strong>无符号数属于基本的数据类型</strong>，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的<strong>复合数据类型</strong>，所有表都习惯性地以“info”结尾。表用于描述有层次关系的复合结构的数据，<strong>整个Class文件本质上就是一张表</strong>。由于表没有固定长度，所以通常<strong>会在其前面加上个数说明</strong>。</li>
</ul>
</li>
<li><p>相关代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全类名：com.atguigu.java1.Demo</span></span><br><span class="line"><span class="comment"> * 全限定名：com/atguigu/java1/Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过javac编译过后的16进制的Class文件：</p>
<p><img src="/2021/04/19/JVM/image-20210519000727861.png" alt="image-20210519000727861"></p>
<p>经过插件——jclasslib反编译后的Class文件：</p>
<p><img src="/2021/04/19/JVM/image-20210519001523659.png" alt="image-20210519001523659"></p>
<p><strong>换句话说，充分理解了每一个字节码文件的细节，自己也可以反编译出Java源文件来</strong>。</p>
</li>
<li><p>Class文件结构概述：Class文件的结构并不是一成不变的，随着Java虛拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。</p>
<p>Class文件的总体结构如下:</p>
<ul>
<li>魔数<ul>
<li>u4               magic;</li>
</ul>
</li>
<li>Class文件版本<ul>
<li>u2             minor_version;</li>
<li>u2             major_version;</li>
</ul>
</li>
<li>常量池<ul>
<li>u2             constant_pool_count;</li>
<li>cp_info       constant_pool[constant_pool_count-1];</li>
</ul>
</li>
<li>访问标志<ul>
<li>u2             access_flags;</li>
</ul>
</li>
<li>类索引，父类索引，接口索引集合<ul>
<li>u2             this_class;</li>
<li>u2             super_class;</li>
<li>u2             interfaces_count;</li>
<li>u2             interfaces[interfaces_count];</li>
</ul>
</li>
<li>字段表集合<ul>
<li>u2             fields_count;</li>
<li>field_info    fields[fields_count];</li>
</ul>
</li>
<li>方法表集合<ul>
<li>u2             methods_count;</li>
<li>method_info    methods[methods_count];</li>
</ul>
</li>
<li>属性表集合<ul>
<li>u2             attributes_count;</li>
<li>attribute_info attributes[attributes_count];</li>
</ul>
</li>
</ul>
<p>The <code>ClassFile</code> Structure：（来自官网）</p>
<p><img src="/2021/04/19/JVM/image-20210519001835589.png" alt="image-20210519001835589"></p>
<p>这是一张Java字节码总的结构表，我们按照上面的顺序逐一进行解读就可以了：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="2、01-魔数：Class文件的标志"><a href="#2、01-魔数：Class文件的标志" class="headerlink" title="2、01-魔数：Class文件的标志"></a>2、01-魔数：Class文件的标志</h5><p>**Magic Number (魔数)**：</p>
<ul>
<li><p>每个Class文件开头的4个字节的无符号整数称为魔数(Magic Number)</p>
</li>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p>
</li>
<li><p>魔数值固定为**<code>0xCAFEBABE</code>**。不会改变。</p>
</li>
<li><p>如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError:Incompatible magic value 1885430635 in class file StringTest</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于<strong>安全方面</strong>的考虑，因为文件扩展名可以随意地改动。</p>
</li>
<li><p>其实魔数不只是在class文件当中有所应用。在图片.png、音乐.mp3等等，里面也有前几位作为魔数，作为进行对应文件的标识符</p>
</li>
</ul>
<h5 id="3、02-Class文件版本号"><a href="#3、02-Class文件版本号" class="headerlink" title="3、02-Class文件版本号"></a>3、02-Class文件版本号</h5><ul>
<li><p>紧接着魔数的4个字节存储的是Class 文件的版本号。同样也是4个字节。<strong>第5个和第6个字节</strong>所代表的含义就是编译的<strong>副版本号minor_ version</strong>, 而<strong>第7个和第8个字节</strong>就是编译的<strong>主版本号major_ version</strong>。</p>
</li>
<li><p>它们共同构成了class文件的格式版本号。譬如某个 Class文件 的主版本号为 M，副版本号为 m，那么这个 Class文件 的格式版本号就确定为 M.m。</p>
</li>
<li><p>版本号和Java编译器的对应关系如下表：</p>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td><strong>52</strong>（十六进制对应的是34）</td>
<td><strong>0</strong></td>
<td><strong>1.8</strong></td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
</li>
<li><p>Java的版本号是从**<code>45</code>**开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。</p>
</li>
<li><p>虚拟机JDK版本为1.k (k &gt;= 2) 时，对应的class文件格式版本号的范围为<strong>45.0 - 44+k.0 (含两端)</strong> 。</p>
</li>
<li><p><strong>不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虛拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。( 向下兼容)</strong></p>
</li>
<li><p>在实际应用中，由于<strong>开发环境和生产环境的不同</strong>，可能会导致该问题的发生。因此，需要我们在开发时，特别注意<strong>开发编译的JDK版本和生产环境中的JDK版本是否一致</strong>。</p>
</li>
<li><p>总结成一句话就是：<strong>高版本的虚拟机可以解释运行低版本的字节码文件</strong>。</p>
</li>
</ul>
<h5 id="4、03-常量池：存放所有常量"><a href="#4、03-常量池：存放所有常量" class="headerlink" title="4、03-常量池：存放所有常量"></a>4、03-常量池：存放所有常量</h5><h6 id="1、常量池概述"><a href="#1、常量池概述" class="headerlink" title="1、常量池概述"></a>1、常量池概述</h6><ul>
<li><p>常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的<strong>字段和方法解析</strong>也有着至关重要的作用。</p>
</li>
<li><p>随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，<strong>常量池是整个Class文件的基石</strong>。</p>
</li>
<li><p>官方文档：</p>
<p><img src="/2021/04/19/JVM/image-20210519012259460.png" alt="image-20210519012259460"></p>
</li>
<li><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
</li>
<li><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值(constant_ pool_ count) 。与Java中语言习惯不一样的是，这个容量<strong>计数是从1而不是0开始的。</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
</tbody></table>
</li>
<li><p>由上表可见，Class文件使用了一个前置的容量计数器(constant_pool_count) 加若干个连续的数据项(constant_pool) 的形式来描述常量池内容。我们把这一 系列连续常量池数据称为常量池集合。</p>
</li>
<li><p><strong>常量池表项</strong>中，用于存放编译时期生成的各种**<code>字面量</code><strong>和</strong><code>符号引用</code><strong>，这部分内容将在类加载后进入</strong>方法区的运行时常量池**中存放。（其中字符串常量池在jdk7以后被移进堆空间中）</p>
</li>
</ul>
<h6 id="2、常量池计数器（constant-pool-count）"><a href="#2、常量池计数器（constant-pool-count）" class="headerlink" title="2、常量池计数器（constant_pool_ count）"></a>2、常量池计数器（constant_pool_ count）</h6><ul>
<li><p>由于常量池的数量不固定，时长时短，所以需要放置<strong>两个字节来表示常量池容量计数值</strong>。</p>
</li>
<li><p>常量池容量计数值(u2类型) ：<strong>从1开始</strong>，表示常量池中有多少项常量。即 <code>constant_pool_count=1</code> 表示常量池中有<strong>0</strong>个常量项</p>
</li>
<li><p>Demo的值为：</p>
<p><img src="/2021/04/19/JVM/image-20210519013853054.png" alt="image-20210519013853054"></p>
<p>其值为0x0016，转换为十进制，也就是22。</p>
<p>需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢?</p>
<ul>
<li>通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。 </li>
<li>这是为了满足后面某些指向常星池的索引值的数据在特定情况下需要表达“<strong>不引用任何一个常量池项目</strong>”的含义，这种情况可用<strong>索引值0</strong>来表示。</li>
</ul>
</li>
</ul>
<h6 id="3、常量池表"><a href="#3、常量池表" class="headerlink" title="3、常量池表"></a>3、常量池表</h6><ul>
<li><p>constant_ pool是一种表结构， 以1 ~ constant_ pool_ count - 1为索引。表明了后面有多少个常量项。</p>
</li>
<li><p>常量池主要存放两大类常量：<code>**字面量(Literal)**</code>和<code>**符号引用(Symbolic References )**</code></p>
</li>
<li><p>它包含了class文件结构及其子结构中引用的所有<strong>字符串常量</strong>、<strong>类或接口名</strong>、<strong>字段名</strong>和<strong>其他常量</strong>。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte(标记字节、标签字节)。</p>
</li>
<li><p>tag byte与对应的类型：（最后三个是在jdk7添加的，体现了java对动态语言的支持）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="4、常量池表——字面量和符号引用"><a href="#4、常量池表——字面量和符号引用" class="headerlink" title="4、常量池表——字面量和符号引用"></a>4、常量池表——字面量和符号引用</h6><ul>
<li><p>字面量和符号引用：</p>
<ul>
<li><p>常量池主要存放两大类常量：</p>
<ul>
<li>字面量(Literal) </li>
<li>符号引用(Symbolic References) 。</li>
</ul>
</li>
<li><p>如下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
<td>String str = “Hello”;</td>
</tr>
<tr>
<td></td>
<td>声明为final的常星值</td>
<td>final int NUM = 10;</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
<td>com/atguigu/test/Demo;</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
<td>add、num</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>全限定名</p>
<ul>
<li>com/atguigu/test/Demo这个就是类的全限定名，仅仅是**把包名的”.”替换成”/“**，</li>
<li>为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会<strong>加入一个”;”表示全限定名结束</strong>。</li>
</ul>
</li>
<li><p>简单名称</p>
<ul>
<li>简单名称是指<strong>没有类型和参数修饰</strong>的<strong>方法</strong>或者<strong>字段名称</strong>，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</li>
</ul>
</li>
<li><p>描述符</p>
<ul>
<li><p>描述符的作用是用来描述<strong>字段的数据类型</strong>、<strong>方法的参数列表(包括数量、类型以及顺序)**和</strong>返回值**。</p>
</li>
<li><p>根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean) 以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：(基本数据类型long对应的是J；基本数据类型boolean对应的是Z；几个[表示几维数组)</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
</li>
<li><p>用描述符来描述方法时，按照<strong>先参数列表</strong>，<strong>后返回值的顺序描述</strong>，<strong>参数列表按照参数的严格顺序放在一组小括号”()”之内</strong>。</p>
<ul>
<li>如方法java.lang.String toString()的描述符为：() Ljava/lang/String；</li>
<li>方法int abc(int[] x, int y)的描述符为([II) I</li>
</ul>
</li>
</ul>
</li>
<li><p>补充说明：</p>
<ul>
<li>虚拟机在<strong>加载</strong>Class文件时才会进行<strong>动态链接</strong>，也就是说，<strong>Class 文件中不会保存各个方法和字段的最终内存布局信息</strong>，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在<code>类加载过程中的解析阶段</code>将其替换为直接引用，并翻译到具体的内存地址中</strong>。</li>
<li>这里说明下<strong>符号引用</strong>和<strong>直接引用</strong>的区别与关联：<ul>
<li>符号引用：符号引用以<strong>一组符号</strong>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到了内存中。</li>
<li>直接引用：直接引用可以是直接<strong>指向目标的指针</strong>、<strong>相对偏移量</strong>或是个<strong>能间接定位到目标的句柄</strong>。<strong>直接引用是与虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果<strong>有了直接引用，那说明引用的目标必定已经存在于内存之中</strong>了。</li>
<li>加载前类的方法等信息只是字符串（字面量与符号引用），而加载后会把这个字符串（字面量与符号引用）替换成相对应的内存地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="5、常量池表——常量类型和结构"><a href="#5、常量池表——常量类型和结构" class="headerlink" title="5、常量池表——常量类型和结构"></a>5、常量池表——常量类型和结构</h6><p>常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：</p>
<p>常量类型和结构细节：</p>
<p><img src="/2021/04/19/JVM/1598773300484.png" alt="1598773300484"></p>
<p><img src="/2021/04/19/JVM/1598773308492.png" alt="1598773308492"></p>
<ul>
<li>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容(主要是字面量、符号引用)的。比如：CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。</li>
<li>标志为15、16、18的常量项类型是用来支持动态语言调用的(jdk1.7时才加入的)。</li>
<li>细节说明：<ul>
<li>CONSTANT_Class_info：结构用于表示类或接口</li>
<li>CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构：表示字段、方法和接口方法</li>
<li>CONSTANT_string_info结构用于表示String类型的常量对象</li>
<li>CONSTANT_Integer_info和CONSTANT_Float_info：表示4字节(int 和float)的数值常量</li>
<li>CONSTANT_Long_info和ICONSTANT Double_info结构：表示8字节(long和double)的数值常量<ul>
<li>在class文件的常量池表中，所有的8字节常量均占两个表成员(项)的空间。如果一个CONSTANT_Long_info或CONSTANT_Double_info结构的项在常量池表中的索引位n，则常量池表中下一个可用项的索引位n+2，此时常量池表中索引为n+1的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info结构用于表示字段或方法，但是和之前的3个结构不同，CONSTANT_NameAndType_info结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_utf8_info用于表示字符常量的值</li>
<li>CONSTANT_MethodHandle_info结构用于表示方法句柄</li>
<li>CONSTANT_MethodType_info结构：表示方法类型</li>
<li>CONSTANT_InvokeDynamic_info结构用于表示invokedynamic指令所用到的引导方法(bootstrap method)、 引导方法所用到的动态调用名(dynamic invocation name)、 参数和返回类型，并可以给引导方法传入一系列称为静态参数(static argument)的常量。</li>
</ul>
</li>
<li>解析方式：<ul>
<li>一个字节一个字节的解析</li>
<li>使用javap命令解析：javap -verbose Demo.class 或 jclasslib工具会更方便。</li>
</ul>
</li>
<li>总结1：<ul>
<li>这14种表(或者常量项结构)的共同点是：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF - 8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢?<ul>
<li><strong>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</strong>，比如你定义一个类， 类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码， 就可以知道其长度。</li>
</ul>
</li>
</ul>
</li>
<li>总结2：<ul>
<li>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型(后面的很多数据类型都会指向此处)，也是占用Class文件空间最大的数据项目之一。</li>
<li><strong>常量池中为什么要包含这些内容</strong>：<ul>
<li>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，<strong>在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</strong>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5、04-访问标识"><a href="#5、04-访问标识" class="headerlink" title="5、04-访问标识"></a>5、04-访问标识</h5><p>访问标识（access_ flag、访问标志、访问标记）</p>
<ul>
<li><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：</p>
<ul>
<li>这个Class是类还是接口；</li>
<li>是否定义为public类型；</li>
<li>是否定义为abstract类型;如果是类的话，是否被声明为final等。</li>
</ul>
</li>
<li><p>各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
</li>
<li><p>类的访问权限通常为ACC_ 开头的常量。</p>
</li>
<li><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。</p>
</li>
<li><p>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</p>
</li>
<li><p>补充说明：</p>
<ol>
<li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。<ol>
<li><strong>如果一个class文件被设置了ACC_INTERFACE 标志，那么同时也得设置ACC_ABSTRACT 标志。同时它不能再设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志。</strong></li>
<li><strong>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</strong></li>
</ol>
</li>
<li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。<strong>针对Java虚拟机指令集的编译器都应当设置这个标志</strong>。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虛拟机都认为每个class文件均设置了ACC_SUPER标志。<ol>
<li><strong>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。</strong>目前的ACC_SUPER标志在由JDK 1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么Oracle的Java虛拟机实现会将其忽略。</li>
</ol>
</li>
<li>ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_ INTERFACE标志。</li>
<li>ACC_ENUM标志表明该类或其父类为枚举类型。</li>
</ol>
</li>
</ul>
<h5 id="6、05-类索引、父类索引、接口索引集合"><a href="#6、05-类索引、父类索引、接口索引集合" class="headerlink" title="6、05-类索引、父类索引、接口索引集合"></a>6、05-类索引、父类索引、接口索引集合</h5><ul>
<li><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
</li>
<li><p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends 语句)后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>this_class (类索引)</strong><ul>
<li>2字节无符号整数，指向常量池的索引。它提供了类的全限定名, 如com/atguigu/java1/Demo。this_ class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</li>
</ul>
</li>
<li><strong>super_class (父类索引)</strong><ul>
<li>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个。</li>
<li>superclass指向的父类不能是final。</li>
</ul>
</li>
<li>interfaces<ul>
<li>指向常量池索引集合，它提供了一个符号引用到所有己实现的接口</li>
<li>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class ( 当然这里就必须是接口，而不是类)。</li>
</ul>
</li>
</ol>
<ul>
<li>interfaces_count (接口计数器)：interfaces_ count 项的值表示当前类或接口的直接超接口数量。</li>
<li>interfaces []（接口索引集合）：<br>interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_ info结构， 其中0 &lt;= i &lt; interfaces_count。 在interfaces []中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即interfaces [0]对应的是源代码中最左边的接口。</li>
</ul>
<h5 id="7、06-字段表集合"><a href="#7、06-字段表集合" class="headerlink" title="7、06-字段表集合"></a>7、06-字段表集合</h5><h6 id="1、字段表集合"><a href="#1、字段表集合" class="headerlink" title="1、字段表集合"></a>1、字段表集合</h6><p>fields：</p>
<ul>
<li>用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。（local variables）</li>
<li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
<li>它指向常量池索引集合，它描述了每个字段的完整信息。比如**字段的标识符、访问修饰符(public、private或protected)、是类变量还是实例变量(static修饰符)、是否是常量(final修饰符)**等。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>字段表集合中<strong>不会列出从父类或者实现的接口中继承而来的字段</strong>，但有可能列出<strong>原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</strong></li>
<li>在<strong>Java语言中</strong>字段是无法重载的，<strong>两个字段</strong>的数据类型、修饰符不管是否相同，都<strong>必须使用不一样的名称</strong>， 但是<strong>对于字节码</strong>来讲，如果两个字段的<strong>描述符不一致</strong>，那<strong>字段重名就是合法</strong>的。</li>
</ul>
<h6 id="2、fields-count-字段计数器"><a href="#2、fields-count-字段计数器" class="headerlink" title="2、fields_ count(字段计数器)"></a>2、fields_ count(字段计数器)</h6><ul>
<li>fields_count的值表示当前class文件fields表的成员个数。 <strong>使用两个字节来表示</strong>。</li>
<li>fields表中每个成员都是一个field_info结构， 用于表示该类或接口所声明的所有类字段或者实例字段，<strong>不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段</strong>。</li>
</ul>
<h6 id="3、fields-（字段表）"><a href="#3、fields-（字段表）" class="headerlink" title="3、fields []（字段表）"></a>3、fields []（字段表）</h6><ul>
<li><p>fields表中的每个成员都必须是个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。</p>
</li>
<li><p>一个字段的信息包括如下这些信息。<strong>这些信息中，各个修饰符都是布尔值，要么有，要么没有</strong>。</p>
<ul>
<li>作用域(public、private、protected修饰符)</li>
<li>是实例变量还是类变量(static修饰符)</li>
<li>可变性(final)</li>
<li>并发可见性(volatile修饰符，是否强制从主内存读写)</li>
<li>可否序列化(transient修饰符)</li>
<li>字段数据类型(基本数据类型、对象、数组)</li>
<li>字段名称</li>
</ul>
</li>
<li><p>字段表作为一个表，同样有他自己的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p>字段表访问标识</p>
<ul>
<li><p>我们知道，一 个字段可以被各种关键字去修饰，比如：作用域修饰符(public、private、protected) 、static修饰符 、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字段名索引：根据字段名索引的值，查询常量池中的指定索引项即可。</p>
</li>
<li><p>描述符索引</p>
<ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型(byte, char, double, float，int，long, short , boolean)及代表无返回值的void类型都用一个大写字符来表示， 而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>属性表集合</p>
<ul>
<li><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p>
</li>
<li><p>例子：以常量属性为例，结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对于常量属性而言，attribute_length值恒为2。</p>
<p>根据上面的例子，我们来实际分析一下，如下图：</p>
<p><img src="/2021/04/19/JVM/FA74699C-FC7C-4A8D-AAA9-989BDD67D75A.png" alt="img"> </p>
</li>
</ul>
</li>
</ul>
<h5 id="8、07-方法表集合"><a href="#8、07-方法表集合" class="headerlink" title="8、07-方法表集合"></a>8、07-方法表集合</h5><h6 id="1、方法表集合"><a href="#1、方法表集合" class="headerlink" title="1、方法表集合"></a>1、方法表集合</h6><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，<strong>每一个method_info项都对应着个类或者接口中的方法信息</strong>。比如方法的访问修饰符(public、private或protected)，方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</li>
<li>一方面，<strong>methods表</strong>只描述当前类或接口中声明的方法，<strong>不包括从父类或父接口继承的方法</strong>。另一方面，methods表<strong>有可能会出现由编译器自动添加的方法</strong>，最典型的便是编译器产生的方法信息(比如：<strong>类(接口)初始化方法<clinit>()**和</clinit></strong>实例初始化方法<init>()**)。</init></li>
</ul>
<p>使用注意事项：</p>
<ul>
<li><strong>在Java语言中</strong>，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为<strong>返回值不会包含在特征签名之中</strong>，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。</li>
<li>但在Class文件格式中， 特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</li>
<li>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，<strong>字节码文件</strong>中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是<strong>这些方法之间的返回值不能相同</strong>。</li>
</ul>
<h6 id="2、methods-count-方法计数器"><a href="#2、methods-count-方法计数器" class="headerlink" title="2、methods_ count(方法计数器)"></a>2、methods_ count(方法计数器)</h6><ul>
<li>methods_count的值表示当前class文件methods表的成员个数。<strong>使用两个字节来表示</strong>。</li>
<li>methods表中每个成员都是一个method_info结构</li>
</ul>
<h6 id="3、methods-方法表"><a href="#3、methods-方法表" class="headerlink" title="3、methods [] (方法表)"></a>3、methods [] (方法表)</h6><ul>
<li><p>methods表中的每个成员都必须是一个method_info结构， 用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志，也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p>
</li>
<li><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
</li>
<li><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p>方法表访问标志</p>
<ul>
<li><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="9、08-属性表集合"><a href="#9、08-属性表集合" class="headerlink" title="9、08-属性表集合"></a>9、08-属性表集合</h5><h6 id="1、属性表集合-attributes"><a href="#1、属性表集合-attributes" class="headerlink" title="1、属性表集合(attributes)"></a>1、属性表集合(attributes)</h6><ul>
<li>方法表集合之后的属性表集合，<strong>指的是class 文件所携带的辅助信息</strong>，比如该class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，<strong>一般无须深入了解</strong>。</li>
<li>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</li>
<li>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且<strong>只要不与已有的属性名重复</strong>，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但<strong>Java虛拟机运行时会忽略掉它不认识的属性</strong>。</li>
</ul>
<h6 id="2、attributes-count-属性计数器"><a href="#2、attributes-count-属性计数器" class="headerlink" title="2、attributes_ count(属性计数器)"></a>2、attributes_ count(属性计数器)</h6><ul>
<li>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是个attribute_info结构。</li>
</ul>
<h6 id="3、attributes-属性表"><a href="#3、attributes-属性表" class="headerlink" title="3、attributes [] ( 属性表)"></a>3、attributes [] ( 属性表)</h6><ul>
<li><p>属性表的每个项的值必须是attribute_ info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
</li>
<li><p>属性的通用格式：（即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
</li>
<li><p>属性类型：</p>
<p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性,这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性.供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>Sourcefile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类，方法，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynamic指令引用的引导方式限定符</td>
</tr>
</tbody></table>
<p>或者（查看官网）：</p>
<p><img src="/2021/04/19/JVM/53F23FBD-4E40-40C7-BC77-5E3E90AC27A1.png" alt="img"> </p>
</li>
<li><p>部分属性详解</p>
<ol>
<li><p>ConstantValue 属性：</p>
<p>ConstantValue 属性表示一个常量字段的值。位于field_info结构的属性表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;&#x2F;&#x2F;字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。</span><br><span class="line">						   &#x2F;&#x2F;（例如，值是1ong型的， 在常量池中便是CONSTANT_ Long )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Deprecated 属性：</p>
<p>Deprecated属性是在JDK 1.1为了支持注释中的关键词@deprecated而引入的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">	u2 attribute name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Code 属性：</p>
<p>Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。</p>
<p>Code属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attribute_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attribute_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code属性表的前两项跟属性表是-致的，即Code属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
</li>
<li><p>InnerClasses 属性：</p>
<ul>
<li>为了方便说明特别定义一个表示类或接口的Class格式为C。如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的InnerClasses属性。</li>
<li>InnerClasses属性是在JDK 1.1中为了支持内部类和内部接口而引入的，位于ClassFile结构的属性表。</li>
</ul>
</li>
<li><p>LineNumberTable 属性：</p>
<ul>
<li><p>LineNumberTable属性是可选变长属性，位于Code结构的属性表。</p>
</li>
<li><p>LineNumberTable属性是用来<strong>描述Java源码行号与字节码行号之间的对应关系</strong>。这个属性可以用来在调试的时候定位代码执行的行数。</p>
<ul>
<li><strong>start_pc，即字节码行号；</strong></li>
<li><strong>line_number，即Java源代码行号。</strong></li>
</ul>
</li>
<li><p>在Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容， 即LineNumberTable 属性不需要与源文件的行一对应。</p>
</li>
<li><p>LineNumberTable属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute&#123;</span><br><span class="line">	u2 attribute_name_index:</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 line_number_table_length;</span><br><span class="line">	&#123;</span><br><span class="line">		u2 start_pc;</span><br><span class="line">		u2 line_number;</span><br><span class="line">	&#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LocalVariableTable 属性：</p>
<ul>
<li><p>LocalVariableTable 是可选变长属性，位于Code属性的属性表中。它被调试器<strong>用于确定方法在执行过程中局部变量的信息</strong>。</p>
</li>
<li><p>在Code属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。</p>
</li>
<li><p>Code属性中的每个局部变量最多只能有一个LocalVariableTable 属性。</p>
<ul>
<li><strong>startpc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置(this生命周期从头0到结尾10)</strong></li>
<li><strong>index就是这个变量在局部变量表中的槽位(槽位可复用)</strong></li>
<li><strong>name就是变量名称</strong></li>
<li><strong>Descriptor表示局部变量类型描述</strong></li>
</ul>
</li>
<li><p>LocalVariableTable属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 local_variable_table_length;</span><br><span class="line">	&#123;</span><br><span class="line">		u2 start_pc;</span><br><span class="line">		u2 length;</span><br><span class="line">		u2 name_index;</span><br><span class="line">		u2 descriptor_index;</span><br><span class="line">		u2 index;</span><br><span class="line">	&#125; local_variable_table[local_variable_table_length] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Signature 属性</p>
<ul>
<li>Signature属性是可选的定长属性，位于ClassFile，field_info或method_info结构的属性表中。</li>
<li>在Java语言中，任何类、接口、 初始化方法或成员的泛型签名如果包含了类型变量(Type Variables) 或参数化类型 ( Parameterized Types) ，则Signature 属性会为它记录泛型签名信息。</li>
</ul>
</li>
<li><p>SourceFile 属性</p>
<ul>
<li><p>SourceFile属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>sourcefile_index</td>
<td>1</td>
<td>源码文件索引</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是<strong>固定的8个字节</strong>。</p>
</li>
</ul>
</li>
<li><p>其他属性：</p>
<ul>
<li>Java虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="10、class字节码文件总结"><a href="#10、class字节码文件总结" class="headerlink" title="10、class字节码文件总结"></a>10、class字节码文件总结</h5><ul>
<li>主要介绍了Class文件的基本格式。</li>
<li>随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整。</li>
<li>从Java虚拟机的角度看，通过Class文件，可以让更多的计算机语言支持Java虚拟机平台。因此，Class文件结构不仅仅是Java虛拟机的执行入口，更是Java生态圈的基础和核心。</li>
</ul>
<h4 id="4、使用javap指令解析Class文件"><a href="#4、使用javap指令解析Class文件" class="headerlink" title="4、使用javap指令解析Class文件"></a>4、使用javap指令解析Class文件</h4><h5 id="1、解析字节码的作用"><a href="#1、解析字节码的作用" class="headerlink" title="1、解析字节码的作用"></a>1、解析字节码的作用</h5><ul>
<li>自己分析类文件结构太麻烦了! oracle提供了javap工具。</li>
<li>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(汇编指令)、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。</li>
<li>通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。</li>
<li>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</li>
</ul>
<h5 id="2、javac-g操作"><a href="#2、javac-g操作" class="headerlink" title="2、javac -g操作"></a>2、javac -g操作</h5><ul>
<li>解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用javac编译成class文件时，指定参数才能输出。</li>
<li>比如，你直接javac xx. java, 就不会在生成对应的局部变量表等信息，如果你使用**<code>javac -g xx.java</code>**就可以生成所有相关信息了。如果你使用的eclipse或IDEA，则默认情况下，eclipse、 IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</li>
</ul>
<h5 id="3、javap的用法"><a href="#3、javap的用法" class="headerlink" title="3、javap的用法"></a>3、javap的用法</h5><ul>
<li><p>javap的用法格式：javap <options> <classes></classes></options></p>
<ul>
<li>其中，options就是需要输入的参数选项</li>
<li>classes就是你要反编译的class文件。</li>
</ul>
</li>
<li><p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：</p>
<p><img src="/2021/04/19/JVM/image-20210520022957097.png" alt="image-20210520022957097"></p>
</li>
<li><p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 五大字段：private、默认、public、protected、final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        info = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两种构造方法：无参(public)与有参(private)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JavapTest</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四大方法：private、默认、public、protected</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(info + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里重组一下：</p>
<ul>
<li><p>-help / –help / -?：输出此用法消息</p>
</li>
<li><p>-version：版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的。（即javap -version == javap -version xx.class）</p>
<p><img src="/2021/04/19/JVM/image-20210520023638002.png" alt="image-20210520023638002"></p>
<p>以上的options与相关class文件无关，为javap本身的options</p>
</li>
<li><p>-public：仅显示公共类和成员</p>
<p><img src="/2021/04/19/JVM/image-20210520023707476.png" alt="image-20210520023707476"></p>
</li>
<li><p>-protected：显示受保护的/公共类和成员</p>
<p><img src="/2021/04/19/JVM/image-20210520024314713.png" alt="image-20210520024314713"></p>
</li>
<li><p><strong>-p / -private：显示所有类和成员</strong></p>
<p><img src="/2021/04/19/JVM/image-20210520024520373.png" alt="image-20210520024520373"></p>
</li>
<li><p>package：显示程序包/受保护的/公共类和成员(默认)</p>
<p><img src="/2021/04/19/JVM/image-20210520024729855.png" alt="image-20210520024729855"></p>
</li>
<li><p>-sysinfo：显示正在处理的类的系统信息(路径，大小，日期，MD5散列，源文件名)</p>
<p><img src="/2021/04/19/JVM/image-20210520024834421.png" alt="image-20210520024834421"></p>
</li>
<li><p>constants：显示静态最终常量</p>
<p><img src="/2021/04/19/JVM/image-20210520025014700.png" alt="image-20210520025014700"></p>
</li>
<li><p>以下options与代码的细节相关：</p>
</li>
<li><p>-s：输出内部类型签名</p>
<p><img src="/2021/04/19/JVM/image-20210520030031188.png" alt="image-20210520030031188"></p>
</li>
<li><p>-l：输出行号和本地变量表</p>
<p><img src="/2021/04/19/JVM/image-20210520030243299.png" alt="image-20210520030243299"></p>
<p>注意：<strong>如果使用的是javac xx. java编译生成的class字节码文件，里面本来就没有本地变量表。因此就是使用-l也看不到本地变量表的信息。</strong></p>
</li>
<li><p>-c：对代码进行反汇编</p>
<p><img src="/2021/04/19/JVM/image-20210520031140075.png" alt="image-20210520031140075"></p>
</li>
<li><p><strong>-v / -verbose：输出附加信息(包括行号、本地变量表，反汇编等详细信息)</strong></p>
<ul>
<li><p>注意：就算-v也依旧没有私有private的信息。如果需要加上私有private的信息，得到一份最全的信息，就需要加上-p：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p JavapTest.class</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以下很少用到，了解即可。</p>
</li>
<li><p>-classpath <path></path>：指定查找用户类文件的位置</p>
</li>
<li><p>-cp <path></path>：指定查找用户类文件的位置</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li><strong>一般常用的是-v、-l、-c三个选项</strong>：（<strong>重要的还是-v和-p</strong>）<ul>
<li>javap -l：会输出行号和本地变量表信息。</li>
<li>javap -c：会对当前class字节码进行反编译生成汇编代码。</li>
<li>javap -v classxx：除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><ol>
<li>通过javap命令可以查看一个java类反汇编得到的Class文件版本号、常量池、访问标识、变量表、指令代码行号表等等信息。<strong>不显示类索引、父类索引、接口索引集合、<clinit>()、 <init>()等结构</init></clinit></strong>。其中<clinit>()、 <init>()这两个是因为javap太智能，帮我们反编译成了相关的构造方法和静态代码块，在class字节码文件依旧可以看到这两个结构。</init></clinit></li>
<li>通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：<ol>
<li>java栈中：局部变量表、操作数栈。</li>
<li>java堆：通过对象的地址引用去操作。</li>
<li>常量池。</li>
<li>其他如帧数据区（方法返回地址、动态链接、一些附加信息）、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</li>
</ol>
</li>
<li>平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">官方文档查看每个指令</a>的含义。</li>
</ol>
<hr>
<h3 id="2、字节码指令集与解析举例"><a href="#2、字节码指令集与解析举例" class="headerlink" title="2、字节码指令集与解析举例"></a>2、字节码指令集与解析举例</h3><h4 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h4><ul>
<li>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li>
<li>Java虚拟机的指令由<strong>一个字节长度</strong>的、代表着某种特定操作含义的数字(称为**<code>操作码，Opcode</code><strong>) 以及跟随其后的零至多个代表此操作所需参数(称为</strong><code>操作数，Operands</code>**) 而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节(即0~255)，这意味着<strong>指令集的操作码总数不可能超过256条</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">官方文档</a></li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<h5 id="1、执行模型"><a href="#1、执行模型" class="headerlink" title="1、执行模型"></a>1、执行模型</h5><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	自动计算PC寄存器的值加1;</span><br><span class="line">	根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">	if(字节码存在操作数)从字节码流中取出操作数;</span><br><span class="line">	执行操作码所定义的操作;</span><br><span class="line">&#125;while(字节码长度&gt;0);</span><br></pre></td></tr></table></figure>

<h5 id="2、字节码与数据类型"><a href="#2、字节码与数据类型" class="headerlink" title="2、字节码与数据类型"></a>2、字节码与数据类型</h5><ul>
<li>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</li>
<li>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：<ul>
<li>i代表对int类型的数据操作</li>
<li>l代表long</li>
<li>s代表short</li>
<li>b代表byte</li>
<li>c代表char</li>
<li>f代表float</li>
<li>d代表double</li>
<li>Boolean使用的是iconst_0或者iconst1</li>
<li>a代表对象</li>
</ul>
</li>
<li>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如arraylength指令， 它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</li>
<li>还有另外一些指令，如无条件跳转指令goto则是<strong>与数据类型无关的</strong>。</li>
<li>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend) 为相应的int类型数据，将boolean和char类型数据零位扩展(Zero-Extend) 为相应的int类型数据。</li>
<li>与之类似，在处理<strong>boolean、byte、 short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理</strong>。因此，大多数对于boolean、 byte、 short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</li>
</ul>
<h5 id="3、指令分析"><a href="#3、指令分析" class="headerlink" title="3、指令分析"></a>3、指令分析</h5><ul>
<li>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
</li>
<li>(说在前面)在做值相关操作时：<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据(可能是值可能是对象的引用)被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值(pop多次)，完成赋值、加减乘除、方法传参、系统调用等等操作。</li>
</ul>
</li>
</ul>
<h4 id="2、加载与存储指令"><a href="#2、加载与存储指令" class="headerlink" title="2、加载与存储指令"></a>2、加载与存储指令</h4><ul>
<li>作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。<ul>
<li>其中数据压入操作数栈被称为加载</li>
<li>此时的数据可能来源于局部变量表，也有可能来自于常量池（分成具体的两个类指令）</li>
<li>把数据保存在局部变量表当中则被称为存储指令</li>
</ul>
</li>
<li>常用指令<ol>
<li>[<strong>局部变量压栈指令</strong>]将一个局部变量加载到操作数栈：xload、xload_<n> (其中x为i、l、f、d、a，n为0到3（不一定都是0~3，需要具体分析）)（<strong>load</strong>）</n></li>
<li>[<strong>常量入栈指令</strong>]将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_W、ldc2_W、aconst_null、iconst_ m1、iconst_ <i>、lconst_ <l>、fconst_ <f>、 dconst_ <d>。（<strong>push、ldc、const</strong>）</d></f></l></i></li>
<li>[<strong>出栈装入局部变量表指令</strong>]将一个数值从操作数栈存储到局部变量表：xstore、xstore_ <n> (其中x为i、l、f、d、a，n为0到3)；xastore ( 其中x为i、l、f、d、a、b、c、s)（<strong>store</strong>）</n></li>
<li>扩充局部变量表的访问索引的指令：wide。</li>
</ol>
</li>
<li>上面所列举的指令助记符中，有一部分是以尖括号结尾的 (例如iload_ <n>)。这些指令助记符实际上代表了一组指令(例如 iload_ <n>代表了iload_0、iload_1、iload_2和iload_3这几个指令) 。这几组指令都是某个带有一个操作数的通用指令(例如iload)的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中</strong>。<ul>
<li>比如：</li>
<li>iload_0：将局部变量表中索引为0位置上的数据压入操作数栈中。（占一个字节）</li>
<li>iload 0：将局部变量表中索引为0位置上的数据压入操作数栈中。（占三个字节）</li>
<li>iload 4：将局部变量表中索引为4位置上的数据压入操作数栈中。（占三个字节）</li>
<li>作用：节约空间，减少内存占用</li>
</ul>
</n></n></li>
<li>除此之外，它们的语义与原生的通用指令完全一致(例如iload_0的语义与操作数为0时的iload指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数， <i>代表是int类型数据，<l>代表1ong类型，<f>代表float类型， <d>代表double类型。</d></f></l></i></n></li>
<li>操作byte、char、short 和boolean类型数据时，经常用int类型的指令来表示。</li>
</ul>
<h5 id="0、复习：再谈操作数栈与局部变量表"><a href="#0、复习：再谈操作数栈与局部变量表" class="headerlink" title="0、复习：再谈操作数栈与局部变量表"></a>0、复习：再谈操作数栈与局部变量表</h5><h6 id="1、操作数栈-Operand-Stacks"><a href="#1、操作数栈-Operand-Stacks" class="headerlink" title="1、操作数栈(Operand Stacks )"></a>1、操作数栈(Operand Stacks )</h6><p>我们知道，Java字节码是Java虛拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟块额外的空间作为<strong>操作数栈</strong>， 来<strong>存放计算的操作数以及返回结果</strong>。</p>
<p>具体来说便是：<strong>执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中</strong>。</p>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210520222930557.png" alt="image-20210520222930557"></p>
<p>以加法指令iadd 为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int, 并将求得的和int值3压入栈中。</p>
<p><img src="/2021/04/19/JVM/image-20210520222944844.png" alt="image-20210520222944844"></p>
<p>由于iadd指令只消耗栈项的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<h6 id="2、局部变量表-Local-Variables"><a href="#2、局部变量表-Local-Variables" class="headerlink" title="2、局部变量表(Local Variables)"></a>2、局部变量表(Local Variables)</h6><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，<strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong>。</p>
<p>实际上，Java虚拟机将局部变量区<strong>当成一个数组</strong>，依次存放this指针(仅非静态方法) ，所传入的参数， 以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。一个槽位就是一个单元，占4个字节。</p>
<p><img src="/2021/04/19/JVM/image-20210520223454201.png" alt="image-20210520223454201"></p>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> <span class="number">1</span>, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello, World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的图示：(槽位复用)</p>
<p><img src="/2021/04/19/JVM/image-20210520223508191.png" alt="image-20210520223508191"></p>
<h5 id="1、局部变量压栈指令"><a href="#1、局部变量压栈指令" class="headerlink" title="1、局部变量压栈指令"></a>1、局部变量压栈指令</h5><p><strong>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈</strong>。</p>
<p>这类指令大体可以分为：</p>
<ul>
<li>xload_ <n> (x为i、l、f、d、a，n为0到3)</n></li>
<li>xload (x为i、l、f、d、a)</li>
</ul>
<p>说明：在这里，x的取值表示数据类型。</p>
<p>指令xload_ n表示将第n个局部变量压入操作数栈，比如iload_1、 fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。此时该字节码指令占用一个字节（包含一个操作码，一个字节）</p>
<p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。此时该字节码指令占用三个字节（包含一个操作码，一个字节、一个操作数，两个字节）</p>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量压栈指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj,<span class="keyword">long</span> count,<span class="keyword">boolean</span> flag,<span class="keyword">short</span>[] arr)</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令执行过程：</p>
<p><img src="/2021/04/19/JVM/image-20210520224306556.png" alt="image-20210520224306556"></p>
<h5 id="2、常量入栈指令"><a href="#2、常量入栈指令" class="headerlink" title="2、常量入栈指令"></a>2、常量入栈指令</h5><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为<strong>const系列</strong>、<strong>push系列</strong>和<strong>ldc指令</strong>。</p>
<p><strong>指令const系列</strong>：用于对特定的常量入栈，入栈的常量隐含在指令本身里。</p>
<p>指令有: <code>iconst_ &lt;i&gt; (i从-1到5)</code>、<code>lconst_ &lt;l&gt; (l从0到1)</code>、<code>fconst_ &lt;f&gt; (f从0到2)</code>、<code>dconst_ &lt;d&gt; (d从0到1)</code>、<code>aconst_null</code>。</p>
<p>比如：</p>
<ul>
<li>iconst_m1将-1压入操作数栈；</li>
<li>iconst_x (x为0到5)将x压入栈；</li>
<li>lconst_0、lconst_1分别将长整数0和1压入栈；</li>
<li>fconst_0、fconst_1、 fconst_2分别将浮点数0、1、2压入栈；</li>
<li>dconst_0和dconst_1分别将double型0和1压入栈；</li>
<li>aconst_null将null压入操作数栈；</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，<code>i表示整数</code>，<code>l表示长整数</code>，<code>f表示浮点数</code>，<code>d表示双精度浮点</code>，习惯上用<code>a表示对象引用</code>。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p><strong>指令push系列</strong>：主要包括bipush和sipush。 它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<p><strong>指令ldc系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的<strong>索引</strong>，将指定的内容压入堆栈。</p>
<p>类似的还有<code>ldc_w</code>，它接收两个8位参数，能支持的索引范围大于ldc。</p>
<p>如果要压入的元素是long或者double类型的，则使用<code>ldc2_w</code>指令，使用方式都是类似的。</p>
<p>总结如下：</p>
<p><img src="/2021/04/19/JVM/image-20210520234851493.png" alt="image-20210520234851493"></p>
<p>举例分析：</p>
<p><img src="/2021/04/19/JVM/566B9397-5AFE-4A3F-9E17-9EBF504DFC80.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/B59702D2-4C93-44DF-87F1-01A5DFE53B61.png" alt="img"></p>
<p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，<strong>常量入栈的n代表数值或者对象，而不是局部变量表中的下标</strong></p>
<h5 id="3、出栈入局部变量表指令"><a href="#3、出栈入局部变量表指令" class="headerlink" title="3、出栈入局部变量表指令"></a>3、出栈入局部变量表指令</h5><p><strong>出栈装入局部变量表指令</strong>用于<strong>将操作数栈中栈项元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</strong>。</p>
<p>这类指令主要以<code>store</code>的形式存在，比如xstore(x为i、l、f、d、a)、xstore_n(x为i、l、f、d、a，n为0至3)。</p>
<ul>
<li>其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量<strong>索引n的位置</strong>。</li>
<li>指令xstore由于没有隐含参数信息，故需要提供一个<strong>byte类型的参数类</strong>指定目标局部变量表的位置。</li>
</ul>
<p>说明：</p>
<p><strong>一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置</strong>。 但是，为了尽可能<strong>压缩指令大小</strong>，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、 istore_3,它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此<strong>这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积</strong>。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p>举例分析：</p>
<p><img src="/2021/04/19/JVM/image-20210521000606437.png" alt="image-20210521000606437"></p>
<p>相关分析：</p>
<ol>
<li>首先该方法被调用的时候，形式参数k和d都是有确定的值，由于该方法不是静态方法，所以局部变量表中的第一个位置（槽位）存储this，而第二个位置存储k<strong>具体的值</strong>，由于老师只是分析，没有调用这个方法，所以老师全部使用的<strong>变量名称来代替具体的值</strong>，所以明白就好。</li>
<li>然后第三个和第四个位置储存d具体的值，由于d是double类型，所以需要占据两个槽位，数据已经准备好了，那就来看字节码<ol>
<li>首先iload_1是将局部变量表中下标为1的k值取出来压入操作数栈中</li>
<li>然后iconst_2是将常量池中的整型值2压入操作数栈，iadd让操作数栈弹出的k值和整型值2执行相加操作</li>
<li>之后将相加的结果值m压入操作数栈中，请注意老师的画法，在执行弹栈和压栈操作之后，老师并没有删除操作数栈中的k值和2，这是因为老师让我们知道具体的操作过程，所以故意为之，不过真正的操作是弹栈之后k值和2就会从操作数栈中弹出，之后操作数栈中就没有k值和2了，只有m值了</li>
</ol>
</li>
<li>然后istore_4是将操作数栈中的m值弹出栈，然后放在局部变量表中下标为4的位置</li>
<li>idc2_w #13代表将long型值12压入操作数栈，istore5是将值12弹栈之后放入局部变量表中下标为5的位置，由于12是long型，所以占据两个位置（槽位）</li>
<li>ldc #15代表将字符串atguigu压入操作数栈，astore 7代表将字符串atguigu弹栈之后放入局部变量表中下标为7的位置</li>
<li>idc #16代表将float类型数据10.0压入操作数栈，fstore 8代表将10.0弹出栈，然后放入局部变量表中下标为8的位置</li>
<li>idc2_w #17代表将10.0压入操作数栈，dstore2代表将10.0弹出栈，之后将10.0放入下标为2和3的操作，毕竟这是double类型数据。</li>
</ol>
<p><strong>槽位复用</strong>：</p>
<p><img src="/2021/04/19/JVM/DD6CCB19-DEDB-426F-815A-A5769ED22E62-1621527103113.png" alt="img"></p>
<p>注意：<strong>在方法没有运行的时候，根据字节码文件就可以计算出需要几个槽位</strong>。</p>
<h4 id="3、算术指令"><a href="#3、算术指令" class="headerlink" title="3、算术指令"></a>3、算术指令</h4><ol>
<li><p><strong>作用</strong>：算术指令用于对<strong>两个操作数栈上的值</strong>进行某种特定运算，并<strong>把结果重新压入操作数栈</strong>。</p>
</li>
<li><p><strong>分类</strong>：</p>
<ul>
<li>大体上算术指令可以分为两种：<ul>
<li>对<strong>整型数据</strong>进行运算的指令</li>
<li>对<strong>浮点类型数据</strong>进行运算的指令</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>byte、short、char和boolean类型说明：</strong></p>
<p>在每一大类中， 都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，<strong>都使用int类型的指令来处理</strong>。此外，在<strong>处理boolean、byte、 short 和char类型的数组</strong>时，也会<strong>转换为使用对应的int类型的字节码指令</strong>来处理。</p>
<p><img src="/2021/04/19/JVM/image-20210521002838645.png" alt="image-20210521002838645"></p>
</li>
<li><p><strong>运算时的溢出</strong>：<br>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有<strong>除法指令以及求余指令中当出现除数为0</strong>时会导致虚拟机抛出异常<code>ArithmeticException</code>。</p>
</li>
<li><p><strong>运算模式：</strong></p>
<ul>
<li>向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近， 将优先选择最低有效位为零的；（四舍五入）</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。（截断法）</li>
</ul>
</li>
<li><p><strong>NaN值使用：</strong></p>
<p>当一个操作产生溢出时，将会使用有符号的无穷大（<code>Infinity</code>）表示，如果某个操作结果没有明确的数学定义的话，将会使用<code>NaN</code>值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p>
<p>对于无穷大Infinity和NaN的举例：</p>
<p><img src="/2021/04/19/JVM/83FDD717-E615-45C8-B2E2-31C5CEB2BA4E.png" alt="img"></p>
<h5 id="1、所有算术指令"><a href="#1、所有算术指令" class="headerlink" title="1、所有算术指令"></a>1、所有算术指令</h5><p>所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem       //remainder:余数</li>
<li>取反指令：ineg、lneg、fneg、dneg       //negation:取反</li>
<li>自增指令：iinc</li>
<li>位运算指令， 又可分为：<ul>
<li>位移指令：ishl、 ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp </li>
</ul>
</li>
</ol>
<p>相关举例的分析：</p>
<ul>
<li><p>对于 i = i + 10 与 i += 10 的区别：（假设i = 100）</p>
<ul>
<li><p>i = i + 10：</p>
<p><img src="/2021/04/19/JVM/image-20210521004835960.png" alt="image-20210521004835960"></p>
</li>
<li><p>i += 10：</p>
<p><img src="/2021/04/19/JVM/image-20210521005146519.png" alt="image-20210521005146519"></p>
</li>
</ul>
<p>结论：</p>
<ul>
<li>若i一开始为byte类型，与10相加之后转换为int类型；自增10之后编译不报错</li>
<li>如果short i = 10，那么i+=10不是在原位置上加10，而是进行了强转，其中用到了i2s</li>
</ul>
</li>
<li><p>JVM取反（~）操作的具体实现过程：（用<strong>异或</strong>实现）</p>
<ul>
<li>先取出操作数压入操作数栈</li>
<li>在将-1压入操作数栈（iconst_m1）</li>
<li><strong>将操作数与-1实现异或（xor）操作</strong></li>
<li>得到的操作数取反后的值在压入操作数栈</li>
</ul>
</li>
</ul>
<h6 id="1、举例"><a href="#1、举例" class="headerlink" title="1、举例"></a>1、举例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令对应的图示：</p>
<p><img src="/2021/04/19/JVM/A54C2AC8-DD36-49F4-A49D-9AFD725E8365.png" alt="img"></p>
<h6 id="2、一个曾经的案例"><a href="#2、一个曾经的案例" class="headerlink" title="2、一个曾经的案例"></a>2、一个曾经的案例</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> a = x / y;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码对应的内存解析：（省略了前面的解析，主要看一下println()方法：返回值为void）</p>
<p><img src="/2021/04/19/JVM/C43C0407-020F-4EC4-BD27-E4C109640B39.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/04282DF1-4E52-4C3D-A47B-84023159B624.png" alt="img"></p>
<p>注意：</p>
<ul>
<li>执行System.out.printin()的时候，会在虚拟机栈当中新建一个System.out.printin方法栈帧，55作为参数传入println()方法当中；</li>
<li>println()方法栈帧的本地变量表中会放55，这样该方法就可以使用了。</li>
<li>println()方法执行结束之后，由于返回值为void，所以字节码指令直接return</li>
<li>进入main方法栈帧之后，也直接执行return。</li>
</ul>
<h6 id="3、关于i-与-i"><a href="#3、关于i-与-i" class="headerlink" title="3、关于i++与++i"></a>3、关于i++与++i</h6><p>在<strong>没有其他操作</strong>（如赋值）的情况下，i++与++i是一样的，没有区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于(前)++和(后)++</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="comment">//++i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：<img src="/2021/04/19/JVM/image-20210521011319549.png" alt="image-20210521011319549"></p>
<p>与其他运算符(赋值运算符)结合运算的情况下，i++与++i就有区别了：</p>
<ul>
<li>i++：先赋值后自增</li>
<li>++i：先自增后赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<p><img src="/2021/04/19/JVM/image-20210521014725284.png" alt="image-20210521014725284"></p>
<p>与println()方法结合的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    System.out.println(i);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<p><img src="/2021/04/19/JVM/image-20210521020635532.png" alt="image-20210521020635532"></p>
<h5 id="2、比较指令的说明"><a href="#2、比较指令的说明" class="headerlink" title="2、比较指令的说明"></a>2、比较指令的说明</h5><ul>
<li><strong>比较指令</strong>的作用是<strong>比较栈顶两个元素的大小，并将比较结果入栈</strong>。</li>
<li><strong>比较指令有：dcmpg, dcmpl、 fcmpg、 fcmpl、 lcmp</strong>。<ul>
<li>与前面讲解的指令类似，首字符d表示double类型， f表示float , l表示long。</li>
</ul>
</li>
<li>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</li>
<li>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</li>
<li>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。</li>
</ul>
<p>举例：</p>
<ul>
<li>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1<ul>
<li>若v1 = v2，则压入0；</li>
<li>若v1 &gt; v2，则压入1；</li>
<li>若v1 &lt; v2，则压入-1</li>
</ul>
</li>
<li>两个指令的不同之处在于，如果遇到NaN值，<strong>fcmpg会压入1</strong>，而<strong>fcmpl会压入-1</strong>。</li>
</ul>
<p><strong>数值类型的数据，才可以谈大小</strong>! boolean、引用数据类型不能比较大小。</p>
<p>注意：</p>
<ul>
<li>NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，<strong>只有double和float类型中可能出现NaN的情况</strong>，而<strong>long类型不会出现NaN</strong>，所以只有<strong>lcmp</strong>。</li>
<li>为什么只存在long/float/double的比较指令，而没有char/byte/short/int类型的比较指令？<ul>
<li>仔细观察会发现long/float/double的比较指令的最后都会往操作数栈压入一个int类型的值（-1/1/0），而比较指令常常与跳转指令一起使用</li>
<li>而两种指令是通过int类型的值结合在一起使用的</li>
<li>所以也就不必要存在int等类型的比较指令</li>
<li>如果说是有int类型的比较指令的话就是比较条件跳转指令了</li>
</ul>
</li>
</ul>
<h4 id="4、类型转换指令"><a href="#4、类型转换指令" class="headerlink" title="4、类型转换指令"></a>4、类型转换指令</h4><p>类型转换指令说明：</p>
<ol>
<li><strong>类型转换指令</strong>可以<strong>将两种不同的数值类型进行相互转换</strong>。</li>
<li>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理<strong>字节码指令集中数据类型相关指令无法与数据类型一一对应</strong>的问题。</li>
</ol>
<h5 id="1、宽化类型转换-Widening-Numeric-Conversions"><a href="#1、宽化类型转换-Widening-Numeric-Conversions" class="headerlink" title="1、宽化类型转换(Widening Numeric Conversions)"></a>1、宽化类型转换(Widening Numeric Conversions)</h5><h6 id="1、转换规则"><a href="#1、转换规则" class="headerlink" title="1、转换规则"></a>1、转换规则</h6><p>Java虚拟机直接支持以下数值的宽化类型转换(widening numeric conversion，小范围类型向大范围类型的安全转换)。也就是说，并不需要指令执行，包括：</p>
<ul>
<li>从int类型到long、float或者double类型。对应的指令为：<code>i2l</code>、<code>i2f</code>、<code>i2d</code></li>
<li>从long类型到float、double类型。对应的指令为：<code>l2f</code>、<code>l2d</code></li>
<li>从float类型到double类型。对应的指令为：<code>f2d</code></li>
</ul>
<p>简化为：int –&gt; long –&gt; float –&gt; double</p>
<h6 id="2、精度损失问题"><a href="#2、精度损失问题" class="headerlink" title="2、精度损失问题"></a>2、精度损失问题</h6><ul>
<li>宽化类型转换是<strong>不会因为超过目标类型最大值而丢失信息</strong>的，例如，从int转换到long，或者从int转换到double，都不会丢失任何信息，<strong>转换前后的值是精确相等</strong>的。</li>
<li>从<strong>int、long类型数值转换到float</strong>，或者<strong>long类型数值转换到double</strong>时，将可能发生精度丢失——可能<strong>丢失掉几个最低有效位上的值</strong>，转换后的浮点数值是根据IEEE754最接近舍入模式所得到的正确整数值。</li>
</ul>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是<strong>这种转换永远不会导致Java虚拟机抛出运行时异常</strong>。</p>
<h6 id="3、补充说明"><a href="#3、补充说明" class="headerlink" title="3、补充说明"></a>3、补充说明</h6><ul>
<li>从<strong>byte、char 和short类型到int类型的宽化类型转换实际上是不存在</strong>的。对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将byte转为long时，使用的是<code>i2l</code>,可以看到<strong>在内部byte在这里已经等同于int类型处理</strong>，类似的还有short类型，这种处理方式有两个特点：<ul>
<li>一方面可以减少实际的数据类型，如果为short和byte都准备一套指令，那么指令的数量就会大增，而<strong>虛拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中</strong>。</li>
<li>另一方面，由于<strong>局部变量表中的槽位固定为32位（4个字节，也是int的长度）</strong>，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</li>
</ul>
</li>
</ul>
<h5 id="2、窄化类型转换-Narrowing-Numeric-Conversion"><a href="#2、窄化类型转换-Narrowing-Numeric-Conversion" class="headerlink" title="2、窄化类型转换(Narrowing Numeric Conversion)"></a>2、窄化类型转换(Narrowing Numeric Conversion)</h5><h6 id="1、转换规则-1"><a href="#1、转换规则-1" class="headerlink" title="1、转换规则"></a>1、转换规则</h6><p>Java虚拟机也直接支持以下<strong>窄化类型转换</strong>：</p>
<ul>
<li>从int类型至byte、short或者char类型。对应的指令有：<code>i2b</code>、<code>i2c</code>、<code>i2s</code></li>
<li>从long类型到int类型。对应的指令有：<code>l2i</code></li>
<li>从float类型到int或者long类型。对应的指令有：<code>f2i</code>、<code>f2l</code></li>
<li>从double类型到int、long或者float类型。 对应的指令有：<code>d2i</code>、<code>d2l</code>、 <code>d2f</code></li>
</ul>
<p>注意：<strong>从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型。</strong></p>
<h6 id="2、精度损失问题-1"><a href="#2、精度损失问题-1" class="headerlink" title="2、精度损失问题"></a>2、精度损失问题</h6><ul>
<li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，<strong>转换过程很可能会导致数值丢失精度</strong>。</li>
<li>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是<strong>Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</strong>。</li>
</ul>
<h6 id="3、补充说明-1"><a href="#3、补充说明-1" class="headerlink" title="3、补充说明"></a>3、补充说明</h6><ol>
<li>当将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：<ul>
<li>如果<strong>浮点值是NaN</strong>，那转换结果就是<strong>int或long类型的0</strong>。</li>
<li>如果<strong>浮点值不是无穷大</strong>的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果<strong>v在目标类型T(int或long)的表示范围之内，那转换结果就是v</strong>。否则，将<strong>根据v的符号，转换为T所能表示的最大或者最小正数</strong>。</li>
</ul>
</li>
<li>当将一个double类型窄化转换为float类型时，将遵循以下转换规则：<ul>
<li>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：<ul>
<li>如果<strong>转换结果的绝对值太小而无法使用float来表示</strong>， 将<strong>返回float类型的正负零</strong>。</li>
<li>如果<strong>转换结果的绝对值太大而无法使用float来表示</strong>，将<strong>返回float类型的正负无穷大</strong>。</li>
<li><strong>对于double类型的NaN值将按规定转换为float类型的NaN值。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1 = Double.NaN; <span class="comment">//0.0 / 0.0</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)d1;</span><br><span class="line">    System.out.println(d1); <span class="comment">// NaN</span></span><br><span class="line">    System.out.println(i); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d2 = Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>)d2;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>)d2;</span><br><span class="line">    System.out.println(l); <span class="comment">// 9223372036854775807</span></span><br><span class="line">    System.out.println(Long.MAX_VALUE); <span class="comment">// 92233720368547 75807</span></span><br><span class="line">    System.out.println(j); <span class="comment">// 2147483647</span></span><br><span class="line">    System.out.println(Integer.MAX_VALUE); <span class="comment">// 2147483647</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = (<span class="keyword">float</span>)d2;</span><br><span class="line">    System.out.println(f); <span class="comment">// infinity</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)d1;</span><br><span class="line">    System.out.println(f1); <span class="comment">// NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、对象的创建与访问指令"><a href="#5、对象的创建与访问指令" class="headerlink" title="5、对象的创建与访问指令"></a>5、对象的创建与访问指令</h4><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为<strong>创建指令</strong>、<strong>字段访问指令</strong>、<strong>数组操作指令</strong>、<strong>类型检查指令</strong>。</p>
<h5 id="1、创建指令"><a href="#1、创建指令" class="headerlink" title="1、创建指令"></a>1、创建指令</h5><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<ol>
<li><p>创建类实例的指令：</p>
<ul>
<li><p><strong>创建类实例的指令：new</strong></p>
<ul>
<li>它<strong>接收一个操作数，为指向常量池的索引</strong>，表示要创建的类型，执行完成后，<strong>将对象的引用压入栈</strong>。</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521031608842.png" alt="image-20210521031608842"></p>
</li>
</ul>
</li>
<li><p>创建数组的指令：</p>
<ul>
<li><p><strong>创建数组的指令：newarray、 anewarray、 multianewarray</strong></p>
<ul>
<li>newarray：创建<strong>基本类型数组</strong></li>
<li>anewarray：创建<strong>引用类型数组</strong></li>
<li>multianewarray：创建<strong>多维数组</strong></li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521032029716.png" alt="image-20210521032029716"></p>
</li>
</ul>
</li>
</ol>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</p>
<h5 id="2、字段访问指令"><a href="#2、字段访问指令" class="headerlink" title="2、字段访问指令"></a>2、字段访问指令</h5><p>对象创建后，就可以通过对象访问指令获取<strong>对象实例</strong>或<strong>数组实例</strong>中的<strong>字段或者数组元素</strong>。</p>
<ul>
<li><strong>访问类字段(static字段，或者称为类变量)的指令</strong>：<code>getstatic</code>、 <code>putstatic</code></li>
<li><strong>访问类实例字段(非static字段，或者称为实例变量)的指令</strong>：<code>getfield</code>、 <code>putfield</code></li>
</ul>
<p>举例1：<br>以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #8 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">3 ldc #9 &lt;hello&gt;</span><br><span class="line">5 invokevirtual #10 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210521033428524.png" alt="image-20210521033428524"></p>
<p>举例2：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.id = <span class="number">1001</span>;</span><br><span class="line">    System.out.println(order.id);</span><br><span class="line"></span><br><span class="line">    Order.name = <span class="string">&quot;ORDER&quot;</span>;</span><br><span class="line">    System.out.println(Order.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">static</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令执行过程：</p>
<p><img src="/2021/04/19/JVM/image-20210521034806188.png" alt="image-20210521034806188"></p>
<p> 注意：<strong>getxxx是入栈，而putxxx是出栈</strong></p>
<h5 id="3、数组操作指令"><a href="#3、数组操作指令" class="headerlink" title="3、数组操作指令"></a>3、数组操作指令</h5><h6 id="1、数组操作指令"><a href="#1、数组操作指令" class="headerlink" title="1、数组操作指令"></a>1、数组操作指令</h6><p>数组操作指令主要有：<code>xastore</code>和<code>xaload</code>指令。具体为：</p>
<ul>
<li>把<strong>一个数组元素加载到操作数栈的指令</strong>：<code>baload</code>、<code>caload</code>、<code>saload</code>、<code>iaload</code>、<code>laload</code>、<code>faload</code>、<code>daload</code>、<code>aaload</code></li>
<li>将<strong>一个操作数栈的值存储到数组元素中的指令</strong>：<code>bastore</code>、<code>castore</code>、<code>sastore</code>、<code>iastore</code>、 <code>lastore</code>、<code>fastore</code>、<code>dastore</code>、<code>aastore</code></li>
</ul>
<p>即：</p>
<p><img src="/2021/04/19/JVM/image-20210521171308285.png" alt="image-20210521171308285"></p>
<ul>
<li><strong>取数组长度的指令</strong>：<code>arraylength</code><ul>
<li>该指令<strong>弹出栈顶的数组元素，获取数组的长度，将长度压入栈</strong>。</li>
</ul>
</li>
</ul>
<h6 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h6><ul>
<li><p>一个操作数栈的值存储到数组元素中的指令，即xastore指令与xstore指令的区别：</p>
<ul>
<li>xstore指令是将值存放进<strong>局部变量表</strong>里面</li>
<li>xastore指令是将值存放进<strong>堆空间</strong>中对应的数组元素里面</li>
</ul>
</li>
<li><p>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入栈。</p>
</li>
<li><p>xastore则专门针对数组操作，以iastore为例， 它用于给一个int数组的给定索引赋值。在iastore执行 ，操作数栈顶需要以此准备3个元素：</p>
<ul>
<li>值</li>
<li>索引</li>
<li>数组引用</li>
</ul>
<p>iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</p>
<p><img src="/2021/04/19/JVM/image-20210521171926923.png" alt="image-20210521171926923"></p>
</li>
</ul>
<h5 id="4、类型检查指令"><a href="#4、类型检查指令" class="headerlink" title="4、类型检查指令"></a>4、类型检查指令</h5><p>检查类实例或数组类型的指令：<code>instanceof</code>、 <code>checkcast</code></p>
<ul>
<li>指令<code>checkcast</code>用于<strong>检查类型强制转换是否可以进行</strong>。如果可以进行，那么checkcast指令不会改变操作数栈，否则<strong>它会抛出<code>ClassCastException</code>异常</strong>。</li>
<li>指令<code>instanceof</code>用来<strong>判断给定对象是否是某一个类的实例</strong>，它会将<strong>判断结果压入操作数栈</strong>。</li>
</ul>
<h4 id="6、方法调用与返回指令"><a href="#6、方法调用与返回指令" class="headerlink" title="6、方法调用与返回指令"></a>6、方法调用与返回指令</h4><h5 id="1、方法调用指令"><a href="#1、方法调用指令" class="headerlink" title="1、方法调用指令"></a>1、方法调用指令</h5><p>方法调用指令：<code>invokevirtual</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokedynamic</code></p>
<p>以下5条指令用于方法调用：</p>
<ul>
<li><code>invokevirtual</code>指令用于<strong>调用对象的实例方法</strong>，<strong>根据对象的实际类型进行分派(虚方法分派)，支持多态</strong>。（<strong>可被子类重写</strong>）这也是Java语言中最常见的方法分派方式。<ul>
<li>invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</li>
</ul>
</li>
<li><code>invokeinterface</code>指令用于<strong>调用接口方法</strong>，它会<strong>在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用</strong>。<ul>
<li>invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</li>
</ul>
</li>
<li><code>invokespecial</code>指令用于<strong>调用一些需要特殊处理的实例方法</strong>，包括<strong>实例初始化方法(构造器)**、</strong>私有方法<strong>和</strong>父类方法<strong>。这些方法都是</strong>静态类型绑定的<strong>，</strong>不会在调用时进行动态派发<strong>。（</strong>不能被子类重写**）<ul>
<li>invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了。</li>
</ul>
</li>
<li><code>invokestatic</code>指令用于<strong>调用命名类中的类方法(static方法)。这是静态绑定的</strong>。<ul>
<li>invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</li>
</ul>
</li>
<li><code>invokedynamic</code>：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于<strong>在运行时动态解析出调用点限定符所引用的方法，并执行该方法</strong>。前面4条调用指令的分派逻辑都固化在java虚拟机内部，而invokedynamic指令的分派逻辑是<strong>由用户所设定的引导方法决定</strong>的。具体可看博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wade-luffy/p/6058087.html">关于invokedynamic</a></li>
</ul>
<p>注意：</p>
<ul>
<li>当一个方法既是私有方法，又是静态方法。使用的是invokestatic指令</li>
<li>关于在接口当中的静态方法与默认方法<ul>
<li>静态方法：使用的是invokestatic指令</li>
<li>默认方法：使用的是invokeinterface指令</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>除了static的接口的方法都是invokeinterface，如果是static那么都是invokestatic。</li>
<li>用static修饰的方法都是使用invokestatic</li>
<li>如果是用多态的话使用的是invokevirtual</li>
<li>如果是强转成接口类型的方法使用的是invokeinterface</li>
</ul>
<h5 id="2、方法返回指令"><a href="#2、方法返回指令" class="headerlink" title="2、方法返回指令"></a>2、方法返回指令</h5><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的：</p>
<ul>
<li>包括<code>ireturn</code> (当返回值是boolean、 byte、char、short和int类型时使用)、<code>lreturn</code>、 <code>freturn</code>、<code>dreturn</code>和<code>areturn</code></li>
<li>另外还有一条<code>return</code>指令供<strong>声明为void的方法</strong>、实<strong>例初始化方法以及类和接口的类初始化方法</strong>使用。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210521200452707.png" alt="image-20210521200452707"></p>
<p>说明：</p>
<ul>
<li>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中(因为调用者非常关心函数的返回值)，<strong>所有在当前函数操作数栈中的其他元素都会被丢弃</strong>。</li>
<li><strong>如果当前返回的是synchronized方法，那么还会执行一个隐含的<code>monitorexit</code>指令，退出临界区（解锁的作用）</strong>。最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</li>
<li>当返回的变量与返回值不是同一个基本数据类型的话，会有一个<strong>使用类型转换指令</strong>的过程。</li>
</ul>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodReturn</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span>(i+j)/k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210521200909546.png" alt="image-20210521200909546"></p>
<h4 id="7、操作数栈管理指令"><a href="#7、操作数栈管理指令" class="headerlink" title="7、操作数栈管理指令"></a>7、操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop</code>, <code>pop2</code>；</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈项：<code>dup</code>, <code>dup2</code>, <code>dup_x1</code>，<code>dup2_x1</code>, <code>dup_x2</code>, <code>dup2_x2</code>;</li>
<li>将<strong>栈最顶端的两个Slot数值位置交换</strong>：<code>swap</code>。<ul>
<li>Java虛拟机没有提供交换两个64位数据类型(long、double) 数值的指令。</li>
</ul>
</li>
<li>指令<code>nop</code>，是一个非常特殊的指令，它的<strong>字节码为0x00</strong>。和汇编语言中的nop一样，它表示什么都不做。这条指令<strong>一般可用于调试、占位</strong>等。</li>
</ul>
<p><strong>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型</strong>。</p>
<p>说明：</p>
<ul>
<li>不带_x的指令是<strong>复制栈顶数据并压入栈顶</strong>。包括两个指令，<code>dup</code>和<code>dup2</code>。<ul>
<li>dup的系数代表要复制的Slot个数。</li>
<li>dup开头的指令用于复制1个Slot的数据。<ul>
<li>例如1个int或1个reference类型数据</li>
</ul>
</li>
<li>dup2开头的指令用于复制2个Slot的数据。 <ul>
<li>例如1个long，或2个int，或1个int+1个float类型数据</li>
</ul>
</li>
</ul>
</li>
<li>带_ x的指令是<strong>复制栈顶数据并<code>插入</code>栈顶以下的某个位置</strong>。共有4个指令，<code>dup_x1</code>，<code>dup2_x1</code>，<code>dup_x2</code>，<code>dup2_x2</code>。<ul>
<li>对于带x的复制插入指令，只要将指令的<strong>dup和x的系数相加</strong>，结果即为需要插入的位置。因此：<ul>
<li>dup_x1插入位置：1+1=2， 即栈顶2个Slot下面</li>
<li>dup_x2插入位置：1+2=3， 即栈顶3个Slot下面</li>
<li>dup2_x1插入位置：2+1=3， 即栈顶3个Slot下面</li>
<li>dup2_x2插入位置：2+2=4， 即栈顶4个Slot下面</li>
</ul>
</li>
</ul>
</li>
<li><code>pop</code>：将栈项的1个Slot数值出栈。例如1个short类型数值</li>
<li><code>pop2</code>：将栈顶的2个Slot数值出栈。例如1个double类型数值，或者2个int类型数值</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521223947568.png" alt="image-20210521223947568"></p>
<h4 id="8、控制转义指令"><a href="#8、控制转义指令" class="headerlink" title="8、控制转义指令"></a>8、控制转义指令</h4><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为：</p>
<ol>
<li>比较指令（在算术指令那里）</li>
<li>条件跳转指令</li>
<li>比较条件跳转指令</li>
<li>多条件分支跳转指令</li>
<li>无条件跳转指令等。</li>
</ol>
<h5 id="1、条件跳转指令"><a href="#1、条件跳转指令" class="headerlink" title="1、条件跳转指令"></a>1、条件跳转指令</h5><p>条件跳转指令通常和<strong>比较指令</strong>结合使用。在条件跳转指令执行前。一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：<code>ifeq</code>，<code>iflt</code>，<code>ifle</code>，<code>ifne</code>，<code>ifgt</code>，<code>ifge</code>, <code>ifnull</code>, <code>ifnonnull</code>。</p>
<p>这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<p>它们的统一含义为：<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置</strong>。</p>
<p>具体说明：</p>
<p><img src="/2021/04/19/JVM/image-20210521230336692.png" alt="image-20210521230336692"></p>
<p>注意：</p>
<ol>
<li>与前面运算规则一致：<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是<strong>使用int类型</strong>的比较指令完成</li>
<li><strong>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</strong></li>
</ul>
</li>
<li>由于<strong>各类型的比较最终都会转为int类型的比较操作</strong>，所以<strong>Java虚拟机提供的int类型的条件分支指令是最为丰富和强大</strong>的。</li>
</ol>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521232741411.png" alt="image-20210521232741411"></p>
<p>注意：</p>
<ol>
<li>对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型。</li>
<li>int类型值（包含byte、char、short）比较和对象类型值比较需要使用<strong>比较条件跳转指令</strong>。</li>
<li>在比较当中，<strong>跳转指令的选择与代码里面的条件判断恰好相反</strong>。<ul>
<li>如题当中代码比较的是f1 &lt; f2，而字节码当中却使用了<code>ifge指令</code>（f1 &gt;= f2）</li>
<li>原因是该指令是<strong>跳转指令</strong>：也就是当满足条件才跳转，不满足的话就只是顺序执行。所以与代码执行顺序相反（代码是满足条件就顺序执行，不满足才跳转到相应的执行语句）</li>
</ul>
</li>
</ol>
<h5 id="2、比较条件跳转指令"><a href="#2、比较条件跳转指令" class="headerlink" title="2、比较条件跳转指令"></a>2、比较条件跳转指令</h5><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、（之前的都是与int相关的比较条件跳转指令）<code>if_acmpeq</code>和<code>if_acmpne</code>。其中指令助记符加上”if”后，以字符”i”开头的指令针对int型整数操作(也包括short和byte类型)， 以字符”a”开头的指令表示对象引用的比较。</p>
<p>具体说明：</p>
<p><img src="/2021/04/19/JVM/image-20210521234455626.png" alt="image-20210521234455626"></p>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。<br>指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。<strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句</strong>。</p>
<p>注意：</p>
<ul>
<li>上面所说的后者是栈顶元素，而前者是栈顶下面的元素</li>
<li>对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成。</li>
<li>而int类型值（包含byte、char、short）比较和对象类型值比较需要使用比较条件跳转指令，</li>
<li>其中对象类型值不是<strong>比较的地址</strong>，就是<strong>比较对象中的某些字段值</strong>，这又归咎到float、double、long、int类型的比较中比较条件跳转指令。</li>
</ul>
<h5 id="3、多条件分支跳转"><a href="#3、多条件分支跳转" class="headerlink" title="3、多条件分支跳转"></a>3、多条件分支跳转</h5><p>多条件分支跳转指令是专为switch-case语句设计的，主要有<code>tableswitch</code>和<code>lookupswitch</code>。</p>
<p><img src="/2021/04/19/JVM/image-20210522000649232.png" alt="image-20210522000649232"></p>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li><code>tableswitch</code>要求<strong>多个条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此<strong>效率比较高</strong>。</li>
<li><code>lookupswitch</code>内部<strong>存放着各个离散的case-offset对</strong>，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，<strong>因此效率较低</strong>。</li>
</ul>
<p><strong>指令tableswitch：</strong></p>
<p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<p><img src="/2021/04/19/JVM/image-20210522001143999.png" alt="image-20210522001143999"></p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/image-20210522002407044.png" alt="image-20210522002407044"></p>
<p>注意：<strong>代码的break语句对应的就是字节码指令里的goto指令</strong>，无条件跳转到return处。如果代码没有加上break语句的话就会发生switch穿透，其实对应到字节码指令就是缺少goto指令跳转到return，只能往下顺序执行。</p>
<p><strong>指令lookupswitch：</strong></p>
<p>指令lookupswitch处理的是离散的case值，但是出于效率考虑，<strong>将case-offset对按照case值大小排序</strong>，给定index时需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p>
<p><img src="/2021/04/19/JVM/image-20210522001304745.png" alt="image-20210522001304745"></p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/image-20210522003748294.png" alt="image-20210522003748294"></p>
<p><strong>关于String的switch语句</strong>：（使用的是指令lookupswitch和方法hashcode与equal）</p>
<p><img src="/2021/04/19/JVM/image-20210522004730384.png" alt="image-20210522004730384"></p>
<h5 id="4、无条件跳转"><a href="#4、无条件跳转" class="headerlink" title="4、无条件跳转"></a>4、无条件跳转</h5><p>目前主要的无条件跳转指令为<code>goto</code>。</p>
<ul>
<li>指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于<strong>指定指令的偏移量</strong>，指令执行的目的就是<strong>跳转到偏移量给定的位置处</strong>。</li>
<li>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令<code>goto_W</code>，它和goto有相同的作用，但是它<strong>接收4个字节的操作数</strong>，可以表示更大的地址范围。</li>
<li>指令<code>jsr</code>、<code>jsr_W</code>、<code>ret</code>虽然也是无条件跳转的，但<strong>主要用于<code>try-finally</code>语句</strong>，且<strong>已经被虚拟机逐渐废弃</strong>，故不在这里介绍这两个指令。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210522005055555.png" alt="image-20210522005055555"></p>
<p>举例：</p>
<p>通过<strong>goto指令与条件比较指令实现循环</strong>：</p>
<p><img src="/2021/04/19/JVM/image-20210522005743194.png" alt="image-20210522005743194"></p>
<p>注意：</p>
<ul>
<li>这里使用的i为int类型，在代码执行<code>i++</code>的时候，字节码指令使用的是<code>iinc 1 by 1</code>；直接在局部变量表里面加。</li>
<li>如果使用的i为double类型，在代码执行<code>i++</code>的时候，字节码使用的是 <code>dload_x</code> + <code>dconst_1</code> + <code>dadd</code> + <code>dastore_x</code> 的指令组合实现的，需要在操作数栈中相加。（注意这里dload_x与dastore_x当中的x是一样的）</li>
<li>如果使用的i为short类型，在代码执行<code>i++</code>的时候，字节码使用的是 <code>iload_x</code> + <code>iconst_1</code> + <code>iadd</code> + <code>i2s</code> + <code>istore_x</code> 的指令组合实现的，需要在操作数栈中相加，并且在相加之后还需要将值从int窄化为short类型，才能存进局部变量表当中。</li>
<li>所以<strong>用于循环遍历的变量尽量使用int，能增加系统的执行速度（调优）</strong></li>
</ul>
<h4 id="9、异常处理指令"><a href="#9、异常处理指令" class="headerlink" title="9、异常处理指令"></a>9、异常处理指令</h4><p>异常及异常的处理：<br>过程一：异常对象的生成过程 —&gt; throw (手动/自动) —&gt; 指令: athrow<br>过程二：异常的处理：抓抛模型。try-catch-finally —&gt;使用异常表</p>
<h5 id="1、抛出异常指令"><a href="#1、抛出异常指令" class="headerlink" title="1、抛出异常指令"></a>1、抛出异常指令</h5><ol>
<li><p><code>athrow</code>指令</p>
<ul>
<li>在Java程序中显示抛出异常的操作(throw语句)都是由athrow指令来实现。</li>
<li>除了使用throw语句显示抛出异常情况之外，<strong>JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出</strong>。<ul>
<li>例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在<code>idiv</code>或<code>ldiv</code>指令中抛出ArithmeticException异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<strong>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上</strong>。</li>
<li>如果使用<code>throw new 异常名称()</code>这种形式来抛出异常，那就会在代码中出现<code>athrow</code>指令，</li>
<li>而<code>在方法上面添加throw异常名称</code>这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions。</li>
</ul>
</li>
<li><p>举例：</p>
<ul>
<li><p>throw new 异常名称()：</p>
<p><img src="/2021/04/19/JVM/image-20210522014446997.png" alt="image-20210522014446997"></p>
</li>
<li><p>在方法上面添加throw异常名称：</p>
<p><img src="/2021/04/19/JVM/CB2FC208-C399-498F-A44E-60E015AAA9A8.png" alt="img"></p>
</li>
<li><p>运行时异常没有athrow：</p>
<p><img src="/2021/04/19/JVM/image-20210522014923019.png" alt="image-20210522014923019"></p>
</li>
</ul>
</li>
</ol>
<h5 id="2、异常处理与异常表"><a href="#2、异常处理与异常表" class="headerlink" title="2、异常处理与异常表"></a>2、异常处理与异常表</h5><ol>
<li>处理异常：<ul>
<li>在Java虚拟机中，<strong>处理异常(catch语句)**不是由字节码指令来实现的(早期使用jsr、ret指令)，而是</strong>采用异常表来完成的**。</li>
</ul>
</li>
<li>异常表：<ul>
<li>如果一个方法定义了一个<strong>try-catch</strong>或者<strong>try-finally</strong>的异常处理，就会创建一个异常表。它包含了<strong>每个异常处理或者finally块的信息</strong>。</li>
<li>异常表保存了每个异常处理信息。比如：<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。</li>
<li><strong>如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程</strong>。</li>
<li><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标。</li>
</ul>
<p>异常表如下所示：</p>
<p><img src="/2021/04/19/JVM/89118A6D-DA70-49FA-8E4C-703C21994488.png" alt="img"></p>
<p>异常表的含义是如果在Start PC和End PC之间（大于等于Start PC，小于End PC（左闭右开））出现对应的Catch Type异常问题（出现异常就匹配对应的异常），将会在操作数栈中压入相应的异常类对象，之后跳转到Handler PC的位置去执行对应的字节码指令。</p>
<p>注意：</p>
<p><strong>当异常出现的时候也会压入操作数栈，之后还会存储局部变量表中</strong></p>
<p>举例1：</p>
<p><img src="/2021/04/19/JVM/image-20210522020333543.png" alt="image-20210522020333543"></p>
<p>举例2：</p>
<p><img src="/2021/04/19/JVM/image-20210522021858220.png" alt="image-20210522021858220"></p>
<h4 id="10、同步控制指令"><a href="#10、同步控制指令" class="headerlink" title="10、同步控制指令"></a>10、同步控制指令</h4><p>组成：</p>
<ul>
<li>java虚拟机支持两种同步结构：<ul>
<li><strong>方法级的同步</strong></li>
<li><strong>方法内部一段指令序列的同步</strong></li>
</ul>
</li>
<li>这两种同步都是使用<code>monitor</code>来支持的。</li>
</ul>
<h5 id="1、方法级的同步-添加synchronized的方法"><a href="#1、方法级的同步-添加synchronized的方法" class="headerlink" title="1、方法级的同步(添加synchronized的方法)"></a>1、方法级的同步(添加synchronized的方法)</h5><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；</p>
<p>当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访 问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法。<strong>最后</strong>在方法完成(无论是正常完成还是非正常完成)时<strong>释放同步锁</strong>。</li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li>
<li>如果一个同步方法执行期间<strong>抛出了异常，并且在方法内部无法处理此异常</strong>，那这个同步方法所持有的<strong>锁将在异常抛到同步方法之外时自动释放</strong>。</li>
</ul>
<p>说明：</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，<strong>当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁</strong>，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会<strong>由虚拟机释放这个锁</strong>。因此，对于同步方法而言，<code>monitorenter</code>和<code>monitorexit</code>指令是<strong>隐式存在</strong>的，并未直接出现在字节码中。</p>
<p>举例：一个方法无论是否添加synchronized，你都无法在字节码中看出区别</p>
<p><img src="/2021/04/19/JVM/5CBBB95D-5AFB-4876-BF22-D846C36D942D.png" alt="img"></p>
<p>是否是同步方法在字节码文件中你是无法看出区别的，但是可以在<strong>方法访问标识</strong>中看出区别</p>
<h5 id="2、方法内部一段指令序列的同步"><a href="#2、方法内部一段指令序列的同步" class="headerlink" title="2、方法内部一段指令序列的同步"></a>2、方法内部一段指令序列的同步</h5><p>同步一段指令集序列：通常是由java中的synchronized语句块来表示的。jvm的指令集有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义。</p>
<ul>
<li>当一个线程进入同步代码块时，它使用<code>monitorenter</code>指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入</li>
<li>若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0,才会被允许进入同步块。</li>
<li>当线程退出同步块时，需要使用<code>monitorexit</code>声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</li>
<li>指令<code>monitorenter</code>和<code>monitorexit</code>在执行时，都需要<strong>在操作数栈项压入对象</strong>，之后<code>monitorenter</code>和<code>monitorexit</code>的锁定和释放都是针对这个对象的监视器进行的。</li>
</ul>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。</p>
<p><img src="/2021/04/19/JVM/image-20210522024144096.png" alt="image-20210522024144096"></p>
<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，<strong>编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常</strong>，它的目的就是用来<strong>执行monitorexit指令</strong>。</p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/EBE13A8E-3107-47D5-9296-C66C49553C0A.png" alt="img"></p>
<p>过程分析：</p>
<ol>
<li>操作数栈中的<strong>对象和<code>monitorenter</code>结合起来可以让线程获取锁</strong>，做法就是<strong>让对象的监视器标记从0变成1，这就代表该线程上锁了</strong>；</li>
<li>然后<strong>在操作数栈的<code>aload_1</code>和<code>monitorexit</code>结合起来就可以让线程解锁</strong>，做法就是<strong>让对象的监视器标记从1变成0</strong>；</li>
<li>这个<strong>解锁需要在方法退出之前完成</strong>，如果方法执行过程中出现了任何异常，将会跳到异常处理的字节码处执行相关代码；</li>
<li>如果异常处理的字节码部分出现了问题，那就<strong>重新执行异常处理的字节码</strong>。</li>
</ol>
<p>这些内容都在异常表中写的很明确，其中异常表也在上面截图中。</p>
<hr>
<h3 id="3、类的加载过程详解"><a href="#3、类的加载过程详解" class="headerlink" title="3、类的加载过程详解"></a>3、类的加载过程详解</h3><h4 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h4><p>类的加载过程详解：这里的类指的是Class。泛指java当中的<strong>类Class、接口Interface、注解类Annotation、枚举Enum</strong>等等。</p>
<p>在Java中数据类型分为基本数据类型和引用数据类型：</p>
<ul>
<li><strong>基本数据类型由虚拟机预先定义</strong></li>
<li><strong>引用数据类型则需要进行类的加载</strong></li>
</ul>
<p>按照Java虛拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="中篇_第3章：类的生命周期"></p>
<p>其中，<strong>验证、准备、解析3个部分统称为链接(Linking)</strong></p>
<p>注意：我们所说的<strong>加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</strong>。</p>
<p>从<strong>程序中类的使用过程</strong>看：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="中篇_第3章：类的加载过程"></p>
<h4 id="2、过程一：Loading（加载）阶段"><a href="#2、过程一：Loading（加载）阶段" class="headerlink" title="2、过程一：Loading（加载）阶段"></a>2、过程一：Loading（加载）阶段</h4><h5 id="1、加载完成的操作"><a href="#1、加载完成的操作" class="headerlink" title="1、加载完成的操作"></a>1、加载完成的操作</h5><h6 id="1、加载的理解"><a href="#1、加载的理解" class="headerlink" title="1、加载的理解"></a>1、加载的理解</h6><p><strong>所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象</strong>。 </p>
<p>所谓<strong>类模板对象</strong>，其实就是<strong>Java类在JVM内存中的一个快照</strong>，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>
<p><strong>反射的机制即基于这一基础</strong>。 如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>
<h6 id="2、加载完成的操作"><a href="#2、加载完成的操作" class="headerlink" title="2、加载完成的操作"></a>2、加载完成的操作</h6><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例</strong>。</p>
<p>在加载类时，Java虚拟机必须完成以下3件事情：</p>
<ul>
<li><strong>通过类的全名，获取类的二进制数据流</strong>。</li>
<li><strong>解析类的二进制数据流为方法区内的数据结构(Java类模型)</strong></li>
<li><strong>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</strong>。</li>
</ul>
<h5 id="2、二进制流的获取方式"><a href="#2、二进制流的获取方式" class="headerlink" title="2、二进制流的获取方式"></a>2、二进制流的获取方式</h5><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得：(只要所读取的字节码符合JVM规范即可)</p>
<ul>
<li>虚拟机可能通过<strong>文件系统读入一个class后缀的文件</strong>(<strong>最常见</strong>)</li>
<li><strong>读入jar、zip等归档数据包</strong>，提取类文件。</li>
<li>事先存放在<strong>数据库中的类</strong>的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载（序列化与反序列化）</li>
<li>在<strong>运行时生成</strong>段Class的二进制信息等</li>
</ul>
<p>在获取到类的二进制信息后，Java虛拟机就会处理这些数据，并最终转为一个<strong>java.lang.Class的实例</strong>。</p>
<p>如果输入数据不是ClassFile的结构， 则会抛出<code>ClassFormatError</code>。</p>
<h5 id="3、类模型与Class实例的位置"><a href="#3、类模型与Class实例的位置" class="headerlink" title="3、类模型与Class实例的位置"></a>3、类模型与Class实例的位置</h5><ol>
<li><p>类模型的位置：加载的类在JVM中创建相应的类结构，类结构会存储在<strong>方法区</strong>(JDK1.8之前：永久代；JDK1.8及之后：元空间)。</p>
</li>
<li><p>Class实例的位置：</p>
<ul>
<li>类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构；</li>
<li>该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。(instanceKlass –&gt; mirror：Class的实例）</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9AClass%E5%AE%9E%E4%BE%8B.jpg" alt="中篇_第3章：Class实例"></p>
</li>
<li><p>说明：</p>
<ul>
<li><strong>Class类的构造方法是私有的，只有JVM能够创建</strong>。</li>
<li>java.lang.Class实例是<strong>访问类型元数据的接口</strong>，也是<strong>实现反射的关键数据、入口</strong>。</li>
<li>通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构：方法、字段等信息。</li>
</ul>
</li>
</ol>
<h5 id="4、数组类的加载"><a href="#4、数组类的加载" class="headerlink" title="4、数组类的加载"></a>4、数组类的加载</h5><ul>
<li>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由<strong>JVM在运行时根据需要而直接创建的</strong>；</li>
<li>但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。</li>
<li>创建数组类(下述简称A)的过程：<ol>
<li>如果数组的元素类型是<strong>引用类型</strong>，那么就遵循<strong>定义的加载过程递归加载和创建数组A的元素类型</strong>；</li>
<li><strong>JVM使用指定的元素类型和数组维度来创建新的数组类</strong>。</li>
</ol>
</li>
<li>如果数组的元素类型是<strong>引用类型</strong>，数组类的可访问性就<strong>由元素类型的可访问性决定</strong>。否则数组类的可访问性将<strong>被缺省定义为public</strong>。</li>
</ul>
<h4 id="3、过程二：Linking（链接）阶段"><a href="#3、过程二：Linking（链接）阶段" class="headerlink" title="3、过程二：Linking（链接）阶段"></a>3、过程二：Linking（链接）阶段</h4><h5 id="1、环节1：链接阶段之Verification（验证）"><a href="#1、环节1：链接阶段之Verification（验证）" class="headerlink" title="1、环节1：链接阶段之Verification（验证）"></a>1、环节1：链接阶段之Verification（验证）</h5><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p>它的目的是<strong>保证加载的字节码是合法、合理并符合规范的</strong>。</p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E7%9A%84%E6%A3%80%E6%9F%A5.jpg" alt="中篇_第3章：验证阶段的检查"></p>
<p><strong>整体说明</strong>：验证的内容则涵盖了<strong>类数据信息的格式验证</strong>、<strong>语义检查</strong>、<strong>字节码验证</strong>，以及<strong>符号引用验证</strong>等。</p>
<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li>
</ul>
<p><strong>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查</strong>。(磨刀不误砍柴工)</p>
<p><strong>具体说明</strong>：</p>
<ol>
<li><p><strong>格式验证</strong>：</p>
<ul>
<li><strong>是否以魔数0xCAFEBABE开头</strong></li>
<li><strong>主版本和副版本号是否在当前Java虚拟机的支持范围内</strong></li>
<li>数<strong>据中每一个项是否都拥有正确的长度</strong>等。</li>
</ul>
</li>
<li><p>Java虚拟机会进行字节码的<strong>语义检查</strong>，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li><strong>是否所有的类都有父类的存在</strong>(在Java里， 除了object外， 其他类都应该有父类)</li>
<li><strong>是否一些被定义为final的方法或者类被重写或继承</strong>了</li>
<li><strong>非抽象类是否实现了所有抽象方法或者接口方法</strong></li>
<li><strong>是否存在不兼容的方法</strong>。比如：<ul>
<li>方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度</li>
<li>abstract情况下的方法，就不能是final的了</li>
</ul>
</li>
</ul>
</li>
<li><p>Java虚拟机还会进行<strong>字节码验证</strong>，字节码验证也是验证过程中<strong>最为复杂的一个过程</strong>。它试图通过对字节码流的分析，<strong>判断字节码是否可以被正确地执行</strong>。比如:</p>
<ul>
<li>在字节码的执行过程中，<strong>是否会跳转到一条不存在的指令</strong></li>
<li><strong>函数的调用是否传递了正确类型的参数</strong></li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p><strong>栈映射帧(StackMapTable)**就是在这个阶段，用于</strong>检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型<strong>。但遗憾的是，</strong>100%准确地判断一段字节码是否可以被安全执行是无法实现的<strong>，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虛拟机也不会正确装载这个类。但是，</strong>如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的<strong>。在前面3次检查中，已经排除</strong>子文件格式错误<strong>、</strong>语义错误<strong>以及</strong>字节码的不正确性<strong>。</strong>但是依然不能确保类是没有问题的**。</p>
<p><img src="/2021/04/19/JVM/image-20210522144342032.png" alt="image-20210522144342032"></p>
</li>
<li><p>校验器还将进行<strong>符号引用</strong>的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且<strong>当前类有权限访问这些数据</strong>，如果一个需要使用类无法在系统中找到，则会抛出<code>NoClassDefFoundError</code>,如果一个方法无法被找到，则会抛出<code>NoSuchMethodError</code>。<strong>此阶段在解析环节才会执行</strong>。</p>
</li>
</ol>
<h5 id="2、环节2：链接阶段之Preparation（准备）"><a href="#2、环节2：链接阶段之Preparation（准备）" class="headerlink" title="2、环节2：链接阶段之Preparation（准备）"></a>2、环节2：链接阶段之Preparation（准备）</h5><p>准备阶段(Preparation)，简言之，**为类的<code>静态变量</code>分配内存，并将其初始化为<code>默认值</code>**。</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，<strong>虚拟机就会为这个类分配相应的内存空间，并设置默认初始值</strong>。</p>
<p>Java虛拟机为各类型变量默认的初始值如表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，<strong>由于int的默认值是0，故对应的，boolean的默认值就是false</strong>。</p>
<p>注意：</p>
<ol>
<li>**这里不包含基本数据类型的字段用static final修饰（常量）的情况， 因为final在<code>编译</code>的时候就会分配了，<code>准备阶段会显式赋值</code>**。</li>
<li>注意这里<strong>不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而<strong>实例变量是会随着对象一起分配到Java堆中</strong>，会在使用类时候才会初始化。</li>
<li>在<strong>准备阶段并不会像初始化阶段中那样会有初始化或者代码被执行</strong>。</li>
</ol>
<p>对注意中的第1点与第3点分析：</p>
<ul>
<li>基本数据类型：<ul>
<li><strong>非final修饰的<code>变量</code>，在准备环节进行<code>默认初始化赋值</code>。</strong></li>
<li>**final修饰以后就是<code>常量</code>了，不能在进行赋值，所以在<code>编译阶段</code>会<code>初始化赋值</code>，然后在<code>准备阶段</code>就会<code>显示赋值</code>**。</li>
</ul>
</li>
<li>如果<strong>使用字面量的方式定义一个字符串的常量</strong>的话(public static final String constStr = “CONST”;)，也是在<code>编译阶段</code>会<code>初始化赋值</code>，然后在<code>准备阶段</code>就会<code>显示赋值</code>。</li>
<li><strong>引用数据类型的静态常量，尤其是new String(“XXX”)这种形式</strong>，如：public static final String constStr1 = new String(“CONST”);<strong>都是在初始化中的中进行显示赋值的</strong>（即在方法<clinit>当中进行初始化的显示赋值，是在初始化阶段使用代码<clinit>的方式才会进行的显示赋值，然而在准备阶段不会有代码的执行）</clinit></clinit></li>
<li>如果<strong>在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在<code>初始化中的方法&lt;clinit&gt;</code>中显示赋值</strong></li>
</ul>
<h5 id="3、环节3：链接阶段之Resolution（解析）"><a href="#3、环节3：链接阶段之Resolution（解析）" class="headerlink" title="3、环节3：链接阶段之Resolution（解析）"></a>3、环节3：链接阶段之Resolution（解析）</h5><p>在准备阶段完成后，就进入了解析阶段。</p>
<p>解析阶段(Resolution)，简言之：<strong>将类、接口、字段和方法的符号引用转为直接引用</strong>。</p>
<p><strong>具体描述</strong>：</p>
<p><strong>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关</strong>。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：输出操作System.out.println()对应的字节码：invokevirtual #24 &lt;java/io/PrintStream. println&gt;</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.jpg" alt="中篇_第3章：输出语句的符号引用"></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p>
<p><strong>小结</strong>：</p>
<p>所谓<strong>解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量</strong>。因此，可以说，如果<strong>直接引用存在，那么可以肯定系统中存在该类、方法或者字段</strong>。但<strong>只存在符号引用，不能确定系统中一定存在该结构</strong>。</p>
<p>不过Java虚拟机规范并<strong>没有明确要求解析阶段一定要按照顺序执行</strong>。在HotSpotVM中，<strong>加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>。</p>
<p><strong>字符串的复习</strong>：</p>
<p>最后，再来看一下CONSTANT_ String的解析。 由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下。</p>
<p>String在Java虚拟机中的处理。<strong>当在Java代码中直接使用字符串常量时，就会在类中出现CONSTANT_String</strong>，它表示字符串常量，并且会引用一个CONSTANT_UTF8的常量项。<strong>在Java虚拟机内部运行中的常量池中，会维护一张字符串拘留表(intern)，它会保存所有出现过的字符串常量，并且没有重复项</strong>。只要以CONSTANT_String形式出现的字符串也都会在这张表中。使用String.intern()方法可以得到一个字符串在拘留表中的引用，<strong>因为该表中没有重复项，所以任何字面相同的字符串的String.intern()方法返回总是相等的</strong>。</p>
<h4 id="4、过程三：Initialization（初始化）阶段"><a href="#4、过程三：Initialization（初始化）阶段" class="headerlink" title="4、过程三：Initialization（初始化）阶段"></a>4、过程三：Initialization（初始化）阶段</h4><p>初始化阶段，简言之：<strong>为类的<code>静态变量</code>赋于正确的初始值（显示赋值）</strong>。</p>
<p><strong>具体描述：</strong></p>
<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即: <strong>到了初始化阶段，才真正开始执行类中定义的Java 程序代码</strong>。)</p>
<p>初始化阶段的重要工作是<strong>执行类的初始化方法：<clinit>()方法</clinit></strong>：</p>
<ul>
<li>该方法<strong>仅能由Java编译器生成并由JVM调用</strong>， 程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是由**<code>类静态成员的赋值语句</code>以及<code>static语句块</code>合并产生的**。</li>
</ul>
<p><strong>说明</strong>：</p>
<ol>
<li><p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类<clinit>之前被调用。也就是说，<strong>父类的static块优先级高于子类</strong>。口诀：<strong>由父及子，静态先行</strong></clinit></clinit></p>
</li>
<li><p>Java编译器并不会为所有的类都产生<clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<clinit>()方法：</clinit></clinit></p>
<ul>
<li><p><strong>一个类中并没有声明任何的类变量，也没有静态代码块时</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中<strong>声明类变量</strong>，但是没<strong>有明确使用类变量的初始化语句以及静态代码块来执行初始化操作</strong>时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中<strong>包含static final修饰的基本数据类型的字段</strong>，这些类字段初始化语句采用编译时常量表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h5 id="1、static与final的搭配问题（显示初始化问题）"><a href="#1、static与final的搭配问题（显示初始化问题）" class="headerlink" title="1、static与final的搭配问题（显示初始化问题）"></a>1、static与final的搭配问题（显示初始化问题）</h5><p>问题研究：使用<code>static + final</code>修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p>
<ul>
<li>情况1：在链接阶段的准备环节赋值</li>
<li>情况2：在初始化阶段<clinit>()中赋值</clinit></li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初步结论：</p>
<ul>
<li>在链接阶段的准备环节赋值的情况：<ul>
<li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法进行动态赋值）通常是在链接阶段的准备环节进行</li>
<li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li>
</ul>
</li>
<li>在初始化阶段<clinit>()中赋值的情况：<ul>
<li>排除上述的在准备环节赋值的情况之外的情况。</li>
</ul>
</clinit></li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结论：</p>
<ul>
<li>在链接阶段的准备环节赋值的情况：<ul>
<li>使用<code>static+final</code>修饰，并且<strong>进行显示赋值（定义的时候后面就已经附了确定的初始值）</strong>，还<strong>不涉及到<code>方法</code>或者<code>构造器调用</code>的基本数据类型或者<code>String类型字面量</code></strong>(“XXX”这种形式，而不是new String(“XXX”)这种形式)<strong>的字段</strong>，将在准备中的链接阶段进行显示赋值</li>
<li>对于<strong>准备阶段就完成赋值</strong>的，**其字段下面的有属性<code>ConstantValue</code>**，在初始化阶段<clinit>()中赋值的字段是没有属性ConstantValue的。</clinit></li>
</ul>
</li>
<li>在初始化阶段<clinit>()中赋值的情况：<ul>
<li>已经进行显示赋值的<strong>静态常量</strong>（<code>static+final</code>修饰）（<strong>包括引用类型，尤其是new String(“XXX”)这种类型的，还有调用其他方法获得的值，比如new Random().nextInt(10)等</strong>）或者<strong>静态变量</strong>（这是肯定在初始化方法中显示赋值）<strong>都将在初始化中的方法中进行显示赋值</strong></li>
</ul>
</clinit></li>
<li><strong>使用<code>static + final</code>修饰，且显示赋值中不涉及到<code>方法</code>或<code>构造器调用的基本数据类型</code>或<code>String类型的显式赋值</code>，是在链接阶段的准备环节进行。</strong></li>
</ul>
<p>补充：</p>
<ol>
<li>换个角度思考下，只有<strong>在常量池中已经确定的值，才会在链接中的准备阶段赋值</strong>，像对象在常量池存储的一般都是符号引用，而并非是对象，仅仅是描述对象一个字符串，真正的对象还需通过字节码进行new，这一new不就得用类构造方法，不就得需要在初始化阶段<clinit>()中赋值了吗</clinit></li>
<li>计算中1/0，即<code>public static final int INT_CONSTANT = 1/0</code>，也不能在链接阶段的准备环节赋值，因为它会要抛异常，<strong>需要使用到代码</strong></li>
<li>这里说的能够用常量池中数据表示是按照结果论，所以2/2这种的结果是一个int值可以表示</li>
<li>而new String(“”)是个特例，<strong>String的引用是可以在常量池中表示的，但是new String是在初始化阶段赋值</strong>的</li>
<li>也不能单纯看是不是字面量，如果是<code>static final Integer a = 1</code>,也是在初始化阶段<clinit>()中赋值，只能说<strong>能尽量能在准备阶段赋值的就在准备阶段，实在不行才在初始化阶段<clinit>()中赋值</clinit></strong></clinit></li>
<li>另外一个角度：在链接阶段的准备环节赋值是不能动用代码的，因为真正开始执行类中定义的Java 程序代码是在到了初始化阶段才开始的。因此：<strong>可以在不使用java代码就能进行显示赋值的就在链接阶段的准备环节进行赋值，而赋值需要java代码参与的就只能在初始化阶段<clinit>()中进行显示赋值</clinit></strong>。</li>
</ol>
<h5 id="2、-的线程安全性"><a href="#2、-的线程安全性" class="headerlink" title="2、()的线程安全性"></a>2、<client>()的线程安全性</client></h5><ul>
<li><p>对于<clinit>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p>
</li>
<li><p>正是因为<strong>函数<clinit>( )带锁线程安全的</clinit></strong>，因此，如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且<strong>这种死锁是很难发现的，因为看起来它们并没有可用的锁信息</strong>。</clinit></p>
<ul>
<li><p>函数<clinit>( )带的锁是隐式的锁，并不是使用sychronized进行加锁的。</clinit></p>
<p><img src="/2021/04/19/JVM/image-20210522204628093.png" alt="image-20210522204628093"></p>
</li>
</ul>
</li>
<li><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>()方法了。那么，当<strong>需要使用这个类时虚拟机会直接返回给它已经准备好的信息</strong>。（<strong>一个类只需要加载一次</strong>）</clinit></p>
</li>
</ul>
<p>死锁的相关代码：（<strong>使用两个进程让A、B交叉加载</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.StaticB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticA init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.StaticA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticB init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDeadLockMain</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDeadLockMain</span><span class="params">(<span class="keyword">char</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;Thread&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.Static&quot;</span> + flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StaticDeadLockMain loadA = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        loadA.start();</span><br><span class="line">        StaticDeadLockMain loadB = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        loadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此得出结论：</p>
<ul>
<li>编写代码的时候要尽量<strong>避免让类进行交叉加载或循环加载/依赖</strong>。</li>
</ul>
<h5 id="3、类的初始化情况：主动使用vs被动使用"><a href="#3、类的初始化情况：主动使用vs被动使用" class="headerlink" title="3、类的初始化情况：主动使用vs被动使用"></a>3、类的初始化情况：主动使用vs被动使用</h5><p>Java程序对类的使用分为两种：</p>
<ul>
<li>主动使用（调用了<clinit>()方法）</clinit></li>
<li>被动使用（没有调用了<clinit>()方法）</clinit></li>
</ul>
<p>注意：<strong>没有调用了<clinit>()方法只是没有进入初始化阶段，并不代表该类没有加载</clinit></strong></p>
<h6 id="1、主动使用"><a href="#1、主动使用" class="headerlink" title="1、主动使用"></a>1、主动使用</h6><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：(即: 如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。)</p>
<ol>
<li><p>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用new关键字</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列化的过程：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列化的过程：（验证）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Order order = (Order) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当调用类的静态方法时，即当使用了字节码<code>invokestatic</code>指令。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Order.method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。( 对应访问变量武值变量操作)</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(User.num); // User类的初始化过程 </span></span><br><span class="line"><span class="comment">//        System.out.println(User.num1); // 1</span></span><br><span class="line">        System.out.println(User.num2); <span class="comment">// User类的初始化过程 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(CompareA.NUM1); // 1</span></span><br><span class="line">        System.out.println(CompareA.NUM2); <span class="comment">// CompareA的初始化 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">1</span>; <span class="comment">// 在链接阶段的准备环节赋值,不需要调用&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过一个静态内部方法展示有没有JVM调用&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareA的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="number">1</span>; <span class="comment">// 在链接阶段的准备环节赋值,不需要调用&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”);</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.atguigu.java1.Order&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其实在加载Father类之前，JVM还会加载Father的父类java.lang.Object。但是这里不好展示。可以通过JVM参数<code>-XX:+TraceClassLoading</code>可以追踪类的加载信息并打印出来。在当中可以看到JVM有先加载java.lang.Object。</p>
</li>
<li><p>关于采用Junit进行测试时JVM参数的设置：</p>
<p><img src="/2021/04/19/JVM/E899EC31-01FB-484E-9894-40E777C0B08A.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// CompareB的初始化</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Son还被其他类继承的话，当Son的子类初始化的时候，对应的Son，CompareB，Father也会被初始化。</p>
</li>
</ul>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveUse3的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">// hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。( 涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)</p>
</li>
</ol>
<p>针对5，补充说明：</p>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li><p>在初始化一个类时，并<strong>不会先初始化它所实现的接口</strong></p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虽然接口CompareB没有初始化，但是它已经被加载进JVM当中了</strong>。</p>
</li>
</ul>
</li>
<li><p>在初始化一个接口时，并<strong>不会先初始化它的父接口</strong></p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// CompareC的初始化</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    System.out.println(CompareC.NUM1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareC</span> <span class="keyword">extends</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareC的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>因此，<strong>一个父接口并不会因为它的子接口或者实现类的初始化而初始化</strong>。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p>
<p>针对7，说明：</p>
<p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
<h6 id="2、被动使用"><a href="#2、被动使用" class="headerlink" title="2、被动使用"></a>2、被动使用</h6><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化</strong>。</p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化</strong>。</p>
<ol>
<li><p>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</p>
<ul>
<li><p>当通过子类引用父类的静态变量，不会导致子类初始化</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Child.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过数组定义类引用，不会触发此类的初始化</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// [空]</span></span><br><span class="line">    Parent[] parents = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// class [Lcom.atguigu.java1.Parent;</span></span><br><span class="line">    System.out.println(parents.getClass());</span><br><span class="line">    <span class="comment">// class java.lang.Object</span></span><br><span class="line">    System.out.println(parents.getClass().getSuperclass());</span><br><span class="line">	<span class="comment">// Parent的初始化过程</span></span><br><span class="line">    parents[<span class="number">0</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">    parents[<span class="number">1</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只是定义不赋值的话，不会触发类初始化。但是只要赋上一次值就会执行类的初始化，之后就不会执行类的初始化了。（<clinit>()这样一个类构造器方法只会初始化一次）</clinit></p>
</li>
</ul>
</li>
<li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(Person.NUM); // 1</span></span><br><span class="line">    <span class="comment">// SerialA的初始化</span></span><br><span class="line">    <span class="comment">// 3 </span></span><br><span class="line">    System.out.println(Person.NUM1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(SerialA.ID); // 1</span></span><br><span class="line">    <span class="comment">// Person类的初始化</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    System.out.println(SerialA.ID1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SerialA的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ID1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h6 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h6><ul>
<li>ClassLoader.getSystemClassLoader().loadClass()方法与Class.forName()方法<ul>
<li>Class.forName()方法：类自动使用</li>
<li>ClassLoader.getSystemClassLoader().loadClass()方法：类被动使用</li>
</ul>
</li>
</ul>
<h4 id="5、过程四：类的Using（使用）"><a href="#5、过程四：类的Using（使用）" class="headerlink" title="5、过程四：类的Using（使用）"></a>5、过程四：类的Using（使用）</h4><p>任何一个类型在使用之前都必须经历过<strong>完整的加载、链接和初始化3个类加载步骤</strong>。一旦一个类型成功经历过这3个步骤之后，就应经加载成功了。便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息(比如：静态字段、静态方法)，或者使用new关键字为其创建对象实例。</p>
<h4 id="6、过程五：类的Unloading（卸载）"><a href="#6、过程五：类的Unloading（卸载）" class="headerlink" title="6、过程五：类的Unloading（卸载）"></a>6、过程五：类的Unloading（卸载）</h4><h5 id="1、类、类的加载器、类的实例之间的引用关系"><a href="#1、类、类的加载器、类的实例之间的引用关系" class="headerlink" title="1、类、类的加载器、类的实例之间的引用关系"></a>1、类、类的加载器、类的实例之间的引用关系</h5><p>在类加载器的内部实现中，<strong>用一个Java集合来存放所加载类的引用</strong>。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法， 就能获得它的类加载器。由此可见，<strong>代表某个类的Class实例与其类的加载器之间为双向关联关系</strong>。</p>
<p><strong>一个类的实例总是引用代表这个类的Class对象</strong>。在Object类中定义了getClass()方法， 这个方法返回代表对象所属类的Class对象的引用。</p>
<p>此外，<strong>所有的Java类都有一个静态属性class，它引用代表这个类的Class对象</strong>。</p>
<h5 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h5><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即<strong>不可触及</strong>时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</strong>。</p>
<h5 id="3、具体例子"><a href="#3、具体例子" class="headerlink" title="3、具体例子"></a>3、具体例子</h5><p><img src="/2021/04/19/JVM/image-20210523011825913.png" alt="image-20210523011825913"></p>
<p>loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。</p>
<ul>
<li>关于方法区的垃圾回收（回顾）：方法区的垃圾收集主要回收两部分内容：**<code>常量池中废弃的常量</code><strong>和</strong><code>不再使用的类型</code>**。(可对应上面的图)<ul>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于 “不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul>
<li><strong>该类所有的实例都已经被回收</strong>。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>。这个条件<strong>除非是经过精心设计的可替换类加载器的场景，如<code>OSGi</code>、<code>JSP</code>的重加载</strong>等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong>。</li>
</ul>
</li>
<li>Java虚拟机**被允许(不是必然)**对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</li>
</ul>
</li>
</ul>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查Sample类的Class对象是否存在，<strong>如果存在会直接使用，不再重新加载</strong>；<strong>如果不存在Sample类会被重新加载，在Java 虚拟机的堆区会生成一个新的代表Sample类的Class实例</strong>(可以通过哈希码查看是否是同一个实例)。</p>
<h5 id="4、类的卸载"><a href="#4、类的卸载" class="headerlink" title="4、类的卸载"></a>4、类的卸载</h5><ol>
<li><strong><code>启动类加载器加载的类型</code>在整个运行期间是不可能被卸载的</strong>(jvm和jls规范)</li>
<li><strong>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li>
<li><strong>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到</strong>。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候<strong>采用<code>缓存</code>的策略以提高系统性能</strong>)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</li>
</ol>
<p>综合以上三点，<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来，<strong>开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能</strong>。</p>
<h4 id="7、相关大厂面试题"><a href="#7、相关大厂面试题" class="headerlink" title="7、相关大厂面试题"></a>7、相关大厂面试题</h4><ul>
<li>蚂蚁金服：<ul>
<li>描述一下JVM加载Class文件的原理机制?</li>
<li>一面：类加载过程</li>
</ul>
</li>
<li>百度：<ul>
<li>类加载的时机</li>
<li>java类加载过程?</li>
<li>简述java类加载机制?</li>
</ul>
</li>
<li>腾讯：<ul>
<li>JVM中类加载机制，类加载过程? </li>
</ul>
</li>
<li>滴滴：<ul>
<li>JVM类加载机制</li>
</ul>
</li>
<li>美团：<ul>
<li>Java类加载过程</li>
<li>描述一下jvm加载class文件的原理机制</li>
</ul>
</li>
<li>京东：<ul>
<li>什么是类的加载?</li>
<li>哪些情况会触发类的加载?</li>
<li>讲一下JVM加载一个类的过程</li>
<li>JVM的类加载机制是什么?</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4、再谈类的加载器"><a href="#4、再谈类的加载器" class="headerlink" title="4、再谈类的加载器"></a>4、再谈类的加载器</h3><h4 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h4><p><strong>类加载器是JVM执行类加载机制的前提</strong>。</p>
<p>ClassLoader的作用：</p>
<p><strong>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的</strong>，ClassLoader 负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换<strong>为一个与目标类对应的java.lang.Class对象实例</strong>。然后交给Java虚拟机进行链接、初始化等操作。因此，<strong>ClassLoader在整个装载阶段，只能影响到类的加载</strong>，而无法通过ClassLoader去改变类的链接和初始化行为。<strong>至于它是否可以运行，则由<code>Execution Engine（执行引擎）</code>决定</strong>。</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="中篇_第4章：类的加载器"></p>
<p>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在<strong>OSGi、字节码加解密领域</strong>大放异彩。这主要归功于Java虚拟机的设计者们当初在设计<strong>类加载器</strong>的时候，并<strong>没有</strong>考虑<strong>将它绑定在JVM内部</strong>，这样做的好处就是<strong>能够更加灵活和动态地执行类加载操作</strong>。</p>
<h5 id="1、类加载器的分类"><a href="#1、类加载器的分类" class="headerlink" title="1、类加载器的分类"></a>1、类加载器的分类</h5><p>类的加载分类：**<code>显式加载</code>** vs <strong><code>隐式加载</code></strong></p>
<p>class文件的显式加载与隐式加载的方式是指<strong>JVM加载class文件到内存的方式</strong>。</p>
<ul>
<li><strong>显式加载</strong>：指的是<strong>在代码中通过调用ClassLoader加载class对象</strong>，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass(name)加载class对象。</li>
<li><strong>隐式加载</strong>：则是<strong>不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中</strong>，如在加载某个类的class文件时，该类的class 文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中（例如User user = new User()）。（常用）</li>
</ul>
<p>在<strong>日常开发以上两种方式一般会混合使用</strong>。</p>
<h5 id="2、类加载器的必要性"><a href="#2、类加载器的必要性" class="headerlink" title="2、类加载器的必要性"></a>2、类加载器的必要性</h5><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题。</li>
<li>需要<strong>支持类的动态加载</strong>或<strong>需要对编译后的字节码文件进行加解密操作</strong>时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。（自己定义的类加载器可以不遵从沙箱安全模型，因为沙箱安全模型有它的缺点）</li>
</ul>
<h5 id="3、命名空间"><a href="#3、命名空间" class="headerlink" title="3、命名空间"></a>3、命名空间</h5><ol>
<li>何为类的唯一性：<br>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</li>
<li>命名空间：<ul>
<li>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有的父加载器所加载的类组成</strong></li>
<li><strong>在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类</strong></li>
<li><strong>在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类</strong></li>
</ul>
</li>
</ol>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<p>代码解释：</p>
<p><img src="/2021/04/19/JVM/A45F46DE-73EC-4B6B-BCD1-9BAB9DE15C51.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/4D382A73-1DF4-4223-9CB9-C7B45D8071A9.png" alt="img"></p>
<p>解释：</p>
<p>rootDir后面的地址是我们使用javac User.class指令生成的class文件地址，然后loader1和loader2是两个用户自定义类加载器（如果自定义的不必理解），之后使用这两个用户自定义类加载器加载同一类型的User类，获得的Class对象不是同一个，可以通过Class对象调用getClassLoader()方法获取对应的类加载器了，最后通过系统类加载器获取的Class对象也是独特的，也可以通过该Class对象获取系统类加载器</p>
<h5 id="4、类加载机制的基本特征"><a href="#4、类加载机制的基本特征" class="headerlink" title="4、类加载机制的基本特征"></a>4、类加载机制的基本特征</h5><p>通常类加载机制有三个基本特征：</p>
<ul>
<li><strong>双亲委派模型</strong><ul>
<li>但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。</li>
<li>例如，Java 中JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>安全  避免重复加载 保护程序 防止核心api被串改</li>
</ul>
</li>
<li><strong>可见性</strong><ul>
<li><strong>子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</strong>。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
</ul>
</li>
<li><strong>单一性</strong><ul>
<li>由于父加载器的类型对于子加载器是可见的，所以<strong>父加载器中加载过的类型，就不会在子加载器中重复加载</strong>。但是注意，<strong>类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2、复习：类的加载器分类"><a href="#2、复习：类的加载器分类" class="headerlink" title="2、复习：类的加载器分类"></a>2、复习：类的加载器分类</h4><p>JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>(Bootstrap ClassLoader) 和<strong>自定义类加载器</strong>（User-Defined ClassLoader) 。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="/2021/04/19/JVM/image-20210523150158667.png" alt="image-20210523150158667"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li>
<li>不同类加载器看似是继承(Inheritance)关系，<strong>实际上是包含关系。在下层加载器中，包含着上层加载器的引用</strong>。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210523150646271.png" alt="image-20210523150646271"></p>
<p>正是由于子类加载器中<strong>包含着父类加载器的引用</strong>，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p>注意：</p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器。</p>
<h5 id="1、启动类加载器-引导类加载器，Bootstrap-ClassLoader"><a href="#1、启动类加载器-引导类加载器，Bootstrap-ClassLoader" class="headerlink" title="1、启动类加载器(引导类加载器，Bootstrap ClassLoader)"></a>1、启动类加载器(引导类加载器，Bootstrap ClassLoader)</h5><ul>
<li>这个类加载<strong>使用C/C++语言实现</strong>的，<strong>嵌套在JVM内部</strong>。</li>
<li>它用来加载Java的核心库(JAVA_HOME/jre/lib/<code>rt.jar</code>或<code>sun.boot.class.path</code>路径下的内容)。用于提供JVM自身需要的类。</li>
<li>并不继承自java.lang.ClassLoader，<strong>没有父加载器</strong>。</li>
<li>出于安全考虑，Bootstrap启动类加载器<strong>只加载包名为<code>java</code>、<code>javax</code>、 <code>sun</code> 等开头的类</strong></li>
<li><strong>加载扩展类和应用程序类加载器</strong>，并<strong>指定为他们的父类加载器</strong>。（聚合）</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523152412581.png" alt="image-20210523152412581"></p>
<p><img src="/2021/04/19/JVM/image-20210523152438385.png" alt="image-20210523152438385"></p>
<p>使用<code>-XX: +TraceClassloading</code>参数得到。</p>
<p>启动类加载器使用C++编写的? Yes!</p>
<ul>
<li>C/C++E 指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java: 由C++演变而来， (C++)–版，单继承</li>
</ul>
<p>引导类加载器需要加载的jar包文件：</p>
<p>代码：</p>
<p><img src="/2021/04/19/JVM/C38CE122-2D25-4E14-B5BE-220FDBDEF84A.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/C9DD335C-6A70-45A3-9091-431DA8C2FBCD.png" alt="img"></p>
<h5 id="2、扩展类加载器-Extension-ClassLoader"><a href="#2、扩展类加载器-Extension-ClassLoader" class="headerlink" title="2、扩展类加载器(Extension ClassLoader)"></a>2、扩展类加载器(Extension ClassLoader)</h5><ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为启动类加载器。(聚合)</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext子目录</code>下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523152834151.png" alt="image-20210523152834151"></p>
<p><img src="/2021/04/19/JVM/image-20210523155350716.png" alt="image-20210523155350716"></p>
<p>注意：扩展类加载器与系统类加载器是<strong>属于同一级的</strong>，都是继承与<code>URLClassLoader</code>，只是扩展类加载器当中有系统类加载器的引用，所以才称系统类加载器是扩展类加载器的”父类”加载器。（<strong>两者并不是继承关系，而是一种聚合关系</strong>）</p>
<p><strong>无法通过扩展类加载器获得引导类加载器</strong>，因为引导类加载器是用C/C++语言编写的，<strong>所以获取的值是null</strong></p>
<p>扩展类加载器：</p>
<p>代码：</p>
<p><img src="/2021/04/19/JVM/15C91D65-CF15-467B-877A-FBF37796246D.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/DE7EBEFA-D191-4069-B6C9-B88FE6071584.png" alt="img"></p>
<h5 id="3、应用程序类加载器-系统类加载器，AppClassLoader"><a href="#3、应用程序类加载器-系统类加载器，AppClassLoader" class="headerlink" title="3、应用程序类加载器(系统类加载器，AppClassLoader)"></a>3、应用程序类加载器(系统类加载器，AppClassLoader)</h5><ul>
<li>java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器。(聚合)</li>
<li>它负责加载<code>环境变量classpath</code>或系统属性<code>java.class.path指定路径</code>下的类库</li>
<li><strong>应用程序中的类加载器默认是系统类加载器</strong>。</li>
<li>它是<strong>用户自定义类加载器的默认父加载器</strong></li>
<li>通过<strong>ClassLoader的getSystemClassLoader( )方法</strong>可以获取到该类加载器</li>
</ul>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210523155305052.png" alt="image-20210523155305052"></p>
<h5 id="4、用户自定义类加载器"><a href="#4、用户自定义类加载器" class="headerlink" title="4、用户自定义类加载器"></a>4、用户自定义类加载器</h5><ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是：<strong>Java开发者可以自定义类加载器来实现<code>类库的动态加载</code>，加载源可以是本地的JAR包，也可以是网络上的远程资源</strong>。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，<strong>著名的OSGI组件框架</strong>，再如<strong>Eclipse的插件机制</strong>。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，<strong>自定义加载器能够实现应用隔离</strong>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader.</li>
</ul>
<h4 id="3、测试不同的类的加载器"><a href="#3、测试不同的类的加载器" class="headerlink" title="3、测试不同的类的加载器"></a>3、测试不同的类的加载器</h4><p><strong>每个Class对象都会包含一个定义它的ClassLoader的一个引用</strong>。</p>
<p>获取ClassLoader的途径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz. getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>说明：<br>站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于<strong>引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值</strong>。</p>
<p><strong>数组类的Class对象</strong>，不是由类加载器去创建的，而<strong>是在Java运行期JVM根据需要自动创建</strong>的。对于数组类的类加载器来说，是<strong>通过Class.getClassLoader( )返回的，与数组当中元素类型的类加载器是一样</strong>的；如果<strong>数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null:表示使用的是引导类加载器</span></span><br><span class="line"></span><br><span class="line">ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br></pre></td></tr></table></figure>

<p>**获取当前线程上下文的ClassLoader的结果就是<code>系统类加载器</code>**，这个可以在Launcher.java中被代码证明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">Thread.currentThread().setContextClassLoader(this.loader);</span><br></pre></td></tr></table></figure>

<p>代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">        <span class="comment">//###########################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            <span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null:表示使用的是引导类加载器</span></span><br><span class="line"></span><br><span class="line">            ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">			<span class="comment">// 关于数组当中的元素类型是基本数据类型</span></span><br><span class="line">            <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br><span class="line">            </span><br><span class="line">            System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/04/19/JVM/54EBA795-A6B6-42D4-AEA2-97DB51CBBC26.png" alt="img"></p>
<h4 id="4、ClassLoader源码解析"><a href="#4、ClassLoader源码解析" class="headerlink" title="4、ClassLoader源码解析"></a>4、ClassLoader源码解析</h4><p>ClassLoader与现有类加载器的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210523193421376.png" alt="image-20210523193421376"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader, 所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h5 id="1、类加载器之间的关系"><a href="#1、类加载器之间的关系" class="headerlink" title="1、类加载器之间的关系"></a>1、类加载器之间的关系</h5><p>Launcher.class：</p>
<p><img src="/2021/04/19/JVM/20200924233838830.png" alt="img"></p>
<p>ExtClassLoader和AppClassLoader是Launcher类的两个内部类：</p>
<p><img src="/2021/04/19/JVM/2020092423393671.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/20200924234038891.png" alt="img"></p>
<p>分析：</p>
<ol>
<li>验证扩展类加载器的父类是null<ul>
<li>先看：var1 = Launcher.ExtClassLoader.<code>getExtClassLoader</code>();</li>
<li>获取到扩展类加载器，点击该方法往里面追溯，在最后找到：return new Launcher.<code>ExtClassLoader</code>(var0);</li>
<li>我们在点击该方法往里面追溯，在找到：<code>super</code>(getExtURLs(var1), (ClassLoader)null, Launcher.factory);</li>
<li>然后点击super，往里面追溯，在找到：public URLClassLoader(URL[] urls, ClassLoader parent,URLStreamHandlerFactory factory){<code>super</code>(parent)}</li>
<li>点击其中的parent（也就是null值），我们点击super，往里面追溯，在找到：protected SecureClassLoader(ClassLoader parent) { <code>super</code>(parent);}</li>
<li>点击其中的parent就是null，我们点击super，往里面追溯，在找到：protected ClassLoader(ClassLoader parent) { <code>this</code>(checkCreateClassLoader(), parent);} </li>
<li>点击其中的parent就是null，我们点击this，往里面追溯，在找到：private ClassLoader(Void unused, ClassLoader parent) { this.<code>parent</code> = parent;}</li>
<li>点击其中的parent就是null，可以看到是：private final ClassLoader <code>parent</code>;<ul>
<li>就是ClassLoader.java定义的属性：父类加载器</li>
</ul>
</li>
<li>由于<strong>parent就是null</strong>，所以<strong>扩展类加载器的父类是null</strong>，也就是<strong>引导类加载器</strong>，因此我们调用获取扩展类加载器父类的方法获得的结果是null</li>
</ul>
</li>
<li>验证系统类加载器的父类是扩展类加载器<ul>
<li>先看：this.loader = Launcher.AppClassLoader.<code>getAppClassLoader</code>(var1);</li>
<li>获取到系统类加载器，点击该方法往里面追溯，在最后找到：return new Launcher.<code>AppClassLoader</code>(var1x, var0);</li>
<li>其中var0就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：AppClassLoader(URL[] var1, ClassLoader var2) { <code>super</code>(var1, var2, Launcher.factory); this.ucp.initLookupCache(this);} </li>
<li>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：public URLClassLoader(URL[] urls, ClassLoader parent,URLStreamHandlerFactory factory) {<code>super</code>(parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：protected SecureClassLoader(ClassLoader parent) { <code>super</code>(parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：protected ClassLoader(ClassLoader parent) { <code>this</code>(checkCreateClassLoader(), parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：private ClassLoader(Void unused, ClassLoader parent) { this.<code>parent</code> = parent;}</li>
<li>点击其中的parent就是扩展类加载器，可以看到是：private final ClassLoader <code>parent</code>;<ul>
<li>就是ClassLoader.java定义的属性：父类加载器</li>
</ul>
</li>
<li>由于<strong>parent就是扩展类加载器</strong>，所以<strong>系统类加载器的父类是扩展类加载器</strong>，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</li>
</ul>
</li>
<li>当前线程上下文的ClassLoader就是系统类加载器<ul>
<li>Thread.currentThread().setContextClassLoader(this.loader)：就是将系统类加载器设置为当前线程的上下文加载器，所以Thread.currentThread().getContextClassLoader()获取到的就是系统类加载器</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li>Launcher源码里定义了static的扩展类加载器ExtClassLoader， static的系统类加载器AppClassLoader。</li>
<li>它们都是<strong>默认包级别的</strong>，它们都是继承URLClassLoader，这就意味着我们的代码里，<strong>不能定义ExtClassLoader laoder =  …或AppClassLoader loader = …。</strong>我们只能ClassLoader loader =  …，而在实际运行时，我们应当能辨别这个loader到底是哪个具体类型。</li>
<li>在ExtClassLoader构造器里，并没有指定parent，或者说ExtClassLoader的parent为null。<strong>因为ExtClassLoader的parent是BootstrapLoader，而BootstrapLoader不存在于Java Api里，只存在于JVM里，我们是看不到的</strong>，所以请正确理解”ExtClassLoader的parent为null”的含义。</li>
<li>在AppClassLoader构造器里，有了parent。<strong>实例化AppClassLoader的时候，传入的parent就是一个ExtClassLoader实例</strong>。</li>
<li>看看Launcher的构造方法：<ul>
<li>**先实例化ExtClassLoader，从java.ext.dirs系统变量里获得URL[]**。</li>
<li>**用这个ExtClassLoader作为parent去实例化AppClassLoader，从java.class.path系统变量里获得URL[]**。Launcher getClassLoader()就是返回的这个AppClassLoader。</li>
<li><strong>设置AppClassLoader为ContextClassLoader</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、ClassLoader的主要方法"><a href="#2、ClassLoader的主要方法" class="headerlink" title="2、ClassLoader的主要方法"></a>2、ClassLoader的主要方法</h5><p>抽象类ClassLoader的主要方法：(内部没有抽象方法)</p>
<ul>
<li><p>public final ClassLoader getParent()：</p>
<ul>
<li>返回该类加载器的超类加载器</li>
</ul>
</li>
<li><p>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException：</p>
<ul>
<li>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。<strong>该方法中的逻辑就是双亲委派模式的实现</strong>。</li>
</ul>
</li>
<li><p>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException：</p>
<ul>
<li>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法， JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。</li>
<li>但是在JDK1. 2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，<strong>findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式</strong>。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛ClassNotFoundException异常，同时应该知道的是findClass 方法通常是和defineClass方法起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader 的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)：</p>
<ul>
<li><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象， 也可以通过其他方式实例化class对象， 如通过网络接收一个类的字节码，然后转换为byte 字节流创建对应的Class对象。</p>
</li>
<li><p><strong>defineClass()方法通常与findClass()方法起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则， 取得要加载类的字节码后转换成流， 然后调用defineClass()方法生成类的Class对象。</strong></p>
</li>
<li><p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//获取类的字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData. length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>protected final void resolveClass(Class&lt;?&gt; c)：</p>
<ul>
<li><strong>链接指定的一个Java类</strong>。使用该方法可以<strong>使用类的Class对象创建完成的同时也被解析</strong>。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</li>
</ul>
</li>
<li><p>protected final Class&lt;?&gt; findLoadedClass(String name)：</p>
<ul>
<li>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。<strong>这个方法是final方法，无法被修改</strong>。</li>
</ul>
</li>
<li><p>private final ClassLoader parent;</p>
<ul>
<li>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为<strong>这个ClassLoader的双亲</strong>。<strong>在类加载的过程中, ClassLoader可能会将某些请求交予自己的双亲处理</strong>。</li>
</ul>
</li>
</ul>
<h6 id="关于loadClass-方法的剖析："><a href="#关于loadClass-方法的剖析：" class="headerlink" title="关于loadClass()方法的剖析："></a>关于loadClass()方法的剖析：</h6><p><strong>loadClass()方法是ClassLoader.java类中的主要方法</strong>。</p>
<p>测试代码：ClassLoader.getSystemClassLoader().loadClass(“com.atguig.java.User”); </p>
<p>涉及到对如下方法的调用：(模板方法模式的实现，抽象类提供基本的方法框架，子类需要重写具体的方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="comment">//resolve: true-加载class的同时进行解析操作。默认为false</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been Loaded</span></span><br><span class="line">        <span class="comment">//首先，在缓在中判断是否已经加载同名的类。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == nu1l) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != nu1l) &#123;</span><br><span class="line">                    <span class="comment">// 如果存在父类加载器，则调用父类加载器进行类的加载（递归）（双亲委派机制）</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent为null:父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent cLass Loader</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == nu11) &#123; <span class="comment">// 当前类的加载器的父类加载器未加载此类or当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findCLass()</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                C =findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class Loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindCLassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p><code>findLoadedClass(name)</code>，查找类是否已经被加载过，如果加载过直接返回该Class类型的对象。如果没有被加载则继续第三的操作！</p>
</li>
<li><p><code>c = findBootstrapClassOrNull(name);</code>和<code>c = parent.loadClass(name, false);</code>如果父加载器不为空，那么调用父加载器的<code>loadClass</code>方法加载类，如果父加载器为空，那么调用虚拟机的加载器来加载类。(此过程当中是通过递归的方法改变c的类型为父类加载器的类型，体现了双亲委派机制)</p>
<p>如果以上两个步骤都没有成功的加载到类，进入第三；</p>
</li>
<li><p><code>c = findClass(name);</code>使用自定义的<code>findClass(name)</code>方法来加载类。（递归回最初的那一层）</p>
<p>这个时候，我们已经得到了加载之后的类，那么就根据<code>resolve</code>的值决定是否调用<code>resolveClass</code>方法。进入第五！</p>
</li>
<li><p><code>resolveClass(c);</code> <strong>链接指定的类。</strong>这个方法给<code>Classloader</code>用来链接一个类，如果这个类已经被链接过了，那么这个方法只做一个简单的返回。否则，这个类将被按照 <code>Java™</code>规范中的<code>Execution</code>描述进行链接……</p>
</li>
<li><p>其中使用到了设计模式的<strong>模板方法模式</strong></p>
<ul>
<li><strong>模板方法模式用于定义构建某个对象的步骤与顺序，或者定义一个算法的骨架</strong>。</li>
<li>模板方法模式的使用的方式，给子类足够的自由度，提供一些方法供子类覆盖，去实现一些骨架中不是必须但却可以有自定义实现的步骤。模板方法模式是一种基础继承的代码复用技术。如ClassLoader中的findClass方法！</li>
</ul>
</li>
<li><p>总结一下：在ClassLoader中定义的算法顺序是</p>
<ol>
<li>首先看<strong>是否有已经加载好的类</strong>。</li>
<li>如果<strong>父类加载器不为空</strong>，则首先<strong>从父类类加载器加载</strong>。</li>
<li>如果<strong>父类加载器为空</strong>，则尝试<strong>从启动加载器加载</strong>。</li>
<li>如果<strong>两者都失败</strong>，才尝试<strong>从findClass方法加载</strong>。</li>
</ol>
</li>
</ol>
<h5 id="3、SecureClassLoader与URLClassLoader"><a href="#3、SecureClassLoader与URLClassLoader" class="headerlink" title="3、SecureClassLoader与URLClassLoader"></a>3、SecureClassLoader与URLClassLoader</h5><ul>
<li>SecureClassLoader：<ul>
<li>接着SecureClassLoader扩展了ClassLoader, 新增了几个<strong>与使用相关的代码源</strong>(对代码源的位置及其证书的验证)和<strong>权限定义类验证</strong>(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</li>
</ul>
</li>
<li>URLClassLoader：<ul>
<li>前面说过，ClassLoader是一个抽象类， 很多<strong>方法是空的没有实现</strong>，比如findClass()、findResource()等（模板方法模式）。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能，<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类， 这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523221840016.png" alt="image-20210523221840016"></p>
<h5 id="4、ExtClassLoader与AppClassLoader"><a href="#4、ExtClassLoader与AppClassLoader" class="headerlink" title="4、ExtClassLoader与AppClassLoader"></a>4、ExtClassLoader与AppClassLoader</h5><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即<strong>拓展类加载器ExtClassLoader</strong>和<strong>系统类加载器AppClassLoader</strong>, 这两个类都<strong>继承自URLClassLoader, 是sun.misc.Launcher的静态内部类</strong>。</p>
<p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader 和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
<p><img src="/2021/04/19/JVM/0979521B-B4F6-4FA9-AE69-99F740449416.png" alt="img"></p>
<p>我们发现<strong>ExtClassLoader</strong>并没有重写loadClass()方法，这足矣说明其<strong>遵循双亲委派模式</strong>，而<strong>AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式</strong>。</p>
<h5 id="5、Class-forName-与ClassLoader-loadClass"><a href="#5、Class-forName-与ClassLoader-loadClass" class="headerlink" title="5、Class.forName()与ClassLoader.loadClass()"></a>5、Class.forName()与ClassLoader.loadClass()</h5><ul>
<li><code>Class.forName()</code>：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className)；根据传入的类的全限定名返回一个Class对象。<strong>该方法在将Class文件加载到内存的同时，会执行类的初始化</strong>。如：Class.forName(“com. atguigu. java.HelloWorld”);</li>
<li><code>ClassLoader.loadClass()</code>：这是一个<strong>实例方法</strong>，需要一个ClassLoader 对象来调用该方法。<strong>该方法将Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化（loadClass()方法当中的resolve: true-加载class的同时进行解析操作。默认为false）</strong>。该方法因为需要得到一个ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。如：ClassLoader c1=…….;c1. loadClass(“com. atguigu. java . HelloWorld”);</li>
</ul>
<h4 id="5、双亲委派模型"><a href="#5、双亲委派模型" class="headerlink" title="5、双亲委派模型"></a>5、双亲委派模型</h4><h5 id="1、定义与本质"><a href="#1、定义与本质" class="headerlink" title="1、定义与本质"></a>1、定义与本质</h5><p>类加载器用来把类加载到Java虚拟机中。从JDK1. 2版本开始，<strong>类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全</strong>。</p>
<ol>
<li><p>定义：</p>
<p><strong>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载</strong>。</p>
</li>
<li><p>本质：</p>
<p>规定了类加载的顺序是：<strong>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210421103744316.png" alt="image-20210421103744316"></p>
</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210524135243252.png" alt="image-20210524135243252"></p>
<h5 id="2、优势与劣势"><a href="#2、优势与劣势" class="headerlink" title="2、优势与劣势"></a>2、优势与劣势</h5><h6 id="1、双亲委派机制优势"><a href="#1、双亲委派机制优势" class="headerlink" title="1、双亲委派机制优势"></a>1、双亲委派机制优势</h6><ul>
<li><strong>避免类的重复加载，确保一个类的全局唯一性</strong>；<ul>
<li><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要于ClassLoader再加载一次。</li>
</ul>
</li>
<li><strong>保护程序安全，防止核心API被随意篡改</strong></li>
</ul>
<h6 id="2、代码支持"><a href="#2、代码支持" class="headerlink" title="2、代码支持"></a>2、代码支持</h6><p>双亲委派机制在java.lang.ClassLoader.loadClass(String, boolean)接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在<strong>当前加载器的缓存中查找</strong>有无目标类，如果有，直接返回。</li>
<li><strong>判断当前加载器的父加载器是否为空</strong>，如果不为空，则调用parent.loadClass(name, false)接口进行加载。</li>
<li>反之，<strong>如果当前加载器的父类加载器为空</strong>，则调用findBootstrapClassOrNull(name)接口， <strong>让引导类加载器进行加载</strong>。</li>
<li><strong>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载</strong>。 该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
</ol>
<p>双亲委派的模型就隐藏在这第2和第3步的递归调用当中</p>
<h6 id="3、举例："><a href="#3、举例：" class="headerlink" title="3、举例："></a>3、举例：</h6><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载java.lang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass(String)，最终通过引导类加载器进行加载。</p>
<h6 id="4、思考："><a href="#4、思考：" class="headerlink" title="4、思考："></a>4、思考：</h6><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法， 抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?</p>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用java.lang.ClassLoader .<code>defineClass</code>(String, byte[], int, int, ProtectionDomain)方法，而该方法会执行<code>preDefineClass()</code>接口，<strong>该接口中提供了对JDK核心类库的保护</strong>。</p>
<h6 id="5、双亲委派模型的弊端："><a href="#5、双亲委派模型的弊端：" class="headerlink" title="5、双亲委派模型的弊端："></a>5、双亲委派模型的弊端：</h6><p><strong>检查类是否加载的委托过程是<code>单向的</code>**，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即</strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类**。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p>由双亲委派模型的优势可以看出：Java类随着它的类加载器一起具备了一种带有优先级的层次关系——双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API。但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，由于BootstrapClassloader是顶级类加载器，BootstrapClassloader无法委派AppClassLoader来加载类，也就是说BootstrapClassloader中加载的类中无法使用由AppClassLoader加载的类。</p>
<p>举例：（java.sql与驱动接口：com.mysql.jdbc.Driver）</p>
<p>接口：java.sql.Driver，定义在java.sql包中，包所在的位置是：jdk\jre\lib\rt.jar中，java.sql包中还提供了其它相应的类和接口比如管理驱动的类：DriverManager类，很明显java.sql包是由BootstrapClassloader加载器加载的；而接口的实现类com.mysql.jdbc.Driver是由第三方实现的类库，由AppClassLoader加载器进行加载的，我们的问题是DriverManager再获取链接的时候必然要加载到com.mysql.jdbc.Driver类，这就是由BootstrapClassloader加载的类使用了由AppClassLoader加载的类，很明显和双亲委托机制的原理相悖。</p>
<h6 id="6、结论："><a href="#6、结论：" class="headerlink" title="6、结论："></a>6、结论：</h6><p>由于<strong>Java虛拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已</strong>。比如在<code>Tomcat</code>中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，<strong>当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行</strong>，这同时<strong>也是Servlet规范推荐的一种做法</strong>。</p>
<h5 id="3、破坏双亲委派机制"><a href="#3、破坏双亲委派机制" class="headerlink" title="3、破坏双亲委派机制"></a>3、破坏双亲委派机制</h5><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h6 id="1、破坏双亲委派机制1——兼容JDK1-2之前的版本"><a href="#1、破坏双亲委派机制1——兼容JDK1-2之前的版本" class="headerlink" title="1、破坏双亲委派机制1——兼容JDK1.2之前的版本"></a>1、破坏双亲委派机制1——兼容JDK1.2之前的版本</h6><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的 “远古” 时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p>上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑， 如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p>以上简单来说就是jdk1.2之前还没引入双亲委派机制，所以jdk1.2之前就是破坏双亲委派机制的情况。</p>
<h6 id="2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）"><a href="#2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）" class="headerlink" title="2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）"></a>2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）</h6><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题(<strong>越基础的类由越上层的加载器进行加载</strong>)，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户的代码，那该怎么办呢</strong>?</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载(在JDK 1.3时加入到rt.jar的)，肯定属于Java中很基础的类型了。但<strong>JNDI 存在的目的就是对资源进行查找和集中管理</strong>，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口(Service Provider Interface, SPI) 的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?</strong>(SPI：在Java平台中， 通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器(Thread Context ClassLoader)**。这个类加载器可以通过java.lang. Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器</strong>默认就是应用程序类加载器**。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBl等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，**以META-INF/services中的配置信息，辅以<code>责任链模式</code>**，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="/2021/04/19/JVM/image-20210524154710225.png" alt="image-20210524154710225"></p>
<p><strong>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类</strong>。</p>
<p>简单来说就是线程上下文类加载器让启动类加载器和系统类加载器直接联系起来了，中间的扩展类加载器被省略了，所以这破坏了双亲委派机制，其中线程上下文类加载器就是系统类加载器，这个证明在之前的ClassLoader &gt;&gt;&gt; 类加载器之间的关系中 有相关代码的解释。</p>
<h6 id="3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换-Hot-Swap-、模块热部署-Hot-Deployment-等"><a href="#3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换-Hot-Swap-、模块热部署-Hot-Deployment-等" class="headerlink" title="3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等"></a>3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等</h6><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等</p>
<p>IBM公司主导的JSR-291 (即OSGi R4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起 换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以<code>java.*</code>开头的类，<strong>委派给父类加载器加载</strong>。</li>
<li>否则，将<strong>委派列表名单内的类，委派给父类加载器加载</strong>。</li>
<li>否则，<strong>将Import列表中的类， 委派给Export这个类的Bundle的类加载器加载</strong>。</li>
<li>否则，查找<strong>当前Bundle的ClassPath, 使用自己的类加载器加载</strong>。</li>
<li>否则，查找<strong>类</strong>是否<strong>在自己的Fragment Bundle</strong>中， 如果在，则<strong>委派给Fragment Bundle的类加载器加载</strong>。</li>
<li>否则，查找<strong>Dynamic Import列表的Bundle， 委派给对应Bundle的类加载器加载</strong>。</li>
<li>否则，<strong>类查找失败</strong>。</li>
</ol>
<p>说明：<strong>只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</strong></p>
<p>小结：</p>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<strong>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</strong>。</p>
<h6 id="4、-补充-破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）"><a href="#4、-补充-破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）" class="headerlink" title="4、(补充)破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）"></a>4、(补充)破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）</h6><p><strong>JDK9引入了Java模块化系统(Java Platform Module System)来实现可配置的封装隔离机制</strong>，同时<strong>JVM对类加载的架构也做出了调整</strong>，也就是双亲委派模型的第四次破坏。</p>
<p>传统的双亲委派加机制：（图示）这里的敌人就是我们要加载的jar包</p>
<p><img src="/2021/04/19/JVM/d62a6059252dd42a4c0e5baa0c9d2bb3c8eab8dc.jpeg" alt="img"></p>
<p><strong>缺点</strong>：</p>
<p>通过上面的漫画不言而喻，当真正的敌人来了，靠这种<strong>低效</strong>的传达机制，怎么可能打一场胜仗呢？</p>
<ul>
<li>启动类加载器负责加载<JAVA_HOME>\jre\lib目录</JAVA_HOME></li>
<li>扩展类加载器负责加载<JAVA_HOME>\jre\lib\ext目录</JAVA_HOME></li>
<li>应用类加载器负责加载ClassPath目录。</li>
</ul>
<p>既然一切都是各司其职，为什么不能加载类的时候一步到位呢？</p>
<p>通过分析JDK9的类加载器源码，我发现最新的类加载器结构在一定程度上是缓解了这种情况的</p>
<p><strong>JDK的模块化</strong>：</p>
<p>在JDK9之前，<strong>JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石</strong>。这不仅是<strong>违反了单一职责原则</strong>，同样程序在编译的时候会将很多无用的类也一并打包，造成<strong>臃肿</strong>。</p>
<p>在JDK9中，整个JDK都基于模块化进行构建，<strong>以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块</strong>，同时各个类加载器各司其职，只加载自己负责的模块。</p>
<p><img src="/2021/04/19/JVM/902397dda144ad34bc59b9aadd047cf230ad8561.jpeg" alt="img"></p>
<p><strong>模块化加载源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(cn); </span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// 找到当前类属于哪个模块 </span></span><br><span class="line">    LoadedModule loadedModule = findLoadedModule(cn); </span><br><span class="line">    <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//获取当前模块的类加载器 </span></span><br><span class="line">        BuiltinClassLoader loader = loadedModule.loader(); </span><br><span class="line">        <span class="comment">//进行类加载 </span></span><br><span class="line">        c = findClassInModuleOrNull(loadedModule, cn); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找不到模块信息才会进行双亲委派 </span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = parent.loadClassOrNull(cn); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是破坏双亲委派模型的“铁证”，而当我们继续跟进<code>findLoadedModule</code>，会发现是根据路径名找到对应的模块，而维护这一数据结构的就是下面这个Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, LoadedModule&gt; packageToModule = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到LoadedModule里面不仅有该模块的loader信息，还有用于描述依赖模块，对外暴露模块的信息的mref，<strong>LoadedModule也是模块化实现封装隔离机制的一块重要实现</strong>。</p>
<p><img src="/2021/04/19/JVM/72f082025aafa40f5bae9f15a6c2734979f0193d.jpeg" alt="img"></p>
<p>每一个module信息都有一个<code>BuiltinClassloader</code>，这个类有三个子类，我们通过源码分析他们的父子关系：</p>
<p><img src="/2021/04/19/JVM/dbb44aed2e738bd4035b63a7ac2df7d0267ff95f.jpeg" alt="img"></p>
<p>在ClassLoaders类中可以发现，<strong>PlatformClassLoader的parent是BootClassLoader，而AppClassLoader的parent则是PlatformClassLoader</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaders</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the built-in class loaders </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BootClassLoader BOOT_LOADER; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PlatformClassLoader PLATFORM_LOADER; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AppClassLoader APP_LOADER; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        BOOT_LOADER = <span class="keyword">new</span> BootClassLoader((append != <span class="keyword">null</span> &amp;&amp; !append.isEmpty()) ? <span class="keyword">new</span> URLClassPath(append, <span class="keyword">true</span>) : <span class="keyword">null</span>); </span><br><span class="line">        PLATFORM_LOADER = <span class="keyword">new</span> PlatformClassLoader(BOOT_LOADER);</span><br><span class="line">        ...; </span><br><span class="line">        APP_LOADER = <span class="keyword">new</span> AppClassLoader(PLATFORM_LOADER, ucp); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ol>
<li>经过破坏后的双亲委派模型更加高效，<strong>减少了很多类加载器之间不必要的委派操作</strong></li>
<li>JDK9的模块化可以<strong>减少Java程序打包的体积，同时拥有更好的隔离线与封装性</strong></li>
<li>每个module拥有专属的类加载器，程序<strong>在并发性上也会更加出色</strong></li>
</ol>
<h5 id="4、热替换的实现"><a href="#4、热替换的实现" class="headerlink" title="4、热替换的实现"></a>4、热替换的实现</h5><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<strong>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中</strong>。基本上大部分脚本语言都是天生支持热替换的，比如：PHP， 只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，<strong>如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类</strong>。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即<strong>两个不同的ClassLoader加载同一个类</strong>，在虚拟机内部，会认为<strong>这两个类是完全不同的</strong>。根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%83%AD%E6%9B%BF%E6%8D%A2.jpg" alt="中篇_第4章：热替换"></p>
<p><strong>每次调用方法之前都要加载字节码文件，然后创建对象，我们可以把字节码文件变成最新的，那么创建的对象肯定是最新的，所以这就完成了热替换</strong></p>
<h4 id="6、沙箱安全机制"><a href="#6、沙箱安全机制" class="headerlink" title="6、沙箱安全机制"></a>6、沙箱安全机制</h4><p>沙箱安全机制：</p>
<ul>
<li><strong>保证程序安全</strong></li>
<li><strong>保护Java原生的JDK代码</strong></li>
</ul>
<p>**Java安全模型的核心就是Java沙箱(sandbox)**。什么是沙箱?</p>
<ul>
<li><strong>沙箱是一个限制程序运行的环境</strong>。</li>
</ul>
<p>沙箱机制就是将Java代码<strong>限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么? </p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>文件系统</li>
<li>网络</li>
</ul>
<p>不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h5 id="1、JDK1-0时期"><a href="#1、JDK1-0时期" class="headerlink" title="1、JDK1.0时期"></a>1、JDK1.0时期</h5><p>在Java中将执行程序分成<strong>本地代码</strong>和<strong>远程代码</strong>两种：</p>
<ul>
<li><strong>本地代码默认视为可信任的，对于授信的本地代码，可以访问一切本地资源。</strong></li>
<li><strong>远程代码则被看作是不受信的。 而对于非授信的远程代码在早期的Java实现中， 安全依赖于沙箱(Sandbox)机制。</strong></li>
</ul>
<p>如下图所示JDK1 .0安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160050558.png" alt="image-20210524160050558"></p>
<h5 id="2、JDK1-1时期"><a href="#2、JDK1-1时期" class="headerlink" title="2、JDK1.1时期"></a>2、JDK1.1时期</h5><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如<strong>当用户希望远程代码访问本地系统的文件时候，就无法实现</strong>。因此在后续的Java1.1版本中，针对安全机制做了改进，<strong>增加了安全策略</strong>。<strong>允许用户指定代码对本地资源的访问权限</strong>。</p>
<p>如下图所示JDK1.1安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160203739.png" alt="image-20210524160203739"></p>
<h5 id="3、JDK1-2时期"><a href="#3、JDK1-2时期" class="headerlink" title="3、JDK1.2时期"></a>3、JDK1.2时期</h5><p>在Java1.2版本中，再次改进了安全机制，<strong>增加了代码签名</strong>。不论本地代码或是远程代码，都会按照<strong>用户的安全策略设定</strong>，<strong>由类加载器加载到虛拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</strong>。</p>
<p>如下图所示JDK1.2安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160319450.png" alt="image-20210524160319450"></p>
<h5 id="4、JDK1-6时期"><a href="#4、JDK1-6时期" class="headerlink" title="4、JDK1.6时期"></a>4、JDK1.6时期</h5><p>当前最新的安全机制实现，则引入了**<code>域(Domain)</code>**的概念。</p>
<p><strong>虚拟机会把所有代码加载到不同的系统域和应用域</strong>：</p>
<ul>
<li>**<code>系统域部分专门负责与关键资源进行交互</code>**；</li>
<li><strong>各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</strong>。</li>
<li><strong>虚拟机中不同的受保护域(ProtectedDomain)，对应不一样的权限(Permission)**。</strong>存在于不同域中的类文件就具有了当前域的全部权限**。</li>
</ul>
<p>如下图所示，最新的安全模型(jdk1.6)：</p>
<p><img src="/2021/04/19/JVM/image-20210524160541465.png" alt="image-20210524160541465"></p>
<h4 id="7、自定义类的加载器"><a href="#7、自定义类的加载器" class="headerlink" title="7、自定义类的加载器"></a>7、自定义类的加载器</h4><h5 id="1、为什么要自定义类加载器"><a href="#1、为什么要自定义类加载器" class="headerlink" title="1、为什么要自定义类加载器?"></a>1、为什么要自定义类加载器?</h5><ul>
<li><strong>隔离加载类</strong><ul>
<li><strong>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境</strong>。</li>
<li>比如：阿里内某容器框架通过自定义类加载器确保<strong>应用中依赖的jar包不会影响到中间件运行时使用的jar包</strong>。</li>
<li>再比如：<strong>Tomcat</strong>这类Web应用服务器，内部自定义了好几种类加载器，<strong>用于隔离同一个Web应用服务器上的不同应用程序</strong>。</li>
</ul>
</li>
<li><strong>修改类加载的方式</strong><ul>
<li>类的加载模型并非强制，除Bootstrap外， 其他的加载并非一定要引入，或者<strong>根据实际情况在某个时间点进行按需进行动态加载</strong></li>
</ul>
</li>
<li><strong>扩展加载源</strong><ul>
<li>比如<strong>从数据库、网络、甚至是电视机机顶盒进行加载</strong></li>
</ul>
</li>
<li><strong>防止源码泄漏</strong><ul>
<li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，<strong>还原加密的字节码</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、常见的场景："><a href="#2、常见的场景：" class="headerlink" title="2、常见的场景："></a>2、常见的场景：</h5><ul>
<li>实现类似<strong>进程内隔离</strong>，<strong>类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果</strong>。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是<code>Java EE</code>和<code>OSGI</code>、<code>JPMS</code>等框架。</li>
<li><strong>应用需要从不同的数据源获取类定义信息</strong>，例如<strong>网络数据源</strong>，而不是本地文件系统。或者是需要<strong>自己操纵字节码，动态修改或者生成类型</strong>。</li>
</ul>
<h5 id="3、注意-1"><a href="#3、注意-1" class="headerlink" title="3、注意"></a>3、注意</h5><p>在一般情况下，<strong>使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性</strong>。但是，如果涉及<strong>Java类型转换</strong>则加载器反而容易产生不美好的事情。<strong>在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常</strong>。(两个不同的类加载器加载同一个class文件，得到的两个类，虽然表面上看上去是一样的，但是却是不一样的两个类。当在进行类型转换的时候会抛异常)。</p>
<h5 id="4、自定义类加载器的实现方式"><a href="#4、自定义类加载器的实现方式" class="headerlink" title="4、自定义类加载器的实现方式"></a>4、自定义类加载器的实现方式</h5><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
<h6 id="1、实现方式："><a href="#1、实现方式：" class="headerlink" title="1、实现方式："></a>1、实现方式：</h6><ul>
<li>Java提供了抽象类java.lang.ClassLoader，<strong>所有用户自定义的类加载器都应该继承ClassLoader类</strong>。</li>
<li>在自定义ClassLoader的子类时候，我们常见的会有两种做法：<ol>
<li>方式一：<strong>重写loadClass()方法</strong>（JDK1.2以前）</li>
<li>方式二：<strong>重写findClass()方法</strong> –&gt;推荐（JDK1.2以后）</li>
</ol>
</li>
</ul>
<h6 id="2、对比"><a href="#2、对比" class="headerlink" title="2、对比"></a>2、对比</h6><p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()， 但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<ul>
<li><strong>loadClass()这个方法是实现双亲委派模型逻辑的地方</strong>，擅自修改这个方法会导致模型被破坏，容易造成问题。<strong>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</strong>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以<strong>在程序中调用loadClass()方法来实现类加载操作</strong>。</li>
</ul>
<h6 id="3、说明"><a href="#3、说明" class="headerlink" title="3、说明"></a>3、说明</h6><ul>
<li><strong>其父类加载器是系统类加载器</strong></li>
<li><strong>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口</strong>(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
<li>如果你不想重写findClass()当中流相关的代码，同时也没什么需要改动的地方。可以尝试不去继承ClassLoader抽象类，而去继承抽象类ClassLoader的子类URLClassLoader，里面帮我们重写了findClass()方法。</li>
</ul>
<h6 id="4、实现代码"><a href="#4、实现代码" class="headerlink" title="4、实现代码"></a>4、实现代码</h6><p>自定义类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义类加载器的重点：重写findClass()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取字节码文件的完整路径</span></span><br><span class="line">            String fileName = byteCodePath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">//获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            <span class="comment">//获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">//具体读入数据并写出的过程</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span></span><br><span class="line">            Class clazz = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试自定义类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将class文件放在了D盘下</span></span><br><span class="line">        MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 需要加载的class文件名：Demo1</span></span><br><span class="line">            Class clazz = loader.loadClass(<span class="string">&quot;Demo1&quot;</span>);</span><br><span class="line">            <span class="comment">// 加载此类的类的加载器为: com.atguigu.java2.MyClassLoader</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());</span><br><span class="line">			<span class="comment">// 加载当前Demo1类的类的加载器的父类加载器为: sun.misc.Launcher$AppClassLoader(系统类加载器)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载当前Demo1类的类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>需要将要加载的字节码文件放在一个文件下，或者重新javac编译一下源文件</li>
<li>不然的话JVM依旧会使用系统加载器去加载你的class文件（因为你的class文件在系统加载器的加载的目录下）</li>
</ul>
<h4 id="8、Java9新特性"><a href="#8、Java9新特性" class="headerlink" title="8、Java9新特性"></a>8、Java9新特性</h4><p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li><p><strong>扩展机制被移除</strong>，<strong>扩展类加载器</strong>由于向后兼容性的原因被保留，不过<strong>被重命名为平台类加载器</strong>(platform class loader)。<strong>可以通过ClassLoader的新方法getPlatformClassLoader()来获取</strong>。(JDK9之前只能获取到系统类加载器，再通过系统类获取扩展类加载器，现在是直接可以获取到平台类加载器)</p>
<ul>
<li>JDK 9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs 系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</JAVA_HOME></li>
</ul>
</li>
<li><p><strong>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader</strong>。</p>
<ul>
<li><p>现在**启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210524172221156.png" alt="image-20210524172221156"></p>
</li>
<li><p><strong>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader 类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃</strong>。</p>
</li>
</ul>
</li>
<li><p>在Java 9中，<strong>类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取</strong>。</p>
<ul>
<li>平台类加载器的名称是platform</li>
<li>应用类加载器的名称是app</li>
</ul>
<p>类加载器的名称<strong>在调试与类加载器相关的问题时会非常有用</strong>。</p>
</li>
<li><p><strong>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器(以前是C++实现)，但为了与之前代码兼容在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例</strong>。</p>
</li>
<li><p>类加载的委派关系也发生了变动：</p>
<ul>
<li>当平台及应用程序类加载器收到类加载请求，<strong>在委派给父加载器加载前</strong>，要<strong>先判断该类是否能够归属到某一个系统模块中</strong>，如果可以找到这样的归属关系，就要<strong>优先委派给负责那个模块的加载器完成加载</strong>。</li>
</ul>
</li>
<li><p>双亲委派模式示意图：</p>
<p><img src="/2021/04/19/JVM/29CF69BE-5F92-444B-82CE-6B1AE51C023D.png" alt="img"></p>
</li>
<li><p>相关代码：（环境：JDK9）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        <span class="comment">// jdk.internal.loader.ClassLoaders$PlatformClassLoader@e73f9ac</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">// null</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称 app</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>附加：在Java模块化系统明确规定了三个类加载器负责各自加载的模块：</p>
<ul>
<li><p>启动类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524173906468.png" alt="image-20210524173906468"></p>
</li>
<li><p>平台类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524174130765.png" alt="image-20210524174130765"></p>
</li>
<li><p>应用程序类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524174026119.png" alt="image-20210524174026119"></p>
</li>
</ul>
</li>
</ol>
<h4 id="9、大厂面试题"><a href="#9、大厂面试题" class="headerlink" title="9、大厂面试题"></a>9、大厂面试题</h4><ul>
<li>蚂蚁金服：<ul>
<li>深入分析ClassLoader，双亲委派机制</li>
<li>类加载器的双亲委派模型是什么?</li>
<li>一面：双亲委派机制及使用原因</li>
</ul>
</li>
<li>百度：<ul>
<li>都有哪些类加载器，这些类加载器都加载哪些文件?</li>
<li>手写一个类加载器Demo</li>
<li>Class的forName(“java.lang.String”)和Class的getClassLoader()的loadClass(“java.lang.String”)有什么区别?</li>
</ul>
</li>
<li>腾讯：<ul>
<li>什么是双亲委派模型?</li>
<li>类加载器有哪些?</li>
</ul>
</li>
<li>小米：<ul>
<li>双亲委派模型介绍一下</li>
</ul>
</li>
<li>滴滴：<ul>
<li>简单说说你了解的类加载器</li>
<li>一面：讲一下双亲委派模型，以及其优点</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>什么是类加载器，类加载器有哪些?</li>
</ul>
</li>
<li>京东：<ul>
<li>类加载器的双亲委派模型是什么?</li>
<li>双亲委派机制可以打破吗?为什么</li>
</ul>
</li>
</ul>
<h2 id="下篇：性能监控与调优篇"><a href="#下篇：性能监控与调优篇" class="headerlink" title="下篇：性能监控与调优篇"></a>下篇：性能监控与调优篇</h2><h3 id="1、概述篇"><a href="#1、概述篇" class="headerlink" title="1、概述篇"></a>1、概述篇</h3><h4 id="1、背景说明"><a href="#1、背景说明" class="headerlink" title="1、背景说明"></a>1、背景说明</h4><ol>
<li>生产环境中的问题<ul>
<li>生产环境发生了内存溢出该如何处理</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境CPU负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加log，如何确定请求是否执行了某一行代码？</li>
<li>不加log，如何实时查看某个方法的入参与返回值？</li>
</ul>
</li>
<li>为什么要调优<ul>
<li>防止出现OOM</li>
<li>解决OOM</li>
<li>减少Full GC出现的频率</li>
</ul>
</li>
<li>不同阶段的考虑<ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现OOM</li>
</ul>
</li>
</ol>
<h4 id="2、调优概述"><a href="#2、调优概述" class="headerlink" title="2、调优概述"></a>2、调优概述</h4><ol>
<li>监控的依据<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
</li>
<li>调优的大方向<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行JVM调优</li>
</ul>
</li>
</ol>
<h4 id="3、性能优化的步骤"><a href="#3、性能优化的步骤" class="headerlink" title="3、性能优化的步骤"></a>3、性能优化的步骤</h4><h5 id="1、第1步（发现问题）：性能监控"><a href="#1、第1步（发现问题）：性能监控" class="headerlink" title="1、第1步（发现问题）：性能监控"></a>1、第1步（发现问题）：性能监控</h5><p>一种以<strong>非强行</strong>或者入侵方式<strong>收集或查看</strong>应用运营性能数据的活动。<br>监控通常是指一种在生产、 质量评估或者开发环境下实施的带有<strong>预防或主动性</strong>的活动。<br>当应用相关干系人提出性能问题却<strong>没有提供足够多的线索</strong>时，首先我们需要进行性能监控，随后是性能分析。</p>
<p>主要的问题有：</p>
<ul>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<h5 id="2、第2步（排查问题）：性能分析"><a href="#2、第2步（排查问题）：性能分析" class="headerlink" title="2、第2步（排查问题）：性能分析"></a>2、第2步（排查问题）：性能分析</h5><p>一种以<strong>侵入方式</strong>收集运行性能数据的活动，它会影响应用的吞吐量或响应性。<br>性能分析是针对性能问题的答复结果，关注的范围通常比性能监控更加集中。<br>性能分析很少在生产环境下进行，通常是在<strong>质量评估、系统测试或者开发环境</strong>下进行，是性能监控之后的步骤。</p>
<p>主要的手段：</p>
<ul>
<li>打印GC日志，通过GCviewer或者<a target="_blank" rel="noopener" href="http://gceasy.io来分析异常信息/">http://gceasy.io来分析异常信息</a></li>
<li>灵活运用命令行工具、jstack、jmap、jinfo等</li>
<li>dump出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li>
<li>jstack查看堆栈信息</li>
</ul>
<h5 id="3、第3步（解决问题）：性能调优"><a href="#3、第3步（解决问题）：性能调优" class="headerlink" title="3、第3步（解决问题）：性能调优"></a>3、第3步（解决问题）：性能调优</h5><p>一种为改善应用响应性或香吐量而更改参数、源代码、属性配置的活动，性能调优<br>是在性能监控、性能分析之后的活动。</p>
<h4 id="4、性能评价-测试指标"><a href="#4、性能评价-测试指标" class="headerlink" title="4、性能评价/测试指标"></a>4、性能评价/测试指标</h4><ol>
<li><p><strong>停顿时间（或响应时间）</strong></p>
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间常用操作的响应时间列表：</p>
<p><img src="/2021/04/19/JVM/image-20210712014649029.png" alt="image-20210712014649029"></p>
<p>在垃圾回收环节中：暂停时间：<strong>执行垃圾收集时，程序的工作线程被暂停的时间（STW）</strong>。</p>
<ul>
<li>XX: MaxGCPauseMillis</li>
</ul>
</li>
<li><p><strong>吞吐量</strong></p>
<p>对单位时间内完成的工作量（请求）的量度</p>
<p>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间 + 内存回收的时间）</p>
<p><strong>吞吐量为1-1/(1+n)，其中-XX::GCTimeRatio=n</strong>（这个参数只有在G1才能设置）</p>
</li>
<li><p>并发数</p>
<p>同一时刻，对服务器有实际交互的请求数</p>
<p>大概的标准：1000个人同时在线，估计并发数在5% - 15%之间，也就是同时并发量： 50 - 150之间。</p>
</li>
<li><p>内存占用</p>
<p>Java堆区所占的内存大小</p>
</li>
</ol>
<ul>
<li>主要的指标有：响应时间和吞吐量</li>
<li>对于一个web应用关注的是：响应时间、吞吐量和并发数</li>
<li>对于GC的时候在意的数据</li>
</ul>
<p>响应时间、吞吐量和并发数相互间的关系（以高速公路通行状况为例）：</p>
<ul>
<li>吞吐量：每天通过高速公路收费站的车辆的数据(也可以理解为收费站收取的高速费)</li>
<li>并发数：高速公路上正在行驶的车辆的数目</li>
<li>响应时间：车速</li>
</ul>
<p>一开始的时候，高速公路上的车辆较少，车速较快，高速公路收费站收取的高速费较少——并发数少，响应时间快，吞吐量低</p>
<p>接着高速公路的车辆越来越多，车速变慢，高速公路收费站收取的高速费提高——并发数变多，响应时间变慢，吞吐量升高</p>
<p>随着高速公路的车辆越来越多，车速越来越慢，高速公路收费站收取的高速费降低——并发数越来越多，响应时间越来越慢，吞吐量降低</p>
<p>当高速公路的车辆发生事故，车速为0，高速公路收费站收取的高速费为0——并发数到顶，响应时间为0，吞吐量为0</p>
<h3 id="2、JVM监控及诊断工具——命令行篇"><a href="#2、JVM监控及诊断工具——命令行篇" class="headerlink" title="2、JVM监控及诊断工具——命令行篇"></a>2、JVM监控及诊断工具——命令行篇</h3><h4 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h4><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p>
<p>Java作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成Java应用出现性能问题的因素非常多，例如<strong>线程控制</strong>、<strong>磁盘读写</strong>、<strong>数据库访问</strong>、<strong>网络I/O</strong>、<strong>垃圾收集</strong>等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p>
<ul>
<li>体会1：<strong>使用数据说明问题，使用知识分析问题，使用工具处理问题</strong>。</li>
<li>体会2：<strong>无监控、不调优!</strong></li>
</ul>
<p><strong>简单命令行工具：</strong></p>
<p>在我们刚接触java学习的时候，大家肯定最先了解的两个命令就是javac、java，那么除此之外，还有没有其他的命令可以供我们使用呢?</p>
<p>我们进入到安装jdk的bin目录，发现还有一系列辅助工具。这些辅助工具用来获取目标JVM不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。这些辅助工具都是一个.exe的可执行文件的方式，若想要找到他的来源：jdk &gt; jdk1.8.0_131 &gt; lib &gt; tool.jar包当中（都是一些.class文件）。<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">相关源码</a>：一般不需要我们去查看源码，除非你有特殊需求，需要自己书写修改源码。</p>
<p>mac系统：</p>
<p><img src="/2021/04/19/JVM/image-20210712021836021.png" alt="image-20210712021836021"></p>
<p>windows系统：</p>
<p><img src="/2021/04/19/JVM/image-20210712021909775.png" alt="image-20210712021909775"></p>
<h4 id="2、jps：查看正在运行的Java进程"><a href="#2、jps：查看正在运行的Java进程" class="headerlink" title="2、jps：查看正在运行的Java进程"></a>2、jps：查看正在运行的Java进程</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程(查看虚拟机进程信息)，可用于查询正在运行的虚拟机进程。</p>
<p>说明：</p>
<ul>
<li>对于本地虛拟机进程来说，<strong>进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的</strong>。</li>
<li>jps只对于在java HotSpot虚拟机运行的进程。</li>
</ul>
<h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jps [options] [hostid]</p>
<p>我们还可以通过追加参数，来打印额外的信息。可以通过 <code>jps -help</code> 来查看对应的参数信息</p>
<ul>
<li><p>options参数</p>
<ul>
<li><p><code>-q</code>：<strong>仅仅显示</strong>LVMID (local virtual machine id)， 即<strong>本地虚拟机唯一id。不显示主类的名称等</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024008753.png" alt="image-20210712024008753"></p>
</li>
<li><p><code>-l</code>：输出<strong>应用程序主类的全类名</strong>或如果进程执行的是jar包，则输出<strong>jar完整路径</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024035710.png" alt="image-20210712024035710"></p>
</li>
<li><p><code>-m</code>：输出<strong>虚拟机进程启动时传递给主类main()的参数</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024528755.png" alt="image-20210712024528755"></p>
<p><img src="/2021/04/19/JVM/image-20210712024311552.png" alt="image-20210712024311552"></p>
<p><img src="/2021/04/19/JVM/image-20210712024430556.png" alt="image-20210712024430556"></p>
</li>
<li><p><code>-v</code>：列出<strong>虚拟机进程启动时的JVM参数</strong>。</p>
<ul>
<li>比如：- Xms20m - Xmx50m是启动程序指定的jvm参数。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210712024613610.png" alt="image-20210712024613610"></p>
<p><img src="/2021/04/19/JVM/image-20210712024715127.png" alt="image-20210712024715127"></p>
</li>
<li><p>说明：以上参数可以综合使用：</p>
<ul>
<li>-q指令单独使用（效果与其他三个相反），-lmv可以一起使用</li>
<li>jps -l -m 等价于 jps -lm</li>
<li>jps -l -m -v 等价于 jps -lmv</li>
<li>如果-q与其他三个指令综合使用的话：（以-l为例，其他两个类似）<ul>
<li>jps -q -l 等价于 jps -q（所以没什么必要，直接执行jps -q就行）</li>
<li>jps -ql：指令错误</li>
</ul>
</li>
<li>如何将信息输出到同级文件中：<ul>
<li>语法：命令 &gt; 文件名称</li>
<li>例如：jps -l &gt; a.txt</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li><p>如果某Java进程关闭了默认开启的UsePerfData参数(即使用参数<code>-XX: -UsePerfData</code>)，那么jps命令(以及下面介绍的jstat)将无法探知该<br>Java进程。</p>
<p><img src="/2021/04/19/JVM/image-20210712025059507.png" alt="image-20210712025059507"></p>
<p><img src="/2021/04/19/JVM/image-20210712025219254.png" alt="image-20210712025219254"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>hostid参数</p>
<ul>
<li>RMI注册表中注册的主机名。如果想要远程监控主机上的java 程序，需要安装jstatd。 </li>
<li>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管<strong>这种技术容易受到IP地址欺诈攻击</strong>。</li>
<li>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。</li>
</ul>
</li>
</ul>
<h5 id="3、相关测试"><a href="#3、相关测试" class="headerlink" title="3、相关测试"></a>3、相关测试</h5><p><img src="/2021/04/19/JVM/image-20210712022534826.png" alt="image-20210712022534826"></p>
<ul>
<li>10292：后面为空，查看任务管理器得知10292为操作系统为IDEA分配的进程ID，说明jps中后面为空的进程ID代表的就是IDEA进程（说明IDEA也是由java编写，运行在JVM虚拟机当中）</li>
<li>6328 ScannerTest：自己写的测试程序</li>
<li>14604 Jps：Jps本身的进程ID（说明在使用Jps的时候，Jps本身会创建一个进程）</li>
<li>2732 Launcher：JVM虚拟机的进程ID</li>
</ul>
<h4 id="3、jstat：查看JVM统计信息"><a href="#3、jstat：查看JVM统计信息" class="headerlink" title="3、jstat：查看JVM统计信息"></a>3、jstat：查看JVM统计信息</h4><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">官方文档</a></p>
<p>jstat(JVM Statistics Monitoring Tool)：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示<strong>本地或者远程虚拟机进程中的类装载、内存、垃圾收集、</strong><br><strong>JIT编译等运行数据</strong>。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。<strong>常用于检测垃圾回收问题以及内存泄漏问题</strong>。</p>
<h5 id="2、基本语法-1"><a href="#2、基本语法-1" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jstat -<option> [-t] [-h<lines>] <vmid> [ <interval> [ <count>]]</count></interval></vmid></lines></option></p>
<p>其中vmid是进程id号，也就是jps之后看到的前面的号码，如下：</p>
<p><img src="/2021/04/19/JVM/C0FE3B08-B6B9-4FF1-AB1A-CEEDCB5EFECF.png" alt="img"></p>
<p>查看命令相关参数：<code>jstat -h</code>或<code>jstat -help</code></p>
<ul>
<li><p>option参数</p>
<ul>
<li><p>类装载相关的：</p>
<ul>
<li><p><code>-class</code>：<strong>显示ClassLoader的相关信息</strong>：<strong>类的装载</strong>、<strong>卸载数量</strong>、<strong>总空间</strong>、<strong>类装载所消耗的时间</strong>等</p>
<p><img src="/2021/04/19/JVM/image-20210712225650046.png" alt="image-20210712225650046"></p>
<p>9000为进程ID（<vmid>）</vmid></p>
</li>
</ul>
</li>
<li><p>垃圾回收相关的：</p>
<ul>
<li><p><code>-gc</code>：<strong>显示与GC相关的堆信息</strong>。包括<strong>Eden区</strong>、<strong>两个Survivor区</strong>、<strong>老年代</strong>、<strong>永久代</strong>等的<strong>容量</strong>、<strong>已用空间</strong>、<strong>GC时间合计</strong>等信息。</p>
<p>其中设置了JVM参数：-Xms60m -Xmx60m -XX:SurvivorRatio=8</p>
<p><img src="/2021/04/19/JVM/image-20210712231844604.png" alt="image-20210712231844604"></p>
<ul>
<li>C：总容量\次数、U：使用的容量、S1\0：Survivor0\1区、E：伊甸园区、O：老年代、M：方法区、CCS：压缩类、YG：young GC、FG：full GC、GC：GC、T：时间</li>
<li>由于设置了-Xms60m -Xmx60m -XX:SurvivorRatio=8，即60M = 40M(Old) + 20M(young) 20M(young) = 16M(伊甸园区) + 2M(S0) + 2M(S1)</li>
<li>S0C：Survivor0区的容量：2M =2048</li>
<li>S1C：Survivor1区的容量：2M = 2048</li>
<li>S0U：Survivor0区使用的容量</li>
<li>S1U：Survivor1区使用的容量</li>
<li>EC：伊甸园区的容量:16M = 16384</li>
<li>EU：伊甸园区使用的容量</li>
<li>OC：老年代的容量：40M = 40960</li>
<li>OU：老年代使用的容量</li>
<li>MC：方法区的容量</li>
<li>MU：方法区使用的容量</li>
<li>CCSC：压缩类的容量</li>
<li>CCSU：压缩类使用的容量</li>
<li>YGC：young GC发生的次数</li>
<li>YGCT：发生young GC花费的时间</li>
<li>FGC：full GC发生的次数</li>
<li>FGCT：发生full GC花费的时间</li>
<li>GCT：用于GC的时间</li>
</ul>
</li>
<li><p><code>-gccapacity</code>：<strong>显示内容与<code>-gc</code>基本相同</strong>，但输出主要关注<strong>Java堆各个区域使用到的最大、最小空间</strong>。</p>
</li>
<li><p><code>-gcutil</code>：<strong>显示内容与<code>-gc</code>基本相同</strong>，但输出主要关注<strong>已使用空间占总空间的百分比</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712234001136.png" alt="image-20210712234001136"></p>
</li>
<li><p><code>-gccause</code>：<strong>与<code>-gcutil</code>功能一样</strong>，但是会额外输出<strong>导致最后一次或当前正在发生的GC产生的原因</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712234235632.png" alt="image-20210712234235632"></p>
</li>
<li><p><code>-gcnew</code>：<strong>显示新生代GC状况</strong></p>
</li>
<li><p><code>-gcnewcapacity</code>：<strong>显示内容与<code>-gcnew</code>基本相同</strong>，输出主要关注<strong>使用到的最大、最小空间</strong></p>
</li>
<li><p><code>-geold</code>：<strong>显示老年代GC状况</strong></p>
</li>
<li><p><code>-gcoldcapacity</code>：<strong>显示内容与<code>-gcold</code>基本相同</strong>，输出主要关注<strong>使用到的最大、最小空间</strong></p>
</li>
<li><p><code>-gcpermcapacity</code>：显示<strong>永久代使用到的最大、最小空间</strong>。</p>
</li>
</ul>
</li>
<li><p>JIT相关的：</p>
<ul>
<li><p><code>-compiler</code>：<strong>显示JIT编译器编译过的方法、耗时等信息</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712231535247.png" alt="image-20210712231535247"></p>
</li>
<li><p><code>-printcompilation</code>：<strong>输出已经被JIT编译的方法</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712231557164.png" alt="image-20210712231557164"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>interval参数：用于指定输出统计数据的周期，单位为毫秒。即：查询间隔。如果没加的话，<strong>默认查询1次</strong>，如果后面的count没有加的话，<strong>默认一直查询</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712230907909.png" alt="image-20210712230907909"></p>
</li>
<li><p>count参数：用于指定查询的总次数。在加上interval参数的情况下，没加count参数，默认一直查询</p>
<p><img src="/2021/04/19/JVM/image-20210712230944650.png" alt="image-20210712230944650"></p>
<p>每1s显示一次ClassLoader的相关信息，显示10次。</p>
</li>
<li><p>-t参数：可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p>
<p><img src="/2021/04/19/JVM/image-20210712231131085.png" alt="image-20210712231131085"></p>
<p><img src="/2021/04/19/JVM/image-20210712231246385.png" alt="image-20210712231246385"></p>
<ul>
<li><p>经验：</p>
<ul>
<li><p>我们可以比较Java进程的启动时间以及总GC时间(GCT列)，或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p>
</li>
<li><p>如果该比例超过20%，则说明目前堆的压力较大;如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。</p>
</li>
<li><p>我们执行jstat -gc -t 13152 1000 10，这代表1秒打印出1行，一共10行，-t代表打印出Timestamp总运行时间，结果如下所示：</p>
<p><img src="/2021/04/19/JVM/CB135068-C793-480B-9070-B48159AC6BC1.png" alt="img"></p>
<p>上方红色框框中代表Timestamp，而蓝色框框中代表垃圾回收时间，单位都是秒，如果让红色框框中的某两个值相减，假设这个值是num1，然后让对应行的蓝色框框中的另外两个值相减，假设这个值是num2，之后让num2/num1，得出的差值就是上述所说的GC时间占运行时间的比例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>h参数：可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<p><img src="/2021/04/19/JVM/image-20210712231441369.png" alt="image-20210712231441369"></p>
</li>
</ul>
<h5 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h5><p>jstat还可以用来判断是否出现内存泄漏。</p>
<ol>
<li>第1步：在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，<strong>并取这几行数据中OU列(即己占用的老年代内存)的最小值</strong>。</li>
<li>第2步：然后，我们<strong>每隔一段较长的时间重复一次上述操作</strong>，来<strong>获得多组OU最小值</strong>。如果这些值<strong>呈上涨趋势</strong>，则说明<strong>该Java程序的老年代内存已使用量在不断上涨</strong>，这意味着<strong>无法回收的对象在不断增加</strong>，因此很<strong>有可能存在内存泄漏</strong>。</li>
</ol>
<h4 id="4、jinfo：实时查看和修改JVM配置参数"><a href="#4、jinfo：实时查看和修改JVM配置参数" class="headerlink" title="4、jinfo：实时查看和修改JVM配置参数"></a>4、jinfo：实时查看和修改JVM配置参数</h4><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">官方文档</a></p>
<p>jinfo(Configuration Info for Java)：<strong>查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数</strong>。</p>
<p>在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虛拟机参数的当前值。</p>
<p><img src="/2021/04/19/JVM/image-20210713000744298.png" alt="image-20210713000744298"></p>
<h5 id="2、基本语法-2"><a href="#2、基本语法-2" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jinfo [ options ] pid</p>
<p>说明：java进程ID必须要加上。</p>
<p>[options] :</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody><tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [+-]name</td>
<td>开启或关闭对应名称的参数<br>只有被标记为manageable的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>设定对应名称的参数</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody></table>
<ul>
<li><p>查看</p>
<ul>
<li><p>jinfo -sysprops 进程id：可以查看由System.getProperties()取得的参数</p>
<p>进程id可以通过jps命令查看，操作结果如下：（其中13152代表进程id）</p>
<p><img src="/2021/04/19/JVM/4512D1D8-6DD0-4602-A589-8F076993F3AB.png" alt="img"></p>
</li>
<li><p>jinfo -flags 进程id：查看曾经赋过值的一些参数</p>
<p>进程id可以通过jps命令查看，参数赋值的一部分是我们自己设置的，另外一部分是系统自动优化设置的参数信息，具体操作如下：（其中13152代表进程id）</p>
<p><img src="/2021/04/19/JVM/0FD1835A-DCB5-436F-9D51-650D789F530F.png" alt="img"></p>
</li>
<li><p>jinfo -flag 参数名称 进程id：查看某个java进程的具体参数信息</p>
<p>进程id可以通过jps命令查看具体操作如下：（其中3540代表进程id）</p>
<p><img src="/2021/04/19/JVM/image-20210713001051530.png" alt="image-20210713001051530"></p>
</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li><p>jinfo不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。但是，并非所有参数都支持动态修改。参数只有被标记为<code>manageable</code>的flag可以被实时修改其实，这个修改能力是极其有限的。</p>
</li>
<li><p>#可以查看被标记为manageable的参数：java -XX:+PrintFlagsFinal -version | grep manageable</p>
<p><img src="/2021/04/19/JVM/image-20210713001449847.png" alt="image-20210713001449847"></p>
</li>
<li><p>针对boolean类型</p>
<ul>
<li><p>jinfo -flag [+|-]参数名称 进程id</p>
<p><img src="/2021/04/19/JVM/image-20210713001553125.png" alt="image-20210713001553125"></p>
</li>
</ul>
</li>
<li><p>针对非boolean类型</p>
<ul>
<li><p>jinfo -flag 参数名称=参数值 进程id</p>
<p><img src="/2021/04/19/JVM/image-20210713001642300.png" alt="image-20210713001642300"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、拓展"><a href="#3、拓展" class="headerlink" title="3、拓展"></a>3、拓展</h5><ul>
<li><p>java -XX:+PrintFlagsInitial</p>
<p>查看所有JVM参数启动的初始值</p>
</li>
<li><p>java -XX:+PrintFlagsFinal</p>
<p>查看所有JVM参数的最终值</p>
<p><img src="/2021/04/19/JVM/image-20210713001929389.png" alt="image-20210713001929389"></p>
<p>值前面添加冒号<code>:</code>的是修改之后的值，没有添加的都是没有发生改变的初始值</p>
</li>
<li><p>java -参数名称:+PrintCommandLineFlags</p>
<p>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p>
</li>
</ul>
<h4 id="5、jmap：导出内存映像文件-amp-内存使用情况"><a href="#5、jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="5、jmap：导出内存映像文件&amp;内存使用情况"></a>5、jmap：导出内存映像文件&amp;内存使用情况</h4><h5 id="1、基本介绍-3"><a href="#1、基本介绍-3" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">官方帮助文档</a></p>
<p>jmap(JVM Memory Map)：作用方面是<strong>获取dump文件</strong> (堆转储快照文件，<strong>二进制文件</strong>)，它还可以获取<strong>目标Java进程的内存相关信息</strong>，包括<strong>Java堆各区域的使用情况</strong>、<strong>堆中对象的统计信息</strong>、<strong>类加载信息</strong>等。</p>
<p>开发人员可以在控制台中输入命令“jmap -help” 查阅jmap工具的具体使用方式和一些标准选项配置。</p>
<p><img src="/2021/04/19/JVM/image-20210713003354636.png" alt="image-20210713003354636"></p>
<h5 id="2、基本语法-3"><a href="#2、基本语法-3" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：</p>
<ul>
<li>jmap [option] <pid></pid></li>
<li>jmap [option] &lt;executable <core></core></li>
<li>jmap [option] [server_ id@]<remote server ip or hostname></remote></li>
</ul>
<p>其中的option包括：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成dump文件</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机对-dump选项没有任何响应的时候，强制执行生成dump文件</td>
</tr>
</tbody></table>
<ol>
<li>使用语法可以通过在DOS窗口中使用jmap/jmap -h/jmap -help查看jmap使用语法</li>
<li>文件名称代表可执行的代码，比如使用&gt; 文件名称来指定生成的dump文件的生成位置</li>
<li>[server_id@]是为远程连接准备的</li>
</ol>
<p>指令描述：</p>
<ul>
<li>**<code>-dump</code>**：生成Java堆转储快照：dump文件<ul>
<li>特别的：<code>-dump:live</code>只保存堆中的存活对象</li>
</ul>
</li>
<li>**<code>-heap</code>**：输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</li>
<li>**<code>-histo</code>**：输出堆中对象的同级信息，包括类、实例数量和合计容量<ul>
<li>特别的：<code>-histo:live</code>只统计堆中的存活对象</li>
</ul>
</li>
<li><code>-permstat</code>：以ClassLoader为统计口径输出永久代的内存状态信息<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-finalizerinfo</code>：显示在F-Queue中等待Finalizer线程执行finalize方法的对象<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-F</code>：当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-h | -help</code>：jamp工具使用的帮助命令</li>
<li><code>-J &lt;flag&gt;</code>：传递参数给jmap启动的jvm</li>
</ul>
<h5 id="3、基本使用"><a href="#3、基本使用" class="headerlink" title="3、基本使用"></a>3、基本使用</h5><h6 id="1、使用1：导出内存映像文件"><a href="#1、使用1：导出内存映像文件" class="headerlink" title="1、使用1：导出内存映像文件"></a>1、使用1：导出内存映像文件</h6><p>一般来说，使用jmap指令生成dump文件的操作算得上是最常用的jmap命令之一，将堆中所有存活对象导出至一个文件之中。</p>
<p>Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在触发内存快照的时候会保存此刻的信息如下:</p>
<ul>
<li>All Objects<br>Class,fields,primitive values and references</li>
<li>All Classes<br>ClassLoader,name,super class,static fields</li>
<li>Garbage Collection Roots<br>Objects defined to be reachable by the JVM</li>
<li>Thread Stacks and Local Variables<br>The call-stacks of threads at the moment of the snapshot，and per-frame information about local objects</li>
</ul>
<p>说明：</p>
<ol>
<li>通常在写Heap Dump文件前会触发一次Full GC， 所以heap dump文件里保存的都是Full GC后留下的对象信息。</li>
<li>由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成。</li>
</ol>
<p>注意：</p>
<ol>
<li>对于以上说明中的第1点是自动方式才会这样做，而手动不会在Full GC之后生成Dump</li>
<li>使用手动方式生成dump文件，一般指令执行之后就会生成，不用等到快出现OOM的时候</li>
<li>使用自动方式生成dump文件，当出现OOM之前先生成dump文件</li>
<li>如果使用手动方式，一般使用第2种，毕竟生成堆中存活对象的dump文件是比较小的，便于传输和分析</li>
</ol>
<p>生成dump文件的方式：</p>
<ul>
<li><p>手动的方式</p>
<ul>
<li>jmap -dump:format=b,file=&lt;filename.hprof&gt; <pid></pid></li>
<li><strong>jmap -dump:live,format=b,file=&lt;filename.hprof&gt; <pid></pid></strong><ul>
<li>小结的内容</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>其中file=后面的是生成的dump文件地址，最后的11696是进程id，可以通过jps查看</li>
<li>filename中的filename是文件名称，而.hprof是后缀名，代表该值可以省略</li>
<li>format=b表示生成的是标准的dump文件，用来进行格式限定</li>
<li>一般使用的是第二种方式，也就是生成堆中存活对象的快照，毕竟这种方式生成的dump文件更小，我们传输处理都更方便</li>
</ul>
<p>具体例子如下：</p>
<p><img src="/2021/04/19/JVM/image-20210713010601073.png" alt="image-20210713010601073"></p>
</li>
<li><p>自动的方式</p>
<p>当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切。这里介绍一种比较常用的取得堆快照文件的方法，即使用：</p>
<ul>
<li><code>-XX: +HeapDumpOnOutOfMemoryError</code>：<strong>在程序发生OOM时，导出应用程序的当前堆快照</strong>。</li>
<li><code>-XX:HeapDumpPath</code>：可以<strong>指定堆快照的保存位置</strong>。</li>
<li>比如：<ul>
<li>-Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D: \m. hprof</li>
</ul>
</li>
<li>具体使用如下：</li>
</ul>
</li>
</ul>
<h6 id="2、使用2：显示堆内存相关信息"><a href="#2、使用2：显示堆内存相关信息" class="headerlink" title="2、使用2：显示堆内存相关信息"></a>2、使用2：显示堆内存相关信息</h6><ul>
<li><p>jmap -heap 进程id</p>
<ul>
<li><p><code>jmap -heap 进程id</code>只是时间点上的堆信息，而<code>jstat</code>后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具，例如<code>jvisualvm</code>等，它们可以用图表的方式动态展示出相关信息，更加直观明了。</p>
</li>
<li><p>使用例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713012001093.png" alt="image-20210713012001093"></p>
<p><img src="/2021/04/19/JVM/image-20210713012319564.png" alt="image-20210713012319564"></p>
<p><img src="/2021/04/19/JVM/image-20210713012602069.png" alt="image-20210713012602069"></p>
</li>
</ul>
</li>
<li><p>jmap -histo 进程id</p>
<ul>
<li><p>输出<strong>堆中对象的同级信息</strong>，包括<strong>类、实例数量和合计容量</strong>，也是<strong>这一时刻的内存中的对象信息</strong></p>
</li>
<li><p>使用例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713012043421.png" alt="image-20210713012043421"></p>
<p><img src="/2021/04/19/JVM/image-20210713012836602.png" alt="image-20210713012836602"></p>
</li>
</ul>
</li>
</ul>
<h6 id="3、使用3：其他作用"><a href="#3、使用3：其他作用" class="headerlink" title="3、使用3：其他作用"></a>3、使用3：其他作用</h6><ul>
<li>jmap -permstat 进程id<ul>
<li>查看系统的ClassLoader信息(永久代)</li>
</ul>
</li>
<li>jmap -finalizerinfo<ul>
<li>查看堆积在finalizer队列中的对象</li>
</ul>
</li>
</ul>
<p>这两个指令仅linux/solaris平台有效，所以无法在windows操作平台上演示，并且使用比较小众，不在多说</p>
<h5 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h5><p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要<strong>借助安全点机制</strong>，让所有线程停留在不改变堆中数据的状态。也就是说，<strong>由jmap导出的堆快照必定是安全点位置的</strong>。这可能导致<strong>基于该堆快照的分析结果存在偏差</strong>。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>-dump:live</code>选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。</p>
<p>与前面讲的jstat则不同，<strong>垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可</strong>。</p>
<h4 id="6、jhat：JDK自带堆分析工具"><a href="#6、jhat：JDK自带堆分析工具" class="headerlink" title="6、jhat：JDK自带堆分析工具"></a>6、jhat：JDK自带堆分析工具</h4><p>jhat命令在jdk9及其之后就被移除了，官方建议使用VisualVm代替jhat，所以该指令只需简单了解一下即可</p>
<h5 id="1、基本介绍-4"><a href="#1、基本介绍-4" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>jhat(JVM Heap Analysis Tool)：Sun JDK提供的<strong>jhat命令与jmap命令搭配使用</strong>，**用于分析jmap生成的heap dump文件(堆转储快照)**。</p>
<p>jhat内置了一个微型的HTTP/HTML服务器（会CPU造成一定的压力），生成dump文件的分析结果后，用户可以在浏览器中查看分析结果(分析虚拟机转储快照信息)。</p>
<p>使用了jhat命令， 就启动了一个http服务，端口是7000， 即<a target="_blank" rel="noopener" href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/，就可以在浏览器里分析。</a></p>
<p>说明：jhat 命令在JDK9、JDK10中已经被删除，官方建议用<code>VisualVM</code>代替。</p>
<p><img src="/2021/04/19/JVM/image-20210713015031277.png" alt="image-20210713015031277"></p>
<h5 id="2、基本语法-4"><a href="#2、基本语法-4" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jhat [option] [dumpfile]</p>
<p>其中dumpfile代表dump文件的地址以及名称，例如：jhat d:\1.hprof</p>
<p>option参数：</p>
<ul>
<li><code>-stack false|true</code>：关闭|打开对象分配调用栈跟踪</li>
<li><code>-refs false|true</code>：关闭|打开对象引用跟踪</li>
<li><code>-port port-number</code>：设置jhat HTTP Server的端口号，默认7000。例子：jhat -port 6565</li>
<li><code>-exclude exclude-file</code>：执行对象查询时需要排除的数据成员</li>
<li><code>-debug int</code>：设置debug级别</li>
<li><code>-version</code>：启动后显示版本信息就退出</li>
<li><code>-J&lt;flag&gt;</code>：传入启动参数，比如-J -Xmx512m</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713020055637.png" alt="image-20210713020055637"></p>
<p><img src="/2021/04/19/JVM/image-20210713020318845.png" alt="image-20210713020318845"></p>
<p><img src="/2021/04/19/JVM/image-20210713020411853.png" alt="image-20210713020411853"></p>
<p>注意：</p>
<ul>
<li><strong>使用jhat一次只能分析一个.hprof文件</strong>，如果要分析另外一个.hprof文件的话，需要将之前打开的jhat关闭。</li>
</ul>
<h4 id="7、jstack：打印JVM中线程快照"><a href="#7、jstack：打印JVM中线程快照" class="headerlink" title="7、jstack：打印JVM中线程快照"></a>7、jstack：打印JVM中线程快照</h4><h5 id="1、基本介绍-5"><a href="#1、基本介绍-5" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">官方帮助文档</a></p>
<p>jstack(JVM Stack Trace)：用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于<strong>定位线程出现长时间停顿的原因</strong>，如<strong>线程间死锁、死循环、请求外部资源导致的长时间等待</strong>等问题。这些都是导致线程长时间停顿的常见原因。<strong>当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况</strong>。</p>
<p>在thread dump中，要留意下面几种状态：</p>
<ul>
<li><strong>死锁：Deadlock (重点关注)</strong></li>
<li><strong>等待资源：Waiting on condition (重点关注)</strong></li>
<li><strong>等待获取监视器：Waiting on monitor entry (重点关注)</strong></li>
<li><strong>阻塞：Blocked (重点关注)</strong></li>
<li>执行中：Runnable</li>
<li>暂停：Suspended</li>
<li>对象等待中：Object.wait() 或 TIMED_WAITING</li>
<li>停止：Parked</li>
</ul>
<h5 id="2、基本语法-5"><a href="#2、基本语法-5" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p><img src="/2021/04/19/JVM/image-20210713022747670.png" alt="image-20210713022747670"></p>
<p>它的基本使用语法为：jstack option pid</p>
<p>jstack管理远程进程的话，需要在远程程序的启动参数中增加：</p>
<ul>
<li>-Djava.rmi.server.hostname=……</li>
<li>-Dcom.sun.management.jmxremote</li>
<li>-Dcom.sun.management.jmxremote.port=8888</li>
<li>-Dcom.sun.management.jmxremote.authenticate=false</li>
<li>-Dcom.sun.management.jmxremote.ssl=false</li>
</ul>
<p>总结：如果程序出现等待问题，可以使用该指令去查看问题所在，结果中也会提示你问题所在</p>
<p>option参数：</p>
<ul>
<li><code>-F</code>：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li><code>-l</code>：除堆栈外，显示关于锁的附加信息</li>
<li><code>-m</code>：如果调用本地方法的话，可以显示C/C++的堆栈</li>
<li><code>-h</code>：帮助操作</li>
</ul>
<p>在java层面实现jstack功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; all = Thread.getAllStackTraces(); <span class="comment">//追踪当前进程中的所有的线程</span></span><br><span class="line">Set&lt;Map.Entry&lt;Thread, StackTraceElement[]&gt;&gt; entries = all.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt; en : entries)&#123;</span><br><span class="line">	Thread t = en.getKey();</span><br><span class="line">    StackTraceElement[] v = en.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;【Thread name is :&quot;</span> + t.getName() + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(StackTraceElement s : v)&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;\t&quot;</span> + s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>死锁问题：</p>
<p><img src="/2021/04/19/JVM/image-20210713023139008.png" alt="image-20210713023139008"></p>
<p><img src="/2021/04/19/JVM/image-20210713025908544.png" alt="image-20210713025908544"></p>
<p><img src="/2021/04/19/JVM/image-20210713030226778.png" alt="image-20210713030226778"></p>
<p>使用sleep：</p>
<p><img src="/2021/04/19/JVM/image-20210713030341435.png" alt="image-20210713030341435"></p>
<p>同步问题：</p>
<p><img src="/2021/04/19/JVM/image-20210713030512538.png" alt="image-20210713030512538"></p>
<h4 id="8、jcmd：多功能命令行"><a href="#8、jcmd：多功能命令行" class="headerlink" title="8、jcmd：多功能命令行"></a>8、jcmd：多功能命令行</h4><h5 id="1、基本介绍-6"><a href="#1、基本介绍-6" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">官方帮助文档</a></p>
<p>在JDK 1.7以后，新增了一个命令行工具jcmd。</p>
<p>它是一个多功能的工具，可以用来实现前面除了jstat之外的所有命令的功能。比如：用它来导出堆、内存使用、查看java进程、导出线程信息、执行GC、JVM运行时间等等。</p>
<p>jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代替jmap命令。</p>
<h5 id="2、基本语法-6"><a href="#2、基本语法-6" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p><img src="/2021/04/19/JVM/image-20210713034508974.png" alt="image-20210713034508974"></p>
<ul>
<li><p>jcmd -l：列出所有的JVM进程</p>
</li>
<li><p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p>
<ul>
<li><p>执行效果：</p>
<p><img src="/2021/04/19/JVM/CAAD6BF7-147F-4BA5-9FCF-D2C3CE80AEB4.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>jcmd 进程号 具体命令：显示指定进程的指令命令的数据</p>
<ul>
<li>首先通过jcmd 进程号 help得出以下命令列表</li>
<li>根据以上命令来替换之前的那些操作：<ul>
<li>Thread.print 可以替换 jstack指令</li>
<li>GC.class_histogram 可以替换 jmap中的-histo操作</li>
<li>GC.heap_dump 可以替换 jmap中的-dump操作</li>
<li>GC.run 可以查看GC的执行情况</li>
<li>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的-t操作</li>
<li>VM.system_properties 可以替换 jinfo -sysprops 进程id</li>
<li>VM.flags 可以获取JVM的配置参数信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9、jstatd：远程主机信息收集"><a href="#9、jstatd：远程主机信息收集" class="headerlink" title="9、jstatd：远程主机信息收集"></a>9、jstatd：远程主机信息收集</h4><p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控(如jps、jstat)。为了启用远程监控，则需要配合使用jstatd 工具。</p>
<p>命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。 jstatd服务器将本机的Java应用程序信息传递到远程计算机。</p>
<p><img src="/2021/04/19/JVM/jstatd%E7%9A%84%E7%90%86%E8%A7%A3.png" alt="jstatd的理解"></p>
<h3 id="3、JVM监控及诊断工具——GUI篇"><a href="#3、JVM监控及诊断工具——GUI篇" class="headerlink" title="3、JVM监控及诊断工具——GUI篇"></a>3、JVM监控及诊断工具——GUI篇</h3><h4 id="1、工具概述"><a href="#1、工具概述" class="headerlink" title="1、工具概述"></a>1、工具概述</h4><p>使用上一章命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p>
<ol>
<li>无法获取<strong>方法级别</strong>的分析数据，如<strong>方法间的调用关系</strong>、<strong>各方法的调用次数</strong>和<strong>调用时间</strong>等(这对定位应用性能瓶颈至关重要)</li>
<li>要求用户登录到目标Java应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ol>
<p>为此，JDK提供 了一些内存泄漏的分析工具，如jconsole、jvisualvm等， 用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>图形化综合诊断工具</strong>：</p>
<ul>
<li>JDK自带的工具<ul>
<li><code>jconsole</code>：JDK自带的可视化监控工具。<strong>查看Java应用程序的运行概况、监控堆信息、永久区(或元空间)使用情况、类加载情况</strong>等<ul>
<li>位置：jdk\bin\jconsole.exe</li>
</ul>
</li>
<li><code>Visual VM</code>：Visual VM是一个工具，它提供了一个可视界面，<strong>用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息</strong>。<ul>
<li>位置: jdk\bin\jvisualvm.exe</li>
</ul>
</li>
<li><code>JMC</code>：Java Mission Control，<strong>内置<code>Java Flight Recorder</code>**。能够</strong>以极低的性能开销收集Java虚拟机的性能数据**。</li>
</ul>
</li>
<li>第三方工具<ul>
<li><code>MAT</code>：MAT(Memory Analyzer Tool) 是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们<strong>查找内存泄漏和减少内存消耗</strong><ul>
<li>Eclipse的插件形式</li>
</ul>
</li>
<li><code>JProfiler</code>：商业软件，需要付费。功能强大。<ul>
<li>与VisualVM类似</li>
</ul>
</li>
<li><code>Arthas</code>：<strong>Alibaba开源的Java诊断工具</strong>。深受开发者喜爱。</li>
<li><code>Btrace</code>：Java运行时追踪工具。<strong>可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2、JConsole"><a href="#2、JConsole" class="headerlink" title="2、JConsole"></a>2、JConsole</h4><h5 id="1、基本概述"><a href="#1、基本概述" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">官方教程</a></p>
<p>jconsole：</p>
<ul>
<li>从Java5开始，在JDK中自带的java监控和管理控制台。</li>
<li>用于对JVM中内存、线程和类等的监控，是一个基于JMX(java management extensions )的GUI性能监控工具。</li>
</ul>
<h5 id="2、启动"><a href="#2、启动" class="headerlink" title="2、启动"></a>2、启动</h5><ul>
<li>在jdk安装目录中找到jconsole.exe，双击该可执行文件就可以</li>
<li>打开DOS窗口，直接输入jconsole就可以了</li>
</ul>
<h5 id="3、三种连接方式"><a href="#3、三种连接方式" class="headerlink" title="3、三种连接方式"></a>3、三种连接方式</h5><ul>
<li><p>Local</p>
<ul>
<li><p>使用JConsole连接一个正在本地系统运行的JVM，并且执行程序的和运行JConsole的需要是<strong>同一个用户</strong>。</p>
</li>
<li><p>JConsole使用文件系统的授权通过RMI连接起链接到平台的MBean的服务器上。这种从本地连接的监控能力只有Sun的JDK具有。</p>
</li>
<li><p>注意：本地连接要求 <strong>启动jconsole的用户</strong> 和 <strong>运行当前程序的用户</strong> 是<strong>同一个用户</strong></p>
</li>
<li><p>具体操作如下：</p>
<ol>
<li><p>在DOS窗口中输入jconsole</p>
<p><img src="/2021/04/19/JVM/A0E6C592-F80C-46EF-9CD8-23255A6B1345.png" alt="img"></p>
</li>
<li><p>在控制台上填写相关信息</p>
<p><img src="/2021/04/19/JVM/868C881D-5F82-440F-B003-DD32C76BFF1D.png" alt="img"></p>
</li>
<li><p>选择“不安全的连接”</p>
<p><img src="/2021/04/19/JVM/D561C7B9-0F68-4DFC-AEB1-5F2526224F7D.png" alt="img"></p>
</li>
<li><p>进入控制台页面</p>
<p><img src="/2021/04/19/JVM/BE7AB453-2FD4-4173-A849-7D3848CB8076.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Remote</p>
<ul>
<li>使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi/rmi://hostName:portNum/jmxrmi。</li>
<li>JConsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名和密码，从而进行授权。</li>
</ul>
</li>
<li><p>Advanced</p>
<ul>
<li>使用一个特殊的URL连接JMX代理。</li>
<li>一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用</li>
</ul>
</li>
</ul>
<h5 id="4、主要作用"><a href="#4、主要作用" class="headerlink" title="4、主要作用"></a>4、主要作用</h5><ol>
<li><p>概览</p>
<p><img src="/2021/04/19/JVM/325B8E74-20E5-4289-A7C6-145D73501D7E.png" alt="img"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/image-20210716160243770.png" alt="image-20210716160243770"></p>
</li>
<li><p>根据线程检测死锁</p>
<p><img src="/2021/04/19/JVM/1F2A8CD4-75F7-48CF-8009-88508BDAB8C9.png" alt="img"></p>
</li>
<li><p>线程</p>
<p><img src="/2021/04/19/JVM/E617AFA7-4D51-41B9-97D4-2DA665C649B0.png" alt="img"></p>
</li>
<li><p>VM 概要</p>
<p><img src="/2021/04/19/JVM/799061CC-841C-475A-8B05-9DB923786A25.png" alt="img"></p>
</li>
</ol>
<h4 id="3、Visual-VM"><a href="#3、Visual-VM" class="headerlink" title="3、Visual VM"></a>3、Visual VM</h4><h5 id="1、基本概述-1"><a href="#1、基本概述-1" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><ul>
<li><p>VisualVM是一个功能强大的多合一故障诊断和性能监控的可视化工具。</p>
</li>
<li><p>它集成了多个JDK命令行工具，使用VisualVM可用于显示虚拟机进程及进程的配置和环境信息(jps、jinfo)，监视应用程序的CPU、GC、堆、方法区及线程的信息(jstat、jstack)等， 也可以代替JConsole。</p>
</li>
<li><p>在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布(VisualVM在JDK/bin目录下)</p>
<ul>
<li>即:它完全免费。</li>
</ul>
</li>
<li><p>此外，Visual VM也可以作为独立的软件安装：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://visualvm.github.io/index.html">首页</a></p>
<p><img src="/2021/04/19/JVM/image-20210713172559297.png" alt="image-20210713172559297"></p>
</li>
</ul>
</li>
<li><p>使用：</p>
<ol>
<li>在jdk安装目录中找到jvisualvm.exe，然后双击执行即可</li>
<li>打开DOS窗口，输入jvisualvm就可以打开该软件</li>
</ol>
</li>
</ul>
<h5 id="2、插件的安装"><a href="#2、插件的安装" class="headerlink" title="2、插件的安装"></a>2、插件的安装</h5><ul>
<li><p>Visual VM的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件*.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下，在线安装插件。(这里建议安装上：VisualGC)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://visualvm.github.io/pluginscenters.html">插件地址</a></li>
<li><img src="/2021/04/19/JVM/image-20210713173016278.png" alt="image-20210713173016278"></li>
</ul>
</li>
<li><p>IDEA安装VisualVM Launcher插件：Preferences –&gt; Plugins –&gt; 搜索VisualVM Launcher，安装重启即可。</p>
<ol>
<li><p>在IDEA中安装插件：首先在IDEA中搜索VisualVM Launcher插件并安装</p>
<p><img src="/2021/04/19/JVM/7A9DB07F-B142-443B-AE82-3D622F681CBB.png" alt="img"></p>
</li>
<li><p>重启IDEA，然后配置该插件：</p>
<p><img src="/2021/04/19/JVM/2E657142-FEFF-46CA-9772-630EF5F6625B.png" alt="img"></p>
</li>
<li><p>使用两种方式来运行程序：</p>
<p><img src="/2021/04/19/JVM/341C9DA7-8275-45B7-B3E3-4FBF924B3C14.png" alt="img"></p>
</li>
<li><p>运行效果：还是打开jvisualvm界面，只是不需要我们手动打开jvisualvm而已</p>
</li>
</ol>
</li>
</ul>
<h5 id="3、连接方式"><a href="#3、连接方式" class="headerlink" title="3、连接方式"></a>3、连接方式</h5><ul>
<li>本地连接<ul>
<li>监控本地Java进程的CPU、类、线程等</li>
</ul>
</li>
<li>远程连接<ol>
<li>确定远程服务器的ip地址</li>
<li>添加JMX（通过JMX技术具体监控远程服务器哪个Java进程）</li>
<li><strong>修改bin/catalina.sh文件，连接远程的tomcat</strong></li>
<li>在…/conf中添加jmxremote.access和jmxremote.password文件</li>
<li><strong>将服务器地址改成公网ip地址</strong></li>
<li>设置阿里云安全策略和防火墙策略</li>
<li><strong>启动tomcat，查看tomcat启动日志和端口监听</strong></li>
<li><strong>JMX中输入端口号、用户名、密码登录</strong></li>
</ol>
</li>
</ul>
<h5 id="4、主要功能"><a href="#4、主要功能" class="headerlink" title="4、主要功能"></a>4、主要功能</h5><ol>
<li><p>生成/读取/对比堆内存快照</p>
<ul>
<li><p>生成堆内存快照：</p>
<ol>
<li><p>方式1：</p>
<p><img src="/2021/04/19/JVM/CE28D8DD-9A19-493F-95F7-9BD7B90988F3.png" alt="img"></p>
</li>
<li><p>方式2：</p>
<p><img src="/2021/04/19/JVM/CBC75128-C200-4DE3-A4B0-5DB55CB31DB5.png" alt="img"></p>
<p>注意：</p>
<p>生成堆内存快照如下图：<img src="/2021/04/19/JVM/C05DD49F-02F5-4718-87FD-0FB5823860BD.png" alt="img"></p>
<p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p>
<p><img src="/2021/04/19/JVM/A441FACD-AAB9-4EC2-B81E-3413BF211421.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>装入堆内存快照</p>
<p><img src="/2021/04/19/JVM/ED1AC2B2-9CF5-41BD-A261-9C7685316D70-1626169886879.png" alt="img"></p>
</li>
<li><p>dump文件对比</p>
<p><img src="/2021/04/19/JVM/image-20210716164337161.png" alt="image-20210716164337161"></p>
</li>
</ul>
</li>
<li><p>查看JVM参数和系统属性</p>
</li>
<li><p>查看运行中的虚拟机进程</p>
</li>
<li><p>生成/读取线程快照</p>
<ul>
<li><p>生成线程快照</p>
<ol>
<li><p>方式1：</p>
<p><img src="/2021/04/19/JVM/1FCBDF6F-9E41-4631-A0F8-9032E3B610F7.png" alt="img"></p>
</li>
<li><p>方式2：</p>
<ul>
<li><p>注意：</p>
<p>生成线程快照如下图：<img src="/2021/04/19/JVM/EBBFD997-9D8C-4B7C-BEAE-763BD685E5C3.png" alt="img"></p>
<p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p>
<p><img src="/2021/04/19/JVM/77171DE3-C335-4934-B071-4567BCB30DB9.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>装入线程快照</p>
<p><img src="/2021/04/19/JVM/E882B309-4E74-4877-B6F0-D6A0EE176B71.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>程序资源的实时监控</p>
</li>
<li><p>抽样器</p>
<ul>
<li><p>CPU</p>
<p><img src="/2021/04/19/JVM/image-20210716162615803.png" alt="image-20210716162615803"></p>
<p><img src="/2021/04/19/JVM/image-20210716163047115.png" alt="image-20210716163047115"></p>
<p><img src="/2021/04/19/JVM/image-20210716163251126.png" alt="image-20210716163251126"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/image-20210716163651100.png" alt="image-20210716163651100"></p>
<p><img src="/2021/04/19/JVM/image-20210716163925557.png" alt="image-20210716163925557"></p>
</li>
</ul>
</li>
<li><p>其他功能</p>
<ol>
<li>JMX代理连接</li>
<li>远程环境监控</li>
<li>CPU分析和内存分析</li>
</ol>
</li>
</ol>
<h4 id="4、Eclipse-MAT"><a href="#4、Eclipse-MAT" class="headerlink" title="4、Eclipse MAT"></a>4、Eclipse MAT</h4><h5 id="1、基本概述-2"><a href="#1、基本概述-2" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><p>MAT(Memory Analyzer Tool)工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况</p>
<p>MAT是基于Eclipse开发的， 不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。大家可以在<br><a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">下载</a>并使用MAT。</p>
<p><img src="/2021/04/19/JVM/image-20210713175646382.png" alt="image-20210713175646382"></p>
<p>只要确保机器上装有JDK并配置好相关的环境变量，MAT可正常启动。还可以在Eclipse中以插件的方式安装：</p>
<p><img src="/2021/04/19/JVM/image-20210713175744891.png" alt="image-20210713175744891"></p>
<p>注意：如果单独使用，那么解压即可用，不需要安装即可</p>
<h5 id="2、获取堆dump文件"><a href="#2、获取堆dump文件" class="headerlink" title="2、获取堆dump文件"></a>2、获取堆dump文件</h5><h6 id="1、dump文件内存"><a href="#1、dump文件内存" class="headerlink" title="1、dump文件内存"></a>1、dump文件内存</h6><p>MAT可以分析heap dump文件。 在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。</p>
<p>一般说来，这些内存信息包含：</p>
<ul>
<li><strong>所有的对象信息</strong>，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li><strong>所有的类信息</strong>，包括classloader、 类名称、父类、静态变量等GCRoot到所有的这些对象的引用路径</li>
<li><strong>线程信息</strong>，包括线程的调用栈及此线程的线程局部变量(TLS)</li>
</ul>
<h6 id="2、两点说明"><a href="#2、两点说明" class="headerlink" title="2、两点说明"></a>2、两点说明</h6><ul>
<li><p>说明1：缺点：<br>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP所采用的HPROF二进制堆存储文件，以及IBM的PHD堆存储文件等都能被很好的解析。</p>
</li>
<li><p>说明2：<br>最吸引人的还是能够快速为开发人员生成<strong>内存泄漏报表</strong>，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p><img src="/2021/04/19/JVM/image-20210713180221126.png" alt="image-20210713180221126"></p>
</li>
</ul>
<h6 id="3、获取dump文件"><a href="#3、获取dump文件" class="headerlink" title="3、获取dump文件"></a>3、获取dump文件</h6><ol>
<li><p>方法一：通过前一章介绍的jmap工具生成，可以生成任意一个java进程的dump文件；</p>
</li>
<li><p>方法二：通过配置JVM参数生成。</p>
<ul>
<li>选项”<code>-XX:+HeapDumpOnOutOfMemoryError</code>“ 或”<code>-XX:+HeapDumpBeforeFullGC</code>“</li>
<li>选项”<code>-XX:HeapDumpPath</code>“所代表的含义就是当程序出现0utofMemory时， 将会在相应的目录下生成一份dump文件。如果不指定选项“<code>-XX:HeapDumpPath</code>“ 则在当前目录下生成dump文件。</li>
<li>对比：考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此<strong>使用jmap+MAT工具是最常见的组合</strong>。</li>
</ul>
</li>
<li><p>方法三：使用VisualVM可以导出堆dump文件</p>
</li>
<li><p>方法四：使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照。该功能将借助jps列出当前正在运行的Java进程，以供选择并获取快照。</p>
<p><img src="/2021/04/19/JVM/image-20210713180452468.png" alt="image-20210713180452468"></p>
</li>
</ol>
<h5 id="4、加载dump文件"><a href="#4、加载dump文件" class="headerlink" title="4、加载dump文件"></a>4、加载dump文件</h5><p><img src="/2021/04/19/JVM/image-20210716175656605.png" alt="image-20210716175656605"></p>
<p><img src="/2021/04/19/JVM/image-20210716175803107.png" alt="image-20210716175803107"></p>
<p><img src="/2021/04/19/JVM/image-20210716180242326.png" alt="image-20210716180242326"></p>
<p>相关解释：</p>
<p><img src="/2021/04/19/JVM/image-20210716180320235.png" alt="image-20210716180320235"></p>
<ul>
<li>Leak Suspects Report（堆泄露疑点报告）：<ul>
<li>自动检查堆转储是否存在泄漏嫌疑。 报告哪些对象保持活动状态以及为什么它们没有被垃圾回收器回收。</li>
</ul>
</li>
<li>Component Report（组件报告）：<ul>
<li>分析一组对象是否存在疑似内存问题：重复字符串、空集合、终结器、弱引用等</li>
</ul>
</li>
<li>Re-open previously run reports（重新打开以前运行的报告）：<ul>
<li>现有报告存储在堆dump同一目录下的 ZIP 文件中</li>
</ul>
</li>
</ul>
<h5 id="4、分析堆dump文件"><a href="#4、分析堆dump文件" class="headerlink" title="4、分析堆dump文件"></a>4、分析堆dump文件</h5><p>相关图例：</p>
<p><img src="/2021/04/19/JVM/B41B4FEA-D55D-442D-A163-E5D7F1BFC720.png" alt="img"><img src="/2021/04/19/JVM/EC747FF8-CCC3-4F57-8C68-59E5819C76A4.png" alt="img"><img src="/2021/04/19/JVM/D4FED4A9-A16E-4E4A-9ECB-69986F952F89.png" alt="img"></p>
<p>通过分析堆dump文件可以得到：</p>
<ul>
<li><p>是否存在类的重复加载：</p>
<p><img src="/2021/04/19/JVM/image-20210716183006378.png" alt="image-20210716183006378"></p>
</li>
<li><p>相关的报告：</p>
<p><img src="/2021/04/19/JVM/image-20210716181822026.png" alt="image-20210716181822026"></p>
<ul>
<li><p>Heap Dump Overview（堆dump的概述）：</p>
<p><img src="/2021/04/19/JVM/image-20210716182152051.png" alt="image-20210716182152051"></p>
</li>
<li><p>Leak Suspects（堆泄露疑点）:</p>
<p><img src="/2021/04/19/JVM/image-20210716182746036.png" alt="image-20210716182746036"></p>
</li>
<li><p>Top Components（顶级组件）：通过图形列举出最大对象的情况</p>
<p><img src="/2021/04/19/JVM/image-20210716182455029.png" alt="image-20210716182455029"></p>
</li>
</ul>
</li>
<li><p>histogram：展示了各个类的实例数目以及这些实例的Shallow heap或者Retained heap的总和</p>
<ul>
<li><p>使用：</p>
<ul>
<li><p>图标：</p>
<p><img src="/2021/04/19/JVM/87E5409D-B6AA-40E5-B033-6E92EB196C96.png" alt="img"></p>
</li>
<li><p>具体内容：</p>
<p><img src="/2021/04/19/JVM/287C8259-7835-4EF6-A81E-7C369B8D3336.png" alt="img"></p>
</li>
<li><p>查找一个类：</p>
<ol>
<li><p>Group by package (根据包进行分组)：（默认是Group by class）</p>
<p><img src="/2021/04/19/JVM/image-20210716223222052.png" alt="image-20210716223222052"></p>
<p><img src="/2021/04/19/JVM/image-20210716223315860.png" alt="image-20210716223315860"></p>
</li>
<li><p>排序：</p>
<p><img src="/2021/04/19/JVM/image-20210716223613860.png" alt="image-20210716223613860"></p>
</li>
<li><p>正则表达式：（精准搜索）</p>
<p><img src="/2021/04/19/JVM/image-20210716223803061.png" alt="image-20210716223803061"></p>
</li>
</ol>
</li>
<li><p>若一个对象可能存在内存泄露（内存泄露疑点），怎么查看？</p>
<p><img src="/2021/04/19/JVM/image-20210716224553500.png" alt="image-20210716224553500"></p>
</li>
<li><p>将两份内存映像文件的直方图进行对比：（以下图片的”树状图”修改为”直方图”）</p>
<p><img src="/2021/04/19/JVM/image-20210716225637523.png" alt="image-20210716225637523"></p>
<p><img src="/2021/04/19/JVM/image-20210716230023991.png" alt="image-20210716230023991"></p>
<p><img src="/2021/04/19/JVM/image-20210716230040409.png" alt="image-20210716230040409"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>thread overview</p>
<ul>
<li><p>查看系统中的Java线程</p>
</li>
<li><p>查看局部变量的信息</p>
</li>
<li><p>使用：</p>
<ul>
<li><p>图标：</p>
<p><img src="/2021/04/19/JVM/E9E4312D-A369-4C56-B612-DF6C90BD9A18.png" alt="img"></p>
</li>
<li><p>具体内容：</p>
<p><img src="/2021/04/19/JVM/9D534AD4-631B-4D78-865B-C793FC61B7C6.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/image-20210716232006164.png" alt="image-20210716232006164"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>获得对象互相引用的关系</p>
<ul>
<li><p>with outgoing references（出引用）</p>
<ul>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/ECADFB9B-708C-4CCC-82C5-8ECDFC6C8E98.png" alt="img"></p>
</li>
<li><p>结果：</p>
<p><img src="/2021/04/19/JVM/F9D58850-F866-4BA6-B5FB-B8508276B4C6.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>with incoming references（入引用）</p>
<ul>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/1EE1EDA8-FE05-4FBA-8D19-2518FCFCFD32.png" alt="img"></p>
</li>
<li><p>结果：</p>
<p><img src="/2021/04/19/JVM/9BA2E3BF-8700-4610-8A4D-45A3B662ACB1.png" alt="img"></p>
</li>
<li><p>分析：</p>
<ul>
<li>若发现此时该对象只有一些生命周期较短的线程(方法/方法里的引用变量)去引用它，则该对象就是可以被GC进行回收，不会存在内存泄露问题</li>
<li>若发现此时该对象还有另外一些生命周期较长的线程(方法/方法里的引用变量)去引用它，则该对象就不能被GC回收，就存在了内存泄露问题。</li>
<li>解决方法：可以将该引用从强引用修改为软引用或弱引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浅堆与深堆（与浅拷贝与深拷贝一一对应）</p>
<ul>
<li><p>shallow heap</p>
<ul>
<li><p>浅堆(Shallow Heap)是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会向8字节进行对齐。</p>
</li>
<li><p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。(jdk7中)</p>
<p><img src="/2021/04/19/JVM/image-20210713181653120.png" alt="image-20210713181653120"></p>
</li>
<li><p>这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
</li>
<li><p>对象头代表根据类创建的对象的对象头，还有对象的大小不是可能向8字节对齐，而是就向8字节对齐(一定)。</p>
</li>
<li><p>注意一下：这里对象头除去类型指针的大小为8字节，然后类型指针看是否启用了引用压缩，如果启用了，对象头总共就是12字节，否则就是16字节。（32位机是不支持指针压缩的）</p>
</li>
</ul>
</li>
<li><p>retained heap</p>
<ul>
<li>保留集(Retained Set)：<ul>
<li>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合(包括对象A本身)，即对象A的保留集可以被认为是<strong>只能通过</strong>对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指<strong>仅被对象A所持有的对象的集合</strong>。</li>
</ul>
</li>
<li>深堆(Retained Heap)：<ul>
<li>深堆是指<strong>对象的保留集中所有的对象的浅堆大小之和</strong>。</li>
<li>注意：<ul>
<li><strong>浅堆指对象本身占用的内存，不包括其内部引用对象的大小</strong>。<strong>一个对象的深堆指只能通过该对象访问到的(直接或间接)所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</strong>。</li>
<li><strong>当前深堆大小 = 当前对象的浅堆大小 + 对象中所包含对象的深堆大小</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：对象实际大小</p>
<ul>
<li><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象<strong>所能触及的</strong>（这里要与<strong>深堆的”只有通过”**相区分）所有对象的浅堆大小之和，也就是通常意义上我们说的</strong>对象大小<strong>。与深堆相比，似乎这个在日常开发中更为直观和被人接受，</strong>但实际上，这个概念和垃圾回收无关**。</p>
</li>
<li><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么<strong>对象A的<code>浅堆</code>大小只是A本身</strong>，不含C和D，而<strong>A的<code>实际大小</code>为A、C、D三者之和</strong>。而<strong>A的<code>深堆</code>大小为A与D之和</strong>，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>
<p><img src="/2021/04/19/JVM/image-20210713182436604.png" alt="image-20210713182436604"></p>
</li>
</ul>
</li>
<li><p>练习</p>
<ul>
<li><p>看图理解Retained Size</p>
<p><img src="/2021/04/19/JVM/image-20210713182530946.png" alt="image-20210713182530946"></p>
</li>
<li><p>解答：</p>
<ul>
<li>上图中，GC Roots直接引用了A和B两个对象。</li>
<li>A对象的Retained Size = A对象的Shallow Size</li>
<li>B对象的Retained Size = B对象的Shallow Size + C对象的Shallow Size</li>
<li>这里不包括D对象，因为D对象被GC Roots直接引用。</li>
</ul>
</li>
<li><p>如果GC Roots不引用D对象呢?</p>
<ul>
<li>那么B对象的Retained Size = B对象的Shallow Size + C对象的Shallow Size + D对象的Shallow Size</li>
<li>因为此时的D对象只有通过B对象进行引用</li>
</ul>
</li>
</ul>
</li>
<li><p>案例分析：StudentTrace</p>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span></span><br><span class="line"><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTrace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> ArrayList&lt;WebPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createWebPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            WebPage wp = <span class="keyword">new</span> WebPage();</span><br><span class="line">            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">            wp.setContent(Integer.toString(i));</span><br><span class="line">            webpages.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        createWebPages();<span class="comment">//创建了100个网页</span></span><br><span class="line">        <span class="comment">//创建3个学生对象</span></span><br><span class="line">        Student st3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Student st5 = <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Student st7 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)</span><br><span class="line">                st3.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)</span><br><span class="line">                st5.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)</span><br><span class="line">                st7.visit(webpages.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        webpages.clear();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WebPage&gt; <span class="title">getHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WebPage wp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            history.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/69656EBC-5090-4781-A02A-E1584AC06230.png" alt="img"></p>
</li>
<li><p>结论：</p>
<ul>
<li>这里三个学生对象的浅堆大小都是24字节：4(id) + 4(name) + 4(history) + 8(对象头) = 20 –&gt; 24（向8字节对齐）<ul>
<li>其实这里如果是32位虚拟机，需要补对齐填充。</li>
<li>但如果不是是32位虚拟机，而且存在类型指针压缩的话：对象头应该有12字节 –&gt; 4 + 4 + 4 + 12 = 24</li>
<li>普通Java对象头的大小为12字节或16字节，默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）</li>
<li>同理每一个网页的浅堆大小也都是24字节4(url) + 4(content) + 12(对象头) = 20 –&gt; 24（向8字节对齐）</li>
</ul>
</li>
</ul>
</li>
<li><p>解释：（为什么elementData数组的深堆为1288个字节）</p>
<ul>
<li>普通Java对象头的大小为12字节或16字节。默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。详情参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/shangshanzixu/article/details/114828860?spm=1001.2014.3001.5501">博客</a>。</li>
<li>为什么有152字节和144字节：<ul>
<li>因为我们的URL和content存在两种情况（个位数与十位数）<ul>
<li>URL：<a target="_blank" rel="noopener" href="http://www.7.com/">http://www.7.com</a>    content：7</li>
<li>URL：<a target="_blank" rel="noopener" href="http://www.14.com/">http://www.14.com</a>    content：14</li>
</ul>
</li>
<li>第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<ul>
<li>【普通对象头(12) + 数组长度(4)】 + 16个字符(32) = 48字节，符合8字节对齐</li>
<li>同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) = 18字节，八字节对齐 = 24字节</li>
</ul>
</li>
<li>第二种URL长度为17，底层的插入数组的占用空间为<ul>
<li>【普通对象头(12) + 数组长度(4)】 + 17个字符(34) = 50字节，不符合8字节对齐，对齐为56</li>
<li>同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) = 20字节，八字节对齐 = 24字节</li>
</ul>
</li>
<li>所以第一种总字节为48 + 24 = 72，第二种总字节为56 + 24 = 80。因此第二种比第一种多了8字节，所以是152和144</li>
<li>为什么总大小是152而不是72？<ul>
<li>因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆，因为结构都相同，所以差别就差在内容的占用上</li>
</ul>
</li>
</ul>
</li>
<li>为什么最终结果是1288？<ul>
<li>首先ElementData数组本身的浅堆大小为：【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用 = 15 * 4】 = 76，八字节对齐 = 80字节</li>
<li>15个Object分为13个152字节 + 2个144字节，总大小为 = 2264字节</li>
<li>7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144</li>
<li>所以2264 - 6 * 152 - 144 = 1208字节</li>
<li>所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 = 1288</li>
</ul>
</li>
<li>为什么ArrayList的长度是15？（并不是因为ArrayList的内容是15个，对于Jerry同学来说：ArrayList的长度是22，但是ArrayList的内容只有21）<ul>
<li>这是和ArrayList的扩容有关</li>
<li>ArrayList默认的长度为10，当长度超过10的时候，ArrayList就会自动扩容，扩容系数是0.5</li>
<li>即ArrayList的长度 = 10 * 1.5 = 15</li>
<li>当超过扩容后的长度（15），ArrayList会再次扩容：15 * 1.5 = 22</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支配树</p>
<ul>
<li><p>支配树(Dominator Tree )(支配树的概念源自图论（统计学）)</p>
</li>
<li><p>MAT提供了一个称为支配树(Dominator Tree) 的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，<strong>所有指向对象B的路径都经过对象A，则认为对象A支配对象B</strong>。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有<br>以下基本性质：</p>
<ul>
<li>对象A的子树(所有被对象A支配的对象集合)表示对象A的保留集(retained set)，即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
</li>
<li><p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对<br>象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。</p>
<p><img src="/2021/04/19/JVM/image-20210713185747798.png" alt="image-20210713185747798"></p>
</li>
<li><p>注意：</p>
<ul>
<li>跟随我一起来理解如何从“对象引用图—》支配树”，首先需要理解支配者（如果要到达对象B，毕竟经过对象A，那么对象A就是对象B的支配者，可以想到支配者大于等于1），</li>
<li>然后需要理解直接支配者（在支配者中距离对象B最近的对象A就是对象B的直接支配者，你要明白直接支配者不一定就是对象B的上一级，然后直接支配者只有一个），</li>
<li>然后还需要理解支配树是怎么画的，其实支配树中的对象与对象之间的关系就是直接支配关系，也就是上一级是下一级的直接支配者，只要按照这样的方式来作图，肯定能从“对象引用图 —》支配树”</li>
</ul>
</li>
<li><p>在Eclipse MAT工具中如何查看支配树：</p>
<ul>
<li><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开对象支配树视图。</p>
<p><img src="/2021/04/19/JVM/image-20210714000259424.png" alt="image-20210714000259424"></p>
</li>
<li><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。（15(总) - 7(被其他引用) = 8(可回收)）</p>
<p><img src="/2021/04/19/JVM/image-20210714000337354.png" alt="image-20210714000337354"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、案例：Tomcat堆溢出分析"><a href="#4、案例：Tomcat堆溢出分析" class="headerlink" title="4、案例：Tomcat堆溢出分析"></a>4、案例：Tomcat堆溢出分析</h5><ul>
<li><p>说明：</p>
<ul>
<li>Tomcat是最常用的Java Servlet容器之一 ， 同时也可以当做单独的Web服务器使用。Tomcat本身使用Java实现，并运行于Java虚拟机之上。在大规模请求时，Tomcat有可能会因为无法承受压力而发生内存溢出错误。这里根据一个被压垮的Tomcat的堆快照文件， 来分析Tomcat在崩溃时的内部情况。</li>
</ul>
</li>
<li><p>分析过程：</p>
<ul>
<li><p>查看大对象（主要分析的对象）：</p>
<p><img src="/2021/04/19/JVM/image-20210717034430939.png" alt="image-20210717034430939"></p>
</li>
<li><p>查看当前最大的对象它到底引用了哪些具体的内部结构：</p>
<p><img src="/2021/04/19/JVM/image-20210717034529989.png" alt="image-20210717034529989"></p>
</li>
<li><p>查看该大对象中哪一部分占用了大部分内存：</p>
<p><img src="/2021/04/19/JVM/image-20210717034627788.png" alt="image-20210717034627788"></p>
</li>
<li><p>继续往里查看：</p>
<p><img src="/2021/04/19/JVM/image-20210717034749850.png" alt="image-20210717034749850"></p>
</li>
<li><p>继续往里查看：</p>
<p><img src="/2021/04/19/JVM/image-20210717034836025.png" alt="image-20210717034836025"></p>
</li>
<li><p>找到出现问题的对象后，可以通过OOL语句查询出想要的对象</p>
<p><img src="/2021/04/19/JVM/C5ECFB6C-0D51-4735-964B-53A8E96BA1FB.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/D6A4483C-4844-4025-A499-C0A2AAC65C9E.png" alt="img"></p>
</li>
<li><p>查看该对象的创建时间与结束时间，判断他是不是一个生命周期短的对象：</p>
<p><img src="/2021/04/19/JVM/2E17C8C1-34ED-48A7-BDAA-3CB7AC33C1A6.png" alt="img"></p>
</li>
<li><p>根据找到的信息进行分析：</p>
<p><img src="/2021/04/19/JVM/57EE2C6A-DB93-46D3-9BD4-36799EA74836.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h5 id="5、支持使用OQL语言查询对象信息"><a href="#5、支持使用OQL语言查询对象信息" class="headerlink" title="5、支持使用OQL语言查询对象信息"></a>5、支持使用OQL语言查询对象信息</h5><p><img src="/2021/04/19/JVM/image-20210716181538800.png" alt="image-20210716181538800"></p>
<ul>
<li>SELECT子句</li>
<li>FROM子句</li>
<li>WHERE子句</li>
<li>内置对象与方法</li>
</ul>
<h4 id="5、JProfiler"><a href="#5、JProfiler" class="headerlink" title="5、JProfiler"></a>5、JProfiler</h4><h5 id="1、基本概述-3"><a href="#1、基本概述-3" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><h6 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h6><p><a target="_blank" rel="noopener" href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网下载地址</a></p>
<p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有Eclipse Memory Analyzer tool (MAT)插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。</p>
<p>JProfiler是由ej-technologies公司开发的一款Java应用性能诊断工具。功能强大，但是收费。</p>
<h6 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h6><ul>
<li>使用方便、界面操作友好( 简单且强大)</li>
<li>对被分析的应用影响小(提供模板)</li>
<li>CPU, Thread , Memory分析功能尤其强大</li>
<li>支持对jdbc、noSql、jsp、servlet、socket等进行分析</li>
<li>支持多种模式(离线，在线)的分析</li>
<li>支持监控本地、远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210717185256510.png" alt="image-20210717185256510"></p>
<h6 id="3、主要功能"><a href="#3、主要功能" class="headerlink" title="3、主要功能"></a>3、主要功能</h6><ol>
<li>方法调用<ul>
<li>对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
</ul>
</li>
<li>内存分配<ul>
<li>通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
</ul>
</li>
<li>线程和锁<ul>
<li>JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</li>
</ul>
</li>
<li>高级子系统<ul>
<li>许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li>
</ul>
</li>
</ol>
<h5 id="2、安装与配置"><a href="#2、安装与配置" class="headerlink" title="2、安装与配置"></a>2、安装与配置</h5><h6 id="1、下载与安装"><a href="#1、下载与安装" class="headerlink" title="1、下载与安装"></a>1、下载与安装</h6><p><a target="_blank" rel="noopener" href="https://www.ej-technologies.com/download/jprofiler/version_100">下载</a></p>
<p><img src="/2021/04/19/JVM/image-20210717190718552.png" alt="image-20210717190718552"></p>
<p><img src="/2021/04/19/JVM/image-20210717195706559.png" alt="image-20210717195706559"></p>
<h6 id="2、JProfiler中配置IDEA"><a href="#2、JProfiler中配置IDEA" class="headerlink" title="2、JProfiler中配置IDEA"></a>2、JProfiler中配置IDEA</h6><ol>
<li><p>IDE Integrations</p>
<p><img src="/2021/04/19/JVM/53F0D68B-B76A-42C8-B206-FBFBD8E96F86.png" alt="img"></p>
</li>
<li><p>选择合适的IDE版本</p>
<p><img src="/2021/04/19/JVM/7CCE5194-2D54-498E-A2B7-F2C52CB9FA44.png" alt="img"></p>
</li>
<li><p>开始集成</p>
<p><img src="/2021/04/19/JVM/2A83AB30-9586-4BA2-83C3-2CACA634B79B.png" alt="img"></p>
</li>
<li><p>正式集成</p>
<p><img src="/2021/04/19/JVM/2E384249-A75D-4F05-8921-D09FD08873D9.png" alt="img"></p>
</li>
<li><p>集成成功</p>
<p><img src="/2021/04/19/JVM/B8B68437-CC8B-4DA5-A498-4F8F784656B6.png" alt="img"></p>
</li>
<li><p>点击OK即可</p>
</li>
</ol>
<h6 id="3、IDEA集成JProfiler"><a href="#3、IDEA集成JProfiler" class="headerlink" title="3、IDEA集成JProfiler"></a>3、IDEA集成JProfiler</h6><ol>
<li><p>安装JProfiler插件</p>
<ol>
<li><p>方式1：在线安装</p>
<p><img src="/2021/04/19/JVM/74BCBC29-1574-45C9-9DAD-B02B2D93493C.png" alt="img"></p>
</li>
<li><p>方式2、离线安装</p>
<ol>
<li><p>首先下载插件：</p>
<p><img src="/2021/04/19/JVM/A496B566-DFF9-41E6-9F7E-C4665BF3D95C.png" alt="img"></p>
</li>
<li><p>准备离线安装：</p>
<p><img src="/2021/04/19/JVM/D2914CF9-9808-4C59-BADE-9C9ADBCAB41E.png" alt="img"></p>
</li>
<li><p>正式离线安装：</p>
<p><img src="/2021/04/19/JVM/947592B8-3F3F-4A6F-93BD-5443EB76F603.png" alt="img"></p>
</li>
</ol>
<p>注意：无论采用方式1还是方式2都需要重启IDEA</p>
</li>
</ol>
</li>
<li><p>将JProfiler配置到IDEA中</p>
<p><img src="/2021/04/19/JVM/D3C2F36C-E12B-45D2-8FA4-F9D8E4F95625.png" alt="img"></p>
</li>
</ol>
<h5 id="3、具体使用"><a href="#3、具体使用" class="headerlink" title="3、具体使用"></a>3、具体使用</h5><ul>
<li><p>启动：</p>
<p><img src="/2021/04/19/JVM/image-20210717220513329.png" alt="image-20210717220513329"></p>
<ul>
<li>相关说明：<ul>
<li>Profile a demo session or a saved session(配置demo会话或保存一个会话)：<ul>
<li>JProfiler附带了几个预先配置的演示会话。你可以让他们开始探索JProfiler的特征。</li>
</ul>
</li>
<li>Attach to a running JVM(连接到正在运行的JVM)：<ul>
<li>JProfiler可以连接到本地或远程运行的jvm，并动态地分析它们。一些附加模式下不支持功能。</li>
</ul>
</li>
<li>Profile an application server, locally or remotely(本地或远程配置应用程序服务器)：<ul>
<li>JProfiler提供了对所有主要应用服务器的广泛支持。两个应用服务器支持在此计算机和远程计算机上运行。</li>
</ul>
</li>
<li>Open a snapshot(打开快照)：<ul>
<li>JProfiler可以保存快照以及以后可以打开的所有分析结果。而且，它可以打开HPROF和PHD快照。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据采集方式</p>
<p><img src="/2021/04/19/JVM/image-20210717221829151.png" alt="image-20210717221829151"></p>
<ul>
<li>JProfier数据采集方式分为两种：<code>Sampling</code>(样本采集)和<code>Instrumentation</code> (重构模式)<ul>
<li><code>Instrumentation</code>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高(取决于Filter的控制)。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</li>
</ul>
</li>
<li><code>Sampling</code>：类似于样本统计，每隔一定时间(5ms )将每个线程栈中方法栈中的信息统计出来。<ul>
<li>优点：对CPU的开销非常低，对应用影响小(即使你不配置任何Filter)</li>
<li>缺点：一些数据/特性不能提供(例如：方法的调用次数、执行时间)</li>
</ul>
</li>
<li>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</li>
<li>推荐使用Sampling方式，足够用来分析OOM问题了</li>
</ul>
</li>
</ul>
</li>
<li><p>遥感监测 Telemetries</p>
<p><img src="/2021/04/19/JVM/85704C41-F30E-4ED9-B48B-605C3102B485.png" alt="img"></p>
<ul>
<li>其中Telemetries就是遥感监测的意思</li>
</ul>
</li>
<li><p>内存视图 Live Memory</p>
<ul>
<li><p>Live memory（内存剖析）：class/class instance的相关信息。例如对象的个数， 大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><p><strong>所有对象All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5 (JVMTI)才会显示此视图。(浅堆)</p>
<p><img src="/2021/04/19/JVM/image-20210717192307939.png" alt="image-20210717192307939"></p>
</li>
<li><p><strong>记录对象Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</p>
<ul>
<li><p>注意：默认关闭，若开启的话，会导致系统的性能急剧的降低。</p>
</li>
<li><p>开启的时机：判断内存泄露的时候开启</p>
</li>
<li><p>使用：</p>
<p><img src="/2021/04/19/JVM/image-20210717223524175.png" alt="image-20210717223524175"></p>
</li>
</ul>
</li>
<li><p><strong>分配访问树Allocation Call Tree</strong>：显示一棵请求树或者方法、 类、包或对己选择类有带注释的分配信息的J2EE组件。</p>
</li>
<li><p><strong>分配热点Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对<br>于每个热点都可以显示它的跟踪记录树。<br><strong>类追踪器Class Tracker</strong>：类跟踪视图可以包含任意数量的图表,显示选定的类和包的实例与时间。</p>
</li>
</ul>
</li>
<li><p>分析：内存中的对象的情况</p>
<ul>
<li>频繁创建的Java对象：死循环、循环次数过多</li>
<li>存在大的对象：读取文件时，byte[]应该边读边写。–&gt; 如果长时间不写出的话，导致byte[]过大</li>
<li>存在内存泄漏</li>
</ul>
</li>
<li><p>注意：</p>
<ol>
<li>All Objects后面的Size大小是浅堆大小</li>
<li>Record Objects在判断内存泄露的时候使用，可以通过观察Telemetries中的Memory，如果里面出现垃圾回收之后的内存占用逐步提高，这就有可能出现内存泄露问题，所以可以使用Record Objects查看，但是该分析默认不开启，毕竟占用CPU性能太多</li>
</ol>
</li>
</ul>
</li>
<li><p>堆遍历 heap walker</p>
<ul>
<li><p>如果通过内存视图 Live Memory已经分析出哪个类的对象不能进行垃圾回收，并且有可能导致内存溢出，如果想进一步分析，我们可以在该对象上点击右键，选择Show Selection In Heap Walker，如下图：</p>
<p><img src="/2021/04/19/JVM/C1C2C2AB-C31F-41A5-B0D2-7335030ECD2A.png" alt="img"></p>
</li>
<li><p>之后进行溯源，操作如下：</p>
<p><img src="/2021/04/19/JVM/64A630C1-126E-4C35-8088-4EEDDCF63FAE.png" alt="img"></p>
</li>
<li><p>查看结果，并根据结果去看对应的图表：</p>
<p><img src="/2021/04/19/JVM/1677A939-BCE7-45BC-901F-9BDA9846910D.png" alt="img"></p>
</li>
<li><p>以下是图表的展示情况：</p>
<p><img src="/2021/04/19/JVM/A3E2654E-81FF-4912-A588-549D817C69E0.png" alt="img"></p>
</li>
<li><p>对于堆快照：</p>
<p><img src="/2021/04/19/JVM/image-20210717224343240.png" alt="image-20210717224343240"></p>
</li>
</ul>
</li>
<li><p>cpu视图 cpu views</p>
<p><img src="/2021/04/19/JVM/image-20210717224827793.png" alt="image-20210717224827793"></p>
<ol>
<li><p>具体使用：</p>
<ol>
<li><p>访问树</p>
<p><img src="/2021/04/19/JVM/image-20210717225913334.png" alt="image-20210717225913334"></p>
</li>
<li><p>记录方法统计信息</p>
<p><img src="/2021/04/19/JVM/01B9832E-145E-485B-A877-6B6395B7FAA1.png" alt="img"></p>
</li>
<li><p>方法统计</p>
<p><img src="/2021/04/19/JVM/5FC6EA0C-FAF0-455C-94B6-8D9736E52657.png" alt="img"></p>
</li>
<li><p>具体分析</p>
<p><img src="/2021/04/19/JVM/510A019F-0C86-47FD-AC0B-CFEBC1B6C91C.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>线程视图 threads</p>
<ul>
<li><p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
</li>
<li><p>线程分析主要关心三个方面：</p>
<ol>
<li>web容器的线程最大数。比如: Tomcat的线程容量应该略大于最大并发数。</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ol>
</li>
<li><p>具体使用：</p>
<ol>
<li><p>查看线程运行情况</p>
<p><img src="/2021/04/19/JVM/62CB25DD-4C43-4B99-ADA7-00D4C52B1130.png" alt="img"></p>
</li>
<li><p>新建线程dump文件</p>
<p><img src="/2021/04/19/JVM/C7A7BFF7-D6E6-49D4-8718-4AADD60A24B3.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>监视器&amp;锁 Monitors&amp;locks</p>
<ul>
<li><strong>监控和锁Monitors &amp; Locks</strong>所有线程持有锁的情况以及锁的信息。</li>
<li>观察JVM的内部线程并查看状态：<ul>
<li><strong>死锁探测图表Current Locking Graph</strong>：显示JVM中的当前死锁图表。</li>
<li><strong>目前使用的监测器CurrentMonitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表Locking History Graph</strong>：显示记录在JVM中的锁定历史。</li>
<li><strong>历史检测记录MonitorHistory</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、案例分析"><a href="#4、案例分析" class="headerlink" title="4、案例分析"></a>4、案例分析</h5><h6 id="1、案例1（较为安全）"><a href="#1、案例1（较为安全）" class="headerlink" title="1、案例1（较为安全）"></a>1、案例1（较为安全）</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JProfilerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Data data = <span class="keyword">new</span> Data();</span><br><span class="line">                list.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1mb</span></span><br><span class="line">    <span class="keyword">private</span> String info = <span class="string">&quot;hello,atguigu&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、案例2（内存泄露）"><a href="#2、案例2（内存泄露）" class="headerlink" title="2、案例2（内存泄露）"></a>2、案例2（内存泄露）</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ArrayList beanList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Bean data = <span class="keyword">new</span> Bean();</span><br><span class="line">                data.list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]);<span class="comment">//10kb</span></span><br><span class="line">                beanList.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    String info = <span class="string">&quot;hello,atguigu&quot;</span>;</span><br><span class="line">    <span class="comment">// ArrayList list = new ArrayList(); // 解决方法</span></span><br><span class="line">    <span class="keyword">static</span> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>我们通过JProfiler来看一下，如下：</p>
<p><img src="/2021/04/19/JVM/E54DCC19-FD9D-4BC6-8A3A-45CED67B278B.png" alt="img"></p>
<p>你可以看到内存一个劲的往上涨，但是就是没有下降的趋势，说明这肯定有问题，过不了多久就会出现OOM，我们来到Live memory中，先标记看一下到底是哪些对象在进行内存增长，等一小下看看会不会触发垃圾回收，如果不触发的话，我们自己来触发垃圾回收，之后观察哪些对象没有被回收掉，如下：</p>
<p><img src="/2021/04/19/JVM/6D1D07AA-AC1C-4F26-8321-3A554F3B2F86.png" alt="img"></p>
<p>我上面点击了Mark Current，发现有些对象在持续增长，然后点击了一下Run GC，结果如下所示：</p>
<p><img src="/2021/04/19/JVM/F80A4EC9-9AF9-4DA1-8DDE-7442F34754CE.png" alt="img"></p>
<p>可以看出byte[]没有被回收，说明它是有问题的，我们点击Show Selection In Heap Walker，如下：</p>
<p><img src="/2021/04/19/JVM/3A3BE60F-7FC9-473B-B793-9B9C12186B0C.png" alt="img"></p>
<p>然后看一下该对象被谁引用，如下：</p>
<p><img src="/2021/04/19/JVM/CC9DBA1E-B6B1-4497-A27F-A2043E47E6B8.png" alt="img"></p>
<p>结果如下：</p>
<p><img src="/2021/04/19/JVM/C2335263-0DE6-4351-9B4A-F2DACE4AEDC3.png" alt="img"></p>
<p>可以看出byte[]来自于Bean类是的list中，并且这个list是ArrayList类型的静态集合，所以找到了：static ArrayList list = new ArrayList();</p>
<p>发现list是静态的，这不妥，因为我们的目的是while结束之后Bean对象被回收，并且Bena对象中的所有字段都被回收，但是list是静态的，那就是类的，众所周知，类变量随类而生，随类而灭，因此每次我们往list中添加值，都是往同一个list中添加值，这会造成list不断增大，并且不能回收，所以最终会导致OOM</p>
<h4 id="6、Arthas"><a href="#6、Arthas" class="headerlink" title="6、Arthas"></a>6、Arthas</h4><h5 id="1、基本概述-4"><a href="#1、基本概述-4" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><h6 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h6><p>前面，我们介绍了jdk自带的jvisualvm等免费工具，以及商业化工具Jprofiler。</p>
<p>jvisualvm界面：</p>
<p><img src="/2021/04/19/JVM/image-20210718010802170.png" alt="image-20210718010802170"></p>
<p>Jprofiler界面：</p>
<p><img src="/2021/04/19/JVM/image-20210718010823344.png" alt="image-20210718010823344"></p>
<p>这两款工具在业界知名度也比较高，他们的优点是<strong>可以图形界面上看到各维度的性能数据</strong>，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题。</p>
<p>但是这两款工具也有个<strong>缺点</strong>，都必须在服务端项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具<strong>不需要远程连接</strong>，也<strong>不需要配置监控参数</strong>，同时也<strong>提供了丰富的性能监控数据</strong>呢?</p>
<p>今天跟大家介绍一款<strong>阿里巴巴开源的性能分析神器Arthas (阿尔萨斯)</strong></p>
<h6 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h6><p><img src="/2021/04/19/JVM/image-20210718011032691.png" alt="image-20210718011032691"></p>
<p>Arthas (阿尔萨斯)是Alibaba开源的Java诊断工具， 深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p>
<p>Arthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的Tab自动补全功能，进-步方便进行问题的定位和诊断。</p>
<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>这个类从哪个jar包加载的？为什么会报各种类相关的Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没commit?分支搞错了？</li>
<li>遇到问题无法在线上debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<h6 id="3、基于哪些工具开发而来"><a href="#3、基于哪些工具开发而来" class="headerlink" title="3、基于哪些工具开发而来"></a>3、基于哪些工具开发而来</h6><ul>
<li><strong>greys-anatomy</strong>：<strong>Arthas代码基于Greys二次开发而来</strong>，非常感谢Greys之前所有的工作，以及Greys原作者对Arthas提出的意见和建议！</li>
<li><strong>termd</strong>：<strong>Arthas的命令行实现基于termd开发</strong>，是一款优秀的命令行程序开发框架，感谢termd提供了优秀的框架。</li>
<li><strong>crash</strong>：<strong>Arthas的文本渲染功能基于crash中的文本渲染功能开发</strong>，可以从这里看到源码，感谢crash在这方面所做的优秀工作。</li>
<li><strong>cli</strong>：<strong>Arthas的命令行界面基于vert.x提供的cli库进行开发</strong>，感谢vert. x在这方面做的优秀工作。</li>
<li><strong>compiler</strong>：Arthas里的<strong>内存编绎器代码</strong>来源</li>
<li><strong>Apache Commons Net</strong>：Arthas里的<strong>Telnet Client</strong>代码来源</li>
<li><strong>JavaAgent</strong>：运行在main方法之前的<strong>拦截器</strong>，它内定的方法名叫premain ，也就是说先执行premain方法然后再执行main方法</li>
<li>ASM：一个通用的Java字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用(当然也可以以静态方式使用，例如在编译器中)</li>
</ul>
<h6 id="4、官方使用文档"><a href="#4、官方使用文档" class="headerlink" title="4、官方使用文档"></a>4、官方使用文档</h6><p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p>
<h5 id="2、安装与使用"><a href="#2、安装与使用" class="headerlink" title="2、安装与使用"></a>2、安装与使用</h5><h6 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h6><ol>
<li><p>安装方式一：可以直接在Linux 上通过命令下载</p>
<ul>
<li><p>可以在官方Github 上进行下载，如果速度较慢，可以尝试国内的码云Gitee 下载。</p>
<ul>
<li><p>github 下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gitee下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.gitee.io/arthas-boot.jar</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安装方式二：</p>
<ul>
<li><p>也可以在浏览器<a target="_blank" rel="noopener" href="https://alibaba.github.io/arthas/arthas-boot.jar">直接访问</a>，等待下载成功后，上传到Linux服务器上。（可以放在opt文件目录下）</p>
<p><img src="/2021/04/19/JVM/image-20210718011406059.png" alt="image-20210718011406059"></p>
</li>
</ul>
</li>
</ol>
<p>卸载：</p>
<ul>
<li><p>在Linux/Unix/Mac 平台</p>
</li>
<li><p>删除下面文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.arthas/I</span><br><span class="line">rm -rf ~/logs/arthas</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows平台直接删除user home下面的.arthas和logs/arthas目录</p>
</li>
</ul>
<h6 id="2、工程目录"><a href="#2、工程目录" class="headerlink" title="2、工程目录"></a>2、工程目录</h6><ul>
<li>arthas-agent：基于JavaAgent技术的代理</li>
<li>bin：一些启动脚本</li>
<li>arthas-boot：Java版本的一键安装启动脚本</li>
<li>arthas-client：telnet client代码</li>
<li>arthas-common：一些共用的工具类和枚举类</li>
<li>arthas-core：核心库，各种arthas命令的交互和实现</li>
<li>arthas-demo：示例代码</li>
<li>arthas-memorycompiler：内存编绎器代码，Fork from <a target="_blank" rel="noopener" href="https://github.com/skalogs/SkaETL/tree/master/compiler">https://github.com/skalogs/SkaETL/tree/master/compiler</a></li>
<li>arthas-packaging：maven打包相关的</li>
<li>arthas-site：arthas站点</li>
<li>arthas-spy：编织到目标类中的各个切面</li>
<li>static：静态资源</li>
<li>arthas-testcase：测试</li>
</ul>
<h6 id="3、启动"><a href="#3、启动" class="headerlink" title="3、启动"></a>3、启动</h6><p>Arthas只是一个java程序，所以可以直接用java -jar 运行。</p>
<p>执行成功后，arthas提供了一种命令行方式的交互方式，arthas 会检测当前服务器上的Java进程，并将进程列表展示出来，用户输入对应的编号(1、2、3、4……)进行选择，然后回车。</p>
<p>比如：</p>
<ol>
<li><p>方式1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>#选择进程(输入[]内编号(不是PID)回车)<br>[INFO] arthas-boot version: 3.1.4<br>[INFO] Found existing java process, please choose one and hit RETURN.</p>
<p>* [1]: 11616 com.Arthas</p>
<p>  [2]: 8676</p>
<p>  [3]: 16200 org. jetbrains. jps . cmdline . Launcher</p>
<p>  [4]: 21032 org. jetbrains. idea . maven. server . RemoteMavenServer</p>
</li>
<li><p>方式2：</p>
<p>运行时选择Java进程PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar [PID]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210718011816040.png" alt="image-20210718011816040"></p>
<h6 id="4、查看进程"><a href="#4、查看进程" class="headerlink" title="4、查看进程"></a>4、查看进程</h6><p>jps</p>
<h6 id="5、查看日志"><a href="#5、查看日志" class="headerlink" title="5、查看日志"></a>5、查看日志</h6><p>cat ~/logs/arthas/arthas.log</p>
<h6 id="6、查看帮助"><a href="#6、查看帮助" class="headerlink" title="6、查看帮助"></a>6、查看帮助</h6><p>java -jar arthas-boot.jar -h</p>
<h6 id="7、web-console"><a href="#7、web-console" class="headerlink" title="7、web console"></a>7、web console</h6><p>除了在命令行查看外，Arthas目前还支持Web Console。在成功启动连接进程之后就已经自动启动，可以直接访问<a target="_blank" rel="noopener" href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><img src="/2021/04/19/JVM/image-20210718012104569.png" alt="image-20210718012104569"></p>
<h6 id="8、退出"><a href="#8、退出" class="headerlink" title="8、退出"></a>8、退出</h6><p>最后一行[arthas@7457]$， 说明打开进入了监控客户端，在这里就可以执行相关命令进行查看了。</p>
<ul>
<li>使用<code>quit\exit</code>：退出当前客户端</li>
<li>使用<code>stop\shutdown</code>：关闭arthas服务端，并退出所有客户端。</li>
</ul>
<h5 id="3、相关诊断指令"><a href="#3、相关诊断指令" class="headerlink" title="3、相关诊断指令"></a>3、相关诊断指令</h5><h6 id="1、基础指令"><a href="#1、基础指令" class="headerlink" title="1、基础指令"></a>1、基础指令</h6><p><img src="/2021/04/19/JVM/image-20210718012307430.png" alt="image-20210718012307430"></p>
<h6 id="2、jvm相关"><a href="#2、jvm相关" class="headerlink" title="2、jvm相关"></a>2、jvm相关</h6><p>命令列表：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/commands.html#id1">https://arthas.aliyun.com/doc/commands.html#id1</a></p>
<p><img src="/2021/04/19/JVM/image-20210718012842725.png" alt="image-20210718012842725"></p>
<ul>
<li><p><strong>dashboard</strong>（常用）</p>
<ul>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dashboard.html">https://arthas.aliyun.com/doc/dashboard.html</a></p>
</li>
<li><p>作用：当前系统的实时数据面板</p>
</li>
<li><p>options：</p>
<ul>
<li><p><code>-i</code>：打印的时间间隔（单位：ms）</p>
<ul>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard -i 500</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>-n</code>：打印的次数</p>
<ul>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard -n 30</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>若没有填写options，则会在默认时间间隔下不断地打印</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>thread</p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/thread.html">https://arthas.aliyun.com/doc/thread.html</a></li>
<li>作用：查看当前线程信息，查看线程的堆栈</li>
</ul>
</li>
<li><p>jvm</p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jvm">https://arthas.aliyun.com/doc/jvm</a></li>
<li>作用：查看jvm详细的性能数据</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>sysprop<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysprop">https://arthas.aliyun.com/doc/sysprop</a></li>
<li>作用：查看和修改JVM的系统属性</li>
</ul>
</li>
<li>sysenv<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysenv">https://arthas.aliyun.com/doc/sysenv</a></li>
<li>作用：查看JVM的环境变量</li>
</ul>
</li>
<li>getstatic<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/getstatic">https://arthas.aliyun.com/doc/getstatic</a></li>
<li>作用：查看类的静态属性</li>
</ul>
</li>
<li>heapdump<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/heapdump">https://arthas.aliyun.com/doc/heapdump</a></li>
<li>作用：类似jmap 命令的heap dump功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="3、class-classloader相关"><a href="#3、class-classloader相关" class="headerlink" title="3、class/classloader相关"></a>3、class/classloader相关</h6><p><img src="/2021/04/19/JVM/image-20210718014201542.png" alt="image-20210718014201542"></p>
<ul>
<li><p>sc</p>
<ul>
<li>作用：查看JVM已加载的类信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sc">https://arthas.aliyun.com/doc/sc</a></li>
<li>常用参数：<ul>
<li><strong>class- pattern</strong>：类名表达式匹配</li>
<li><strong>-d</strong>：输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。如果一个类被多个ClassLoader所<br>加载，则会出现多次</li>
<li><strong>-E</strong>：开启正则表达式匹配，默认为通配符匹配</li>
<li><strong>-f</strong>：输出当前类的成员变量信息(需要配合参数-d一起使用)</li>
<li><strong>-x</strong>：指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</li>
</ul>
</li>
<li>补充：<ol>
<li>class-pattern支持全限定名， 如com.test.AAA，也支持com/test/AAA这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把<code>/</code>替换为<code>.</code>了。</li>
<li>sc默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关 </li>
</ol>
</li>
</ul>
</li>
<li><p>sm</p>
<ul>
<li>作用：查看己加载类的方法信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sm">https://arthas.aliyun.com/doc/sm</a></li>
<li><strong>sm命令只能看到由当前类所声明(declaring) 的方法，父类则无法看到</strong>。</li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>-d</strong>：展示每个方法的详细信息</li>
<li><strong>-E</strong>：开启正则表达式匹配，默认为通配符匹配</li>
</ul>
</li>
</ul>
</li>
<li><p>jad</p>
<ul>
<li><p>作用：反编译指定己加载类的源码</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jad">https://arthas.aliyun.com/doc/jad</a></p>
</li>
<li><p>在Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</p>
</li>
<li><p>当然，反编译出来的java代码可能会存在语法错误，但不影响你进行阅读理解</p>
</li>
<li><p>编译java.lang.String</p>
<p><img src="/2021/04/19/JVM/image-20210718004243898.png" alt="image-20210718004243898"></p>
</li>
</ul>
</li>
<li><p>mc、redefine</p>
<ul>
<li><p>mc命令：Memory Compiler/内存编译器，编译.java文件生成.class</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mc">https://arthas.aliyun.com/doc/mc</a></p>
</li>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc /tmp/Test.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>redefine命令：加载外部的.class文件，redefine jvm已加载的类。</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/redefine">https://arthas.aliyun.com/doc/redefine</a></p>
</li>
<li><p>推荐使用retransform命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/Test.class </span><br><span class="line">redefine -c 327a647b /tmp/Test.class  /tmp/Test\$Inner.class</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>classloader</p>
<ul>
<li>作用：查看classloader 的继承树，urls，类加载信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/classloader">https://arthas.aliyun.com/doc/classloader</a></li>
<li>了解当前系统中有多少类加载器，以及每个加载器加载的类数量，帮助您判断是否有类加载器泄漏。</li>
<li>常用参数：<ul>
<li><strong>-t</strong>：查看ClassLoader的继承树</li>
<li><strong>-l</strong>：按类加载实例查看统计信息</li>
<li><strong>-c</strong>：用classloader对应的hashcode来查看对应的jar urls</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4、monitor-watch-trace相关"><a href="#4、monitor-watch-trace相关" class="headerlink" title="4、monitor/watch/trace相关"></a>4、monitor/watch/trace相关</h6><p>命令列表：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/commands.html#id1">https://arthas.aliyun.com/doc/commands.html#id1</a></p>
<p><img src="/2021/04/19/JVM/image-20210718014942945.png" alt="image-20210718014942945"></p>
<ul>
<li><p>monitor</p>
<ul>
<li><p>monitor命令：方法执行监控</p>
</li>
<li><p>对匹配class-pattern / method-pattern的类、方法的调用进行监控。涉及方法的调用次数、执行时间、失败率等</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/monitor">https://arthas.aliyun.com/doc/monitor</a></p>
</li>
<li><p>monitor命令是一个非实时返回命令</p>
</li>
<li><p>常用参数：</p>
<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>-c</strong>：统计周期，默认值为120秒</li>
</ul>
</li>
<li><p>监控项：</p>
<p><img src="/2021/04/19/JVM/image-20210718015103331.png" alt="image-20210718015103331"></p>
</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>watch命令：方法执行数据观测</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/watch">https://arthas.aliyun.com/doc/watch</a></li>
<li>作用：让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看。</li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>express</strong>：观察表达式</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-b</strong>：在方法调用之前观察(默认关闭)</li>
<li><strong>-e</strong>：在方法异常之后观察(默认关闭)</li>
<li><strong>-s</strong>：在方法返回之后观察(默认关闭)</li>
<li><strong>-f</strong>：在方法结束之后(正常返回和异常返回)观察(默认开启)</li>
<li><strong>-x</strong>：指定输出结果的属性遍历深度，默认为0</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
<li>说明：这里重点要说明的是<strong>观察表达式</strong>，观察表达式的构成主要由<strong>ognl 表达式</strong>组成，所以你可以这样写”{params, returnObj}”,只要是一个合法的ognl表达式，都能被正常支持。</li>
<li>举例：watch全限定类名 方法名returnObj</li>
</ul>
</li>
<li><p>trace</p>
<ul>
<li>trace命令：方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/trace">https://arthas.aliyun.com/doc/trace</a></li>
<li>补充说明：<ul>
<li>trace命令能主动搜索class-pattern / method- pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</li>
<li>trace能方便的帮助你定位和发现因RT高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路</li>
<li>trace 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像JProfiler一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。</li>
</ul>
</li>
<li>参数说明：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern：</strong>方法名表达式匹配</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-n</strong>：命令执行次数</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>stack命令：输出当前方法被调用的调用路径</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/stack">https://arthas.aliyun.com/doc/stack</a></li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-n</strong>：执行次数限制</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
</ul>
</li>
<li><p>tt</p>
<ul>
<li>tt命令：方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/tt">https://arthas.aliyun.com/doc/tt</a></li>
<li>TimeTunnel的缩写</li>
<li>常用参数：<ul>
<li><strong>-t</strong>：表明希望记录下类 *Test 的 print 方法的每次执行情况。</li>
<li><strong>-n 3</strong>：指定你需要记录的次数，当达到记录次数时Arthas会主动中断tt命令的记录过程，避免人工操作无法停止的情况。</li>
<li><strong>-s</strong>：筛选指定方法的调用信息</li>
<li><strong>-i</strong>：参数后边跟着对应的INDEX编号查看到它的详细信息</li>
<li><strong>-p</strong>：重做一次调用，通过<code>--replay-times</code> 指定调用次数，通过<code>--replay- interval</code> 指定多次调用间隔(单位ms，默认1000ms)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h6><p>使用&gt;将结果重写到日志文件，使用&amp;指令命令是后台运行，session断开不影响任务执行(生命周期默认为1天)</p>
<ul>
<li><strong>jobs</strong>：列出所有job</li>
<li><strong>kill</strong>：强制终止任务</li>
<li><strong>fg</strong>：将暂停的任务拉到前台执行</li>
<li><strong>bg</strong>：将暂停的任务放到后台执行</li>
<li><strong>grep</strong>：搜索满足条件的结果</li>
<li><strong>plaintext</strong>：将命令的结果去除ANSI颜色</li>
<li><strong>wc</strong>：按行统计输出结果</li>
<li><strong>options</strong>：查看或设置Arthas全局开关<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/options.html">https://arthas.aliyun.com/doc/options.html</a></li>
</ul>
</li>
<li><strong>profiler</strong>：使用async-profiler对应用采样，生成火焰图<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/profiler.html">https://arthas.aliyun.com/doc/profiler.html</a></li>
</ul>
</li>
</ul>
<h4 id="7、Java-Misssion-Control"><a href="#7、Java-Misssion-Control" class="headerlink" title="7、Java Misssion Control"></a>7、Java Misssion Control</h4><h5 id="1、历史"><a href="#1、历史" class="headerlink" title="1、历史"></a>1、历史</h5><p>在Oracle 收购Sun之前，Oracle 的JRockit 虚拟机提供了一款叫做JRockitMission Control的虛拟机诊断工具。</p>
<p>在Oracle收购Sun之后，Oracle公司同时拥有了Sun Hotspot和JRockit两款虚拟机。根据Oracle对于Java的战略，在今后的发展中，会将JRockit的优秀特性移植到Hotspot上。其中一个重要的改进就是在Sun的JDK中加入了JRockit的支持。</p>
<p>在Oracle JDK 7u40之后，Mission Control这款工具已经绑定在Oracle JDK中发布。</p>
<p>自Java 11开始，本节介绍的JFR已经开源。但在之前的Java版本，JFR属于Commercial Feature，可要通过Java虚拟机参数<code>-XX: +UnlockCommercialFeatures</code>开启。</p>
<p>如果你有兴趣请可以查看OpenJDK的<a target="_blank" rel="noopener" href="https://github.com/JDKMissionControl/jmc">Mission Control项目</a>。</p>
<h5 id="2、启动-1"><a href="#2、启动-1" class="headerlink" title="2、启动"></a>2、启动</h5><p>Mission Control位于%JAVA_ HOME%/bin/jmc.exe，打开这款软件。</p>
<p><img src="/2021/04/19/JVM/image-20210718021714996.png" alt="image-20210718021714996"></p>
<h5 id="3、概述"><a href="#3、概述" class="headerlink" title="3、概述"></a>3、概述</h5><p>Java Mission Control (简称JMC) Java官方提供的性能强劲的工具，是一个用于对Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。</p>
<p>它包含一个GUI客户端，以及众多用来收集Java虚拟机性能数据的插件，如JMX Console(能够访问用来存放虚拟机各个子系统运行数据的<code>MXBeans</code>)，以及虚拟机内置的高效profiling 工具<code>Java Flight Recorder (JFR)</code>。</p>
<p>JMC 的另一个优点就是：<strong>采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小</strong>，完全可以开着JMC来做压测(唯一影响可能是full gc多了)。</p>
<h5 id="4、功能：实时监控JVM运行时的状态"><a href="#4、功能：实时监控JVM运行时的状态" class="headerlink" title="4、功能：实时监控JVM运行时的状态"></a>4、功能：实时监控JVM运行时的状态</h5><p>如果是远程服务器，使用前要开JMX。</p>
<p>-Dcom. sun. management . jmxremote . port=${YOUR PORT}<br>-Dcom. sun. management . jmxremote<br>-Dcom. sun. management . imxremote . authenticate=false<br>-Dcom. sun . management . jmxremote. ss1=false<br>-Djava. rmi. server . hostname=${YOUR HOST/IP}</p>
<p>文件 -&gt; 连接 -&gt;创建新连接，填入上面JMX参数的host和port</p>
<p><img src="/2021/04/19/JVM/image-20210718022620212.png" alt="image-20210718022620212"></p>
<h5 id="5、Java-Flight-Recorder"><a href="#5、Java-Flight-Recorder" class="headerlink" title="5、Java Flight Recorder"></a>5、Java Flight Recorder</h5><p>Java Flight Recorder是JMC 的其中一个组件。</p>
<p>Java Flight Recorder能够以极低的性能开销收集Java虚拟机的性能数据。</p>
<p>JFR的性能开销很小，在默认配置下平均低于<strong>1%**。与其他工具相比，JFR能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它</strong>非常适用于生产环境下满负荷运行的Java程序**。</p>
<p>Java Flight Recorder和JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control可对Java Flight Recorder连续收集低水平和详细的运行时信息进行高效详细的分析。</p>
<ul>
<li><p>事件类型</p>
<ul>
<li>当启用时，JFR 将记录运行过程中发生的一系列事件。其中包括Java层面的事件，如线程事件、锁事件，以及Java 虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件。</li>
<li>按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：<ol>
<li>**瞬时事件(Instant Event)**：用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>**持续事件(Duration Event)**：用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>**计时事件(Timed Event)**：是时长超出指定阈值的持续事件。</li>
<li>**取样事件(Sample Event)**：是周期性取样的事件。</li>
</ol>
</li>
<li>取样事件的其中一个常见例子便是<strong>方法抽样</strong>(Method Sampling)，即每隔一段时间统计各个线程的栈轨迹。如果在这些<strong>抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</strong>。</li>
</ul>
</li>
<li><p>启动方式</p>
<ol>
<li><p>方式1：使用<code>-XX:StartFlightRecording=参数</code></p>
<ul>
<li><p>比如：下面命令中，JFR将会在Java虚拟机启动5s后(对应delay=5s)收集数据，持续20s (对应duration=20s)。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中(对应filename=myrecording . jfr)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">-XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,setting s=profile MyApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于JFR将持续收集数据，如果不加以限制，那么JFR可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p>
<ul>
<li><p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:StartFlightRecording=maxage=10m, maxsize=100m, name=SomeLabel MyApp</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方式2：使用<code>jcmd的JFR.*子命令</code></p>
<ul>
<li><p>通过jcmd来让JFR开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为<code>JFR.start</code>、<code>JFR.stop</code>以及<code>JFR.dump</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述命令运行过后，目标进程中的JFR已经开始收集数据。此时，我们可以通过下述命令来导出己经收集到的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们可以通过下述命令关闭目标进程中的JFR：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式3：JMC的<code>JFR插件</code></p>
<p><img src="/2021/04/19/JVM/71F5A9C6-31CB-44AA-9414-D64D25F5098E.png" alt="img"></p>
<ul>
<li><p>具体使用：</p>
<ol>
<li><p>启动飞行记录仪</p>
<p><img src="/2021/04/19/JVM/5CCE5317-A223-4B43-8A31-4CC35A5F0EC4.png" alt="img"></p>
</li>
<li><p>启动飞行记录</p>
<p><img src="/2021/04/19/JVM/44614069-2B6C-46F1-BC08-8CEDB3552550.png" alt="img"></p>
</li>
<li><p>正式启动</p>
<p><img src="/2021/04/19/JVM/56BF6BA6-FBD4-4C2A-B38C-26DD8CD63E8F.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/E8EE12B7-FE3F-4D17-ACB6-7D9C7E06AB59.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/EF74F519-69A7-4D42-B255-1B7FF4F59208.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Java Flight Recorder 取样分析</p>
<ul>
<li><p>要采用取样，必须先添加参数：</p>
<ul>
<li><code>-XX: +UnlockCommercialFeatures</code></li>
<li><code>-XX: +Flight Recorder</code></li>
</ul>
</li>
<li><p>否则：</p>
<p><img src="/2021/04/19/JVM/image-20210718170905047.png" alt="image-20210718170905047"></p>
</li>
<li><p>取样时间默认1分钟，可自行按需调整，事件设置选为profiling，然后可以设置取样profile哪些信息，比如：</p>
<ul>
<li>加上对象数量的统计：Java Virtual Machine -&gt; GC -&gt; Detailed -&gt; Object Count/Object Count after GC</li>
<li>方法调用采样的间隔从10ms改为1ms(但不能低于 1ms,否则会影响性能了)：Java Virtual Machine -&gt; Profiling -&gt; Method Profiling Sample/Method Sampling Information</li>
<li>Socket与File采样，10ms 太久，但即使改为1ms也未必能抓住什么，可以干脆取消掉：Java Application -&gt; File Read/FileWrite/Socket Read/Socket Write</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210718171442960.png" alt="image-20210718171442960"></p>
</li>
<li><p>然后就开始Profile，到时间后Profile 结束，会自动把记录下载回来，在JMC中展示。</p>
<p><img src="/2021/04/19/JVM/image-20210718171510051.png" alt="image-20210718171510051"></p>
</li>
<li><p>从展示信息中，我们大致可以读到内存和CPU信息、代码、线程和IO等比较重要的信息展示。</p>
</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *  -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * 默认情况下，新生代占 1/3 ： 200m，老年代占2/3 : 400m</span></span><br><span class="line"><span class="comment"> *   其中，Eden默认占新生代的8/10 : 160m ,Survivor0，Survivor1各占新生代的1/10 ： 20m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span> * <span class="number">50</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPixels() &#123;</span><br><span class="line">        <span class="keyword">return</span> pixels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPixels</span><span class="params">(<span class="keyword">byte</span>[] pixels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = pixels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ol>
<li><p>一般信息</p>
<p><img src="/2021/04/19/JVM/EE0FD730-64E5-4F07-8D0B-CF2B7F6ECA8A.png" alt="img"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/71F0F847-36CE-409F-8690-4D69E5ADB552.png" alt="img"></p>
</li>
<li><p>代码</p>
<p><img src="/2021/04/19/JVM/CE8E8DE1-00EC-45C4-AE5C-7B6E888F3748.png" alt="img"></p>
</li>
<li><p>线程</p>
<p><img src="/2021/04/19/JVM/F2A47ADC-177C-4723-923E-48D654D2CCA9.png" alt="img"></p>
</li>
<li><p>I/O</p>
<p><img src="/2021/04/19/JVM/DA9DF354-EF7F-481E-B1EA-C45D418E9327.png" alt="img"></p>
</li>
<li><p>系统</p>
<p><img src="/2021/04/19/JVM/CEF36242-1EB0-44E8-96E9-60E3A729C56F.png" alt="img"></p>
</li>
<li><p>事件</p>
<p><img src="/2021/04/19/JVM/5F2A69FF-BDBE-44D2-912E-81CB6E7782A2.png" alt="img"></p>
</li>
</ol>
<h4 id="8、其他工具"><a href="#8、其他工具" class="headerlink" title="8、其他工具"></a>8、其他工具</h4><h5 id="1、Flame-Graphs（火焰图）"><a href="#1、Flame-Graphs（火焰图）" class="headerlink" title="1、Flame Graphs（火焰图）"></a>1、Flame Graphs（火焰图）</h5><p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示cpu在程序整个生命周期过程中时间分配的工具。</p>
<p>火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用栈中的CPU消耗瓶颈。</p>
<p>网上的关于java火焰图的讲解大部分来自于<a target="_blank" rel="noopener" href="http://www.brendangregg.com/flamegraphs.html">Brendan Gregg的博客</a></p>
<p><img src="/2021/04/19/JVM/image-20210718172030880.png" alt="image-20210718172030880"></p>
<p>火焰图简单通过<strong>x轴横条宽度来度量时间指标</strong>，<strong>y轴代表线程栈的层次</strong>。</p>
<h5 id="2、Tprofiler"><a href="#2、Tprofiler" class="headerlink" title="2、Tprofiler"></a>2、Tprofiler</h5><ul>
<li>案例：<ul>
<li>使用JDK自身提供的工具进行JVM调优可以将TPS由2.5提升到20（提升了7倍），并准确定位系统瓶颈</li>
<li>系统的瓶颈有：应用里静态对象不是很多、有大量的业务进程在频繁创建一些生命周期很长的临时对象，代码里有问题</li>
<li>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具Tprofiler来定位这些性能代码，成功解决掉GC过于频繁的性能瓶颈，并最终在上次优化的基础上将TPS在提升了4倍，即提升到100。<ul>
<li>TProfiler配置部署、远程操作、日志阅读都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶颈。</li>
<li>TProfiler最重要的特性就是<strong>能够统计出你指定时间段内JVM 的top method</strong>，这些top method极有可能就是造成你JVM 性能瓶颈的元凶。这是其他大多数JVM调优工具所不具备的，包括JRockit Mission Control。JRokit 首席开发者Marcus Hirt在其私人博客《Low Overhead Method Profiling with Java Mission Control》下的评论中曾明确指出JRMC并不支持TOP方法的统计。</li>
<li>TProfiler的<a target="_blank" rel="noopener" href="https://github.com/alibaba/TProfiler">下载</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、Btrace"><a href="#3、Btrace" class="headerlink" title="3、Btrace"></a>3、Btrace</h5><ul>
<li><strong>Java运行时追踪工具</strong></li>
<li>常见的动态追踪工具有BTrace、HouseMD (该项目已经停止开发)、Greys-Anatomy (国人开发，个人开发者)、Byteman (JBoss出品)，注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常用的。</li>
<li>BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一下BTrace的官方定义：<ul>
<li>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program (similar to DTrace for OpenSolaris applications and OS). BTrace dynamically instruments the classes of the target application to inject tracing code (“bytecode tracing”)。</li>
</ul>
</li>
<li>简洁明了，大意是一个Java平台的安全的动态追踪工具。可以用来动态地追踪一个运行的Java程序。BTrace动态调整目标应用程序的类以注入跟踪代码(“字节码跟踪”)。</li>
</ul>
<h5 id="4、YourKit"><a href="#4、YourKit" class="headerlink" title="4、YourKit"></a>4、YourKit</h5><h5 id="5、JProbe"><a href="#5、JProbe" class="headerlink" title="5、JProbe"></a>5、JProbe</h5><h5 id="6、Spring-Insight"><a href="#6、Spring-Insight" class="headerlink" title="6、Spring Insight"></a>6、Spring Insight</h5><h4 id="9、学习建议"><a href="#9、学习建议" class="headerlink" title="9、学习建议"></a>9、学习建议</h4><p>Visual VM -&gt; Arthus -&gt; Jproflier（公司有能购买商业版） -&gt; MAT</p>
<h4 id="10、补充1：再谈内存泄露"><a href="#10、补充1：再谈内存泄露" class="headerlink" title="10、补充1：再谈内存泄露"></a>10、补充1：再谈内存泄露</h4><h5 id="1、内存泄露的理解与分析"><a href="#1、内存泄露的理解与分析" class="headerlink" title="1、内存泄露的理解与分析"></a>1、内存泄露的理解与分析</h5><h6 id="1、何为内存泄漏-memory-leak"><a href="#1、何为内存泄漏-memory-leak" class="headerlink" title="1、何为内存泄漏( memory leak)"></a>1、何为内存泄漏( memory leak)</h6><p><img src="/2021/04/19/JVM/image-20210427230217504.png" alt="image-20210427230217504"></p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题(让JVM误以为此对象还在引用中，无法回收，造成内存泄漏)。</p>
<ul>
<li>是否还被使用?是</li>
<li>是否还被需要?否</li>
</ul>
<h6 id="2、内存泄漏-memory-leak-的理解"><a href="#2、内存泄漏-memory-leak-的理解" class="headerlink" title="2、内存泄漏( memory leak) 的理解"></a>2、内存泄漏( memory leak) 的理解</h6><p>严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
<p>但实际情况很多时候一些不太好的实践(或疏忽)会导致<strong>对象的生命周期变得很长甚至导致OOM</strong>，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p><img src="/2021/04/19/JVM/image-20210717171640356.png" alt="image-20210717171640356"></p>
<p>对象X引用对象Y，X的生命周期比Y的生命周期长；那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<h6 id="3、内存泄漏与内存溢出的关系"><a href="#3、内存泄漏与内存溢出的关系" class="headerlink" title="3、内存泄漏与内存溢出的关系"></a>3、内存泄漏与内存溢出的关系</h6><ol>
<li><p>内存泄漏(memory leak)</p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M 的内存一直不回收，那么可以用的内存只有512M了， 仿佛泄露掉了一部分；通俗点讲的话， 内存泄漏就是 [占着茅坑不拉shi] 。</p>
</li>
<li><p>内存溢出(out of memory)</p>
<p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的(内存泄漏)，剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位(内存)就不够了，内存泄漏变成内存溢出了。</p>
<p>可见，内存泄漏和内存溢出的关系：<strong>内存泄漏的增多，最终会导致内存溢出。</strong></p>
</li>
</ol>
<h6 id="4、泄漏的分类"><a href="#4、泄漏的分类" class="headerlink" title="4、泄漏的分类"></a>4、泄漏的分类</h6><ul>
<li><strong>经常发生</strong>：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存;（坚决杜绝）</li>
<li><strong>偶然发生</strong>：在某些特定情况下才会发生；</li>
<li><strong>一次性</strong>：发生内存泄露的方法只会执行一次；</li>
<li><strong>隐式泄漏</strong>：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h5 id="2、Java中内存泄露的8种情况"><a href="#2、Java中内存泄露的8种情况" class="headerlink" title="2、Java中内存泄露的8种情况"></a>2、Java中内存泄露的8种情况</h5><ul>
<li><p>静态集合类</p>
<ul>
<li><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单例模式</p>
<ul>
<li>单例模式，和静态集合导致内存泄露的原因类似，因为<strong>单例的静态特性，它的生命周期和JVM的生命周期一样长</strong>，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</li>
</ul>
</li>
<li><p>内部类持有外部类</p>
<ul>
<li>内部类持有外部类，如果个外部类的实例对象的方法返回了一个内部类的实例对象。<strong>这个内部类对象被长期引用了</strong>，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</li>
</ul>
</li>
<li><p>各种连接，如数据库连接、网络连接和IO连接等</p>
<ul>
<li><p>各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。<strong>只有连接被关闭后，垃圾回收器才会回收对应的对象</strong>。否则，如果在访问数据库的过程中，对Connection、 Statement或ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Class.forName (<span class="string">&quot;com.mysq1.jdbc.Driver&quot;</span>);</span><br><span class="line">		conn = DriverManager . getConnection(<span class="string">&quot;url&quot;</span>, <span class="number">11</span>);</span><br><span class="line">		Statement stmt = conn. createStatement();</span><br><span class="line">		ResultSet rs = stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">//异常日志</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//1.关闭结果集Statement</span></span><br><span class="line">		<span class="comment">// 2.关闭声明的对象ResultSet</span></span><br><span class="line">		<span class="comment">// 3.关闭连接Connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量不合理的作用域</p>
<ul>
<li><p>变量不合理的作用域。一般而言，<strong>一个变量的定义的作用范围大于其使用范围</strong>，很有可能会造成内存泄漏。另一方面，<strong>如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生</strong>。</p>
</li>
<li><p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。</p>
</li>
<li><p>实际上这个msg变量可以放在receiveMsg方法内部， 当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p>
</li>
<li><p>解决方法1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">		msg = readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">        msg = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>改变哈希值</p>
<ul>
<li><p><strong>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了</strong>。</p>
</li>
<li><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
</li>
<li><p>这也是String为什么被设置成了不可变类型，我们可以放心地把String存入HashSet，或者把String当做HashMap的key值；</p>
</li>
<li><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>缓存泄露</p>
<ul>
<li><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
</li>
<li><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，<strong>当除了自身有对key的引用外，此key没有其他引用，那么此map会自动丢弃此值</strong>。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<ul>
<li>String引用ref1，ref2，ref3，ref4 消失</li>
<li>WeakHashMap GC之前</li>
<li>obejct2=cacheObject2</li>
</ul>
<ul>
<li>obejct1=cacheObject1</li>
<li>WeakHashMap GC之后</li>
<li>HashMap GC之前</li>
<li>obejct4=cacheObject4</li>
<li>obejct3=cacheObject3</li>
<li>Disconnected from the target VM, address: ‘127.0.0.1:51628’, transport: ‘socket’</li>
<li>HashMap GC之后</li>
<li>obejct4=cacheObject4</li>
<li>obejct3=cacheObject3</li>
</ul>
</li>
<li><p>分析：</p>
<p><img src="/2021/04/19/JVM/image-20210717180541120.png" alt="image-20210717180541120"></p>
<ul>
<li>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1、weakd2、d1、d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</li>
</ul>
</li>
</ul>
</li>
<li><p>监听器和回调</p>
<ul>
<li>内存泄漏另一个常见来源是<strong>监听器和其他回调</strong>，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</li>
<li>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</li>
</ul>
</li>
</ul>
<h5 id="3、内存泄露案例分析"><a href="#3、内存泄露案例分析" class="headerlink" title="3、内存泄露案例分析"></a>3、内存泄露案例分析</h5><h6 id="1、案例代码"><a href="#1、案例代码" class="headerlink" title="1、案例代码"></a>1、案例代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在内存泄漏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];<span class="comment">//只是将指针下移，没有回收内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h6><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数， 下面通过这张图示展现</p>
<p>假设这个栈一直增长，增长后如下图所示：</p>
<p><img src="/2021/04/19/JVM/image-20210717181048650.png" alt="image-20210717181048650"></p>
<p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p>
<p><img src="/2021/04/19/JVM/image-20210717181439315.png" alt="image-20210717181439315"></p>
<p>从上图中看以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称<strong>过期引用</strong>，这个内存泄露很隐蔽。</p>
<h6 id="3、解决办法"><a href="#3、解决办法" class="headerlink" title="3、解决办法"></a>3、解决办法</h6><p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一旦引用过期，清空这些引用，将引用置空。</strong></p>
<h6 id="4、案例代码（与移动端的开发有关）"><a href="#4、案例代码（与移动端的开发有关）" class="headerlink" title="4、案例代码（与移动端的开发有关）"></a>4、案例代码（与移动端的开发有关）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> object key = <span class="keyword">new</span> <span class="number">0</span>bject();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (key) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        key.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace( );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5、分析"><a href="#5、分析" class="headerlink" title="5、分析"></a>5、分析</h6><p><img src="/2021/04/19/JVM/image-20210717182307112.png" alt="image-20210717182307112"></p>
<p><img src="/2021/04/19/JVM/image-20210717182357403.png" alt="image-20210717182357403"></p>
<p>内部类持有外部类：当GC要回收TestActivity的时候，发现内部类（匿名线程）内部持有了外部类（key对象），不能将TestActivity顺利回收，导致了内存泄露。</p>
<h6 id="6、解决方法"><a href="#6、解决方法" class="headerlink" title="6、解决方法"></a>6、解决方法</h6><ol>
<li>使用线程时，一定要确保线程在周期性对象(如Activity) 销毁时能正常结束， 如能正常结束，但是Activity销毁后还需执行一段时间，也可能造成泄露，此时可采用WeakReference方法来解决，另外在使用Handler的时候，如存在Delay操作，也可以采用WeakReference；</li>
<li>使用Handler + HandlerThread时， 记住在周期性对象销毁时调用looper.quit()方法；</li>
</ol>
<h4 id="11、补充2：支持使用OQL语言查询对象信息"><a href="#11、补充2：支持使用OQL语言查询对象信息" class="headerlink" title="11、补充2：支持使用OQL语言查询对象信息"></a>11、补充2：支持使用OQL语言查询对象信息</h4><h5 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>MAT支持一种类似于SQL的查询语言OQL (Object Query Language) 。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>
<h5 id="2、在Eclipse-MAT中如何用"><a href="#2、在Eclipse-MAT中如何用" class="headerlink" title="2、在Eclipse MAT中如何用"></a>2、在Eclipse MAT中如何用</h5><p><img src="/2021/04/19/JVM/C4BC430D-C575-40EC-81F0-44DE723F0EAD.png" alt="img"></p>
<h5 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h5><ol>
<li>select * from java.util.ArrayList（列出所有的ArrayList对象信息）</li>
<li>select v.elementData from java.util.ArrayList v（注意：elementData代表ArrayList底层的数组，结果最终以数组形式将结果呈现出来）</li>
<li>select objects v.elementData from java.util.ArrayList v（注意：elementData代表ArrayList底层的数组，objects代表对象类型，所以最终以对象形式将结果呈现出来，同时展示出来的还有浅堆、深堆）</li>
<li>select as retained set * from com.atguigu.mat.Student（得到对象的保留级）</li>
<li>select * from 0x6cd57c828（0x6cd57c828是Student类的地址值）</li>
<li>select * from char[] s where s.@length &gt; 10（char型数组长度大于10的数组）</li>
<li>select * from java.lang.String s where s.value != null（字符串值不为空的字符串信息）</li>
<li>select toString(f.path.value) from java.io.File f（列出文件的路径值）</li>
<li>select v.elementData.@length from java.util.ArrayList v（列出Arraylist对象中ArrayList中的数组长度）</li>
</ol>
<h5 id="4、SELECT子句"><a href="#4、SELECT子句" class="headerlink" title="4、SELECT子句"></a>4、SELECT子句</h5><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用<code>*</code>，查看结果对象的引用实例(相当于outgoing references) 。</p>
<p>SELECT * FROM java.util.Vector v</p>
<p>使用”<code>OBJECTS</code>“关键字，可以将返回结果集中的项以对象的形式显示。</p>
<ul>
<li>SELECT objects v.elementData FROM java.util.Vector v</li>
<li>SELECT OBJECTS s.value FROM java.lang.String s</li>
</ul>
<p>在Select子句中，使用”<code>AS RETAINED SET</code>“关键字可以得到所得对象的保留集。</p>
<ul>
<li>SELECT AS RETAINED SET * FROM com.atguigu.mat.Student</li>
</ul>
<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<ul>
<li>SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s</li>
</ul>
<h5 id="5、FROM子句"><a href="#5、FROM子句" class="headerlink" title="5、FROM子句"></a>5、FROM子句</h5><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<p>SELECT * FROM java.lang.StrIng s</p>
<p>下例使用正则表达式，限定搜索范围，输出所有com. atguigu包下所有类的实例</p>
<ul>
<li>SELECT * FROM “com\.atguigu\..*”</li>
</ul>
<p>也可以直接使用类的地址进行搜索。<strong>使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型</strong>。</p>
<ul>
<li>select * from 0x37a0b4d</li>
</ul>
<h5 id="6、WHERE子句"><a href="#6、WHERE子句" class="headerlink" title="6、WHERE子句"></a>6、WHERE子句</h5><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>下例返回长度大于10的char数组。</p>
<ul>
<li>SELECT * FROM char[] s WHERE s.@length&gt;10</li>
</ul>
<p>下例返回包含”java”子字符串的所有字符串，使用”LIKE”操作符，”LIKE”操作符的操作参数为正则表达式。</p>
<ul>
<li>SELECT * FROM java.lang.String s WHERE toString(s) LIKE “. *java. *”</li>
</ul>
<p>下例返回所有value域不为null的字符串，使用”=”操作符。</p>
<ul>
<li>SELECT * FROM java.lang.String s where s. value!=null</li>
</ul>
<p>Where子句支持多个条件的AND、OR运算。下例返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<ul>
<li>SELECT * FROM java.util.Vector v WHERE v.elementData.@length&gt;15 AND v. @retainedHeapSize&gt;1000</li>
</ul>
<h5 id="7、内置对象与方法"><a href="#7、内置对象与方法" class="headerlink" title="7、内置对象与方法"></a>7、内置对象与方法</h5><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下：</p>
<ul>
<li>[ <alias>. ] <field> . <field>. <field></field></field></field></alias></li>
<li>其中alias为对象名称。</li>
</ul>
<p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p>
<ul>
<li>SELECT toString(f.path.value) FROM java.io.File f</li>
</ul>
<p>下例显示了String对象的内容、objectid和objectAddress。</p>
<ul>
<li>SELECT s.toString(), s.@objectId, s.@objectAddress FROM java.lang.String s</li>
</ul>
<p>下例显示java.util.Vector内部数组的长度。</p>
<ul>
<li>SELECT v.elementData.@length FROM java.util.Vector v</li>
</ul>
<p>下例显示了所有的java.util.Vector对象及其子类型</p>
<ul>
<li>select * from INSTANCEOF java.util.Vector</li>
</ul>
<h3 id="4、JVM运行时参数"><a href="#4、JVM运行时参数" class="headerlink" title="4、JVM运行时参数"></a>4、JVM运行时参数</h3><h4 id="1、JVM参数选项"><a href="#1、JVM参数选项" class="headerlink" title="1、JVM参数选项"></a>1、JVM参数选项</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数来源</a></p>
<h5 id="1、类型一：标准参数选项"><a href="#1、类型一：标准参数选项" class="headerlink" title="1、类型一：标准参数选项"></a>1、类型一：标准参数选项</h5><h6 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>比较稳定，后续版本基本不会变化</li>
<li><strong>以<code>-</code>开头</strong></li>
</ul>
<h6 id="2、各种选项"><a href="#2、各种选项" class="headerlink" title="2、各种选项"></a>2、各种选项</h6><p>直接在DOS窗口中运行java或者java -help可以看到所有的标准选项</p>
<p><img src="/2021/04/19/JVM/image-20210718175015752.png" alt="image-20210718175015752"></p>
<p><img src="/2021/04/19/JVM/image-20210718175046637.png" alt="image-20210718175046637"></p>
<h6 id="3、补充内容：-server与-client"><a href="#3、补充内容：-server与-client" class="headerlink" title="3、补充内容：-server与-client"></a>3、补充内容：-server与-client</h6><p>Hotspot JVM有 两种模式，分别是<code>server</code>（C2编译器）和<code>client</code>（C1编译器），分别通过-server和-client模式设置</p>
<ol>
<li><p><strong>在32位Windows系统上，默认使用Client类型的JVM</strong>。要想使用Server模式，则机器配置至少有2个以上的CPU和2G以上的物理内存。client模式适用于对内存要求较小的桌面应用程序，<strong>默认使用Serial串行垃圾收集器</strong></p>
</li>
<li><p><strong>64位机器上<code>只支持server模式</code>的JVM</strong>，适用于需要大内存的应用程序，<strong>默认使用并行垃圾收集器</strong></p>
</li>
<li><p>关于server和client的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">官网介绍</a></p>
</li>
</ol>
<p>对于以上第2点，我们可以打开DOS窗口，输入java -version就可以看到64位机器上用的server模式，如下所示：</p>
<p><img src="/2021/04/19/JVM/BD46C8BE-6B93-4AE0-B6D0-C54B879E31AB.png" alt="img"></p>
<h5 id="2、类型二：-X参数选项"><a href="#2、类型二：-X参数选项" class="headerlink" title="2、类型二：-X参数选项"></a>2、类型二：-X参数选项</h5><h6 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>非标准化参数</li>
<li>功能还是比较稳定的。但官方说后续版本可能会变更</li>
<li><strong>以<code>-X</code>开头</strong></li>
</ul>
<h6 id="2、各种选项-1"><a href="#2、各种选项-1" class="headerlink" title="2、各种选项"></a>2、各种选项</h6><p>直接在DOS窗口中运行java -X命令可以看到所有的X选项</p>
<p><img src="/2021/04/19/JVM/image-20210718175909651.png" alt="image-20210718175909651"></p>
<p>其中</p>
<ul>
<li>-Xmixed 混合模式执行 (默认)</li>
<li>-Xint 仅解释模式执行</li>
<li>-Xcomp 仅采用即时编译器模式</li>
</ul>
<h6 id="3、JVM的JIT编译模式相关的选项"><a href="#3、JVM的JIT编译模式相关的选项" class="headerlink" title="3、JVM的JIT编译模式相关的选项"></a>3、JVM的JIT编译模式相关的选项</h6><ul>
<li><p>-Xint</p>
<ul>
<li>只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的</li>
</ul>
</li>
<li><p>-Xcomp</p>
<ul>
<li>只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行</li>
</ul>
</li>
<li><p>-Xmixed（默认）</p>
<ul>
<li><p>混合模式：这是默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了。</p>
</li>
<li><p>默认使用的就是这种模式，证明如下：</p>
<p><img src="/2021/04/19/JVM/D8A89BF9-18A3-4BB3-AB4F-7AD2D776F826.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h6 id="4、特别地：-Xmx-Xms-Xss属于XX参数？"><a href="#4、特别地：-Xmx-Xms-Xss属于XX参数？" class="headerlink" title="4、特别地：-Xmx -Xms -Xss属于XX参数？"></a>4、特别地：-Xmx -Xms -Xss属于XX参数？</h6><ul>
<li><p>单位分别是：k/K、m/M、g/G</p>
</li>
<li><p>设置：-Xmx、-Xms最好设置成一样的值，避免扩容带来的损耗</p>
<ul>
<li><p>-Xms<size></size></p>
<ul>
<li><p>设置初始Java堆大小，等价于<code>-XX:InitialHeapSize</code></p>
</li>
<li><p>查看该参数值的时候，应该使用InitialHeapSize，例如jinfo flag InitialHeapSize 进程id</p>
</li>
<li><p>等价证明：</p>
<p><img src="/2021/04/19/JVM/61F43F0D-E803-40ED-8D01-3C51769DD3EE.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/963D0947-69DB-4F67-B746-3E2670B13071.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>-Xmx<size></size></p>
<ul>
<li><p>设置最大Java堆大小，等价于<code>-XX:MaxHeapSize</code></p>
</li>
<li><p>查看该参数值的时候，应该使用MaxHeapSize，例如jinfo flag InitialHeapSize 进程id</p>
</li>
<li><p>等价证明：</p>
<p><img src="/2021/04/19/JVM/image-20210718181620379.png" alt="image-20210718181620379"></p>
</li>
</ul>
</li>
<li><p>-Xss<size></size></p>
<ul>
<li>设置Java线程堆栈大小，等价于<code>-XX:ThreadStackSize</code></li>
<li>查看该参数值的时候，应该使用ThreadStackSize，例如jinfo flag InitialHeapSize 进程id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、类型三：-XX参数选项（重要）"><a href="#3、类型三：-XX参数选项（重要）" class="headerlink" title="3、类型三：-XX参数选项（重要）"></a>3、<strong>类型三：-XX参数选项</strong>（重要）</h5><h6 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>非标准化参数</li>
<li><strong>使用的最多的参数类型</strong></li>
<li>这类选项属于实验性，不稳定</li>
<li><strong>以<code>-XX</code>开头</strong></li>
</ul>
<h6 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h6><p>用于开发和调试JVM</p>
<h6 id="3、分类"><a href="#3、分类" class="headerlink" title="3、分类"></a>3、<strong>分类</strong></h6><ul>
<li>Boolean类型格式<ul>
<li>-XX:+<option>  表示启用option属性</option></li>
<li>-XX:-<option>   表示禁用option属性</option></li>
<li>举例：<ul>
<li><code>-XX:+UseParallelGC</code>：选择垃圾收集器为并行收集器</li>
<li><code>-XX:+UseG1GC</code>：表示启用G1收集器</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择年轻代区大小和相应的Survivor区比例</li>
</ul>
</li>
<li>说明：因为有的指令默认是开启的，所以可以使用<code>-</code>关闭</li>
</ul>
</li>
<li>非Boolean类型格式（key-value类型）<ul>
<li>子类型1：数值型格式-XX:<option>=<number><ul>
<li>number表示数值，number可以带上单位，比如：’m’、’M’ 表示兆，’k’、’K’表示Kb, ‘g’、’G’表示g (例如32k跟32768是一样的效果)</li>
<li>例如：<ul>
<li><code>-XX:NewSize=1024m</code>：表示设置新生代初始大小为1024兆</li>
<li><code>-XX:MaxGCPauseMillis=500</code>：表示设置GC停顿时间: 500毫秒</li>
<li><code>-XX: GCTimeRatio=19</code>：表示设置吞吐量</li>
<li><code>-XX:NewRatio=2</code>：表示新生代与老年代的比例</li>
</ul>
</li>
</ul>
</number></option></li>
<li>子类型2：非数值型格式-XX:<name>=<string><ul>
<li>例如：<ul>
<li><code>-XX:HeapDumpPath=/usr/local/heapdump.hprof</code>：用来指定heap转存文件的存储路径。</li>
</ul>
</li>
</ul>
</string></name></li>
</ul>
</li>
</ul>
<h6 id="4、特别地：-XX-PrintFlagsFinal"><a href="#4、特别地：-XX-PrintFlagsFinal" class="headerlink" title="4、特别地：-XX:+PrintFlagsFinal"></a>4、特别地：<code>-XX:+PrintFlagsFinal</code></h6><ul>
<li>输出所有参数的名称和默认值</li>
<li>默认不包括Diagnostic和Experimental的参数</li>
<li>可以配合<code>-XX:+UnlockDiagnosticVMOptions</code>和<code>-XX:UnlockExperimentalVMOptions</code>使用</li>
</ul>
<h4 id="2、添加JVM参数选项"><a href="#2、添加JVM参数选项" class="headerlink" title="2、添加JVM参数选项"></a>2、添加JVM参数选项</h4><h5 id="1、Eclipse"><a href="#1、Eclipse" class="headerlink" title="1、Eclipse"></a>1、Eclipse</h5><ol>
<li><p>在空白处单击右键，选择Run As，在选择Run Configurations……</p>
<p><img src="/2021/04/19/JVM/098406BB-FB1F-4DC0-AE87-81C6ECBE6B00.png" alt="img"></p>
</li>
<li><p>设置虚拟机参数</p>
<p><img src="/2021/04/19/JVM/EA52A159-CB0B-4104-9C2C-86579C2B2F3A.png" alt="img"></p>
</li>
</ol>
<h5 id="2、IDEA"><a href="#2、IDEA" class="headerlink" title="2、IDEA"></a>2、IDEA</h5><ol>
<li><p>Edit Configurations…</p>
<p><img src="/2021/04/19/JVM/8432A5D7-B42B-4DD9-AADD-AC996FD9BE0B.png" alt="img"></p>
</li>
<li><p>设置虚拟机参数</p>
<p><img src="/2021/04/19/JVM/0C60AA58-6366-4085-BA1D-FF92EA6AF335.png" alt="img"></p>
</li>
</ol>
<h5 id="3、运行jar包"><a href="#3、运行jar包" class="headerlink" title="3、运行jar包"></a>3、运行jar包</h5><ul>
<li>这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息<ul>
<li>java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</li>
</ul>
</li>
</ul>
<h5 id="4、通过Tomcat运行war包"><a href="#4、通过Tomcat运行war包" class="headerlink" title="4、通过Tomcat运行war包"></a>4、通过Tomcat运行war包</h5><ul>
<li>Linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：<ul>
<li>JAVA_OPTS=”-Xms512M -Xmx1024M”</li>
</ul>
</li>
<li>Windows系统下载catalina.bat中添加类似如下配置：<ul>
<li>set “JAVA_OPTS=-Xms512M -Xmx1024M”</li>
</ul>
</li>
</ul>
<h5 id="5、程序运行过程中"><a href="#5、程序运行过程中" class="headerlink" title="5、程序运行过程中"></a>5、程序运行过程中</h5><p>jinfo不仅可以查看运行时某一个Java虛拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p>
<p>但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。其实，这个修改能力是极其有限的。</p>
<p>#可以查看被标记为manageable的参数：java -XX:+PrintFlagsFinal -version | grep manageable</p>
<p><img src="/2021/04/19/JVM/image-20210713001449847.png" alt="image-20210713001449847"></p>
<ul>
<li>使用jinfo -flag <name>=<value> <pid>设置非Boolean类型参数</pid></value></name></li>
<li>使用jinfo -flag [+|-]<name> <pid>设置Boolean类型参数</pid></name></li>
</ul>
<h4 id="3、常用的JVM参数选项"><a href="#3、常用的JVM参数选项" class="headerlink" title="3、常用的JVM参数选项"></a>3、常用的JVM参数选项</h4><h5 id="1、打印设置的XX选项及值"><a href="#1、打印设置的XX选项及值" class="headerlink" title="1、打印设置的XX选项及值"></a>1、打印设置的XX选项及值</h5><ul>
<li><p><code>-XX:+PrintCommandLineFlags</code>：可以让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</p>
</li>
<li><p><code>-XX:+PrintFlagsInitial</code>：</p>
</li>
<li><p>**<code>-XX:+PrintFlagsFinal</code>**：表示打印出XX选项在运行程序时生效的值</p>
<ul>
<li><p>如果值的前面加上了:=，说明该值不是初始值，该值可能被jvm自动改变了，也可能被我们设置的参数改变了，如下所示：</p>
<p><img src="/2021/04/19/JVM/10326F84-0DAE-4D29-867E-C38676FC36D5.png" alt="img"></p>
</li>
<li><p>有一些被改变的值是项目在启动过程中，系统帮我们修改的</p>
</li>
<li><p>注意区别：</p>
<ul>
<li><p>-XX:+PrintFlagsFinal是打印出<strong>所有</strong>XX选项在运行程序时生效的值</p>
</li>
<li><p><strong><code>jinfo -flag 参数名称 进程id</code>**：查看某个java进程的</strong>具体**参数信息</p>
<ul>
<li><p>进程id可以通过jps命令查看具体操作如下：（其中3540代表进程id）</p>
<p><img src="/2021/04/19/JVM/image-20210713001051530.png" alt="image-20210713001051530"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintVMOptions</code>：打印JVM的参数</p>
</li>
</ul>
<h5 id="2、堆、栈、方法区等内存大小设置"><a href="#2、堆、栈、方法区等内存大小设置" class="headerlink" title="2、堆、栈、方法区等内存大小设置"></a>2、堆、栈、方法区等内存大小设置</h5><h6 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h6><ul>
<li><code>-Xss128k</code><ul>
<li>设置每个线程的栈大小为128k</li>
<li>等价于<code>-XX:ThreadStackSize</code></li>
</ul>
</li>
</ul>
<h6 id="2、堆内存"><a href="#2、堆内存" class="headerlink" title="2、堆内存"></a>2、堆内存</h6><ul>
<li><code>-Xms3550m</code><ul>
<li>等价于<code>-XX:InitialHeapSize</code>，设置JVM初始堆内存为3500M</li>
</ul>
</li>
<li><code>-Xmx3550m</code><ul>
<li>等价于<code>-XX:MaxHeapSize</code>，设置JVM最大堆内存为3500M</li>
</ul>
</li>
<li><code>-Xmn2g</code><ul>
<li>设置年轻代大小为2G，即等价于<code>-XX:NewSize=2g</code> <code>-XX:MaxNewSize=2g</code>，也就是设置年轻代初始值和年轻代最大值都是2G</li>
<li>官方推荐配置为<strong>整个堆大小的3/8</strong></li>
</ul>
</li>
<li><code>-XX:NewSize=1024m</code><ul>
<li>设置年轻代初始值为1024M</li>
</ul>
</li>
<li><code>-XX:MaxNewSize=1024m</code><ul>
<li>设置年轻代最大值为1024M</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio=8</code><ul>
<li>设置年轻代中Eden区与一个Survivor区的比值，默认为8</li>
<li>只有显示使用Eden区和Survivor区的比例，才会让比例生效，否则比例都会自动设置，至于其中的原因，请看下面的-XX:+UseAdaptiveSizePolicy中的解释，最后推荐使用默认打开的-XX:+UseAdaptiveSizePolicy设置，并且不显示设置-XX:SurvivorRatio</li>
</ul>
</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code><ul>
<li>自动选择各区大小比例，默认开启</li>
<li>分析<ul>
<li>默认开启，将会导致Eden区和Survivor区的比例自动分配，因此也会引起我们默认值-XX:SurvivorRatio=8失效，所以真实比例可能不是8，比如可能是6等</li>
</ul>
</li>
<li>如何设置Eden区和Survivor区的比例：-XX:SurvivorRatio=8<ol>
<li>显示使用显示使用Eden区和Survivor区的比例，那就使用我自己的</li>
<li>没有显示使用Eden区和Survivor区的比例，无论打开或者关闭-XX:+UseAdaptiveSizePolicy，都会自动设置Eden区和Survivor区的比例</li>
</ol>
</li>
<li>结论：<ul>
<li>只有显示使用Eden区和Survivor区的比例，才会让比例生效，否则比例都会自动设置，最后推荐使用默认打开的-XX:+UseAdaptiveSizePolicy设置，并且不显示设置-XX:SurvivorRatio</li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:NewRatio=2</code><ul>
<li>设置老年代与年轻代（包括1个Eden区和2个Survivor区）的比值，默认为2</li>
<li>根据实际情况进行设置，主要根据对象生命周期来进行分配，如果对象生命周期很长，那么让老年代大一点，否则让新生代大一点</li>
</ul>
</li>
<li><code>-XX:PretenureSizeThreadshold=1024</code><ul>
<li>设置让大于此阈值的对象直接分配在老年代，单位为字节</li>
<li>只对Serial、ParNew收集器有效</li>
<li>不好控制</li>
</ul>
</li>
<li><code>-XX:MaxTenuringThreshold=15</code><ul>
<li>默认值为15</li>
<li>新生代每次MinorGC后，还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代</li>
</ul>
</li>
<li><code>-XX:+PrintTenuringDistribution</code><ul>
<li>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
</ul>
</li>
<li><code>-XX:TargetSurvivorRatio</code><ul>
<li>表示MinorGC结束后Survivor区域中占用空间的期望比例</li>
</ul>
</li>
</ul>
<h6 id="3、方法区"><a href="#3、方法区" class="headerlink" title="3、方法区"></a>3、方法区</h6><ul>
<li>永久代<ul>
<li><code>-XX:PermSize=256m</code><ul>
<li>设置永久代初始值为256M</li>
</ul>
</li>
<li><code>-XX:MaxPermSize=256m</code><ul>
<li>设置永久代最大值为256M</li>
</ul>
</li>
</ul>
</li>
<li>元空间<ul>
<li><code>-XX:MetaspaceSize</code><ul>
<li>初始空间大小</li>
</ul>
</li>
<li><code>-XX:MaxMetaspaceSize</code><ul>
<li>最大空间，默认没有限制</li>
</ul>
</li>
<li><code>-XX:+UseCompressedOops</code><ul>
<li>使用压缩对象指针</li>
</ul>
</li>
<li><code>-XX:+UseCompressedClassPointers</code><ul>
<li>使用压缩类指针</li>
</ul>
</li>
<li><code>-XX:CompressedClassSpaceSize</code><ul>
<li>设置Klass Metaspace的大小，默认1G</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4、直接内存"><a href="#4、直接内存" class="headerlink" title="4、直接内存"></a>4、直接内存</h6><ul>
<li><code>-XX:MaxDirectMemorySize</code><ul>
<li>指定DirectMemory容量，若未指定，则默认与Java堆最大值一样</li>
</ul>
</li>
</ul>
<h5 id="3、OutOfMemory相关的选项"><a href="#3、OutOfMemory相关的选项" class="headerlink" title="3、OutOfMemory相关的选项"></a>3、OutOfMemory相关的选项</h5><ul>
<li><p><code>-XX:+HeapDumpOnOutMemoryError</code></p>
<ul>
<li>表示<strong>在内存出现OOM的时候，生成Heap转储文件，以便后续分析</strong></li>
<li>-<code>XX:+HeapDumpBeforeFullGC</code>和<code>-XX:+HeapDumpOnOutMemoryError</code>只能设置1个</li>
</ul>
</li>
<li><p><code>-XX:+HeapDumpBeforeFullGC</code></p>
<ul>
<li>表示<strong>在出现FullGC之前，生成Heap转储文件，以便后续分析</strong></li>
<li><code>-XX:+HeapDumpBeforeFullGC</code>和<code>-XX:+HeapDumpOnOutMemoryError</code>只能设置1个</li>
<li>请注意<strong>FullGC可能出现多次</strong>，那么dump文件也会生成多个，而OOM只能有一次，所以<code>-XX:+HeapDumpOnOutMemoryError</code>生成的dump文件只有一个</li>
</ul>
</li>
<li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code></p>
<ul>
<li>指定heap转存文件的存储路径，如果不指定，就会将dump文件放在当前目录中</li>
</ul>
</li>
<li><p><code>-XX:OnOutOfMemoryError</code></p>
<ul>
<li><p>指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</p>
</li>
<li><p>对OnOutOfMemoryError的运维处理：</p>
<ul>
<li><p>以部署在linux系统/opt/Server目录下的Server.jar为例：</p>
<ol>
<li><p>在run. sh启动脚本中添加jvm参数：<code>-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></p>
</li>
<li><p>restart.sh脚本：</p>
<ul>
<li><p>linux环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">pid=$(ps -eflgrep Server.jar|awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;)</span><br><span class="line">kill -9 $pid</span><br><span class="line">cd /opt/Server/;sh run.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo off</span><br><span class="line">wmic process where Name=&#x27;java.exe&#x27; delete</span><br><span class="line">cd D:\Server</span><br><span class="line">start run.bat</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、垃圾收集器相关选项"><a href="#4、垃圾收集器相关选项" class="headerlink" title="4、垃圾收集器相关选项"></a>4、垃圾收集器相关选项</h5><p>7款经典收集器与垃圾分代之间的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210429024547757.png" alt="image-20210429024547757"></p>
<p>垃圾收集器的组合关系：</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<h6 id="1、查看默认的垃圾回收器"><a href="#1、查看默认的垃圾回收器" class="headerlink" title="1、查看默认的垃圾回收器"></a>1、查看默认的垃圾回收器</h6><ul>
<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令: <code>jinfo - flag 相关垃圾回收器参数进程ID</code></li>
</ul>
<p>以上两种方式都可以查看默认使用的垃圾回收器，第一种方式更加准备，但是需要程序的支持；第二种方式需要去尝试，如果使用了，返回的值中有<code>+</code>号（使用），否则就是<code>-</code>号（没使用）。</p>
<h6 id="2、Serial回收器"><a href="#2、Serial回收器" class="headerlink" title="2、Serial回收器"></a>2、Serial回收器</h6><ul>
<li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li>
<li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器。</li>
<li><code>-XX:+UseSerialGC</code>：<ul>
<li>指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC。 可以获得最高的单线程收集效率。</li>
</ul>
</li>
</ul>
<h6 id="3、Parnew回收器"><a href="#3、Parnew回收器" class="headerlink" title="3、Parnew回收器"></a>3、Parnew回收器</h6><ul>
<li><code>-XX: +UseParNewGC</code>：<ul>
<li>手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：<ul>
<li>设置年轻代并行收集器的线程数。一般地， 最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li>
<li>在默认情况下，<strong>当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量。</strong></li>
<li><strong>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [5 * CPU_Count] / 8]</code> 。</strong></li>
</ul>
</li>
</ul>
<p>注意：根据下图可知，该回收器最终将会没有搭档，那就相当于被遗弃了（JDK14以后）</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<h6 id="4、Parallel回收器"><a href="#4、Parallel回收器" class="headerlink" title="4、Parallel回收器"></a>4、Parallel回收器</h6><ul>
<li><code>-XX:+UseParallelGC</code><ul>
<li>手动指定年轻代使用Parallel并行收集器执行内存回收任务。</li>
</ul>
</li>
<li><code>-XX: +UseParallelOldGC</code>：<ul>
<li>手动指定 =老年代都是使用并行回收收集器。<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>上面两个参数，默认开启一个， 另一个也会被开启。(<strong>互相激活</strong>)</li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：<ul>
<li>设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li>
<li>在默认情况下，<strong>当CPU 数量小于8个，ParallelGCThreads 的值等于CPU数量</strong>。</li>
<li><strong>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [5 * CPU_Count] / 8]</code> 。</strong></li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：<ul>
<li>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</li>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li><strong>该参数使用需谨慎。</strong></li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：<ul>
<li>垃圾收集时间占总时间的比例(= 1 / (N + 1))。用于衡量吞吐量的大小。</li>
<li>取值范围(0,100) 。默认值99，也就是垃圾回收时间不超过1%。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li>
</ul>
</li>
<li><code>-XX: +UseAdaptiveSizePolicy</code>：<ul>
<li>设置Parallel Scavenge收集器具有自适应调节策略</li>
<li>在这种模式下，年轻代的大小、Eden 和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，<strong>仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio) 和停顿时间(MaxGCPauseMills)</strong> ，让虚拟机自已完成调优工作。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ol>
<li><strong>Parallel回收器主打吞吐量</strong>，而<strong>CMS和G1主打低延迟</strong>，<strong>如果主打吞吐量，那么就不应该限制最大停顿时间，所以-XX:MaxGCPauseMills不应该设置</strong></li>
<li>-XX:MaxGCPauseMills中的调整堆大小通过默认开启的-XX:+UseAdaptiveSizePolicy来实现</li>
<li>-XX:GCTimeRatio用来衡量吞吐量，并且和-XX:MaxGCPauseMills矛盾，因此不会同时使用</li>
</ol>
<h6 id="5、CMS回收器"><a href="#5、CMS回收器" class="headerlink" title="5、CMS回收器"></a>5、CMS回收器</h6><ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：<ul>
<li>手动指定使用CMS收集器执行内存回收任务。</li>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开。</li>
<li>即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。</li>
</ul>
</li>
<li><code>-XX:CMS1nitiatingOccupanyFraction</code>：<ul>
<li>设置堆内存使用率的阅值，一旦达到该阈值，便开始进行回收。</li>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。**JDK6及以上版本默认值为92%**。</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阅值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：<ul>
<li>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时<br>间变得更长了。</li>
</ul>
</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：<ul>
<li>设置在执行多少次Full GC后对内存空间进行压缩整理。</li>
</ul>
</li>
<li><code>-XX:ParallelCMSThreads</code>：<ul>
<li>设置CMS的线程数量。</li>
<li>CMS默认启动的线程数是**(ParallelGCThreads + 3) / 4**，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧涨时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<p>-XX:ParallelCMSThreads和ParallelGCThreads有关系，ParallelGCThreads在上面Parnew回收器中有提到</p>
<p>另外，CMS收集器还有如下常用参数：</p>
<ul>
<li><code>-XX:ConcGCThreads</code>：<ul>
<li>设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的；</li>
</ul>
</li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：<ul>
<li>是否动态可调，用这个参数可以使CMS直按CMSInitiatingOccupancyFraction设定的值启动</li>
</ul>
</li>
<li><code>-XX:+CMSScavengeBeforeRemark</code>：<ul>
<li>强制hotspot 虚拟机在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</li>
</ul>
</li>
<li><code>-XX:+CMSClassUnloadingEnable</code>：<ul>
<li>如果有的话，启用回收Perm区(JDK8之前)</li>
</ul>
</li>
<li><code>-XX:+CMSParallelInitialEnabled</code>：<ul>
<li>用于开启CMS initial-mark阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；</li>
</ul>
</li>
<li><code>-XX:+CMSParallelRemarkEnbled</code>：<ul>
<li>用户开启CMS remark阶段采用多线程的方式进行重新标记。默认开启；</li>
</ul>
</li>
<li><code>-XX:+ExplicitGCInvokesConcurrent</code>、<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>：<ul>
<li>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期；</li>
</ul>
</li>
<li><code>-XX:+CMSPrecleaningEnabled</code>：<ul>
<li>指定CMS是否需要进行Pre cleaning这个阶段</li>
</ul>
</li>
</ul>
<p>特别说明：</p>
<ul>
<li>JDK9新特性：CMS被标记为Deprecate 了(JEP291)<ul>
<li>如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示<br>CMS未来将会被废弃。</li>
</ul>
</li>
<li>JDK14新特性：删除CMS垃圾回收器(JEP363)<ul>
<li>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li>
<li>OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGc；support was removed in 14.0 and the VM will continue execution using the default collector.</li>
</ul>
</li>
</ul>
<h6 id="6、G1回收器"><a href="#6、G1回收器" class="headerlink" title="6、G1回收器"></a>6、G1回收器</h6><ul>
<li><code>-XX:+UseG1GC</code>：<ul>
<li>手动指定使用G1收集器执行内存回收任务。</li>
</ul>
</li>
<li><code>-XX:G1HeapRegionSize</code>：<ul>
<li>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。<strong>默认是堆内存的1/2000</strong>。</li>
</ul>
</li>
<li><code>-XX: MaxGCPauseMillis</code>：<ul>
<li>设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。<strong>默认值是200ms</strong></li>
<li><code>-XX: ParallelGCThread</code>：<ul>
<li>设置STW时GC线程数的值。<strong>最多设置为8</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:ConcGCThreads</code>：<ul>
<li>设置并发标记的线程数。<strong>将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</strong>。</li>
</ul>
</li>
<li><code>-XX:InitiatingHeapoccupancyPercent</code>：<ul>
<li>设置触发并发GC周期的Java堆占用率阙值。超过此值，就触发GC。<strong>默认值是45</strong>。</li>
</ul>
</li>
<li><code>-XX: G1NewSizePercent</code>、 <code>-XX:G1MaxNewSizePercent</code>：<ul>
<li>新生代占用整个堆内存的最小百分比(默认5%)、最大百分比( 默认60%)</li>
</ul>
</li>
<li><code>-XX:G1ReservePercent=10</code><ul>
<li>保留内存区域，防止to space (Survivor中的to区)溢出</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>如果使用G1垃圾收集器，<strong>不建议设置<code>-Xmn</code>和<code>-XX:NewRatio</code>，毕竟可能影响G1的自动调节</strong></li>
</ul>
<p>Mixed GC调优参数：</p>
<ul>
<li>注意：<ul>
<li>G1收集器主要涉及到Mixed GC，<strong>Mixed GC 会回收young区和部分old区</strong>。</li>
</ul>
</li>
<li>G1关于MixedGC调优常用参数：<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：<ul>
<li>设置堆占用率的百分比(0到100)达到这个数值的时候触发global concurrent marking (全局并发标记)，<strong>默认为45%**。</strong>值为0表示间断进行全局并发标记**。</li>
</ul>
</li>
<li><code>-XX:G1MixedGCLiveThresholdPercent</code>：<ul>
<li>设置Old区的region被回收时候的对象占比，**默认占用率为85%**。只有Old区的region中存活的对象占用达到了这个百分比才会在Mixed GC中被回收。</li>
</ul>
</li>
<li><code>-XX:G1HeapWastePercent</code>：<ul>
<li>在global concurrent marking (全局并发标记)结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li>
</ul>
</li>
<li><code>-XX:G1MixedGCCountTarget</code>：<ul>
<li>一次global concurrent marking (全局并发标记)之后，最多执行Mixed GC的次数，<strong>默认是8</strong>。</li>
</ul>
</li>
<li><code>-XX:G1OldCSetRegionThresholdPercent</code>：<ul>
<li>设置Mixed GC收集周期中要收集的Old region数的 上限。<strong>默认值是Java堆的10%</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="7、怎么选择垃圾收集器"><a href="#7、怎么选择垃圾收集器" class="headerlink" title="7、怎么选择垃圾收集器"></a>7、怎么选择垃圾收集器</h6><ul>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应(比如延迟不能超过1秒，如互联网应用)，使用并发收集器。官方推荐G1，性能高。<strong>现在互联网的项目，基本都是使用G1</strong>。</li>
</ul>
<p>特别说明：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<h5 id="5、GC日志相关选项"><a href="#5、GC日志相关选项" class="headerlink" title="5、GC日志相关选项"></a>5、GC日志相关选项</h5><h6 id="1、常用参数"><a href="#1、常用参数" class="headerlink" title="1、常用参数"></a>1、常用参数</h6><ul>
<li><p><code>-verbose:gc</code>：</p>
<ul>
<li><p>输出日志信息，默认输出的标准输出</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003357660.png" alt="image-20210719003357660"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGC</code>：</p>
<ul>
<li><p>等同于<code>-verbose:gc</code>表示打开简化的日志</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003357660.png" alt="image-20210719003357660"></p>
</li>
</ul>
</li>
<li><p>**<code>-XX:+PrintGCDetails</code>**：</p>
<ul>
<li><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域的分配情况</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003601948.png" alt="image-20210719003601948"></p>
</li>
</ul>
</li>
<li><p>**<code>-XX:+PrintGCTimeStamps</code>**：</p>
<ul>
<li><p>程序启动到GC发生的时间秒数</p>
</li>
<li><p>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p>
<p><img src="/2021/04/19/JVM/2B360717-915B-414F-8897-127B432CD616.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGCDateStamps</code>：</p>
<ul>
<li><p>输出GC发生时的时间戳（以日期的形式，例如：2013-05-04T21:53:59.234+0800）</p>
</li>
<li><p>不可以独立使用，可以配合-XX:+PrintGCDetails使用</p>
<p><img src="/2021/04/19/JVM/96A76B65-8305-4A60-A695-F7079E5BAE03.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintHeapAtGC</code>：</p>
<ul>
<li><p>每一次GC前和GC后，都打印堆信息</p>
</li>
<li><p>可以独立使用</p>
</li>
<li><p>若配合**<code>-XX:+PrintGCDetails</code>**一起使用的话，可以将两个命令的结果结合在一起：每一次GC前和GC后，都打印堆信息+在进程退出时输出当前内存各区域的分配情况</p>
<p><img src="/2021/04/19/JVM/2C4F1339-2902-48E6-B298-B5F19C8C93D7.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>**<code>-XIoggc:&lt;file&gt;</code>**：</p>
<ul>
<li><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p>
<p><img src="/2021/04/19/JVM/DCEA1B70-2B04-4F80-9425-9F037465D0BB.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h6 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h6><ul>
<li><p><code>-XX:TraceClassLoading</code>：</p>
<ul>
<li>监控类的加载</li>
</ul>
</li>
<li><p><code>-XX:PrintGCApplicationStoppedTime</code>：</p>
<ul>
<li><p>打印GC时线程的停顿时间</p>
<p><img src="/2021/04/19/JVM/image-20210719004842828.png" alt="image-20210719004842828"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGCApplicationConcurrentTime</code>：</p>
<ul>
<li>垃圾收集之前打印出应用未中断的执行时间</li>
</ul>
</li>
<li><p><code>-XX:+PrintReferenceGC</code>：</p>
<ul>
<li>记录回收了多少种不同引用类型的引用</li>
</ul>
</li>
<li><p><code>-XX:+PrintTenuringDistribution</code>：</p>
<ul>
<li>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
</ul>
</li>
<li><p><code>-XX:+UseGCLogFileRotation</code>：</p>
<ul>
<li>启用GC日志文件的自动转储</li>
</ul>
</li>
<li><p><code>-XX:NumberOfGCLogFiles=1</code>：</p>
<ul>
<li>GC日志文件的循环数目</li>
</ul>
</li>
<li><p><code>-XX:GCLogFileSize=1M</code>：</p>
<ul>
<li>控制GC日志文件的大小</li>
</ul>
</li>
</ul>
<h5 id="6、其他参数"><a href="#6、其他参数" class="headerlink" title="6、其他参数"></a>6、其他参数</h5><ul>
<li><code>-XX:+DisableExplicitGC</code>：<ul>
<li>禁用hotspot执行System.gc()，默认禁用</li>
</ul>
</li>
<li><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]</code>、<code>-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code>：<ul>
<li>指定代码缓存的大小</li>
</ul>
</li>
<li><code>-XX:+UseCodeCacheFlushing</code>：<ul>
<li>使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</li>
</ul>
</li>
<li><code>-XX:+DoEscapeAnalysis</code>：<ul>
<li>开启逃逸分析</li>
</ul>
</li>
<li><code>-XX:+UseBiasedLocking</code>：<ul>
<li>开启偏向锁</li>
</ul>
</li>
<li><code>-XX:+UseLargePages</code>：<ul>
<li>开启使用大页面</li>
</ul>
</li>
<li><code>-XX:+PrintTLAB</code>：<ul>
<li>打印TLAB的使用情况</li>
</ul>
</li>
<li><code>-XX:TLABSize</code>：<ul>
<li>设置TLAB大小</li>
</ul>
</li>
</ul>
<h4 id="4、通过Java代码获取JVM参数"><a href="#4、通过Java代码获取JVM参数" class="headerlink" title="4、通过Java代码获取JVM参数"></a>4、通过Java代码获取JVM参数</h4><p>Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虛拟机。其中ManagementFactory这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。</p>
<p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上篇可以通过Runtime获取：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返间Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print1n(<span class="string">&quot;-Xms :&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx :&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为:&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为:&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、分析GC日志"><a href="#5、分析GC日志" class="headerlink" title="5、分析GC日志"></a>5、分析GC日志</h3><h4 id="1、GC日志参数"><a href="#1、GC日志参数" class="headerlink" title="1、GC日志参数"></a>1、GC日志参数</h4><p>同上面第4、JVM运行时参数中的第5点、GC日志相关选项一致</p>
<h4 id="2、GC日志格式"><a href="#2、GC日志格式" class="headerlink" title="2、GC日志格式"></a>2、GC日志格式</h4><h5 id="1、复习：GC分类"><a href="#1、复习：GC分类" class="headerlink" title="1、复习：GC分类"></a>1、复习：GC分类</h5><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是<strong>部分收集（Partial GC）</strong>，一种是<strong>整堆收集（Full GC）</strong></p>
<ul>
<li>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul>
<li><strong>新生代收集（Minor GC / Young GC）</strong>：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li><strong>老年代收集（Major GC / Old GC）</strong>：只是老年代的垃圾收集。<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为。</li>
<li>注意：<ul>
<li><strong>在进行Major GC之前，系统会先进行一次Minor GC</strong></li>
<li><strong>很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>混合收集（Mixed GC）</strong>：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li>
</ul>
<p>那些情况会触发Full GC呢？</p>
<ul>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>显式调用System.gc()</li>
<li>Minor GC进入老年代的数据的平均大小 大于 老年代的可用内存</li>
<li>大对象直接进入老年代，而老年代的可用空间不足</li>
</ul>
<h5 id="2、GC日志分类"><a href="#2、GC日志分类" class="headerlink" title="2、GC日志分类"></a>2、GC日志分类</h5><h6 id="1、Minor-GC"><a href="#1、Minor-GC" class="headerlink" title="1、Minor GC"></a>1、Minor GC</h6><p>MinorGC（或 young GC 或 YGC）日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210719011748465.png" alt="image-20210719011748465"></p>
<p><img src="/2021/04/19/JVM/image-20210719011823127.png" alt="image-20210719011823127"></p>
<h6 id="2、Full-GC"><a href="#2、Full-GC" class="headerlink" title="2、Full GC"></a>2、Full GC</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210719011929852.png" alt="image-20210719011929852"></p>
<p><img src="/2021/04/19/JVM/image-20210719012024393.png" alt="image-20210719012024393"></p>
<h5 id="3、GC日志结构剖析"><a href="#3、GC日志结构剖析" class="headerlink" title="3、GC日志结构剖析"></a>3、GC日志结构剖析</h5><h6 id="1、透过日志看垃圾收集器"><a href="#1、透过日志看垃圾收集器" class="headerlink" title="1、透过日志看垃圾收集器"></a>1、透过日志看垃圾收集器</h6><ul>
<li>使用<code>Serial收集器</code>在<strong>新生代</strong>的名字是Default New Generation，因此显示的是”<code>[DefNew</code>“</li>
<li>使用<code>ParNew收集器</code>在<strong>新生代</strong>的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation’</li>
<li>使用<code>Parallel Scavenge收集器</code>在<strong>新生代</strong>的名字是”<code>[PSYoungGen</code>“，这里的JDK1.7使用的就是PSYoungGen</li>
<li>使用<code>Parallel Old Generation收集器</code>在<strong>老年代</strong>的名字是”<code>[ParOldGen</code>“</li>
<li>使用<code>G1收集器</code>的话，会显示为”<code>garbage-first heap</code>“</li>
</ul>
<h6 id="2、透过日志看-GC-原因"><a href="#2、透过日志看-GC-原因" class="headerlink" title="2、透过日志看 GC 原因"></a>2、透过日志看 GC 原因</h6><ul>
<li><code>Allocation Failure</code>：表明本次引起GC的原因是因为在<strong>年轻代</strong>中没有足够的空间能够存储新的数据了</li>
<li><code>Metadata GCThreshold</code>：Metaspace 区不够用了</li>
<li><code>FErgonomics</code>：JVM 自适应调整导致的 GC</li>
<li><code>System</code>：调用了 System.gc()方法</li>
</ul>
<h6 id="3、透过日志看-GC-前后情况"><a href="#3、透过日志看-GC-前后情况" class="headerlink" title="3、透过日志看 GC 前后情况"></a>3、透过日志看 GC 前后情况</h6><p>通过图示，我们可以发现 GC 日志格式的规律一般都是：<strong>GC 前内存占用 -＞ GC 后内存占用（该区域内存总大小）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure>

<ul>
<li>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li>
<li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
<p>注意：</p>
<ul>
<li>Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代。<ul>
<li>原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1=8:1:1。</li>
</ul>
</li>
</ul>
<h6 id="4、透过日志看-GC-时间"><a href="#4、透过日志看-GC-时间" class="headerlink" title="4、透过日志看 GC 时间"></a>4、透过日志看 GC 时间</h6><p>GC 日志中有三个时间：<strong>user</strong>，<strong>sys</strong> 和 <strong>real</strong>（结果采用四舍五入的形式）</p>
<ul>
<li><code>user</code>：进程执行用户态代码（核心之外）所使用的时间。这是<strong>执行此进程所使用的实际 CPU 时间</strong>，其他进程和此进程阻塞的时间并不包括在内。<strong>在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间</strong>。</li>
<li><code>sys</code>：进程在内核态消耗的 CPU 时间，即<strong>在内核执行系统调用或等待系统事件所使用的 CPU 时间</strong></li>
<li><code>real</code>：<strong>程序从开始到结束所用的时钟时间</strong>。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。<strong>对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</strong>。</li>
</ul>
<p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。<strong>如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</strong></p>
<h5 id="4、Minor-GC日志解析"><a href="#4、Minor-GC日志解析" class="headerlink" title="4、Minor GC日志解析"></a>4、Minor GC日志解析</h5><p><code>-XX:+PrintGCTimeStamps</code> + <code>-XX:+PrintGCDateStamps</code> + <code>-XX:+PrintGCDetails</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.265-0800:0.822: [GC (ALLOCATION FAILURE) [PSYOUNGGEN:76800K-&gt;8433K(89600K)] 76800K -&gt; 8449K(294400K), 0.0088371 SECS] [TIMES:USER=0.02 SYS=0.01, REAL=0.01 SECS]</span><br></pre></td></tr></table></figure>

<ul>
<li>2020-11-20T17:19:43.265-0800<ul>
<li>日志打印时间日期格式如：2013-05-04T21:53:59.234+0800</li>
</ul>
</li>
<li>0.822<ul>
<li>gc发生时，Java虛拟机启动以来经过的秒数</li>
</ul>
</li>
<li>[GC (Allocation Failure)<ul>
<li>发生了一次垃圾回收，这是一次Minor GC。它不区分新生代GC还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是<strong>新生代中没有足够区域能够存放需要分配的数据而失败</strong>。</li>
<li>除此之外还有：<ul>
<li><code>Metadata GCThreshold</code>：Metaspace 区不够用了</li>
<li><code>FErgonomics</code>：JVM 自适应调整导致的 GC</li>
<li><code>System</code>：调用了 System.gc()方法</li>
</ul>
</li>
</ul>
</li>
<li>[PSYoungGen:76800K-&gt;8433K(89600K)]<ul>
<li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li><strong>Serial收集器</strong>：Default New Generation显示<strong>DefNew</strong></li>
<li><strong>ParNew</strong>收集器：<strong>ParNew</strong></li>
<li><strong>Parallel Scanvenge</strong>收集器：<strong>PSYoungGen</strong></li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li>76800K-&gt;8433K(89600K)：GC前该内存区域已使用容量 -&gt; GC后该区域容量(该区域总容量)<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from区（默认SurvivorRatio = 8）</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li>76800K -&gt; 8449K(294400K)<ul>
<li>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量 -&gt; GC堆内存容量(堆内存总容量)</li>
<li>堆内存总容量 = 9/10新生代+老年代 &lt; 初始化的内存大小.</li>
</ul>
</li>
<li>0.0088371 secs]<ul>
<li>整个GC所花费的时间，单位是秒</li>
</ul>
</li>
<li>[Times:user=0.02 sys=0.01, real=0.01 secs]<ul>
<li>user：指的是CPU工作在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h5 id="5、Full-GC日志解析"><a href="#5、Full-GC日志解析" class="headerlink" title="5、Full GC日志解析"></a>5、Full GC日志解析</h5><p><code>-XX:+PrintGCTimeStamps</code> + <code>-XX:+PrintGCDateStamps</code> + <code>-XX:+PrintGCDetails</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.794-0800:1.351:[FULL GC (METADATA GC THRESHOLD)[PSYOUNGGEN:10082K -&gt; 0K(89600K)][PAROLDGEN:32K -&gt; 9638K(204800K)] </span><br><span class="line">10114K -&gt; 9638K(294400K),[METASPACE:20158K -&gt; 20156K(1067008K)], 0.0285388 SECS] </span><br><span class="line">[TIMES: USER=0.11 SYS=0.00, REAL=0.03 SECS]</span><br></pre></td></tr></table></figure>

<ul>
<li>2020-11-20T17:19:43.794-0800<ul>
<li>日志打印时间日期格式如：2013-05-04T21:53:59.234+0800</li>
</ul>
</li>
<li>1.351<ul>
<li>gc发生时，Java虛拟机启动以来经过的秒数</li>
</ul>
</li>
<li>[Full GC (Metadata GC Threshold)<ul>
<li>发生了一次垃圾回收，这是一次FULL GC。它不区分新生代GC还是老年代GC</li>
<li>括号里的内容是gc发生的原因，这里的MetadataGC Threshold的原因是Metaspace区不够用了。<ul>
<li>Full GC (Ergonomics)：JVM自适应调整导致的GC</li>
<li>Full GC (System)：调用了System.gc()方法</li>
</ul>
</li>
</ul>
</li>
<li>[PSYoungGen:10082K -&gt; 0K(89600K)]<ul>
<li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li><strong>Serial收集器</strong>：Default New Generation显示<strong>DefNew</strong></li>
<li><strong>ParNew</strong>收集器：<strong>ParNew</strong></li>
<li><strong>Parallel Scanvenge</strong>收集器：<strong>PSYoungGen</strong></li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li>10082K -&gt; 0K(89600K)：GC前该内存区域已使用容量 -&gt; GC后该区域容量(该区域总容量)<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from区（默认SurvivorRatio = 8）</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li>[ParOldGen:32K -&gt; 9638K(204800K)]<ul>
<li>老年代区域没有发生GC，因为本次GC是metaspace引起的</li>
</ul>
</li>
<li>10114K -&gt; 9638K(294400K)<ul>
<li>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量 -&gt; GC堆内存容量(堆内存总容量)</li>
<li>堆内存总容量 = 9/10新生代+老年代 &lt; 初始化的内存大小.</li>
</ul>
</li>
<li>[Metaspace:20158K -&gt; 20156K(1067008K)]<ul>
<li>metaspace GC回收2K空间</li>
</ul>
</li>
<li>0.0285388 secs]<ul>
<li>整个GC所花费的时间，单位是秒</li>
</ul>
</li>
<li>[Times:user=0.11 sys=0.00, real=0.03 secs]<ul>
<li>user：指的是CPU工作在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h5 id="6、G1-GC的日志分析"><a href="#6、G1-GC的日志分析" class="headerlink" title="6、G1 GC的日志分析"></a>6、G1 GC的日志分析</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab37844d0e9e">参考博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/convict_eva/article/details/80623215">参考博客</a></p>
<h4 id="3、GC日志分析工具"><a href="#3、GC日志分析工具" class="headerlink" title="3、GC日志分析工具"></a>3、GC日志分析工具</h4><h5 id="1、GCEasy"><a href="#1、GCEasy" class="headerlink" title="1、GCEasy"></a>1、GCEasy</h5><ul>
<li>基本概述：<ul>
<li>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。（当然有一些服务还是收费的）</li>
</ul>
</li>
<li>下载安装：<a target="_blank" rel="noopener" href="https://gceasy.io/">官网地址</a></li>
</ul>
<p>选择需要分析的log文件 -&gt; 点击Analyze -&gt; 可以点击Download将分析结果下载下来进行离线分析</p>
<p><img src="/2021/04/19/JVM/image-20210719024156110.png" alt="image-20210719024156110"></p>
<p>相关分析：</p>
<ul>
<li><p>案例1：MetaspaceOOM</p>
<p><img src="/2021/04/19/JVM/image-20210719025413453.png" alt="image-20210719025413453"></p>
</li>
<li><p>案例2：老年代满了导致堆OOM</p>
<p><img src="/2021/04/19/JVM/image-20210719025515161.png" alt="image-20210719025515161"></p>
</li>
</ul>
<h5 id="2、GCViewer"><a href="#2、GCViewer" class="headerlink" title="2、GCViewer"></a>2、GCViewer</h5><ul>
<li>基本概述<ul>
<li>GCViewer是一个免费的、开源的分析小工具，用于可视化查看由SUN/Oracle、IBM、HP和BEA Java虚拟机产生的垃圾收集器的日志。</li>
<li>GCViewer 是一款<strong>离线</strong>的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。</file></li>
<li><strong>当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</strong>。</li>
</ul>
</li>
<li>下载安装：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chewiebug/GCViewer">源码下载</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chewiebug/GCViewer/wiki/Changelog">运行版本下载</a></li>
<li>下载之后只需双击gcviewer-1.3x. jar或运行java -jar gcviewer-1.3x.jar (它需要运行java1.8 vm)，即可启动GCViewer (gui) </li>
</ul>
</li>
</ul>
<h5 id="3、其他工具"><a href="#3、其他工具" class="headerlink" title="3、其他工具"></a>3、其他工具</h5><ul>
<li>GChisto<ul>
<li>基本概述：GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：MinorGC、Full GC的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应gc的情况。</li>
<li>虽然界面略显粗糙，但是功能还是不错的。</li>
<li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li>
<li>不过这个工具似乎没怎么维护了，存在不少 bug</li>
</ul>
</li>
<li>HPjmeter<ul>
<li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li>
<li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li>
</ul>
</li>
</ul>
<h3 id="6、OOM常见各种场景及解决方案"><a href="#6、OOM常见各种场景及解决方案" class="headerlink" title="6、OOM常见各种场景及解决方案"></a>6、OOM常见各种场景及解决方案</h3><h4 id="1、案例1：堆溢出"><a href="#1、案例1：堆溢出" class="headerlink" title="1、案例1：堆溢出"></a>1、案例1：堆溢出</h4><h4 id="2、案例2：元空间溢出"><a href="#2、案例2：元空间溢出" class="headerlink" title="2、案例2：元空间溢出"></a>2、案例2：元空间溢出</h4><h4 id="3、案例3：GC-overhead-limit-exceeded"><a href="#3、案例3：GC-overhead-limit-exceeded" class="headerlink" title="3、案例3：GC overhead limit exceeded"></a>3、案例3：GC overhead limit exceeded</h4><h4 id="4、案例4：线程溢出"><a href="#4、案例4：线程溢出" class="headerlink" title="4、案例4：线程溢出"></a>4、案例4：线程溢出</h4><h3 id="7、性能优化案例"><a href="#7、性能优化案例" class="headerlink" title="7、性能优化案例"></a>7、性能优化案例</h3><h4 id="1、性能测试工具：Jmeter"><a href="#1、性能测试工具：Jmeter" class="headerlink" title="1、性能测试工具：Jmeter"></a>1、性能测试工具：Jmeter</h4><h4 id="2、案例1：调整堆大小提高服务的吞吐量"><a href="#2、案例1：调整堆大小提高服务的吞吐量" class="headerlink" title="2、案例1：调整堆大小提高服务的吞吐量"></a>2、案例1：调整堆大小提高服务的吞吐量</h4><h4 id="3、案例2：调整垃圾回收器提高服务的吞吐量"><a href="#3、案例2：调整垃圾回收器提高服务的吞吐量" class="headerlink" title="3、案例2：调整垃圾回收器提高服务的吞吐量"></a>3、案例2：调整垃圾回收器提高服务的吞吐量</h4><h4 id="4、案例3：JVM优化之JIT优化"><a href="#4、案例3：JVM优化之JIT优化" class="headerlink" title="4、案例3：JVM优化之JIT优化"></a>4、案例3：JVM优化之JIT优化</h4><h4 id="5、案例4：G1并发执行的线程数对性能的影响"><a href="#5、案例4：G1并发执行的线程数对性能的影响" class="headerlink" title="5、案例4：G1并发执行的线程数对性能的影响"></a>5、案例4：G1并发执行的线程数对性能的影响</h4><h4 id="6、案例5：合理配置堆内存"><a href="#6、案例5：合理配置堆内存" class="headerlink" title="6、案例5：合理配置堆内存"></a>6、案例5：合理配置堆内存</h4><h4 id="7、特殊问题：新生代与老年代的比例"><a href="#7、特殊问题：新生代与老年代的比例" class="headerlink" title="7、特殊问题：新生代与老年代的比例"></a>7、特殊问题：新生代与老年代的比例</h4><h5 id="1、参数设置"><a href="#1、参数设置" class="headerlink" title="1、参数设置"></a>1、参数设置</h5><h5 id="2、参数AdaptiveSizePolicy"><a href="#2、参数AdaptiveSizePolicy" class="headerlink" title="2、参数AdaptiveSizePolicy"></a>2、参数AdaptiveSizePolicy</h5><ul>
<li>补充</li>
</ul>
<h4 id="8、案例6：CPU占用很高排查方案"><a href="#8、案例6：CPU占用很高排查方案" class="headerlink" title="8、案例6：CPU占用很高排查方案"></a>8、案例6：CPU占用很高排查方案</h4><h4 id="9、日均百万级订单交易系统如何设置JVM参数"><a href="#9、日均百万级订单交易系统如何设置JVM参数" class="headerlink" title="9、日均百万级订单交易系统如何设置JVM参数"></a>9、日均百万级订单交易系统如何设置JVM参数</h4><h5 id="1、现状"><a href="#1、现状" class="headerlink" title="1、现状"></a>1、现状</h5><h5 id="2、解决思路"><a href="#2、解决思路" class="headerlink" title="2、解决思路"></a>2、解决思路</h5><h5 id="3、参数配置"><a href="#3、参数配置" class="headerlink" title="3、参数配置"></a>3、参数配置</h5><h3 id="8、Java代码层及其它层面调优"><a href="#8、Java代码层及其它层面调优" class="headerlink" title="8、Java代码层及其它层面调优"></a>8、Java代码层及其它层面调优</h3><h3 id="9、大厂面试题-1"><a href="#9、大厂面试题-1" class="headerlink" title="9、大厂面试题"></a>9、大厂面试题</h3><ul>
<li>支付宝：<ul>
<li>支付宝三面：JVM性能调优都做了什么?</li>
</ul>
</li>
<li>小米：<ul>
<li>有做过JVM内存优化吗?</li>
<li>从SQL、JVM、 架构、数据库四个方面讲讲优化思路</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>JVM的编译优化</li>
<li>JVM性能调优都做了什么</li>
<li>JVM诊断调优工具用过哪些?</li>
<li>二面：jvm怎样调优，堆内存、栈空间设置多少合适</li>
<li>三面：JVM相关的分析工具使用过的有哪些?具体的性能调优步骤如何</li>
</ul>
</li>
<li>阿里：<ul>
<li>如何进行JVM调优?有哪些方法?</li>
<li>如何理解内存泄漏问题?有哪些情况会导致内存泄漏?如何解决?</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>三面: JVM如何调优、参数怎么调?</li>
</ul>
</li>
<li>拼多多：<ul>
<li>从SQL、JVM、架构、数据库四个方面讲讲优化思路</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM诊断调优工具用过哪些?</li>
<li>每秒几十万并发的秒杀系统为什么会频繁发生GC?</li>
<li>日均百万级交易系统如何优化JVM?</li>
<li>线上生产系统00M如何监控及定位与解决?</li>
<li>高并发系统如何基于G1垃圾回收器优化性能?</li>
</ul>
</li>
</ul>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/su20145104009/article/details/83095871">Java引用类型：强引用，软引用，弱引用，虚引用</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/185612299">浅谈双亲委派机制的缺陷及打破双亲委派机制</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1662654539572628762&wfr=spider&for=pc">谈谈双亲委派模型的第四次破坏——模块化</a></p>
<p>相关网站：</p>
<p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数查找</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/04/19/JVM/" title="JVM">http://xgh-user.github.io/2021/04/19/JVM/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/15/springcloud/" rel="prev" title="SpringCloud">
      <i class="fa fa-chevron-left"></i> SpringCloud
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式">
      设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.</span> <span class="nav-text">上篇：内存与垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、JVM与Java体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8EJava%E4%B8%8EJVM"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、关于Java与JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2、字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3、多语言混合编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">4、虚拟机与JVM（java虚拟机）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">1、什么是虚拟机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="nav-number">1.1.1.4.2.</span> <span class="nav-text">2、JVM（java虚拟机）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81JVM%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.1.4.3.</span> <span class="nav-text">3、JVM的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81JVM%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.1.4.4.</span> <span class="nav-text">4、JVM的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.1.1.4.5.</span> <span class="nav-text">5、JVM的位置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81JVM%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">5、JVM的整体结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">6、Java代码的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">7、JVM的架构模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">8、JVM的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">1.1.1.8.1.</span> <span class="nav-text">1、虚拟机的启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.1.8.2.</span> <span class="nav-text">2、虚拟机的执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%80%80%E5%87%BA"><span class="nav-number">1.1.1.8.3.</span> <span class="nav-text">3、虚拟机的退出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81JVM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">1.1.1.9.</span> <span class="nav-text">9、JVM的发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Sun-Classic-VM%EF%BC%88SUN%EF%BC%89"><span class="nav-number">1.1.1.9.1.</span> <span class="nav-text">1、Sun Classic VM（SUN）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Exact-VM%EF%BC%88SUN%EF%BC%89"><span class="nav-number">1.1.1.9.2.</span> <span class="nav-text">2、Exact VM（SUN）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Hotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%E5%A4%A7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E4%B8%80%EF%BC%89%EF%BC%88Longview-Technologies-SUN-Oracle%EF%BC%89"><span class="nav-number">1.1.1.9.3.</span> <span class="nav-text">3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81JRockit%EF%BC%88%E4%B8%89%E5%A4%A7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E4%B8%80%EF%BC%89%EF%BC%88BEA-Oracle%EF%BC%89"><span class="nav-number">1.1.1.9.4.</span> <span class="nav-text">4、JRockit（三大虚拟机之一）（BEA\Oracle）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81J9%EF%BC%88%E4%B8%89%E5%A4%A7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E4%B8%80%EF%BC%89%EF%BC%88IBM%EF%BC%89"><span class="nav-number">1.1.1.9.5.</span> <span class="nav-text">5、J9（三大虚拟机之一）（IBM）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81KVM%E5%92%8CCDC-CLDC-Hotspot"><span class="nav-number">1.1.1.9.6.</span> <span class="nav-text">6、KVM和CDC&#x2F; CLDC Hotspot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81Azul-VM%EF%BC%88Azul-Systems%EF%BC%89"><span class="nav-number">1.1.1.9.7.</span> <span class="nav-text">7、Azul VM（Azul Systems）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81Liquid-VM%EF%BC%88BEA%EF%BC%89"><span class="nav-number">1.1.1.9.8.</span> <span class="nav-text">8、Liquid VM（BEA）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81Apache-Harmony%EF%BC%88IBM%E5%92%8CInter%EF%BC%89"><span class="nav-number">1.1.1.9.9.</span> <span class="nav-text">9、Apache Harmony（IBM和Inter）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10%E3%80%81Microsoft-JVM%EF%BC%88Microsoft%EF%BC%89"><span class="nav-number">1.1.1.9.10.</span> <span class="nav-text">10、Microsoft JVM（Microsoft）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11%E3%80%81TaobaoJVM%EF%BC%88Alibaba%EF%BC%89"><span class="nav-number">1.1.1.9.11.</span> <span class="nav-text">11、TaobaoJVM（Alibaba）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12%E3%80%81Dalvik-VM%EF%BC%88Google%EF%BC%89"><span class="nav-number">1.1.1.9.12.</span> <span class="nav-text">12、Dalvik VM（Google）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13%E3%80%81Graal-VM"><span class="nav-number">1.1.1.9.13.</span> <span class="nav-text">13、Graal VM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14%E3%80%81%E5%85%B6%E4%BB%96%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">1.1.1.9.14.</span> <span class="nav-text">14、其他虚拟机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88Class-Loader%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、类加载器子系统（Class Loader）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1、内部结构概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">1、类加载器子系统作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E8%A7%92%E8%89%B2"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">2、类加载器ClassLoader角色</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2、类加载器与类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81JVM%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">1、JVM架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">2、类加载的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.2.2.3.</span> <span class="nav-text">3、类加载的三个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="nav-number">1.1.2.2.3.1.</span> <span class="nav-text">1、阶段一：Loading（加载）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="nav-number">1.1.2.2.3.2.</span> <span class="nav-text">2、阶段二：Linking（链接）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89"><span class="nav-number">1.1.2.2.3.3.</span> <span class="nav-text">3、阶段三：Initialization（初始化）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">3、类加载器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">1、类加载器分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CBootstrap-ClassLoader-%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader-%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">1.1.2.3.3.</span> <span class="nav-text">3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CAppClassLoader-%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">1.1.2.3.4.</span> <span class="nav-text">4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.1.2.3.5.</span> <span class="nav-text">5、用户自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Class-Loader%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">4、Class Loader的使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">5、双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.5.1.</span> <span class="nav-text">1、什么是双亲委派机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.2.5.2.</span> <span class="nav-text">2、工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BE%8B%E5%AD%90"><span class="nav-number">1.1.2.5.3.</span> <span class="nav-text">3、例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BC%98%E5%8A%BF"><span class="nav-number">1.1.2.5.4.</span> <span class="nav-text">4、优势</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">6、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9C%A8JVM%E4%B8%AD%E8%A1%A8%E7%A4%BA%E4%B8%A4%E4%B8%AAclass%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.2.6.1.</span> <span class="nav-text">1、在JVM中表示两个class对象是否为同一个类存在两个必要条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.2.6.2.</span> <span class="nav-text">2、对类加载器的引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.2.6.3.</span> <span class="nav-text">3、类的主动使用与被动使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、运行时数据区概述及线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%BB%8F%E5%85%B8%E7%9A%84JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">1、经典的JVM内存布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">2、进程同步与线程同步：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">1.1.3.1.3.</span> <span class="nav-text">3、关于线程间共享的说明：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">2、线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">1、关于线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">2、线程的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81JVM%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">3、JVM的系统线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="nav-number">1.1.4.</span> <span class="nav-text">4、程序计数器（PC寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81PC-Register%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1、PC Register介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">2、举例说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">3、两个常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81CPU%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">4、CPU时间片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.1.5.</span> <span class="nav-text">5、虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1、虚拟机栈概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">1、虚拟机栈出现的背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">2、内存中的栈与堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">3、虚拟机栈基本内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">2、栈的存储单位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">1、栈中存储什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">2、栈的运行原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.5.2.3.</span> <span class="nav-text">3、栈帧的内部结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8-Local-Variables"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">3、局部变量表( Local Variables)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">1、局部变量表的概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">2、对程序编译后的字节码文件的查看方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.5.3.3.</span> <span class="nav-text">3、关于Slot的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="nav-number">1.1.5.3.4.</span> <span class="nav-text">4、Slot的重复利用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.5.3.5.</span> <span class="nav-text">5、静态变量与局部变量的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">1.1.5.3.6.</span> <span class="nav-text">6、补充说明：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88-Operand-Stack"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">4、操作数栈(Operand Stack)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%BB%A3%E7%A0%81%E8%B7%9F%E8%B8%AA"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">5、代码跟踪</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AF%B9%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.1.5.5.1.</span> <span class="nav-text">1、对操作数栈相关知识点的代码分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9Ai-VS-i"><span class="nav-number">1.1.5.5.2.</span> <span class="nav-text">2、面试问题：i++ VS ++i</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">1.1.5.6.</span> <span class="nav-text">6、栈顶缓存技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-Dynamic-Linking-%EF%BC%88%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89%EF%BC%88%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B9%8B%E4%B8%80%EF%BC%89"><span class="nav-number">1.1.5.7.</span> <span class="nav-text">7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9A%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E6%B4%BE"><span class="nav-number">1.1.5.8.</span> <span class="nav-text">8、方法的调用：解析与分派</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.5.8.1.</span> <span class="nav-text">1、静态链接与动态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.5.8.2.</span> <span class="nav-text">2、方法的绑定机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.5.8.3.</span> <span class="nav-text">3、虚方法与非虚方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E4%BA%8Einvokedynamic"><span class="nav-number">1.1.5.8.4.</span> <span class="nav-text">4、关于invokedynamic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.1.5.8.5.</span> <span class="nav-text">5、方法重写的本质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="nav-number">1.1.5.8.6.</span> <span class="nav-text">6、虚方法表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80-Return-Address"><span class="nav-number">1.1.5.9.</span> <span class="nav-text">9、方法返回地址(Return Address)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.5.10.</span> <span class="nav-text">10、一些附加信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.5.11.</span> <span class="nav-text">11、栈的相关面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12%E3%80%81%E5%85%B3%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E4%BA%94%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84OOM%E4%B8%8EGC%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.5.12.</span> <span class="nav-text">12、关于运行时数据区的五大部分的OOM与GC问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.6.</span> <span class="nav-text">6、本地方法接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">1、什么是本地方法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Native-Method"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">2、为什么要使用Native Method?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%8E%B0%E7%8A%B6"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">3、现状</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stack"><span class="nav-number">1.1.7.</span> <span class="nav-text">7、本地方法栈(Native Method Stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="nav-number">1.1.8.</span> <span class="nav-text">8、堆（Heap）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">1、堆的核心概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">2、设置堆内存大小与OOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">3、年轻代与老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%9B%BE%E8%A7%A3%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">4、图解大小分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="nav-number">1.1.8.5.</span> <span class="nav-text">5、minor GC、Major GC、Full GC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81GC%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.8.5.1.</span> <span class="nav-text">1、GC的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%AD%96%E7%95%A5%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.8.5.2.</span> <span class="nav-text">2、最简单的分代式GC策略的触发条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.8.6.</span> <span class="nav-text">6、堆空间分代思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E6%88%96%E5%AF%B9%E8%B1%A1%E6%8F%90%E5%8D%87-Promotion-%E8%A7%84%E5%88%99"><span class="nav-number">1.1.8.7.</span> <span class="nav-text">7、内存分配策略(或对象提升(Promotion)规则)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="nav-number">1.1.8.8.</span> <span class="nav-text">8、为对象分配内存：TLAB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89TLAB-Thread-Local-Allocation-Buffer"><span class="nav-number">1.1.8.8.1.</span> <span class="nav-text">1、为什么有TLAB ( Thread Local Allocation Buffer ) ?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%9F"><span class="nav-number">1.1.8.8.2.</span> <span class="nav-text">2、什么是TLAB？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81TLAB%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.8.8.3.</span> <span class="nav-text">3、TLAB相关说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.8.9.</span> <span class="nav-text">9、小结堆空间的常用的JVM参数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="nav-number">1.1.8.10.</span> <span class="nav-text">10、堆是分配对象的唯一选择吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="nav-number">1.1.8.10.1.</span> <span class="nav-text">1、堆是分配对象的唯一选择吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.8.10.2.</span> <span class="nav-text">2、逃逸分析概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9F"><span class="nav-number">1.1.8.10.2.1.</span> <span class="nav-text">1、什么是逃逸分析？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">1.1.8.10.2.2.</span> <span class="nav-text">2、逃逸分析的几种情况：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="nav-number">1.1.8.10.2.3.</span> <span class="nav-text">3、逃逸分析相关的参数设置：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%BB%93%E8%AE%BA"><span class="nav-number">1.1.8.10.2.4.</span> <span class="nav-text">4、结论:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.8.10.2.5.</span> <span class="nav-text">5、逃逸分析的代码优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-number">1.1.8.10.2.6.</span> <span class="nav-text">6、代码优化之栈上分配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5%EF%BC%88%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%89"><span class="nav-number">1.1.8.10.2.7.</span> <span class="nav-text">7、代码优化之同步省略（锁消除）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.1.8.10.2.8.</span> <span class="nav-text">8、代码优化之标量替换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.8.10.2.9.</span> <span class="nav-text">9、逃逸分析总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81%E5%A0%86%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.8.11.</span> <span class="nav-text">11、堆总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">1.1.9.</span> <span class="nav-text">9、方法区（Method Area）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">1、栈、堆、方法区的交互关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">2、方法区的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A"><span class="nav-number">1.1.9.2.1.</span> <span class="nav-text">1、官方文档：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.1.9.2.2.</span> <span class="nav-text">2、方法区的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.9.2.3.</span> <span class="nav-text">3、方法区和基本理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Hotspot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.1.9.2.4.</span> <span class="nav-text">4、Hotspot中方法区的演进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">3、设置方法区大小与OOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3OOM"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">4、如何解决OOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.9.5.</span> <span class="nav-text">5、方法区的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.9.5.1.</span> <span class="nav-text">1、方法区存储的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.9.5.2.</span> <span class="nav-text">2、方法区和内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.9.5.2.1.</span> <span class="nav-text">1、类型信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%9F%9F%EF%BC%88Field%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.9.5.2.2.</span> <span class="nav-text">2、域（Field）信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.9.5.2.3.</span> <span class="nav-text">3、方法（Method）信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81non-final%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.9.5.2.4.</span> <span class="nav-text">4、non-final的类变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%EF%BC%9Astatic-final"><span class="nav-number">1.1.9.5.2.5.</span> <span class="nav-text">5、全局常量：static final</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-VS-%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.1.9.5.3.</span> <span class="nav-text">3、运行时常量池 VS 常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.1.9.5.4.</span> <span class="nav-text">4、为什么需要常量池？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.9.5.5.</span> <span class="nav-text">5、常量池中的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.9.5.6.</span> <span class="nav-text">6、常量池小结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.1.9.5.7.</span> <span class="nav-text">7、运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.1.9.6.</span> <span class="nav-text">6、方法区使用举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-number">1.1.9.7.</span> <span class="nav-text">7、方法区的演进细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.1.9.7.1.</span> <span class="nav-text">1、方法区的演进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%85%83%E7%A9%BA%E9%97%B4-VS-%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="nav-number">1.1.9.7.2.</span> <span class="nav-text">2、元空间 VS 永久代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81StringTable%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-number">1.1.9.7.3.</span> <span class="nav-text">3、StringTable的调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.1.9.7.4.</span> <span class="nav-text">4、静态变量的位置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.9.8.</span> <span class="nav-text">8、方法区的垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.9.9.</span> <span class="nav-text">9、总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.9.10.</span> <span class="nav-text">10、常见面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.1.10.</span> <span class="nav-text">10、对象的实例化、内存布局与访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">1、对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.10.1.1.</span> <span class="nav-text">1、大厂面试题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.10.1.2.</span> <span class="nav-text">2、对象实例化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">2、对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E5%AD%98%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">3、对象的访存定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.10.3.1.</span> <span class="nav-text">1、句柄访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%EF%BC%88HotSpot%E9%87%87%E7%94%A8%EF%BC%89"><span class="nav-number">1.1.10.3.2.</span> <span class="nav-text">2、直接指针（HotSpot采用）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-Direct-Memory"><span class="nav-number">1.1.11.</span> <span class="nav-text">11、直接内存(Direct Memory)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">1、直接内存概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81IO-VS-NIO"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">2、IO VS NIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA%EF%BC%88IO%EF%BC%89-VS-%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA%EF%BC%88NIO%EF%BC%89"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">3、直接缓存区（IO） VS 非直接缓存区（NIO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84OOM%E5%BC%82%E5%B8%B8"><span class="nav-number">1.1.11.4.</span> <span class="nav-text">4、直接内存的OOM异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.12.</span> <span class="nav-text">12、执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">1、执行引擎概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.12.1.1.</span> <span class="nav-text">1、执行引擎的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.12.1.2.</span> <span class="nav-text">2、执行引擎的工作过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.12.2.</span> <span class="nav-text">2、Java代码编译和执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.12.3.</span> <span class="nav-text">3、机器码、指令、汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.12.3.1.</span> <span class="nav-text">1、理解执行引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-number">1.1.12.3.2.</span> <span class="nav-text">2、机器码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">1.1.12.3.3.</span> <span class="nav-text">3、指令与指令集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.12.3.4.</span> <span class="nav-text">4、汇编语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.12.3.5.</span> <span class="nav-text">5、高级语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">1.1.12.3.6.</span> <span class="nav-text">6、字节码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81C-C-%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.12.3.7.</span> <span class="nav-text">7、C&#x2F;C++源程序执行过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">1.1.12.4.</span> <span class="nav-text">4、解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.12.4.1.</span> <span class="nav-text">1、解释器概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%88%E6%88%96%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="nav-number">1.1.12.4.2.</span> <span class="nav-text">2、解释器的工作机制（或工作任务）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.12.4.3.</span> <span class="nav-text">3、解释器分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E7%8E%B0%E7%8A%B6"><span class="nav-number">1.1.12.4.4.</span> <span class="nav-text">4、解释器现状</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.12.5.</span> <span class="nav-text">5、JIT编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.12.5.1.</span> <span class="nav-text">1、Java代码的执行分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%9F"><span class="nav-number">1.1.12.5.2.</span> <span class="nav-text">2、为什么需要解释器？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81HotSpot-JVM-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.12.5.3.</span> <span class="nav-text">3、HotSpot JVM 的执行方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.12.5.4.</span> <span class="nav-text">4、JIT即时编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="nav-number">1.1.12.5.4.1.</span> <span class="nav-text">1、概念解释</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%98%AF%E5%90%A6%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.12.5.4.2.</span> <span class="nav-text">2、是否选择使用编译器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.12.5.4.3.</span> <span class="nav-text">3、热点代码及探测方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.12.5.4.4.</span> <span class="nav-text">4、方法调用计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.12.5.4.5.</span> <span class="nav-text">5、回边计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81HotSpot-VM%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.12.5.4.6.</span> <span class="nav-text">6、HotSpot VM可以设置程序执行方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81HotSpot-VM%E4%B8%ADJIT%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.12.5.4.7.</span> <span class="nav-text">7、HotSpot VM中JIT分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E6%9C%80%E5%90%8E%E8%A1%A5%E5%85%85"><span class="nav-number">1.1.12.5.4.8.</span> <span class="nav-text">8、最后补充</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81String-Table"><span class="nav-number">1.1.13.</span> <span class="nav-text">13、String Table</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81String%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">1、String的基本特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">3、String的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.13.3.</span> <span class="nav-text">4、字符串拼接操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81intern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.13.4.</span> <span class="nav-text">5、intern()的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Java-lang-String-intern-%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A7%A3%E9%87%8A"><span class="nav-number">1.1.13.4.1.</span> <span class="nav-text">1、Java.lang.String.intern()的相关解释</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81intern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.13.4.2.</span> <span class="nav-text">2、intern()的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E7%9B%AE-new-String-%E2%80%9Cab%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1-%E6%8B%93%E5%B1%95-new-String-%E2%80%9Ca%E2%80%9D-new-String-%E2%80%9Cb%E2%80%9D-%E5%91%A2"><span class="nav-number">1.1.13.4.3.</span> <span class="nav-text">3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81intern-%E7%9A%84%E4%BD%BF%E7%94%A8-jdk6-vs-jdk7-8"><span class="nav-number">1.1.13.4.4.</span> <span class="nav-text">4、intern()的使用: jdk6 vs jdk7&#x2F;8</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93String%E7%9A%84intern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.13.4.5.</span> <span class="nav-text">5、总结String的intern()方法的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%85%B3%E4%BA%8Eintern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E9%81%93%E7%BB%83%E4%B9%A0"><span class="nav-number">1.1.13.4.6.</span> <span class="nav-text">6、关于intern()方法的两道练习</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%BB%83%E4%B9%A01"><span class="nav-number">1.1.13.4.6.1.</span> <span class="nav-text">1、练习1:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%BB%83%E4%B9%A02"><span class="nav-number">1.1.13.4.6.2.</span> <span class="nav-text">2、练习2</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E4%BD%BF%E7%94%A8intern-%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%9A%E7%A9%BA%E9%97%B4%E8%A7%92%E5%BA%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8A"><span class="nav-number">1.1.13.4.7.</span> <span class="nav-text">7、使用intern()测试执行效率：空间角度的使用上</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81StringTable%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.13.5.</span> <span class="nav-text">6、StringTable的垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81G1%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.13.6.</span> <span class="nav-text">7、G1的String去重操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.14.</span> <span class="nav-text">14、垃圾回收概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">1.1.14.1.</span> <span class="nav-text">1、什么是垃圾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC"><span class="nav-number">1.1.14.2.</span> <span class="nav-text">2、为什么需要GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%97%A9%E6%9C%9F%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.14.3.</span> <span class="nav-text">3、早期的垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.14.4.</span> <span class="nav-text">4、java垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.</span> <span class="nav-text">15、垃圾回收相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">1、标记阶段：引用计数算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.15.1.1.</span> <span class="nav-text">1、引用计数算法概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.15.1.2.</span> <span class="nav-text">2、循环引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.15.1.3.</span> <span class="nav-text">3、小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-%E6%88%96%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%BD%E8%B8%AA%E6%80%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">3、对象的finalization机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81MAT%E4%B8%8EJProfiler%E7%9A%84GC-Roots%E6%BA%AF%E6%BA%90"><span class="nav-number">1.1.15.4.</span> <span class="nav-text">4、MAT与JProfiler的GC Roots溯源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81MAT%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.15.4.1.</span> <span class="nav-text">1、MAT概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96dump%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.15.4.2.</span> <span class="nav-text">2、获取dump文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8MAT%E6%89%93%E5%BC%80heap-dump%E6%96%87%E4%BB%B6-hprof"><span class="nav-number">1.1.15.4.3.</span> <span class="nav-text">3、使用MAT打开heap dump文件.hprof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8Profiler%E8%BF%9B%E8%A1%8CGC-Roots%E6%BA%AF%E6%BA%90"><span class="nav-number">1.1.15.4.4.</span> <span class="nav-text">4、使用Profiler进行GC Roots溯源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E4%BD%BF%E7%94%A8Profiler%E5%88%86%E6%9E%90OOM"><span class="nav-number">1.1.15.4.5.</span> <span class="nav-text">5、使用Profiler分析OOM</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.5.</span> <span class="nav-text">5、清除阶段：标记-清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.6.</span> <span class="nav-text">6、清除阶段：复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.7.</span> <span class="nav-text">7、清除阶段：标记-压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.15.8.</span> <span class="nav-text">8、小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.9.</span> <span class="nav-text">9、分代收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E3%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.15.10.</span> <span class="nav-text">10、增量收集算法、分区算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.16.</span> <span class="nav-text">16、垃圾回收相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.16.1.</span> <span class="nav-text">1、System.gc()的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-OOM-%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-Memory-Leak"><span class="nav-number">1.1.16.2.</span> <span class="nav-text">2、内存溢出(OOM)与内存泄漏(Memory Leak)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88OOM%EF%BC%89"><span class="nav-number">1.1.16.2.1.</span> <span class="nav-text">1、内存溢出（OOM）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="nav-number">1.1.16.2.2.</span> <span class="nav-text">2、内存泄漏（Memory Leak）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Stop-The-World"><span class="nav-number">1.1.16.3.</span> <span class="nav-text">3、Stop The World</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.16.4.</span> <span class="nav-text">4、垃圾回收的并行与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89"><span class="nav-number">1.1.16.4.1.</span> <span class="nav-text">1、并发（Concurrent）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="nav-number">1.1.16.4.2.</span> <span class="nav-text">2、并行（Parallel）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%B9%B6%E8%A1%8C-VS-%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.16.4.3.</span> <span class="nav-text">3、并行 VS 并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.1.16.4.4.</span> <span class="nav-text">4、垃圾回收的并发与并行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.1.16.5.</span> <span class="nav-text">5、安全点与安全区域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%88Safepoint%EF%BC%89"><span class="nav-number">1.1.16.5.1.</span> <span class="nav-text">1、安全点（Safepoint）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.1.16.5.2.</span> <span class="nav-text">2、安全区域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%9C%A8%E8%B0%88%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.16.6.</span> <span class="nav-text">6、在谈引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8Strong-Reference%EF%BC%88%E4%B8%8D%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="nav-number">1.1.16.7.</span> <span class="nav-text">7、再谈引用：强引用Strong Reference（不回收）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%BD%AF%E5%BC%95%E7%94%A8Soft-Reference%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%8D%B3%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="nav-number">1.1.16.8.</span> <span class="nav-text">8、再谈引用：软引用Soft Reference（内存不足即回收）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%B1%E5%BC%95%E7%94%A8Weak-Reference%EF%BC%88%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="nav-number">1.1.16.9.</span> <span class="nav-text">9、再谈引用：弱引用Weak Reference（发现即回收）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%99%9A%E5%BC%95%E7%94%A8Phantom-Reference%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA%EF%BC%89"><span class="nav-number">1.1.16.10.</span> <span class="nav-text">10、再谈引用：虚引用Phantom Reference（对象回收跟踪）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8Final-reference"><span class="nav-number">1.1.16.11.</span> <span class="nav-text">11、再谈引用：终结器引用Final reference</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.17.</span> <span class="nav-text">17、垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81GC%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.1.17.1.</span> <span class="nav-text">1、GC分类与性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.17.1.1.</span> <span class="nav-text">1、垃圾回收器概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.17.1.2.</span> <span class="nav-text">2、垃圾回收器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%8C%89%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%88%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.17.1.2.1.</span> <span class="nav-text">1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%8C%89%E7%85%A7%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%B9%B6%E5%8F%91%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E7%8B%AC%E5%8D%A0%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.17.1.2.2.</span> <span class="nav-text">2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%8C%89%E7%A2%8E%E7%89%87%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%88%86%EF%BC%8C%E5%8F%AF%E5%88%86%E4%B8%BA%E5%8E%8B%E7%BC%A9%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E9%9D%9E%E5%8E%8B%E7%BC%A9%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.17.1.2.3.</span> <span class="nav-text">3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%8C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%86%EF%BC%8C%E5%8F%88%E5%8F%AF%E5%88%86%E4%B8%BA%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.17.1.2.4.</span> <span class="nav-text">4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.1.17.1.3.</span> <span class="nav-text">3、评估GC的性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88throughput%EF%BC%89"><span class="nav-number">1.1.17.1.3.1.</span> <span class="nav-text">1、吞吐量（throughput）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%EF%BC%88pause-time%EF%BC%89"><span class="nav-number">1.1.17.1.3.2.</span> <span class="nav-text">2、暂停时间（pause time）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F-VS-%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.17.1.3.3.</span> <span class="nav-text">3、吞吐量 VS 暂停时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.17.2.</span> <span class="nav-text">2、不同的垃圾回收器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="nav-number">1.1.17.2.1.</span> <span class="nav-text">1、垃圾回收器发展史</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%83%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.1.17.2.2.</span> <span class="nav-text">2、七款经典的垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Serial%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.17.3.</span> <span class="nav-text">3、Serial回收器：串行回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.17.4.</span> <span class="nav-text">4、ParNew回收器：并行回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Parallel%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">1.1.17.5.</span> <span class="nav-text">5、Parallel回收器：吞吐量优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.1.17.6.</span> <span class="nav-text">6、CMS回收器：低延迟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-number">1.1.17.7.</span> <span class="nav-text">7、G1回收器：区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.17.7.1.</span> <span class="nav-text">1、两个问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81G1%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.17.7.2.</span> <span class="nav-text">2、G1概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81G1%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E4%BC%98%E5%8A%BF%EF%BC%89%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.17.7.3.</span> <span class="nav-text">3、G1的特点（优势）与缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.17.7.4.</span> <span class="nav-text">4、G1回收器的参数设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.17.7.5.</span> <span class="nav-text">5、G1回收器的常见操作步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.17.7.6.</span> <span class="nav-text">6、G1回收器的适用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E5%88%86%E5%8C%BARegion%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="nav-number">1.1.17.7.7.</span> <span class="nav-text">7、分区Region：化整为零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.17.7.8.</span> <span class="nav-text">8、G1回收器垃圾回收过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BB%A3GC"><span class="nav-number">1.1.17.7.9.</span> <span class="nav-text">9、G1回收过程一：年轻代GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10%E3%80%81G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.17.7.10.</span> <span class="nav-text">10、G1回收过程二：并发标记过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11%E3%80%81G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9A%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.17.7.11.</span> <span class="nav-text">11、G1回收过程三：混合回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%8F%AF%E9%80%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9AFull-GC"><span class="nav-number">1.1.17.7.12.</span> <span class="nav-text">12、G1回收可选的过程四：Full GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13%E3%80%81G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9A%E8%A1%A5%E5%85%85"><span class="nav-number">1.1.17.7.13.</span> <span class="nav-text">13、G1回收过程：补充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.1.17.7.14.</span> <span class="nav-text">14、G1回收器优化建议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.17.8.</span> <span class="nav-text">8、垃圾回收总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-number">1.1.17.9.</span> <span class="nav-text">9、GC日志分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95"><span class="nav-number">1.1.17.10.</span> <span class="nav-text">10、垃圾回收器的新发展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-number">1.1.17.10.1.</span> <span class="nav-text">1、垃圾回收器的发展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81JDK11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.17.10.2.</span> <span class="nav-text">2、JDK11的新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Open-JDK12%E7%9A%84Shenandoah-GC%EF%BC%9A%E4%BD%8E%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E7%9A%84GC-%E5%AE%9E%E9%AA%8C%E6%80%A7"><span class="nav-number">1.1.17.10.3.</span> <span class="nav-text">3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BB%A4%E4%BA%BA%E9%9C%87%E6%83%8A%E3%80%81%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84ZGC%EF%BC%88JDK14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="nav-number">1.1.17.10.4.</span> <span class="nav-text">4、令人震惊、革命性的ZGC（JDK14新特性）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.18.</span> <span class="nav-text">18、垃圾回收的相关大厂面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">1.1.19.</span> <span class="nav-text">0、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81label"><span class="nav-number">1.1.19.1.</span> <span class="nav-text">1、label</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0Java%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.19.2.</span> <span class="nav-text">2、怎么学习Java的不同版本的新特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">中篇：字节码与类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">1、字节码文件的跨平台性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Java%E7%9A%84%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">2、Java的前端编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%9C%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.1.1.2.1.</span> <span class="nav-text">1、关于前端编译器与后台编译器在程序编译过程中的作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8vs%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.2.1.1.2.2.</span> <span class="nav-text">2、前端编译器vs后端编译器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%80%8F%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">3、透过字节码指令看代码细节</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9Aclass%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2、虚拟机的基石：class文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">3、class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8EClass%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">1、关于Class文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%8101-%E9%AD%94%E6%95%B0%EF%BC%9AClass%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%87%E5%BF%97"><span class="nav-number">1.2.1.3.2.</span> <span class="nav-text">2、01-魔数：Class文件的标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%8102-Class%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">1.2.1.3.3.</span> <span class="nav-text">3、02-Class文件版本号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%8103-%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9A%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.1.3.4.</span> <span class="nav-text">4、03-常量池：存放所有常量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.1.3.4.1.</span> <span class="nav-text">1、常量池概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88constant-pool-count%EF%BC%89"><span class="nav-number">1.2.1.3.4.2.</span> <span class="nav-text">2、常量池计数器（constant_pool_ count）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8"><span class="nav-number">1.2.1.3.4.3.</span> <span class="nav-text">3、常量池表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8%E2%80%94%E2%80%94%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.1.3.4.4.</span> <span class="nav-text">4、常量池表——字面量和符号引用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8%E2%80%94%E2%80%94%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.4.5.</span> <span class="nav-text">5、常量池表——常量类型和结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%8104-%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86"><span class="nav-number">1.2.1.3.5.</span> <span class="nav-text">5、04-访问标识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%8105-%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.6.</span> <span class="nav-text">6、05-类索引、父类索引、接口索引集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%8106-%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.7.</span> <span class="nav-text">7、06-字段表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.7.1.</span> <span class="nav-text">1、字段表集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81fields-count-%E5%AD%97%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.2.1.3.7.2.</span> <span class="nav-text">2、fields_ count(字段计数器)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81fields-%EF%BC%88%E5%AD%97%E6%AE%B5%E8%A1%A8%EF%BC%89"><span class="nav-number">1.2.1.3.7.3.</span> <span class="nav-text">3、fields []（字段表）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%8107-%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.8.</span> <span class="nav-text">8、07-方法表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.8.1.</span> <span class="nav-text">1、方法表集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81methods-count-%E6%96%B9%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.2.1.3.8.2.</span> <span class="nav-text">2、methods_ count(方法计数器)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81methods-%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="nav-number">1.2.1.3.8.3.</span> <span class="nav-text">3、methods [] (方法表)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%8108-%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">1.2.1.3.9.</span> <span class="nav-text">9、08-属性表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88-attributes"><span class="nav-number">1.2.1.3.9.1.</span> <span class="nav-text">1、属性表集合(attributes)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81attributes-count-%E5%B1%9E%E6%80%A7%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.2.1.3.9.2.</span> <span class="nav-text">2、attributes_ count(属性计数器)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81attributes-%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="nav-number">1.2.1.3.9.3.</span> <span class="nav-text">3、attributes [] ( 属性表)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10%E3%80%81class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.1.3.10.</span> <span class="nav-text">10、class字节码文件总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8javap%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90Class%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">4、使用javap指令解析Class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">1、解析字节码的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81javac-g%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.4.2.</span> <span class="nav-text">2、javac -g操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81javap%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.1.4.3.</span> <span class="nav-text">3、javap的用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.1.4.4.</span> <span class="nav-text">4、总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、字节码指令集与解析举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-2"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">1、执行模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">2、字节码与数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90"><span class="nav-number">1.2.2.1.3.</span> <span class="nav-text">3、指令分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2、加载与存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#0%E3%80%81%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">0、复习：再谈操作数栈与局部变量表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88-Operand-Stacks"><span class="nav-number">1.2.2.2.1.1.</span> <span class="nav-text">1、操作数栈(Operand Stacks )</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8-Local-Variables"><span class="nav-number">1.2.2.2.1.2.</span> <span class="nav-text">2、局部变量表(Local Variables)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">1、局部变量压栈指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.2.3.</span> <span class="nav-text">2、常量入栈指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%87%BA%E6%A0%88%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.2.4.</span> <span class="nav-text">3、出栈入局部变量表指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3、算术指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%80%E6%9C%89%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">1、所有算术指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.2.2.3.1.1.</span> <span class="nav-text">1、举例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%80%E4%B8%AA%E6%9B%BE%E7%BB%8F%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">1.2.2.3.1.2.</span> <span class="nav-text">2、一个曾经的案例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8Ei-%E4%B8%8E-i"><span class="nav-number">1.2.2.3.1.3.</span> <span class="nav-text">3、关于i++与++i</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">2、比较指令的说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">4、类型转换指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Widening-Numeric-Conversions"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">1、宽化类型转换(Widening Numeric Conversions)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="nav-number">1.2.2.4.1.1.</span> <span class="nav-text">1、转换规则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.2.4.1.2.</span> <span class="nav-text">2、精度损失问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.2.4.1.3.</span> <span class="nav-text">3、补充说明</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Narrowing-Numeric-Conversion"><span class="nav-number">1.2.2.4.2.</span> <span class="nav-text">2、窄化类型转换(Narrowing Numeric Conversion)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99-1"><span class="nav-number">1.2.2.4.2.1.</span> <span class="nav-text">1、转换规则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98-1"><span class="nav-number">1.2.2.4.2.2.</span> <span class="nav-text">2、精度损失问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-1"><span class="nav-number">1.2.2.4.2.3.</span> <span class="nav-text">3、补充说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">5、对象的创建与访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.1.</span> <span class="nav-text">1、创建指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.2.</span> <span class="nav-text">2、字段访问指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.3.</span> <span class="nav-text">3、数组操作指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.3.1.</span> <span class="nav-text">1、数组操作指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.2.5.3.2.</span> <span class="nav-text">2、说明</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.5.4.</span> <span class="nav-text">4、类型检查指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">6、方法调用与返回指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.6.1.</span> <span class="nav-text">1、方法调用指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.6.2.</span> <span class="nav-text">2、方法返回指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">7、操作数栈管理指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">8、控制转义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.8.1.</span> <span class="nav-text">1、条件跳转指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.8.2.</span> <span class="nav-text">2、比较条件跳转指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.2.2.8.3.</span> <span class="nav-text">3、多条件分支跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.2.2.8.4.</span> <span class="nav-text">4、无条件跳转</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">9、异常处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.9.1.</span> <span class="nav-text">1、抛出异常指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="nav-number">1.2.2.9.2.</span> <span class="nav-text">2、异常处理与异常表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.10.</span> <span class="nav-text">10、同步控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5-%E6%B7%BB%E5%8A%A0synchronized%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.10.1.</span> <span class="nav-text">1、方法级的同步(添加synchronized的方法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E4%B8%80%E6%AE%B5%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.2.10.2.</span> <span class="nav-text">2、方法内部一段指令序列的同步</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、类的加载过程详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-3"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2、过程一：Loading（加载）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">1、加载完成的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.3.2.1.1.</span> <span class="nav-text">1、加载的理解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.2.1.2.</span> <span class="nav-text">2、加载完成的操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">2、二进制流的获取方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8EClass%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.2.3.2.3.</span> <span class="nav-text">3、类模型与Class实例的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.2.3.2.4.</span> <span class="nav-text">4、数组类的加载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3、过程二：Linking（链接）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%8E%AF%E8%8A%821%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BVerification%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">1、环节1：链接阶段之Verification（验证）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%8E%AF%E8%8A%822%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BPreparation%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">2、环节2：链接阶段之Preparation（准备）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%8E%AF%E8%8A%823%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BResolution%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">3、环节3：链接阶段之Resolution（解析）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">4、过程三：Initialization（初始化）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81static%E4%B8%8Efinal%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%BE%E7%A4%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">1.2.3.4.1.</span> <span class="nav-text">1、static与final的搭配问题（显示初始化问题）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.2.3.4.2.</span> <span class="nav-text">2、()的线程安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.3.4.3.</span> <span class="nav-text">3、类的初始化情况：主动使用vs被动使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.3.4.3.1.</span> <span class="nav-text">1、主动使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.3.4.3.2.</span> <span class="nav-text">2、被动使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F"><span class="nav-number">1.2.3.4.3.3.</span> <span class="nav-text">3、注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9A%E7%B1%BB%E7%9A%84Using%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">5、过程四：类的Using（使用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E8%BF%87%E7%A8%8B%E4%BA%94%EF%BC%9A%E7%B1%BB%E7%9A%84Unloading%EF%BC%88%E5%8D%B8%E8%BD%BD%EF%BC%89"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">6、过程五：类的Unloading（卸载）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.3.6.1.</span> <span class="nav-text">1、类、类的加载器、类的实例之间的引用关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.2.3.6.2.</span> <span class="nav-text">2、类的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="nav-number">1.2.3.6.3.</span> <span class="nav-text">3、具体例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.2.3.6.4.</span> <span class="nav-text">4、类的卸载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E7%9B%B8%E5%85%B3%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">7、相关大厂面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、再谈类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-4"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.4.1.1.</span> <span class="nav-text">1、类加载器的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">1.2.4.1.2.</span> <span class="nav-text">2、类加载器的必要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.4.1.3.</span> <span class="nav-text">3、命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.2.4.1.4.</span> <span class="nav-text">4、类加载机制的基本特征</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%A4%8D%E4%B9%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2、复习：类的加载器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CBootstrap-ClassLoader"><span class="nav-number">1.2.4.2.1.</span> <span class="nav-text">1、启动类加载器(引导类加载器，Bootstrap ClassLoader)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader"><span class="nav-number">1.2.4.2.2.</span> <span class="nav-text">2、扩展类加载器(Extension ClassLoader)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CAppClassLoader"><span class="nav-number">1.2.4.2.3.</span> <span class="nav-text">3、应用程序类加载器(系统类加载器，AppClassLoader)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.4.2.4.</span> <span class="nav-text">4、用户自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">3、测试不同的类的加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ClassLoader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">4、ClassLoader源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.4.4.1.</span> <span class="nav-text">1、类加载器之间的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ClassLoader%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.4.4.2.</span> <span class="nav-text">2、ClassLoader的主要方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EloadClass-%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%96%E6%9E%90%EF%BC%9A"><span class="nav-number">1.2.4.4.2.1.</span> <span class="nav-text">关于loadClass()方法的剖析：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81SecureClassLoader%E4%B8%8EURLClassLoader"><span class="nav-number">1.2.4.4.3.</span> <span class="nav-text">3、SecureClassLoader与URLClassLoader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81ExtClassLoader%E4%B8%8EAppClassLoader"><span class="nav-number">1.2.4.4.4.</span> <span class="nav-text">4、ExtClassLoader与AppClassLoader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81Class-forName-%E4%B8%8EClassLoader-loadClass"><span class="nav-number">1.2.4.4.5.</span> <span class="nav-text">5、Class.forName()与ClassLoader.loadClass()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">5、双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.2.4.5.1.</span> <span class="nav-text">1、定义与本质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.2.4.5.2.</span> <span class="nav-text">2、优势与劣势</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF"><span class="nav-number">1.2.4.5.2.1.</span> <span class="nav-text">1、双亲委派机制优势</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E6%94%AF%E6%8C%81"><span class="nav-number">1.2.4.5.2.2.</span> <span class="nav-text">2、代码支持</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.2.4.5.2.3.</span> <span class="nav-text">3、举例：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%80%9D%E8%80%83%EF%BC%9A"><span class="nav-number">1.2.4.5.2.4.</span> <span class="nav-text">4、思考：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A"><span class="nav-number">1.2.4.5.2.5.</span> <span class="nav-text">5、双亲委派模型的弊端：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="nav-number">1.2.4.5.2.6.</span> <span class="nav-text">6、结论：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.4.5.3.</span> <span class="nav-text">3、破坏双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B61%E2%80%94%E2%80%94%E5%85%BC%E5%AE%B9JDK1-2%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-number">1.2.4.5.3.1.</span> <span class="nav-text">1、破坏双亲委派机制1——兼容JDK1.2之前的版本</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B62%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E8%A7%A3%E5%86%B3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A%E4%B8%8A%E5%B1%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%94%B1%E4%B8%8B%E5%B1%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%EF%BC%89"><span class="nav-number">1.2.4.5.3.2.</span> <span class="nav-text">2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B63%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%8A%A8%E6%80%81%E6%80%A7%E7%9A%84%E8%BF%BD%E6%B1%82%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%BF%E6%8D%A2-Hot-Swap-%E3%80%81%E6%A8%A1%E5%9D%97%E7%83%AD%E9%83%A8%E7%BD%B2-Hot-Deployment-%E7%AD%89"><span class="nav-number">1.2.4.5.3.3.</span> <span class="nav-text">3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81-%E8%A1%A5%E5%85%85-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B64%E2%80%94%E2%80%94JDK9%E5%BC%95%E5%85%A5%E4%BA%86Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%B7%E4%BD%93%E5%9C%A8%E4%B8%8B%E6%96%87JDK9%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="nav-number">1.2.4.5.3.4.</span> <span class="nav-text">4、(补充)破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.4.5.4.</span> <span class="nav-text">4、热替换的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">6、沙箱安全机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81JDK1-0%E6%97%B6%E6%9C%9F"><span class="nav-number">1.2.4.6.1.</span> <span class="nav-text">1、JDK1.0时期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81JDK1-1%E6%97%B6%E6%9C%9F"><span class="nav-number">1.2.4.6.2.</span> <span class="nav-text">2、JDK1.1时期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81JDK1-2%E6%97%B6%E6%9C%9F"><span class="nav-number">1.2.4.6.3.</span> <span class="nav-text">3、JDK1.2时期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81JDK1-6%E6%97%B6%E6%9C%9F"><span class="nav-number">1.2.4.6.4.</span> <span class="nav-text">4、JDK1.6时期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">7、自定义类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.4.7.1.</span> <span class="nav-text">1、为什么要自定义类加载器?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">1.2.4.7.2.</span> <span class="nav-text">2、常见的场景：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F-1"><span class="nav-number">1.2.4.7.3.</span> <span class="nav-text">3、注意</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.4.7.4.</span> <span class="nav-text">4、自定义类加载器的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.2.4.7.4.1.</span> <span class="nav-text">1、实现方式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.4.7.4.2.</span> <span class="nav-text">2、对比</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.4.7.4.3.</span> <span class="nav-text">3、说明</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.4.7.4.4.</span> <span class="nav-text">4、实现代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">8、Java9新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">9、大厂面试题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87"><span class="nav-number">1.3.</span> <span class="nav-text">下篇：性能监控与调优篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0%E7%AF%87"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、概述篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1、背景说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2、调优概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3、性能优化的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%AC%AC1%E6%AD%A5%EF%BC%88%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">1、第1步（发现问题）：性能监控</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%AC%AC2%E6%AD%A5%EF%BC%88%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%9A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">2、第2步（排查问题）：性能分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%AC%AC3%E6%AD%A5%EF%BC%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%9A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">3、第3步（解决问题）：性能调优</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7-%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">4、性能评价&#x2F;测试指标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、JVM监控及诊断工具——命令行篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-5"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81jps%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84Java%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2、jps：查看正在运行的Java进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">2、基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E6%B5%8B%E8%AF%95"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">3、相关测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81jstat%EF%BC%9A%E6%9F%A5%E7%9C%8BJVM%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3、jstat：查看JVM统计信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">1.3.2.3.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-number">1.3.2.3.2.</span> <span class="nav-text">2、基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%A1%A5%E5%85%85"><span class="nav-number">1.3.2.3.3.</span> <span class="nav-text">3、补充</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81jinfo%EF%BC%9A%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">4、jinfo：实时查看和修改JVM配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="nav-number">1.3.2.4.2.</span> <span class="nav-text">2、基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%8B%93%E5%B1%95"><span class="nav-number">1.3.2.4.3.</span> <span class="nav-text">3、拓展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81jmap%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6-amp-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">5、jmap：导出内存映像文件&amp;内存使用情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">1.3.2.5.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="nav-number">1.3.2.5.2.</span> <span class="nav-text">2、基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.2.5.3.</span> <span class="nav-text">3、基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A81%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.2.5.3.1.</span> <span class="nav-text">1、使用1：导出内存映像文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A82%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.2.5.3.2.</span> <span class="nav-text">2、使用2：显示堆内存相关信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A83%EF%BC%9A%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.2.5.3.3.</span> <span class="nav-text">3、使用3：其他作用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.3.2.5.4.</span> <span class="nav-text">4、小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81jhat%EF%BC%9AJDK%E8%87%AA%E5%B8%A6%E5%A0%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">6、jhat：JDK自带堆分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="nav-number">1.3.2.6.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="nav-number">1.3.2.6.2.</span> <span class="nav-text">2、基本语法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81jstack%EF%BC%9A%E6%89%93%E5%8D%B0JVM%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">7、jstack：打印JVM中线程快照</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="nav-number">1.3.2.7.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="nav-number">1.3.2.7.2.</span> <span class="nav-text">2、基本语法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81jcmd%EF%BC%9A%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.3.2.8.</span> <span class="nav-text">8、jcmd：多功能命令行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="nav-number">1.3.2.8.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-6"><span class="nav-number">1.3.2.8.2.</span> <span class="nav-text">2、基本语法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81jstatd%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="nav-number">1.3.2.9.</span> <span class="nav-text">9、jstatd：远程主机信息收集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94GUI%E7%AF%87"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、JVM监控及诊断工具——GUI篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1、工具概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81JConsole"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2、JConsole</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">1、基本概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">2、启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">3、三种连接方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">4、主要作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Visual-VM"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3、Visual VM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">1、基本概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">2、插件的安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.3.3.</span> <span class="nav-text">3、连接方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.3.3.3.4.</span> <span class="nav-text">4、主要功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Eclipse-MAT"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">4、Eclipse MAT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-2"><span class="nav-number">1.3.3.4.1.</span> <span class="nav-text">1、基本概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96%E5%A0%86dump%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.4.2.</span> <span class="nav-text">2、获取堆dump文件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81dump%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%98"><span class="nav-number">1.3.3.4.2.1.</span> <span class="nav-text">1、dump文件内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%A4%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.3.4.2.2.</span> <span class="nav-text">2、两点说明</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96dump%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.4.2.3.</span> <span class="nav-text">3、获取dump文件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%8A%A0%E8%BD%BDdump%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.4.3.</span> <span class="nav-text">4、加载dump文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%88%86%E6%9E%90%E5%A0%86dump%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.4.4.</span> <span class="nav-text">4、分析堆dump文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B%EF%BC%9ATomcat%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.4.5.</span> <span class="nav-text">4、案例：Tomcat堆溢出分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.3.4.6.</span> <span class="nav-text">5、支持使用OQL语言查询对象信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81JProfiler"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">5、JProfiler</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-3"><span class="nav-number">1.3.3.5.1.</span> <span class="nav-text">1、基本概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.3.5.1.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.3.5.1.2.</span> <span class="nav-text">2、特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.3.3.5.1.3.</span> <span class="nav-text">3、主要功能</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.3.5.2.</span> <span class="nav-text">2、安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.3.5.2.1.</span> <span class="nav-text">1、下载与安装</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81JProfiler%E4%B8%AD%E9%85%8D%E7%BD%AEIDEA"><span class="nav-number">1.3.3.5.2.2.</span> <span class="nav-text">2、JProfiler中配置IDEA</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81IDEA%E9%9B%86%E6%88%90JProfiler"><span class="nav-number">1.3.3.5.2.3.</span> <span class="nav-text">3、IDEA集成JProfiler</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.3.5.3.</span> <span class="nav-text">3、具体使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.5.4.</span> <span class="nav-text">4、案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A1%88%E4%BE%8B1%EF%BC%88%E8%BE%83%E4%B8%BA%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">1.3.3.5.4.1.</span> <span class="nav-text">1、案例1（较为安全）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%A1%88%E4%BE%8B2%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%89"><span class="nav-number">1.3.3.5.4.2.</span> <span class="nav-text">2、案例2（内存泄露）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81Arthas"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">6、Arthas</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-4"><span class="nav-number">1.3.3.6.1.</span> <span class="nav-text">1、基本概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF"><span class="nav-number">1.3.3.6.1.1.</span> <span class="nav-text">1、背景</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.3.6.1.2.</span> <span class="nav-text">2、概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%80%8C%E6%9D%A5"><span class="nav-number">1.3.3.6.1.3.</span> <span class="nav-text">3、基于哪些工具开发而来</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%AE%98%E6%96%B9%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3"><span class="nav-number">1.3.3.6.1.4.</span> <span class="nav-text">4、官方使用文档</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.3.6.2.</span> <span class="nav-text">2、安装与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.3.6.2.1.</span> <span class="nav-text">1、安装</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95"><span class="nav-number">1.3.3.6.2.2.</span> <span class="nav-text">2、工程目录</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%90%AF%E5%8A%A8"><span class="nav-number">1.3.3.6.2.3.</span> <span class="nav-text">3、启动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.3.6.2.4.</span> <span class="nav-text">4、查看进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.3.6.2.5.</span> <span class="nav-text">5、查看日志</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.3.3.6.2.6.</span> <span class="nav-text">6、查看帮助</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81web-console"><span class="nav-number">1.3.3.6.2.7.</span> <span class="nav-text">7、web console</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E9%80%80%E5%87%BA"><span class="nav-number">1.3.3.6.2.8.</span> <span class="nav-text">8、退出</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.3.6.3.</span> <span class="nav-text">3、相关诊断指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.3.6.3.1.</span> <span class="nav-text">1、基础指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81jvm%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.3.6.3.2.</span> <span class="nav-text">2、jvm相关</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81class-classloader%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.3.6.3.3.</span> <span class="nav-text">3、class&#x2F;classloader相关</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81monitor-watch-trace%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.3.6.3.4.</span> <span class="nav-text">4、monitor&#x2F;watch&#x2F;trace相关</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">1.3.3.6.3.5.</span> <span class="nav-text">5、其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81Java-Misssion-Control"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">7、Java Misssion Control</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8E%86%E5%8F%B2"><span class="nav-number">1.3.3.7.1.</span> <span class="nav-text">1、历史</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8-1"><span class="nav-number">1.3.3.7.2.</span> <span class="nav-text">2、启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.3.7.3.</span> <span class="nav-text">3、概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.3.7.4.</span> <span class="nav-text">4、功能：实时监控JVM运行时的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81Java-Flight-Recorder"><span class="nav-number">1.3.3.7.5.</span> <span class="nav-text">5、Java Flight Recorder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">8、其他工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Flame-Graphs%EF%BC%88%E7%81%AB%E7%84%B0%E5%9B%BE%EF%BC%89"><span class="nav-number">1.3.3.8.1.</span> <span class="nav-text">1、Flame Graphs（火焰图）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Tprofiler"><span class="nav-number">1.3.3.8.2.</span> <span class="nav-text">2、Tprofiler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Btrace"><span class="nav-number">1.3.3.8.3.</span> <span class="nav-text">3、Btrace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81YourKit"><span class="nav-number">1.3.3.8.4.</span> <span class="nav-text">4、YourKit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81JProbe"><span class="nav-number">1.3.3.8.5.</span> <span class="nav-text">5、JProbe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81Spring-Insight"><span class="nav-number">1.3.3.8.6.</span> <span class="nav-text">6、Spring Insight</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.3.3.9.</span> <span class="nav-text">9、学习建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81%E8%A1%A5%E5%85%851%EF%BC%9A%E5%86%8D%E8%B0%88%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">1.3.3.10.</span> <span class="nav-text">10、补充1：再谈内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.10.1.</span> <span class="nav-text">1、内存泄露的理解与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BD%95%E4%B8%BA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-memory-leak"><span class="nav-number">1.3.3.10.1.1.</span> <span class="nav-text">1、何为内存泄漏( memory leak)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-memory-leak-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.3.3.10.1.2.</span> <span class="nav-text">2、内存泄漏( memory leak) 的理解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.3.10.1.3.</span> <span class="nav-text">3、内存泄漏与内存溢出的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%B3%84%E6%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.3.10.1.4.</span> <span class="nav-text">4、泄漏的分类</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Java%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%848%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">1.3.3.10.2.</span> <span class="nav-text">2、Java中内存泄露的8种情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.10.3.</span> <span class="nav-text">3、内存泄露案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.3.10.3.1.</span> <span class="nav-text">1、案例代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.10.3.2.</span> <span class="nav-text">2、分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.3.3.10.3.3.</span> <span class="nav-text">3、解决办法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%BC%80%E5%8F%91%E6%9C%89%E5%85%B3%EF%BC%89"><span class="nav-number">1.3.3.10.3.4.</span> <span class="nav-text">4、案例代码（与移动端的开发有关）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.3.10.3.5.</span> <span class="nav-text">5、分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.10.3.6.</span> <span class="nav-text">6、解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81%E8%A1%A5%E5%85%852%EF%BC%9A%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.3.11.</span> <span class="nav-text">11、补充2：支持使用OQL语言查询对象信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">1.3.3.11.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8Eclipse-MAT%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8"><span class="nav-number">1.3.3.11.2.</span> <span class="nav-text">2、在Eclipse MAT中如何用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BE%8B%E5%AD%90-1"><span class="nav-number">1.3.3.11.3.</span> <span class="nav-text">3、例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81SELECT%E5%AD%90%E5%8F%A5"><span class="nav-number">1.3.3.11.4.</span> <span class="nav-text">4、SELECT子句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81FROM%E5%AD%90%E5%8F%A5"><span class="nav-number">1.3.3.11.5.</span> <span class="nav-text">5、FROM子句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81WHERE%E5%AD%90%E5%8F%A5"><span class="nav-number">1.3.3.11.6.</span> <span class="nav-text">6、WHERE子句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.11.7.</span> <span class="nav-text">7、内置对象与方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、JVM运行时参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81JVM%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1、JVM参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9E%8B%E4%B8%80%EF%BC%9A%E6%A0%87%E5%87%86%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.1.1.</span> <span class="nav-text">1、类型一：标准参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.4.1.1.1.</span> <span class="nav-text">1、特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%90%84%E7%A7%8D%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.1.1.2.</span> <span class="nav-text">2、各种选项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9%EF%BC%9A-server%E4%B8%8E-client"><span class="nav-number">1.3.4.1.1.3.</span> <span class="nav-text">3、补充内容：-server与-client</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%9E%8B%E4%BA%8C%EF%BC%9A-X%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.1.2.</span> <span class="nav-text">2、类型二：-X参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%89%B9%E7%82%B9-1"><span class="nav-number">1.3.4.1.2.1.</span> <span class="nav-text">1、特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%90%84%E7%A7%8D%E9%80%89%E9%A1%B9-1"><span class="nav-number">1.3.4.1.2.2.</span> <span class="nav-text">2、各种选项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81JVM%E7%9A%84JIT%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.1.2.3.</span> <span class="nav-text">3、JVM的JIT编译模式相关的选项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%89%B9%E5%88%AB%E5%9C%B0%EF%BC%9A-Xmx-Xms-Xss%E5%B1%9E%E4%BA%8EXX%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">1.3.4.1.2.4.</span> <span class="nav-text">4、特别地：-Xmx -Xms -Xss属于XX参数？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E5%9E%8B%E4%B8%89%EF%BC%9A-XX%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">1.3.4.1.3.</span> <span class="nav-text">3、类型三：-XX参数选项（重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%89%B9%E7%82%B9-2"><span class="nav-number">1.3.4.1.3.1.</span> <span class="nav-text">1、特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.4.1.3.2.</span> <span class="nav-text">2、作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.4.1.3.3.</span> <span class="nav-text">3、分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%89%B9%E5%88%AB%E5%9C%B0%EF%BC%9A-XX-PrintFlagsFinal"><span class="nav-number">1.3.4.1.3.4.</span> <span class="nav-text">4、特别地：-XX:+PrintFlagsFinal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%B7%BB%E5%8A%A0JVM%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2、添加JVM参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Eclipse"><span class="nav-number">1.3.4.2.1.</span> <span class="nav-text">1、Eclipse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81IDEA"><span class="nav-number">1.3.4.2.2.</span> <span class="nav-text">2、IDEA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%BF%90%E8%A1%8Cjar%E5%8C%85"><span class="nav-number">1.3.4.2.3.</span> <span class="nav-text">3、运行jar包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87Tomcat%E8%BF%90%E8%A1%8Cwar%E5%8C%85"><span class="nav-number">1.3.4.2.4.</span> <span class="nav-text">4、通过Tomcat运行war包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="nav-number">1.3.4.2.5.</span> <span class="nav-text">5、程序运行过程中</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3、常用的JVM参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE%E7%9A%84XX%E9%80%89%E9%A1%B9%E5%8F%8A%E5%80%BC"><span class="nav-number">1.3.4.3.1.</span> <span class="nav-text">1、打印设置的XX选项及值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AD%89%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.3.4.3.2.</span> <span class="nav-text">2、堆、栈、方法区等内存大小设置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A0%88"><span class="nav-number">1.3.4.3.2.1.</span> <span class="nav-text">1、栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">1.3.4.3.2.2.</span> <span class="nav-text">2、堆内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.3.4.3.2.3.</span> <span class="nav-text">3、方法区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.3.4.3.2.4.</span> <span class="nav-text">4、直接内存</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81OutOfMemory%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.3.3.</span> <span class="nav-text">3、OutOfMemory相关的选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.3.4.</span> <span class="nav-text">4、垃圾收集器相关选项</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.1.</span> <span class="nav-text">1、查看默认的垃圾回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Serial%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.2.</span> <span class="nav-text">2、Serial回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81Parnew%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.3.</span> <span class="nav-text">3、Parnew回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81Parallel%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.4.</span> <span class="nav-text">4、Parallel回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81CMS%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.5.</span> <span class="nav-text">5、CMS回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81G1%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.4.3.4.6.</span> <span class="nav-text">6、G1回收器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.3.4.3.4.7.</span> <span class="nav-text">7、怎么选择垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81GC%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.4.3.5.</span> <span class="nav-text">5、GC日志相关选项</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.3.5.1.</span> <span class="nav-text">1、常用参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.3.5.2.</span> <span class="nav-text">2、其他参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.3.6.</span> <span class="nav-text">6、其他参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96JVM%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">4、通过Java代码获取JVM参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.5.</span> <span class="nav-text">5、分析GC日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81GC%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">1、GC日志参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81GC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">2、GC日志格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A4%8D%E4%B9%A0%EF%BC%9AGC%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.5.2.1.</span> <span class="nav-text">1、复习：GC分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81GC%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.5.2.2.</span> <span class="nav-text">2、GC日志分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81Minor-GC"><span class="nav-number">1.3.5.2.2.1.</span> <span class="nav-text">1、Minor GC</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Full-GC"><span class="nav-number">1.3.5.2.2.2.</span> <span class="nav-text">2、Full GC</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81GC%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90"><span class="nav-number">1.3.5.2.3.</span> <span class="nav-text">3、GC日志结构剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%80%8F%E8%BF%87%E6%97%A5%E5%BF%97%E7%9C%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.3.5.2.3.1.</span> <span class="nav-text">1、透过日志看垃圾收集器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%80%8F%E8%BF%87%E6%97%A5%E5%BF%97%E7%9C%8B-GC-%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.3.5.2.3.2.</span> <span class="nav-text">2、透过日志看 GC 原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%80%8F%E8%BF%87%E6%97%A5%E5%BF%97%E7%9C%8B-GC-%E5%89%8D%E5%90%8E%E6%83%85%E5%86%B5"><span class="nav-number">1.3.5.2.3.3.</span> <span class="nav-text">3、透过日志看 GC 前后情况</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E9%80%8F%E8%BF%87%E6%97%A5%E5%BF%97%E7%9C%8B-GC-%E6%97%B6%E9%97%B4"><span class="nav-number">1.3.5.2.3.4.</span> <span class="nav-text">4、透过日志看 GC 时间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Minor-GC%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.5.2.4.</span> <span class="nav-text">4、Minor GC日志解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81Full-GC%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.5.2.5.</span> <span class="nav-text">5、Full GC日志解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81G1-GC%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-number">1.3.5.2.6.</span> <span class="nav-text">6、G1 GC的日志分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">3、GC日志分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81GCEasy"><span class="nav-number">1.3.5.3.1.</span> <span class="nav-text">1、GCEasy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81GCViewer"><span class="nav-number">1.3.5.3.2.</span> <span class="nav-text">2、GCViewer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="nav-number">1.3.5.3.3.</span> <span class="nav-text">3、其他工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81OOM%E5%B8%B8%E8%A7%81%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.3.6.</span> <span class="nav-text">6、OOM常见各种场景及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">1、案例1：堆溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%85%83%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">2、案例2：元空间溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%A1%88%E4%BE%8B3%EF%BC%9AGC-overhead-limit-exceeded"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">3、案例3：GC overhead limit exceeded</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%BA%A2%E5%87%BA"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">4、案例4：线程溢出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.7.</span> <span class="nav-text">7、性能优化案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%9AJmeter"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">1、性能测试工具：Jmeter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A1%88%E4%BE%8B1%EF%BC%9A%E8%B0%83%E6%95%B4%E5%A0%86%E5%A4%A7%E5%B0%8F%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">2、案例1：调整堆大小提高服务的吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%A1%88%E4%BE%8B2%EF%BC%9A%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">3、案例2：调整垃圾回收器提高服务的吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%A1%88%E4%BE%8B3%EF%BC%9AJVM%E4%BC%98%E5%8C%96%E4%B9%8BJIT%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">4、案例3：JVM优化之JIT优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%A1%88%E4%BE%8B4%EF%BC%9AG1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.3.7.5.</span> <span class="nav-text">5、案例4：G1并发执行的线程数对性能的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%A1%88%E4%BE%8B5%EF%BC%9A%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">1.3.7.6.</span> <span class="nav-text">6、案例5：合理配置堆内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E7%89%B9%E6%AE%8A%E9%97%AE%E9%A2%98%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E4%BE%8B"><span class="nav-number">1.3.7.7.</span> <span class="nav-text">7、特殊问题：新生代与老年代的比例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.3.7.7.1.</span> <span class="nav-text">1、参数设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8F%82%E6%95%B0AdaptiveSizePolicy"><span class="nav-number">1.3.7.7.2.</span> <span class="nav-text">2、参数AdaptiveSizePolicy</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%A1%88%E4%BE%8B6%EF%BC%9ACPU%E5%8D%A0%E7%94%A8%E5%BE%88%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88"><span class="nav-number">1.3.7.8.</span> <span class="nav-text">8、案例6：CPU占用很高排查方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E8%AE%A2%E5%8D%95%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEJVM%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.7.9.</span> <span class="nav-text">9、日均百万级订单交易系统如何设置JVM参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%8E%B0%E7%8A%B6"><span class="nav-number">1.3.7.9.1.</span> <span class="nav-text">1、现状</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="nav-number">1.3.7.9.2.</span> <span class="nav-text">2、解决思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.7.9.3.</span> <span class="nav-text">3、参数配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81Java%E4%BB%A3%E7%A0%81%E5%B1%82%E5%8F%8A%E5%85%B6%E5%AE%83%E5%B1%82%E9%9D%A2%E8%B0%83%E4%BC%98"><span class="nav-number">1.3.8.</span> <span class="nav-text">8、Java代码层及其它层面调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="nav-number">1.3.9.</span> <span class="nav-text">9、大厂面试题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
