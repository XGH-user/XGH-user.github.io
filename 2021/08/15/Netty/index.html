<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] Netty1、Netty的介绍以及应用场景1、Netty的基本介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。  Netty 是一个&#x3D;&#x3D;异步的&#x3D;&#x3D;、&#x3D;&#x3D;基于事件驱动&#x3D;&#x3D;的&#x3D;&#x3D;网络应用框架&#x3D;&#x3D;，用以快速开发高性能、高可靠性的网络 IO 程序。   Netty主要针对在&#x3D;&#x3D;TCP协议&#x3D;&#x3D;下，&#x3D;&#x3D;面向Clients端&#x3D;&#x3D;的高并发应用，或者&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://xgh-user.github.io/2021/08/15/Netty/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] Netty1、Netty的介绍以及应用场景1、Netty的基本介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。  Netty 是一个&#x3D;&#x3D;异步的&#x3D;&#x3D;、&#x3D;&#x3D;基于事件驱动&#x3D;&#x3D;的&#x3D;&#x3D;网络应用框架&#x3D;&#x3D;，用以快速开发高性能、高可靠性的网络 IO 程序。   Netty主要针对在&#x3D;&#x3D;TCP协议&#x3D;&#x3D;下，&#x3D;&#x3D;面向Clients端&#x3D;&#x3D;的高并发应用，或者&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816030806875.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816030833354.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816031145708.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816031437724.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816031742962.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816031941432.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816032001424.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816032943453.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816033058098.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816033912512.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816204510649.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816205036305.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816220148414.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816222453542.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816222527728.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816233421568.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816234508355.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816235045647.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817012929177.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817040423887.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817040359556.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817171431861.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817172751502.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817224717376.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817225056336.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817225834704.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210817230238423.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818031152788.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818032518521.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818033948497.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818040744312.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818173529694.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818180105435.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818181829563.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818181932485.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818182434248.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818194738294.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818195224698.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818195414795.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818210506772.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818213124808.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210818213257551.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819024626333.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819025333778.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819025741518.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819213544007.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819233354647.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819234347536.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819234419147.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210819234704352.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210820035309447.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210820001615735.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821000047461.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210820233534694.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821000350763.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821023654601.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821035333607.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821050856155.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821035744141.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821053430472.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821053547439.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821053839116.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821053849720.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821054850668.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821155622581.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821155936176.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821160639783.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210821160731328.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210823041445976.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210823042900872.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/hasOutputChanged%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/eventloop%E7%BB%A7%E6%89%BF%E5%9B%BE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210823043804591.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210823043954338.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210823044457880.png">
<meta property="article:published_time" content="2021-08-15T12:39:36.000Z">
<meta property="article:modified_time" content="2021-08-22T20:45:06.020Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/08/15/Netty/image-20210816030806875.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/08/15/Netty/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Netty | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/08/15/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 20:39:36" itemprop="dateCreated datePublished" datetime="2021-08-15T20:39:36+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 04:45:06" itemprop="dateModified" datetime="2021-08-23T04:45:06+08:00">2021-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Netty/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记 - Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="1、Netty的介绍以及应用场景"><a href="#1、Netty的介绍以及应用场景" class="headerlink" title="1、Netty的介绍以及应用场景"></a>1、Netty的介绍以及应用场景</h2><h3 id="1、Netty的基本介绍"><a href="#1、Netty的基本介绍" class="headerlink" title="1、Netty的基本介绍"></a>1、Netty的基本介绍</h3><ol>
<li><p>Netty 是由 JBOSS 提供的一个 <strong>Java 开源框架</strong>，现为 Github上的独立项目。</p>
</li>
<li><p>Netty 是一个==异步的==、==基于事件驱动==的==网络应用框架==，用以<strong>快速开发高性能、高可靠性的网络 IO 程序</strong>。</p>
<p><img src="/2021/08/15/Netty/image-20210816030806875.png" alt="image-20210816030806875"></p>
</li>
<li><p>Netty主要针对在==TCP协议==下，==面向Clients端==的高并发应用，或者==Peer-to-Peer场景==下的<strong>大量数据持续传输</strong>的应用。</p>
</li>
<li><p>Netty本质是一个==NIO框架==，适用于服务器通讯相关的多种应用场景</p>
</li>
<li><p>要透彻理解Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码。 </p>
<p><img src="/2021/08/15/Netty/image-20210816030833354.png" alt="image-20210816030833354"></p>
</li>
</ol>
<h3 id="2、Netty的应用场景"><a href="#2、Netty的应用场景" class="headerlink" title="2、Netty的应用场景"></a>2、Netty的应用场景</h3><h4 id="1、互联网行业"><a href="#1、互联网行业" class="headerlink" title="1、互联网行业"></a>1、互联网行业</h4><ol>
<li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，<strong>Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用</strong>。</p>
</li>
<li><p>典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，<strong>Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信</strong></p>
<p><img src="/2021/08/15/Netty/image-20210816031145708.png" alt="image-20210816031145708"></p>
</li>
</ol>
<h4 id="2、游戏行业"><a href="#2、游戏行业" class="headerlink" title="2、游戏行业"></a>2、游戏行业</h4><ol>
<li>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用</li>
<li>Netty 作为高性能的基础通信组件，<strong>提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器</strong></li>
<li>地图服务器之间可以方便的通过 Netty 进行高性能的通信</li>
</ol>
<h4 id="3、大数据领域"><a href="#3、大数据领域" class="headerlink" title="3、大数据领域"></a>3、大数据领域</h4><ol>
<li><p><strong>经典的 Hadoop 的高性能通信和序列化组件 Avro（实现数据文件共享） 的 RPC 框架，默认采用 Netty 进行跨界点通信</strong></p>
</li>
<li><p>它的 Netty Service 基于 Netty 框架二次封装实现。</p>
<p><img src="/2021/08/15/Netty/image-20210816031437724.png" alt="image-20210816031437724"></p>
</li>
</ol>
<h4 id="4、其它开源项目使用到Netty"><a href="#4、其它开源项目使用到Netty" class="headerlink" title="4、其它开源项目使用到Netty"></a>4、其它开源项目使用到Netty</h4><p>网址: <a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">https://</a><a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">netty.io/wiki/related-projects.html</a></p>
<p><img src="/2021/08/15/Netty/image-20210816031742962.png" alt="image-20210816031742962"></p>
<h3 id="3、Netty的学习参考资料"><a href="#3、Netty的学习参考资料" class="headerlink" title="3、Netty的学习参考资料"></a>3、Netty的学习参考资料</h3><ul>
<li>《Netty IN Action》<ul>
<li><img src="/2021/08/15/Netty/image-20210816031941432.png" alt="image-20210816031941432"></li>
</ul>
</li>
<li>Netty权威指南<ul>
<li><img src="/2021/08/15/Netty/image-20210816032001424.png" alt="image-20210816032001424"></li>
</ul>
</li>
</ul>
<hr>
<h2 id="2、Java-BIO编程"><a href="#2、Java-BIO编程" class="headerlink" title="2、Java BIO编程"></a>2、Java BIO编程</h2><h3 id="1、I-O模型"><a href="#1、I-O模型" class="headerlink" title="1、I/O模型"></a>1、I/O模型</h3><h4 id="1、I-O模型的基本说明"><a href="#1、I-O模型的基本说明" class="headerlink" title="1、I/O模型的基本说明"></a>1、I/O模型的基本说明</h4><ul>
<li><p>I/O 模型简单的理解：就是<strong>用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</strong></p>
</li>
<li><p>Java共支持3种网络编程模型/IO模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code></p>
<ul>
<li><p><code>Java BIO</code>： 同步并阻塞(<strong>传统阻塞型</strong>)，服务器实现模式为==一个连接一个线程==，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</strong></p>
<p><img src="/2021/08/15/Netty/image-20210816032943453.png" alt="image-20210816032943453"></p>
</li>
<li><p><code>Java NIO</code>： <strong>同步非阻塞</strong>，服务器实现模式为==一个线程处理多个请求(连接)==，即<strong>客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理</strong></p>
<p><img src="/2021/08/15/Netty/image-20210816033058098.png" alt="image-20210816033058098"></p>
</li>
<li><p><code>Java AIO(NIO.2)</code>： <strong>异步非阻塞</strong>，AIO 引入异步通道的概念，采用了 <code>Proactor 模式</code>，简化了程序编写，有效的请求才启动线程，它的特点是<strong>先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="2、BIO、NIO、AIO适用场景分析"><a href="#2、BIO、NIO、AIO适用场景分析" class="headerlink" title="2、BIO、NIO、AIO适用场景分析"></a>2、BIO、NIO、AIO适用场景分析</h4><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于<strong>连接数目多且连接比较短</strong>（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于<strong>连接数目多且连接比较长</strong>（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h3 id="2、Java-BIO-基本介绍"><a href="#2、Java-BIO-基本介绍" class="headerlink" title="2、Java BIO 基本介绍"></a>2、Java BIO 基本介绍</h3><ol>
<li>Java BIO 就是<strong>传统的java io编程</strong>，其相关的类和接口在 <code>java.io</code></li>
<li><strong>BIO(blocking I/O)**： **同步阻塞</strong>，服务器实现模式为==一个连接一个线程==，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过<strong>线程池机制</strong>改善(实现多个客户连接服务器)。 【<strong>后有应用实例</strong>】</li>
<li>BIO方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</li>
</ol>
<h3 id="3、Java-BIO-工作机制"><a href="#3、Java-BIO-工作机制" class="headerlink" title="3、Java BIO 工作机制"></a>3、Java BIO 工作机制</h3><h4 id="1、工作原理图"><a href="#1、工作原理图" class="headerlink" title="1、工作原理图"></a>1、工作原理图</h4><p><img src="/2021/08/15/Netty/image-20210816033912512.png" alt="image-20210816033912512"></p>
<h4 id="2、BIO编程简单流程"><a href="#2、BIO编程简单流程" class="headerlink" title="2、BIO编程简单流程"></a>2、BIO编程简单流程</h4><ol>
<li>服务器端启动一个ServerSocket</li>
<li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行</li>
</ol>
<h3 id="4、Java-BIO-应用实例"><a href="#4、Java-BIO-应用实例" class="headerlink" title="4、Java BIO 应用实例"></a>4、Java BIO 应用实例</h3><p>实例说明：</p>
<ol>
<li>使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端；</li>
<li>服务器端可以接收客户端发送的数据(telnet 方式即可)。</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息 id =&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 名字=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket 获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息 id =&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 名字=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> read;</span><br><span class="line">                <span class="keyword">if</span> ((read = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、Java-BIO-问题分析"><a href="#5、Java-BIO-问题分析" class="headerlink" title="5、Java BIO 问题分析"></a>5、Java BIO 问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li>
<li>当并发数较大时，需要<strong>创建大量线程来处理连接</strong>，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</li>
</ol>
<hr>
<h2 id="3、Java-NIO编程"><a href="#3、Java-NIO编程" class="headerlink" title="3、Java NIO编程"></a>3、Java NIO编程</h2><h3 id="1、Java-NIO-基本介绍"><a href="#1、Java-NIO-基本介绍" class="headerlink" title="1、Java NIO 基本介绍"></a>1、Java NIO 基本介绍</h3><ol>
<li><p>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</p>
</li>
<li><p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</p>
<p><img src="/2021/08/15/Netty/image-20210816204510649.png" alt="image-20210816204510649"></p>
</li>
<li><p>NIO 有三大核心部分：<code>Channel(通道)</code>，<code>Buffer(缓冲区)</code>，<code>Selector(选择器)</code></p>
</li>
<li><p>NIO是 ==面向缓冲区== ，或者==面向 块 编程==的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供<strong>非阻塞</strong>式的高伸缩性网络</p>
</li>
<li><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而<strong>不是保持线程阻塞</strong>，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【<strong>后面有案例说明</strong>】</p>
</li>
<li><p>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来，根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。</p>
</li>
<li><p><code>HTTP2.0</code>使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
</li>
</ol>
<h3 id="2、NIO-和-BIO的比较"><a href="#2、NIO-和-BIO的比较" class="headerlink" title="2、NIO 和 BIO的比较"></a>2、NIO 和 BIO的比较</h3><ol>
<li>BIO 以==流==的方式处理数据，而 NIO 以==块==的方式处理数据，块 I/O 的效率比流 I/O 高很多</li>
<li>BIO 是==阻塞==的，NIO 则是==非阻塞==的</li>
<li>BIO基于==字节流==和==字符流==进行操作，而 NIO 基于 ==Channel(通道)==和 ==Buffer(缓冲区)==进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于==监听多个通道的事件==（比如：连接请求，数据到达等），因此使用<strong>单个线程就可以监听多个客户端</strong>通道 </li>
</ol>
<h3 id="3、NIO-三大核心原理示意图"><a href="#3、NIO-三大核心原理示意图" class="headerlink" title="3、NIO 三大核心原理示意图"></a>3、NIO 三大核心原理示意图</h3><p>一张图描述NIO 的 <code>Selector</code> 、 <code>Channel</code> 和 <code>Buffer</code> 的关系：</p>
<p><img src="/2021/08/15/Netty/image-20210816205036305.png" alt="image-20210816205036305"></p>
<p><code>Selector</code> 、 <code>Channel</code> 和 <code>Buffer</code> 的关系图(简单版)关系图的说明：</p>
<ol>
<li><strong>每个channel 都会对应一个Buffer</strong></li>
<li><strong>Selector 对应一个线程， 一个线程对应多个channel(连接)</strong></li>
<li>该图反应了有三个channel 注册到 该selector //程序</li>
<li><strong>程序切换到哪个channel 是有事件决定的</strong>，Event 就是一个重要的概念</li>
<li><strong>Selector 会根据不同的事件，在各个通道上切换</strong></li>
<li><strong>Buffer 就是一个内存块 ，底层是有一个数组</strong></li>
<li><strong>数据的读取写入是通过Buffer</strong>，这个和BIO有着本质的不同：BIO 中要么是输入流，要么是输出流，不能双向，但是NIO的Buffer 是可以读也可以写，需要 <code>flip</code> 方法切换</li>
<li><strong>channel 是双向的，可以返回底层操作系统的情况</strong>，比如Linux：底层的操作系统通道就是双向的。</li>
</ol>
<h3 id="4、缓冲区-Buffer"><a href="#4、缓冲区-Buffer" class="headerlink" title="4、缓冲区(Buffer)"></a>4、缓冲区(Buffer)</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个<strong>容器对象(含数组)**，该对象提供了</strong>一组方法<strong>，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够</strong>跟踪和记录缓冲区的状态变化情况**。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图: 【后面举例说明】</p>
<p><img src="/2021/08/15/Netty/image-20210816220148414.png" alt="image-20210816220148414"></p>
<h4 id="2、Buffer-类及其子类"><a href="#2、Buffer-类及其子类" class="headerlink" title="2、Buffer 类及其子类"></a>2、Buffer 类及其子类</h4><h5 id="1、Buffer类继承关系"><a href="#1、Buffer类继承关系" class="headerlink" title="1、Buffer类继承关系"></a>1、Buffer类继承关系</h5><p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，类的层级关系图</p>
<ul>
<li>常用Buffer子类一览<ul>
<li><code>ByteBuffer</code>：存储字节数据到缓冲区</li>
<li><code>ShortBuffer</code>：存储字符串数据到缓冲区</li>
<li><code>CharBuffer</code>：存储字符数据到缓冲区</li>
<li><code>IntBuffer</code>：存储整数数据到缓冲区</li>
<li><code>LongBuffer</code>：存储长整型数据到缓冲区</li>
<li><code>DoubleBuffer</code>：存储小数到缓冲区</li>
<li><code>FloatBuffer</code>：存储小数到缓冲区</li>
<li><img src="/2021/08/15/Netty/image-20210816222453542.png" alt="image-20210816222453542"></li>
<li><img src="/2021/08/15/Netty/image-20210816222527728.png" alt="image-20210816222527728"></li>
</ul>
</li>
<li>每一个Buffer的实现类都有一个属性：<code>hb</code>（不同实现类该属性的类型不同，但都是一个数组），数据实际上就是存放在<code>hb</code>数组里面的</li>
</ul>
<h5 id="2、Buffer的四个主要属性"><a href="#2、Buffer的四个主要属性" class="headerlink" title="2、Buffer的四个主要属性"></a>2、Buffer的四个主要属性</h5><p>Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p>
<ul>
<li><code>Capacity</code>：容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</li>
<li><code>Limit</code>：表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作（左闭右开）。且极限是可以修改的</li>
<li><code>Position</code>：位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</li>
<li><code>Mark</code>：标记（很少主动修改）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<p>其中最重要的flip()方法：用来切换Buffer的读写（其中对于limit是一个“左闭右开区间”）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前所在位置设置成缓存区的终点</span></span><br><span class="line">    limit = position;</span><br><span class="line">    <span class="comment">// 将当前位置归0</span></span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左闭右开：</p>
<p><img src="/2021/08/15/Netty/image-20210816233421568.png" alt="image-20210816233421568"></p>
<h5 id="3、Buffer类相关方法一览"><a href="#3、Buffer类相关方法一览" class="headerlink" title="3、Buffer类相关方法一览"></a>3、Buffer类相关方法一览</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JDK1.4时，引入的api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的容量(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的位置(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span> <span class="params">(<span class="keyword">int</span> newPosition)</span></span>;<span class="comment">//设置此缓冲区的位置(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的限制(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span> <span class="params">(<span class="keyword">int</span> newLimit)</span></span>;<span class="comment">//设置此缓冲区的限制(重要)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span></span>;<span class="comment">//在此缓冲区的位置设置标记</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span></span>;<span class="comment">//将此缓冲区的位置重置为以前标记的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span></span>;<span class="comment">//反转此缓冲区(重要)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span></span>;<span class="comment">//重绕此缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span></span>;<span class="comment">//返回当前位置与限制之间的元素数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span></span>;<span class="comment">//告知在当前位置和限制之间是否有元素(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;<span class="comment">//告知此缓冲区是否为只读缓冲区(重要)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.6时引入的api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>;<span class="comment">//告知此缓冲区是否具有可访问的底层实现数组(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">array</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的底层实现数组(重要)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;<span class="comment">//告知此缓冲区是否为直接缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：什么是直接缓冲区？</p>
<ul>
<li>直接缓冲区指的是操作系统的缓冲区</li>
<li>而平常的缓冲区通常都是JVM分配的缓冲区</li>
</ul>
</blockquote>
<h5 id="4、ByteBuffer（最常用）"><a href="#4、ByteBuffer（最常用）" class="headerlink" title="4、ByteBuffer（最常用）"></a>4、ByteBuffer（最常用）</h5><p>从前面可以看出对于 Java 中的基本数据类型(boolean除外)，都有一个 Buffer 类型与之相对应，<strong>最常用</strong>的自然是ByteBuffer 类（二进制数据），该类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//缓冲区创建相关api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;<span class="comment">//创建直接缓冲区(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;<span class="comment">//设置缓冲区的初始容量(重要)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span>;<span class="comment">//把一个数组放到缓冲区中使用</span></span><br><span class="line">    <span class="comment">//构造初始化位置offset和上界length的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,<span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存区存取相关API</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">( )</span></span>;<span class="comment">//从当前位置position上get，get之后，position会自动+1(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//从绝对位置get(重要)</span></span><br><span class="line">    <span class="comment">//从当前位置上添加，put之后，position会自动+1(重要)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;<span class="comment">//从绝对位置上put(重要)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/15/Netty/image-20210816234508355.png" alt="image-20210816234508355"></p>
<h3 id="5、通道-Channel"><a href="#5、通道-Channel" class="headerlink" title="5、通道(Channel)"></a>5、通道(Channel)</h3><h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><ol>
<li><p>NIO的通道类似于流，但有些区别如下：</p>
<ul>
<li><strong>通道可以同时进行读写，而流只能读或者只能写</strong></li>
<li><strong>通道可以实现异步读写数据</strong></li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲：<ul>
<li><img src="/2021/08/15/Netty/image-20210816235045647.png" alt="image-20210816235045647"></li>
</ul>
</li>
</ul>
</li>
<li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p>Channel在NIO中是一个接口：</p>
<ul>
<li><pre><code class="java">public interface Channel extends Closeable&#123;&#125; 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 常用的 Channel 类有：</span><br><span class="line"></span><br><span class="line">   - &#96;FileChannel&#96;：用于文件的数据读写</span><br><span class="line">   - &#96;DatagramChannel&#96;：用于 UDP 的数据读写</span><br><span class="line">   - &#96;ServerSocketChannel&#96;：用于 TCP 的数据读写</span><br><span class="line">     - ServerSocketChanne 类似 ServerSocket</span><br><span class="line">   - &#96;SocketChannel&#96;：用于 TCP 的数据读写</span><br><span class="line">     - SocketChannel 类似 Socket</span><br><span class="line"></span><br><span class="line">![image-20210817001954099](Netty&#x2F;image-20210817001954099.png)</span><br><span class="line"></span><br><span class="line">![image-20210817002125912](Netty&#x2F;image-20210817002125912.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、FileChannel类</span><br><span class="line"></span><br><span class="line">FileChannel主要用来对本地文件进行 IO 操作，常见的方法有：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 从通道读取数据并放到缓冲区中</span><br><span class="line">public int read(ByteBuffer dst);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把缓冲区的数据写到通道中</span><br><span class="line">public int write(ByteBuffer src);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从目标通道中复制数据到当前通道(可以用来做文件的拷贝，速度很快)</span><br><span class="line">public long transferFrom(ReadableByteChannel src, long position, long count);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把数据从当前通道复制给目标通道（底层实现了零拷贝，速度很快）</span><br><span class="line">public long transferTo(long position, long count, WritableByteChannel target);</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="3、应用实例"><a href="#3、应用实例" class="headerlink" title="3、应用实例"></a>3、应用实例</h4><h5 id="1、应用实例1——本地文件写数据"><a href="#1、应用实例1——本地文件写数据" class="headerlink" title="1、应用实例1——本地文件写数据"></a>1、应用实例1——本地文件写数据</h5><p>实例要求: </p>
<ol>
<li>使用前面的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello，world” 写入到file01.txt 中</li>
<li>文件不存在就创建</li>
</ol>
<p>分析：</p>
<p><img src="/2021/08/15/Netty/image-20210817012929177.png" alt="image-20210817012929177"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\编程\\netty\\src\\file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、应用实例2——本地文件读数据"><a href="#2、应用实例2——本地文件读数据" class="headerlink" title="2、应用实例2——本地文件读数据"></a>2、应用实例2——本地文件读数据</h5><p>实例要求: </p>
<ol>
<li>使用前面的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
</ol>
<p>分析：</p>
<p><img src="/2021/08/15/Netty/image-20210817040423887.png" alt="image-20210817040423887"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\编程\\netty\\src\\file01.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过fileInputStream 获取对应的FileChannel -&gt; 实际类型  FileChannelImpl</span></span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 通道的数据读入到Buffer</span></span><br><span class="line">        channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer 的 字节数据 转成String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、应用实例3——使用一个Buffer完成文件读取"><a href="#3、应用实例3——使用一个Buffer完成文件读取" class="headerlink" title="3、应用实例3——使用一个Buffer完成文件读取"></a>3、应用实例3——使用一个Buffer完成文件读取</h5><p>实例要求: </p>
<ol>
<li>使用 FileChannel(通道) 和 方法  read , write，完成文件的拷贝</li>
<li>拷贝一个文本文件 1.txt , 放在项目下即可</li>
</ol>
<p>分析：</p>
<p><img src="/2021/08/15/Netty/image-20210817040359556.png" alt="image-20210817040359556"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel readChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">        FileChannel writeChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">//清空buffer,其实就是复位一下属性值</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">int</span> read = readChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//表示读完</span></span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将buffer 中的数据写入到 fileChannel02 -- 2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear()的相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、应用实例4——拷贝文件transferFrom-方法"><a href="#4、应用实例4——拷贝文件transferFrom-方法" class="headerlink" title="4、应用实例4——拷贝文件transferFrom 方法"></a>4、应用实例4——拷贝文件transferFrom 方法</h5><p>实例要求: </p>
<ol>
<li>使用 FileChannel(通道) 和 方法  transferFrom ，完成文件的拷贝</li>
<li>拷贝一张图片</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;Koala.jpg&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Koala01.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取各个流对应的filechannel</span></span><br><span class="line">        FileChannel sourceCh = fis.getChannel();</span><br><span class="line">        FileChannel destCh = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh, <span class="number">0</span>, sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        destCh.close();</span><br><span class="line">        sourceCh.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、关于Buffer-和-Channel的注意事项和细节"><a href="#4、关于Buffer-和-Channel的注意事项和细节" class="headerlink" title="4、关于Buffer 和 Channel的注意事项和细节"></a>4、关于Buffer 和 Channel的注意事项和细节</h4><ol>
<li><strong>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。</strong></li>
<li>可以将一个普通Buffer 转成只读Buffer：使用<code>buffer.asReadOnlyBuffer();</code>方法将一个普通buffer转换成只读Buffer<ul>
<li>如果在只读Buffer当中添加数据，会抛出一个<code>ReadOnlyBufferException</code>异常</li>
</ul>
</li>
<li>NIO 还提供了 <code>MappedByteBuffer</code>， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成。调用<code>channel.map(FileChannel.MapMode.READ_WRITE, 0, 6);</code>方法生成一个<code>MappedByteBuffer</code>对象<ul>
<li>注意：map的几个参数<ul>
<li><code>MapMode mode</code>：映射的模式——与上面创建流的模式对应</li>
<li><code>long position</code>：从哪里开修改，即修改的开始位置</li>
<li><code>long size</code>：修改的大小，如果修改的地方超过设置的修改大小，会抛出一个<code>IndexOutOfBoundsException</code>异常</li>
</ul>
</li>
</ul>
</li>
<li>前面我们讲的读写操作，都是通过一个Buffer 完成的，<strong>NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作</strong>，即 <code>Scattering</code> 和 <code>Gathering</code><ul>
<li>Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入  [分散读取]</li>
<li>Gathering: 从buffer读取数据时，可以采用buffer数组，依次读取 [聚集写入]</li>
</ul>
</li>
</ol>
<h5 id="1、关于MappedByteBuffer的相关示例："><a href="#1、关于MappedByteBuffer的相关示例：" class="headerlink" title="1、关于MappedByteBuffer的相关示例："></a>1、关于MappedByteBuffer的相关示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：MappedByteBuffer 可让文件直接在内存(堆外内存)修改, 操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3:  6: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-6</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="comment">// 抛出异常：IndexOutOfBoundsException</span></span><br><span class="line">        <span class="comment">// mappedByteBuffer.put(6, (byte) &#x27;9&#x27;);</span></span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、关于-Scattering-和-Gathering的相关示例"><a href="#2、关于-Scattering-和-Gathering的相关示例" class="headerlink" title="2、关于 Scattering 和 Gathering的相关示例"></a>2、关于 Scattering 和 Gathering的相关示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入  [分散读取]</span></span><br><span class="line"><span class="comment"> * Gathering: 从buffer读取数据时，可以采用buffer数组，依次读取 [聚集写入]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到socket ，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等客户端连接(telnet)</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="comment">//假定从客户端接收8个字节</span></span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> read = socketChannel.read(byteBuffers);</span><br><span class="line">                <span class="comment">//累计读取的字节数</span></span><br><span class="line">                byteRead += read;</span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead=&quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">//使用流打印, 看看当前的这个buffer的position 和 limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;position=&quot;</span> + buffer.position() + <span class="string">&quot;, limit=&quot;</span> + buffer.limit())</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将所有的buffer进行flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="keyword">long</span> byteWirte = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> write = socketChannel.write(byteBuffers);</span><br><span class="line">                byteWirte += write;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的buffer 进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.clear());</span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead:=&quot;</span> + byteRead + <span class="string">&quot; byteWrite=&quot;</span> + byteWirte + <span class="string">&quot;, messagelength&quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、Selector-选择器"><a href="#6、Selector-选择器" class="headerlink" title="6、Selector(选择器)"></a>6、Selector(选择器)</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><ol>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到<strong>Selector选择器</strong></li>
<li>**Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)**，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ol>
<h4 id="2、Selector示意图和特点说明"><a href="#2、Selector示意图和特点说明" class="headerlink" title="2、Selector示意图和特点说明"></a>2、Selector示意图和特点说明</h4><h5 id="1、Selector示意图"><a href="#1、Selector示意图" class="headerlink" title="1、Selector示意图"></a>1、Selector示意图</h5><p><img src="/2021/08/15/Netty/image-20210817171431861.png" alt="image-20210817171431861"></p>
<h5 id="2、特点说明"><a href="#2、特点说明" class="headerlink" title="2、特点说明"></a>2、特点说明</h5><ol>
<li>Netty 的 IO 线程 <code>NioEventLoop</code> 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。</li>
<li>一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h4 id="3、Selector类相关方法"><a href="#3、Selector类相关方法" class="headerlink" title="3、Selector类相关方法"></a>3、Selector类相关方法</h4><p>Selector 类是一个抽象类，以下为Selector的相关方法：</p>
<p><img src="/2021/08/15/Netty/image-20210817172751502.png" alt="image-20210817172751502"></p>
<p>常用方法和说明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123; </span><br><span class="line">    <span class="comment">//得到一个选择器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从内部集合中得到所有的 SelectionKey	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h4><ol>
<li><p>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类似Socket</p>
</li>
<li><p>selector 相关方法说明：</p>
<ul>
<li><pre><code class="java">selector.select()//阻塞

selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回

selector.wakeup();//唤醒selector

selector.selectNow();//不阻塞，立马返还
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7、NIO 非阻塞 网络编程</span><br><span class="line"></span><br><span class="line">#### 1、NIO 非阻塞 网络编程原理分析图</span><br><span class="line"></span><br><span class="line">NIO 非阻塞 网络编程相关的(&#96;Selector&#96;、&#96;SelectionKey&#96;、&#96;ServerScoketChannel&#96;和&#96;SocketChannel&#96;) 关系梳理图：</span><br><span class="line"></span><br><span class="line">![image-20210817173445617](Netty&#x2F;image-20210817173445617.png)</span><br><span class="line"></span><br><span class="line">对上图的说明：</span><br><span class="line"></span><br><span class="line">1. 当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel</span><br><span class="line">2. Selector 进行监听 select 方法, 返回有事件发生的通道的个数.</span><br><span class="line">3. 将 socketChannel 注册到Selector上，register(Selector sel, int ops)， 一个selector上可以注册多个SocketChannel</span><br><span class="line">   - 其中register(Selector sel, int ops)方法的两个参数：</span><br><span class="line">     - Selector sel：想要注册到的选择器</span><br><span class="line">     - int ops：SelectionKey与Channel的注册关系</span><br><span class="line">       - &#96;int OP_ACCEPT&#96;：有新的网络连接可以 accept，值为 16</span><br><span class="line">       - &#96;int OP_CONNECT&#96;：代表连接已经建立，值为 8</span><br><span class="line">       - &#96;int OP_READ&#96;：代表读操作，值为 1 </span><br><span class="line">       - &#96;int OP_WRITE&#96;：代表写操作，值为 4</span><br><span class="line">4. 注册后返回一个 SelectionKey，会和该Selector 关联(集合)</span><br><span class="line">5. 进一步得到各个 SelectionKey (有事件发生)</span><br><span class="line">6. 在通过 SelectionKey 反向获取 SocketChannel，方法 channel()</span><br><span class="line">7. 可以通过channel()方法得到的 channel  , 完成业务处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、NIO 非阻塞 网络编程快速入门</span><br><span class="line"></span><br><span class="line">案例要求：</span><br><span class="line"></span><br><span class="line">1. 编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</span><br><span class="line">2. 目的：理解NIO非阻塞网络编程机制</span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line">- 服务端：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">package com.awo.nio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NIOServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建ServerSocketChannel -&gt; ServerSocket</span><br><span class="line">        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;得到一个Selector对象</span><br><span class="line">        Selector selector &#x3D; Selector.open();</span><br><span class="line">        &#x2F;&#x2F;绑定一个端口6666, 在服务器端监听</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(6666));</span><br><span class="line">        &#x2F;&#x2F;设置为非阻塞</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1</span><br><span class="line">        System.out.println(&quot;注册后的Selectionkey 数量&#x3D;&quot; + selector.keys().size());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;循环等待客户端连接</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;这里我们等待1秒，如果没有事件发生, 返回</span><br><span class="line">            if (selector.select(1000) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;没有事件发生</span><br><span class="line">                System.out.println(&quot;服务器等待了1秒，无连接&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果返回的&gt;0, 就获取到相关的 selectionKey集合</span><br><span class="line">            &#x2F;&#x2F;1.如果返回的&gt;0， 表示已经获取到关注的事件</span><br><span class="line">            &#x2F;&#x2F;2. selector.selectedKeys() 返回关注事件的集合</span><br><span class="line">            &#x2F;&#x2F;   通过 selectionKeys 反向获取通道</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();</span><br><span class="line">            System.out.println(&quot;selectionKeys 数量 &#x3D; &quot; + selectionKeys.size());</span><br><span class="line">            &#x2F;&#x2F;遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator &#x3D; selectionKeys.iterator();</span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取到SelectionKey</span><br><span class="line">                SelectionKey selectionKey &#x3D; keyIterator.next();</span><br><span class="line">                &#x2F;&#x2F;根据key 对应的通道发生的事件做相应处理</span><br><span class="line">                &#x2F;&#x2F;如果是 OP_ACCEPT, 有新的客户端连接</span><br><span class="line">                if (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;该该客户端生成一个 SocketChannel</span><br><span class="line">                    SocketChannel socketChannel &#x3D; serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(&quot;客户端连接成功 生成了一个 socketChannel &quot; + socketChannel.hashCode());</span><br><span class="line">                    &#x2F;&#x2F;将  SocketChannel 设置为非阻塞</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    &#x2F;&#x2F;将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel关联一个Buffer</span><br><span class="line">                    ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class="line">                    &#x2F;&#x2F;2,3,4..</span><br><span class="line">                    System.out.println(&quot;客户端连接后 ，注册的selectionkey 数量&#x3D;&quot; + selector.keys().size());</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;发生 OP_READ</span><br><span class="line">                if (selectionKey.isReadable()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;通过key 反向获取到对应channel</span><br><span class="line">                    SocketChannel channel &#x3D; (SocketChannel) selectionKey.channel();</span><br><span class="line">                    &#x2F;&#x2F;获取到该channel关联的buffer</span><br><span class="line">                    ByteBuffer buffer &#x3D; (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(&quot;form 客户端 &quot; + new String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;手动从集合中移动当前的selectionKey, 防止重复操作</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip 和 端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其它工作..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8、SelectionKey"><a href="#8、SelectionKey" class="headerlink" title="8、SelectionKey"></a>8、SelectionKey</h3><h4 id="1、SelectionKey和网络通道的注册关系"><a href="#1、SelectionKey和网络通道的注册关系" class="headerlink" title="1、SelectionKey和网络通道的注册关系"></a>1、SelectionKey和网络通道的注册关系</h4><p>SelectionKey，表示 Selector 和网络通道的注册关系, 共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 accept，值为 16</li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 8</li>
<li><code>int OP_READ</code>：代表读操作，值为 1 </li>
<li><code>int OP_WRITE</code>：代表写操作，值为 4</li>
</ul>
<p>相关源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2、SelectionKey相关方法"><a href="#2、SelectionKey相关方法" class="headerlink" title="2、SelectionKey相关方法"></a>2、SelectionKey相关方法</h4><p><img src="/2021/08/15/Netty/image-20210817224717376.png" alt="image-20210817224717376"></p>
<p>其中几个比较常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的 Selector 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//设置或改变监听事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span></span>;<span class="comment">//是否可以 accept</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;<span class="comment">//是否可以读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;<span class="comment">//是否可以写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9、ServerSocketChannel"><a href="#9、ServerSocketChannel" class="headerlink" title="9、ServerSocketChannel"></a>9、ServerSocketChannel</h3><p><strong>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</strong></p>
<p>ServerSocketChannel相关方法如下：</p>
<p><img src="/2021/08/15/Netty/image-20210817225056336.png" alt="image-20210817225056336"></p>
<p>常用方法以及说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>  <span class="keyword">implements</span> <span class="title">NetworkChannel</span></span>&#123;</span><br><span class="line">    <span class="comment">// 得到一个 ServerSocketChannel 通道(静态方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器端端口号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受一个连接，返回代表这个连接的通道对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个选择器并设置监听事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10、SocketChannel"><a href="#10、SocketChannel" class="headerlink" title="10、SocketChannel"></a>10、SocketChannel</h3><p>SocketChannel，网络 IO 通道，<strong>具体负责进行读写操作</strong>。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
<p>相关方法如下：</p>
<p><img src="/2021/08/15/Netty/image-20210817225834704.png" alt="image-20210817225834704"></p>
<p>常用方法以及说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往通道里写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从通道里读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11、NIO-网络编程应用实例——群聊系统"><a href="#11、NIO-网络编程应用实例——群聊系统" class="headerlink" title="11、NIO 网络编程应用实例——群聊系统"></a>11、NIO 网络编程应用实例——群聊系统</h3><h4 id="1、实例要求"><a href="#1、实例要求" class="headerlink" title="1、实例要求"></a>1、实例要求</h4><ol>
<li>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</li>
<li>目的：进一步理解NIO非阻塞网络编程机制</li>
</ol>
<h4 id="2、实例需求图"><a href="#2、实例需求图" class="headerlink" title="2、实例需求图"></a>2、实例需求图</h4><p><img src="/2021/08/15/Netty/image-20210817230238423.png" alt="image-20210817230238423"></p>
<h4 id="3、分析"><a href="#3、分析" class="headerlink" title="3、分析"></a>3、分析</h4><ol>
<li>先编写服务器端<ol>
<li>服务器启动并监听 6667</li>
<li>服务器接收客户端信息，并实现转发 [处理上线和离线]</li>
<li>其中转发注意需要排除发送消息的客户端</li>
</ol>
</li>
<li>编写客户端<ol>
<li>连接服务器</li>
<li>发送消息</li>
<li>接收服务器消息</li>
</ol>
</li>
</ol>
<h4 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h4><p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// 初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="comment">// 有事件处理</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得到SelectionKeys的迭代器</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 取出selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="comment">// 监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="comment">// 得到socketChannel</span></span><br><span class="line">                            SocketChannel socketChannel = listenChannel.accept();</span><br><span class="line">                            <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">// 将该 socketChannel 注册到 selector</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">// 提示</span></span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 调用readData处理读事件</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个SocketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取到关联的channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">// 创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// 从buffer读取数据到channel</span></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">// 根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">// 输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line">                <span class="comment">// 向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">// 取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">                ioException.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭通道</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">                    ioException.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向其它的客户端转发消息(去掉自己)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 转发的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> self 自己</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// 遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 转型</span></span><br><span class="line">                    SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                    <span class="comment">// 将msg 存储到buffer</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                    <span class="comment">// 将buffer 的数据写入 通道</span></span><br><span class="line">                    dest.write(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务器发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取从服务器端回复的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="comment">// 有可以用的通道</span></span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">// 得到相关的通道</span></span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 得到一个Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">// 读取</span></span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        <span class="comment">// 把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="comment">// 启动一个线程, 每个3秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                groupChatClient.readInfo();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12、NIO与零拷贝"><a href="#12、NIO与零拷贝" class="headerlink" title="12、NIO与零拷贝"></a>12、NIO与零拷贝</h3><h4 id="1、零拷贝基本介绍"><a href="#1、零拷贝基本介绍" class="headerlink" title="1、零拷贝基本介绍"></a>1、零拷贝基本介绍</h4><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开零拷贝。</li>
<li>在 Java 程序中，常用的零拷贝有 <code>mmap(内存映射)</code> 和 <code>sendFile</code>。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝</li>
<li>另外我们看下NIO 中如何使用零拷贝</li>
</ol>
<h4 id="2、传统IO数据读写"><a href="#2、传统IO数据读写" class="headerlink" title="2、传统IO数据读写"></a>2、传统IO数据读写</h4><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>



<h4 id="3、传统IO模型"><a href="#3、传统IO模型" class="headerlink" title="3、传统IO模型"></a>3、传统IO模型</h4><p><img src="/2021/08/15/Netty/image-20210818031152788.png" alt="image-20210818031152788"></p>
<p>注意：</p>
<ol>
<li><code>DMA</code>：direct memory access——<strong>直接内存拷贝(不使用CPU)</strong></li>
<li>这个IO经过了四次拷贝（两次CPU拷贝、两次DMA拷贝）和三次状态切换（用户态-&gt;内核态-&gt;用户态-&gt;内核态），代价较高<ul>
<li>四次拷贝<ol>
<li>第一次： 从硬盘 经过 DMA 拷贝 到 kernel buffer （内核buferr）</li>
<li>第二次： 从kernel buffer 经过cpu 拷贝到 user buffer，比如拷贝到应用程序</li>
<li>第三次： 从user buffer 拷贝到 socket buffer </li>
<li>第四次： 从socket buffer 拷贝到 protocol engine 协议栈</li>
</ol>
</li>
<li>三次状态切换<ol>
<li>第一次状态切换： 用户态 —&gt; 内核态 （或者叫着 用户上下文—-&gt; 内核上下文）</li>
<li>第二次状态切换： 内核态—&gt; 用户态</li>
<li>第三次状态切换： 用户态—&gt; 内核态</li>
</ol>
</li>
</ul>
</li>
<li>有一个观点认为状态切换变成了四次（最后需要从内核态切换为用户态）<ul>
<li>第四次状态切换：内核态—&gt; 用户态</li>
</ul>
</li>
</ol>
<h4 id="4、mmap优化"><a href="#4、mmap优化" class="headerlink" title="4、mmap优化"></a>4、mmap优化</h4><p>mmap 通过<strong>内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据</strong>。这样，在进行网络传输时，就可以<strong>减少内核空间到用户控件的拷贝次数</strong>。</p>
<p><img src="/2021/08/15/Netty/image-20210818032518521.png" alt="image-20210818032518521"></p>
<p>注意：</p>
<ol>
<li>通过mmap内存映射优化之后，拷贝次数变成了3次，状态切换还是3次<ul>
<li>三次拷贝<ol>
<li>第一次拷贝： DMA拷贝，从硬件拷贝到内核空间<ul>
<li>因为user buffer 与kernel buffer共享数据 ，所以不需要将数据从kernel buffer 拷贝到 user buffer , 数据可以直接在内核空间修改</li>
</ul>
</li>
<li>第二次拷贝： kernel buffer 中的数据经过 cpu 拷贝到 socket buffer </li>
<li>第三次拷贝： socket buffer 过DMA拷贝到protocol engine  协议栈</li>
</ol>
</li>
<li>三次状态切换<ol>
<li>第一次状态切换： 用户态 —&gt; 内核态（或者叫着 用户上下文—-&gt; 内核上下文）</li>
<li>第二次状态切换： 内核态—&gt; 用户态</li>
<li>第三次状态切换： 用户态—&gt; 内核态</li>
</ol>
</li>
</ul>
</li>
<li>有一个观点认为状态切换变成了四次（最后需要从内核态切换为用户态）<ul>
<li>第四次状态切换：内核态—&gt; 用户态</li>
</ul>
</li>
</ol>
<h4 id="5、sendFile优化"><a href="#5、sendFile优化" class="headerlink" title="5、sendFile优化"></a>5、sendFile优化</h4><p>Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：<strong>数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</strong>具体如下图和小结：</p>
<p><img src="/2021/08/15/Netty/image-20210818033948497.png" alt="image-20210818033948497"></p>
<p>注意：</p>
<ul>
<li>Linux 2.1 版本中，通过sendFile优化之后，拷贝次数变成了3次，状态切换还是2次<ul>
<li>三次拷贝<ol>
<li>第一次拷贝： DMA拷贝，从硬件拷贝到内核空间</li>
<li>第二次拷贝： kernel buffer 中的数据经过 cpu 拷贝到 socket buffer </li>
<li>第三次拷贝： socket buffer 过DMA拷贝到protocol engine  协议栈</li>
</ol>
</li>
<li>两次状态切换<ol>
<li>第一次状态切换： 用户态 —&gt; 内核态（或者叫着 用户上下文—-&gt; 内核上下文）</li>
<li>第二次状态切换： 内核态—&gt; 用户态<ul>
<li>由于和用户态完全无关，所以就不用切换到用户态后再切换到内核态了，减少了一次上下文切换</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：</p>
<ul>
<li>零拷贝从操作系统角度，是<strong>没有cpu 拷贝</strong>（DMA不可避免）</li>
<li>Linux 2.1 版本 提供了 sendFile 函数并没有完全实现零拷贝（存在CPU拷贝）</li>
</ul>
</blockquote>
<p>Linux 在 2.4 版本中，做了一些修改，<strong>避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝</strong>。具体如下图和小结：</p>
<p><img src="/2021/08/15/Netty/image-20210818040744312.png" alt="image-20210818040744312"></p>
<p>注意：</p>
<ul>
<li>Linux 在 2.4 版本中，通过sendFile优化之后，拷贝次数变成了2次，状态切换还是2次<ul>
<li>两次拷贝<ol>
<li>第一次拷贝： DMA拷贝，将数据从硬盘拷贝到kernel buffer </li>
<li>第二次拷贝： DMA拷贝，将数据从kernel buffer拷贝到protocol engine<ul>
<li>没有经过cpu拷贝，也就是操作系统级别的拷贝，实现了真正的零拷贝</li>
</ul>
</li>
</ol>
</li>
<li>两次状态切换<ol>
<li>第一次状态切换： 用户态 —&gt; 内核态（或者叫着 用户上下文—-&gt; 内核上下文）</li>
<li>第二次状态切换： 内核态—&gt; 用户态</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：</p>
<ol>
<li>Linux2.4 提供的sendFile实现了真正的零拷贝</li>
<li>这里其实有 一次cpu 拷贝 <strong>kernel buffer -&gt; socket buffer</strong> 但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略</li>
</ol>
</blockquote>
<h4 id="6、零拷贝的再次理解"><a href="#6、零拷贝的再次理解" class="headerlink" title="6、零拷贝的再次理解"></a>6、零拷贝的再次理解</h4><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为<strong>内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据）</strong>。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</li>
</ol>
<h4 id="7、mmap与sendFile的区别"><a href="#7、mmap与sendFile的区别" class="headerlink" title="7、mmap与sendFile的区别"></a>7、mmap与sendFile的区别</h4><ol>
<li>mmap 适合小数据量读写，sendFile 适合大文件传输。</li>
<li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</li>
<li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</li>
</ol>
<h4 id="8、NIO零拷贝案例"><a href="#8、NIO零拷贝案例" class="headerlink" title="8、NIO零拷贝案例"></a>8、NIO零拷贝案例</h4><p>案例要求： </p>
<ol>
<li>使用传统的IO 方法传递一个大文件</li>
<li>使用NIO 零拷贝方式传递(transferTo)一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<p>代码：</p>
<p>传统IO的服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java IO 的服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传统IO的客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java IO 的服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>零拷贝的服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line"></span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                   <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>零拷贝的客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置 =》 课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>传统IO：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总的字节数 = 1,007,473 耗时:60</span><br></pre></td></tr></table></figure>

<p>零拷贝：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总的字节数 = 1,007,473 耗时:21</span><br></pre></td></tr></table></figure>



<h3 id="4、Java-AIO-以及-三种IO模型的对比"><a href="#4、Java-AIO-以及-三种IO模型的对比" class="headerlink" title="4、Java AIO 以及 三种IO模型的对比"></a>4、Java AIO 以及 三种IO模型的对比</h3><h4 id="1、Java-AIO-基本介绍"><a href="#1、Java-AIO-基本介绍" class="headerlink" title="1、Java AIO 基本介绍"></a>1、Java AIO 基本介绍</h4><ol>
<li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：<code>Reactor</code>和 <code>Proactor</code>。<strong>Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</strong></li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。<strong>AIO 引入异步通道的概念，采用了 Proactor 模式</strong>，简化了程序编写，有效的请求才启动线程，它的特点是<strong>先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</strong></li>
<li>目前 AIO 还没有广泛应用，Netty 也是基于NIO, 而不是AIO， 因此我们就不详解AIO了，有兴趣的同学可以参考 <a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html">&lt;&lt;Java新一代网络编程模型AIO原理及Linux系统AIO介绍&gt;&gt;</a></li>
</ol>
<h4 id="2、BIO、NIO、AIO对比表"><a href="#2、BIO、NIO、AIO对比表" class="headerlink" title="2、BIO、NIO、AIO对比表"></a>2、BIO、NIO、AIO对比表</h4><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IO 模型</strong></td>
<td><strong>同步阻塞</strong></td>
<td><strong>同步非阻塞（多路复用）</strong></td>
<td><strong>异步非阻塞</strong></td>
</tr>
<tr>
<td><strong>编程难度</strong></td>
<td><strong>简单</strong></td>
<td><strong>复杂</strong></td>
<td><strong>复杂</strong></td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td><strong>差</strong></td>
<td><strong>好</strong></td>
<td><strong>好</strong></td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td><strong>低</strong></td>
<td><strong>高</strong></td>
<td><strong>高</strong></td>
</tr>
</tbody></table>
<p>举例说明：</p>
<ol>
<li><strong>同步阻塞</strong>：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li><strong>同步非阻塞</strong>：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己。</li>
<li><strong>异步非阻塞</strong>：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<hr>
<h2 id="4、Netty概述"><a href="#4、Netty概述" class="headerlink" title="4、Netty概述"></a>4、Netty概述</h2><h3 id="1、原生NIO存在的问题"><a href="#1、原生NIO存在的问题" class="headerlink" title="1、原生NIO存在的问题"></a>1、原生NIO存在的问题</h3><ol>
<li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li>
<li>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>
<li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h3 id="2、Netty官网"><a href="#2、Netty官网" class="headerlink" title="2、Netty官网"></a>2、Netty官网</h3><p><a target="_blank" rel="noopener" href="https://netty.io/">Netty官网</a>上的说明：</p>
<blockquote>
<p>Netty is <em>an asynchronous event-driven network application framework</em> for rapid development of maintainable high performance protocol servers &amp; clients</p>
</blockquote>
<p><img src="/2021/08/15/Netty/image-20210818173529694.png" alt="image-20210818173529694"></p>
<h3 id="3、Netty官网说明"><a href="#3、Netty官网说明" class="headerlink" title="3、Netty官网说明"></a>3、Netty官网说明</h3><ul>
<li>Netty 是由 JBOSS 提供的一个 Java 开源框架。<strong>Netty 提供==异步==的、==基于事件驱动==的网络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序</strong></li>
<li>Netty 可以帮助你快速、简单的开发出一个网络应用，相当于<strong>简化和流程化了 NIO 的开发过程</strong></li>
<li>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</li>
</ul>
<h3 id="4、Netty的优点"><a href="#4、Netty的优点" class="headerlink" title="4、Netty的优点"></a>4、Netty的优点</h3><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 SSL/TLS 和 StartTLS 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入</li>
</ol>
<h3 id="5、Netty版本说明"><a href="#5、Netty版本说明" class="headerlink" title="5、Netty版本说明"></a>5、Netty版本说明</h3><ol>
<li>netty版本分为 netty3.x 和 netty4.x、netty5.x</li>
<li>因为Netty5出现重大bug，已经被官网废弃了，<strong>目前推荐使用的是Netty4.x的稳定版本</strong></li>
<li>目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x</li>
<li>本次以 Netty4.1.x 版本为主</li>
<li><a target="_blank" rel="noopener" href="https://bintray.com/netty/downloads/netty/">netty 下载地址</a></li>
</ol>
<hr>
<h2 id="5、Netty-高性能架构设计"><a href="#5、Netty-高性能架构设计" class="headerlink" title="5、Netty 高性能架构设计"></a>5、Netty 高性能架构设计</h2><h3 id="1、线程模型基本介绍"><a href="#1、线程模型基本介绍" class="headerlink" title="1、线程模型基本介绍"></a>1、线程模型基本介绍</h3><ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清Netty 线程模式，我们来系统的讲解下各个线程模式， 最后看看Netty 线程模型有什么优越性。</li>
<li>目前存在的线程模型有：<ul>
<li><strong>传统阻塞</strong> <strong>I/O</strong> <strong>服务模型</strong> </li>
<li><strong>Reactor</strong> <strong>模式</strong></li>
</ul>
</li>
<li>根据 <strong>Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</strong><ul>
<li><strong>单 Reactor 单线程</strong>；</li>
<li><strong>单 Reactor 多线程</strong>；</li>
<li><strong>主从 Reactor 多线程</strong>；</li>
</ul>
</li>
<li>Netty 线程模式(Netty 主要<strong>基于主从</strong> <strong>Reactor</strong> <strong>多线程模型</strong>做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</li>
</ol>
<h3 id="2、传统阻塞-I-O-服务模型"><a href="#2、传统阻塞-I-O-服务模型" class="headerlink" title="2、传统阻塞 I/O 服务模型"></a>2、传统阻塞 I/O 服务模型</h3><h4 id="1、工作原理图-1"><a href="#1、工作原理图-1" class="headerlink" title="1、工作原理图"></a>1、工作原理图</h4><p><img src="/2021/08/15/Netty/image-20210818180105435.png" alt="image-20210818180105435"></p>
<blockquote>
<p>黄色的框表示对象， 蓝色的框表示线程，白色的框表示方法(API)</p>
</blockquote>
<h4 id="2、模型特点"><a href="#2、模型特点" class="headerlink" title="2、模型特点"></a>2、模型特点</h4><ol>
<li>采用<strong>阻塞IO模式</strong>获取输入的数据</li>
<li><strong>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</strong></li>
</ol>
<h4 id="3、问题分析"><a href="#3、问题分析" class="headerlink" title="3、问题分析"></a>3、问题分析</h4><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</li>
</ol>
<h3 id="3、Reactor-模式（整体）"><a href="#3、Reactor-模式（整体）" class="headerlink" title="3、Reactor 模式（整体）"></a>3、Reactor 模式（整体）</h3><h4 id="1、针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案"><a href="#1、针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案" class="headerlink" title="1、针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案"></a>1、针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案</h4><ol>
<li>==基于 I/O 复用模型==：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理<ul>
<li>`Reactor 对应的叫法：<ul>
<li>反应器模式</li>
<li>分发者模式(Dispatcher)</li>
<li>通知者模式(notifier)</li>
</ul>
</li>
</ul>
</li>
<li>==基于线程池复用线程资源==：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<p><img src="/2021/08/15/Netty/image-20210818181829563.png" alt="image-20210818181829563"></p>
<h4 id="2、工作原理图"><a href="#2、工作原理图" class="headerlink" title="2、工作原理图"></a>2、工作原理图</h4><p><strong>I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</strong>：</p>
<p><img src="/2021/08/15/Netty/image-20210818181932485.png" alt="image-20210818181932485"></p>
<h4 id="3、模型特点"><a href="#3、模型特点" class="headerlink" title="3、模型特点"></a>3、模型特点</h4><ol>
<li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)</li>
<li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程， 因此Reactor模式也叫 Dispatcher模式</li>
<li>Reactor 模式使用IO复用监听事件，收到事件后，分发给某个线程(进程)，这点就是网络服务器高并发处理关键</li>
</ol>
<h4 id="4、Reactor-模式中-核心组成"><a href="#4、Reactor-模式中-核心组成" class="headerlink" title="4、Reactor 模式中 核心组成"></a>4、Reactor 模式中 核心组成</h4><ul>
<li><code>Reactor</code>：<strong>Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应</strong>。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers</code>：<strong>处理程序执行 I/O 事件要完成的实际事件</strong>，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li>
</ul>
<h4 id="5、Reactor-模式分类"><a href="#5、Reactor-模式分类" class="headerlink" title="5、Reactor 模式分类"></a>5、Reactor 模式分类</h4><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p>
<ol>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程</li>
</ol>
<h3 id="4、单-Reactor-单线程"><a href="#4、单-Reactor-单线程" class="headerlink" title="4、单 Reactor 单线程"></a>4、单 Reactor 单线程</h3><h5 id="1、工作原理图-2"><a href="#1、工作原理图-2" class="headerlink" title="1、工作原理图"></a>1、工作原理图</h5><p><img src="/2021/08/15/Netty/image-20210818182434248.png" alt="image-20210818182434248"></p>
<h5 id="2、原理图说明"><a href="#2、原理图说明" class="headerlink" title="2、原理图说明"></a>2、原理图说明</h5><ol>
<li>Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li>
<li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>
<li>Handler 会完成 Read→业务处理→Send 的完整业务流程</li>
</ol>
<p><strong>结合实例：</strong>服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。</p>
<h5 id="3、单-Reactor-单线程的优缺点"><a href="#3、单-Reactor-单线程的优缺点" class="headerlink" title="3、单 Reactor 单线程的优缺点"></a>3、单 Reactor 单线程的优缺点</h5><ul>
<li><strong>优点：</strong><ul>
<li>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li>客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</li>
</ul>
</li>
</ul>
<h3 id="5、单Reactor-多线程"><a href="#5、单Reactor-多线程" class="headerlink" title="5、单Reactor 多线程"></a>5、单Reactor 多线程</h3><h4 id="1、工作原理图-3"><a href="#1、工作原理图-3" class="headerlink" title="1、工作原理图"></a>1、工作原理图</h4><p><img src="/2021/08/15/Netty/image-20210818194738294.png" alt="image-20210818194738294"></p>
<h4 id="2、原理图说明-1"><a href="#2、原理图说明-1" class="headerlink" title="2、原理图说明"></a>2、原理图说明</h4><ol>
<li>Reactor 对象通过select 监控客户端请求事件，收到事件后，通过dispatch进行分发</li>
<li>如果建立连接请求，则由 Acceptor 通过accept 处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由reactor分发调用连接对应的handler 来处理</li>
<li>handler 只负责响应事件，不做具体的业务处理，通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务</li>
<li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler</li>
<li>handler收到响应后，通过send 将结果返回给client</li>
</ol>
<h4 id="3、单Reactor-多线程的优缺点"><a href="#3、单Reactor-多线程的优缺点" class="headerlink" title="3、单Reactor 多线程的优缺点"></a>3、单Reactor 多线程的优缺点</h4><ul>
<li><strong>优点：</strong>可以充分的利用多核cpu 的处理能力</li>
<li><strong>缺点：</strong>多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈。</li>
</ul>
<h3 id="6、主从-Reactor-多线程"><a href="#6、主从-Reactor-多线程" class="headerlink" title="6、主从 Reactor 多线程"></a>6、主从 Reactor 多线程</h3><h4 id="1、工作原理图-4"><a href="#1、工作原理图-4" class="headerlink" title="1、工作原理图"></a>1、工作原理图</h4><p><img src="/2021/08/15/Netty/image-20210818195224698.png" alt="image-20210818195224698"></p>
<p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行</p>
<h4 id="2、原理图说明-2"><a href="#2、原理图说明-2" class="headerlink" title="2、原理图说明"></a>2、原理图说明</h4><ol>
<li>Reactor主线程 MainReactor 对象通过select 监听连接事件，收到事件后，通过Acceptor 处理连接事件</li>
<li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给SubReactor </li>
<li>subreactor 将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li>
<li>当有新事件发生时， subreactor 就会调用对应的handler处理</li>
<li>handler 通过read 读取数据，分发给后面的worker 线程处理</li>
<li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果</li>
<li>handler 收到响应的结果后，再通过send 将结果返回给client</li>
<li>Reactor 主线程可以对应多个Reactor 子线程，即MainRecator 可以关联多个SubReactor</li>
</ol>
<h4 id="3、Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解"><a href="#3、Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解" class="headerlink" title="3、Scalable IO in Java 对 Multiple Reactors 的原理图解"></a>3、Scalable IO in Java 对 Multiple Reactors 的原理图解</h4><p><img src="/2021/08/15/Netty/image-20210818195414795.png" alt="image-20210818195414795"></p>
<h4 id="4、主从-Reactor-多线程的优缺点"><a href="#4、主从-Reactor-多线程的优缺点" class="headerlink" title="4、主从 Reactor 多线程的优缺点"></a>4、主从 Reactor 多线程的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>编程复杂度较高</li>
</ul>
</li>
<li><strong>结合实例：</strong>这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 Reactor 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li>
</ul>
<h3 id="7、Reactor-模式小结"><a href="#7、Reactor-模式小结" class="headerlink" title="7、Reactor 模式小结"></a>7、Reactor 模式小结</h3><h4 id="1、3-种模式用生活案例来理解"><a href="#1、3-种模式用生活案例来理解" class="headerlink" title="1、3 种模式用生活案例来理解"></a>1、3 种模式用生活案例来理解</h4><ol>
<li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 Reactor 多线程，多个前台接待员，多个服务生</li>
</ol>
<h4 id="2、Reactor-模式具有如下的优点"><a href="#2、Reactor-模式具有如下的优点" class="headerlink" title="2、Reactor 模式具有如下的优点"></a>2、Reactor 模式具有如下的优点</h4><ul>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<h3 id="8、Netty模型"><a href="#8、Netty模型" class="headerlink" title="8、Netty模型"></a>8、Netty模型</h3><h4 id="1、工作原理图1——简单版"><a href="#1、工作原理图1——简单版" class="headerlink" title="1、工作原理图1——简单版"></a>1、工作原理图1——简单版</h4><p>Netty 主要基于<strong>主从</strong> <strong>Reactors</strong> <strong>多线程模型</strong>（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p>
<p><img src="/2021/08/15/Netty/image-20210818210506772.png" alt="image-20210818210506772"></p>
<ol>
<li>BossGroup 线程维护 Selector ，只关注 Accecpt 事件</li>
<li>当接收到Accept事件，获取到对应的SocketChannel，封装成 NIOScoketChannel并注册到Worker 线程(事件循环)，并进行维护</li>
<li>当Worker线程监听到 selector 中通道发生自己感兴趣的事件后，就进行处理(就由handler进行处理)， 注意handler 已经加入到通道</li>
</ol>
<h4 id="2、工作原理图2——进阶版"><a href="#2、工作原理图2——进阶版" class="headerlink" title="2、工作原理图2——进阶版"></a>2、工作原理图2——进阶版</h4><p><img src="/2021/08/15/Netty/image-20210818213124808.png" alt="image-20210818213124808"></p>
<p>Netty 主要基于<strong>主从</strong> <strong>Reactors</strong> <strong>多线程模型</strong>（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor</p>
<h4 id="3、工作原理图3——详细版"><a href="#3、工作原理图3——详细版" class="headerlink" title="3、工作原理图3——详细版"></a>3、工作原理图3——详细版</h4><p><img src="/2021/08/15/Netty/image-20210818213257551.png" alt="image-20210818213257551"></p>
<h4 id="4、原理图说明"><a href="#4、原理图说明" class="headerlink" title="4、原理图说明"></a>4、原理图说明</h4><ol>
<li>Netty抽象出两组线程池：<ul>
<li><code>BossGroup</code>：专门负责接收客户端的连接</li>
<li><code>WorkerGroup</code>： 专门负责网络的读写</li>
</ul>
</li>
<li>BossGroup 和 WorkerGroup 类型都是 <code>NioEventLoopGroup</code></li>
<li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</li>
<li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector，用于监听绑定在其上的socket的网络通讯</li>
<li>NioEventLoopGroup 可以有多个线程，即可以含有多个NioEventLoop</li>
<li>每个Boss NioEventLoop 循环执行的步骤有3步<ol>
<li>轮询accept 事件</li>
<li>处理accept 事件，与client建立连接，生成NioScocketChannel，并将其注册到某个worker NIOEventLoop 上的 selector</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ol>
</li>
<li>每个 Worker NIOEventLoop 循环执行的步骤<ol>
<li>轮询read/write 事件</li>
<li>处理i/o事件，即read/write 事件，在对应NioScocketChannel上进行处理</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ol>
</li>
<li>每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道)，pipeline 中包含了 channel，即通过pipeline 可以获取到对应通道，管道中维护了很多的处理器（可对数据进行相关的拦截与过滤等等）。</li>
</ol>
<h4 id="5、Netty快速入门实例——TCP服务"><a href="#5、Netty快速入门实例——TCP服务" class="headerlink" title="5、Netty快速入门实例——TCP服务"></a>5、Netty快速入门实例——TCP服务</h4><ol>
<li>实例要求：使用IDEA 创建Netty项目</li>
<li>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~”</li>
<li>服务器可以回复消息给客户端 “hello, 客户端~”</li>
<li>目的：对Netty 线程模型 有一个初步认识，便于理解Netty 模型理论<ol>
<li>编写服务端 </li>
<li>编写客户端</li>
<li>对netty 程序进行分析，看看netty模型特点</li>
</ol>
</li>
</ol>
<p>代码：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">null</span>;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">            <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">            <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">            <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">            <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">            bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    <span class="comment">// .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;客户socketchannel hashcode=&quot;</span> + socketChannel.hashCode());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;.....服务器 is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给ChannelFuture注册监听器，监控我们关心的事件</span></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bossGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bossGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                workerGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端的Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1、我们自定义一个Handler 需要继承netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * 2、这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"><span class="comment">     *  1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">     *  2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将 msg 转成一个 ByteBuf</span></span><br><span class="line">        <span class="comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是:&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常, 一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//加入自己的处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址： &quot;</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常, 一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、相关问题以及解答"><a href="#6、相关问题以及解答" class="headerlink" title="6、相关问题以及解答"></a>6、相关问题以及解答</h4><h5 id="问题1：bossGroup与workerGroup含有的子线程的数量"><a href="#问题1：bossGroup与workerGroup含有的子线程的数量" class="headerlink" title="问题1：bossGroup与workerGroup含有的子线程的数量"></a>问题1：bossGroup与workerGroup含有的子线程的数量</h5><p>解答：默认为CPU核数的两倍，即CPU核数*2</p>
<p>相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoopGroup构造函数（空参）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终调用了其父类MultithreadEventLoopGroup的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的nThread就是上面this的参数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DEFAULT_EVENT_LOOP_THREADS相关说明</span></span><br><span class="line"><span class="comment">// 其中的NettyRuntime.availableProcessors()返回的就是CPU核数，然后乘以2返回</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h5 id="问题2：Netty服务端接收的新连接是如何绑定到worker线程池的（即worker线程池是怎么分配线程的）？"><a href="#问题2：Netty服务端接收的新连接是如何绑定到worker线程池的（即worker线程池是怎么分配线程的）？" class="headerlink" title="问题2：Netty服务端接收的新连接是如何绑定到worker线程池的（即worker线程池是怎么分配线程的）？"></a>问题2：Netty服务端接收的新连接是如何绑定到worker线程池的（即worker线程池是怎么分配线程的）？</h5><p>解答：通过==轮询==的方式，（假设worker线程的个数为8）首先为第一个连接分配线程1，接着为第二个连接分配线程2……然后为第八个连接分配线程8；如果之后还有连接到来的的话，在线程1空闲的情况下，会分配线程1到第九个连接。</p>
<h5 id="问题3：ctx-上下文对象-里面包含的内容"><a href="#问题3：ctx-上下文对象-里面包含的内容" class="headerlink" title="问题3：ctx(上下文对象)里面包含的内容"></a>问题3：ctx(上下文对象)里面包含的内容</h5><p><img src="/2021/08/15/Netty/image-20210819024626333.png" alt="image-20210819024626333"></p>
<p>ctx实际上是一个数据流，有着出站与入站（inbound 入站 ，outbound  出站）</p>
<h5 id="问题4：channel与-pipeline-之间的关系"><a href="#问题4：channel与-pipeline-之间的关系" class="headerlink" title="问题4：channel与 pipeline 之间的关系"></a>问题4：channel与 pipeline 之间的关系</h5><p>pipeline(管道) 本质上是一个双向链表，有着头尾指针。一个pipeline 与一个 channel对应，可以通过pipeline 获取到它对应的channel</p>
<p><img src="/2021/08/15/Netty/image-20210819025333778.png" alt="image-20210819025333778"></p>
<p>channel(通道) ：其中也包含了与channel对应的pipeline对象</p>
<p><img src="/2021/08/15/Netty/image-20210819025741518.png" alt="image-20210819025741518"></p>
<h4 id="7、任务队列中的-Task-有-3-种典型使用场景"><a href="#7、任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="7、任务队列中的 Task 有 3 种典型使用场景"></a>7、任务队列中的 Task 有 3 种典型使用场景</h4><p>如果当前有一个非常耗时长（长时间的操作）的业务，如果正常地放在handler中去执行的话，势必会造成pipeline的阻塞。因此，对于某些任务的执行可以提交到NioEventLoop的TaskQueue任务队列中去异步执行。其实TaskQueue与Channel之间存在绑定关系。对于这些任务有以下3种典型的应用：</p>
<ol>
<li>用户程序自定义的普通任务</li>
<li>用户自定义定时任务</li>
<li>非当前 Reactor 线程调用 Channel 的各种方法</li>
</ol>
<p>例如在<strong>推送系统</strong>的业务线程里面，根据<strong>用户的标识</strong>，找到对应的 <strong>Channel</strong> <strong>引用</strong>，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被<strong>异步消费</strong></p>
<p>将这些任务从handler中提交到channel对应的NIOEventLoop 的 TaskQueue的方法：</p>
<h5 id="1、用户程序自定义的普通任务-gt-提交到该channel-对应的NioEventLoop-的-taskQueue中"><a href="#1、用户程序自定义的普通任务-gt-提交到该channel-对应的NioEventLoop-的-taskQueue中" class="headerlink" title="1、用户程序自定义的普通任务 -&gt; 提交到该channel 对应的NioEventLoop 的 taskQueue中"></a>1、用户程序自定义的普通任务 -&gt; 提交到该channel 对应的NioEventLoop 的 taskQueue中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户程序自定义的普通任务</span></span><br><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ctx.channel().eventLoop().execute(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void run() &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(20 * 1000);</span></span><br><span class="line"><span class="comment">            ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;, CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;发生异常&quot; + ex.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>该方法是通过ctx获得channel对象，在通过channel对象去获取该channel所在的evevtLoop，最后在将任务提交到eventLoop的taskQueue中</p>
</li>
<li><p>eventLoop会起<strong>一个线程</strong>去异步解决taskQueue当中的任务，==注意是一个线程==。如果taskQueue当中有多个任务的话，那么该线程会按照taskQueue中任务的顺序依次执行任务，即执行taskQueue任务的时间是累加的</p>
<ul>
<li>eg：taskQueue的第一个任务花费10s，taskQueue的第二个任务花费20s，那么该线程执行完taskQueue当中的任务总共要花费30s</li>
</ul>
</li>
<li><p>解决方法：</p>
<ol>
<li><p><strong>在当前Handler中创建一个业务线程池</strong>，把耗时任务放到创建的线程池中执行。此时就变成了一个线程有一个业务线程池，来完成耗时任务的异步操作。（局部异步）</p>
<ul>
<li><p>创建线程池的方法：</p>
<ul>
<li><pre><code class="java">// 创建一个线程池，线程数为16
// 这里是用static 创建的全局线程池，即在整一个Handler都可以使用该业务线程池
static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);

// 调用一下方法将耗时任务放在线程池创建的线程中进行执行
group.sumbit(Callable task);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **在Server端中创建一个业务线程池（Context中添加线程池）**（整个异步）</span><br><span class="line"></span><br><span class="line">   - 创建线程池的方法：</span><br><span class="line"></span><br><span class="line">     - &#96;&#96;&#96;java</span><br><span class="line">       &#x2F;&#x2F; 创建一个线程池，线程数为16</span><br><span class="line">       &#x2F;&#x2F; 这里是用static 创建的全局线程池，即在整一个Handler都可以使用该业务线程池</span><br><span class="line">       static final EventExecutorGroup group &#x3D; new DefaultEventExecutorGroup(16);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 在ChannelInitializer的initChannel方法中</span><br><span class="line">       ChannelPipeline p &#x3D; chpipeline();</span><br><span class="line">       &#x2F;&#x2F; 在这里将group设置进去：如果这样设置的话，该handler会优先加入到该线程池中，这样一来，workerGroup主要接收任务 然后在将任务提交给线程池来处理。</span><br><span class="line">       &#x2F;&#x2F; 默认没添加group的话，handler会进入workerLoopGroup的某一个workerLoop子线程</span><br><span class="line">       p.addLast(group,new MyServerHandler());</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="2、用户自定义定时任务-gt-提交到该channel-对应的NioEventLoop-的-scheduleTaskQueue中"><a href="#2、用户自定义定时任务-gt-提交到该channel-对应的NioEventLoop-的-scheduleTaskQueue中" class="headerlink" title="2、用户自定义定时任务 -&gt; 提交到该channel 对应的NioEventLoop 的  scheduleTaskQueue中"></a>2、用户自定义定时任务 -&gt; 提交到该channel 对应的NioEventLoop 的  scheduleTaskQueue中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>该任务在5s后执行</li>
<li>sleep 需要占用线程资源，这5s线程啥都干不了，延时5s执行任务，这5s线程可以做别的事情</li>
<li>taskQueue里的任务执行完毕后，会再执行scheduledtaskQueue。并且scheduled里的延迟时间是从taskQueue执行第一个任务之前开始算的</li>
<li>并且如果scheduled延迟时间若小于taskQueue里的总执行时间，在后者执行完后前者会立即执行，而不会在后者运行期间执行前者。</li>
<li>以上代码只是一个延迟任务，如果是定时任务的话还少了个参数，在第一个数字(延迟时间)后加一个间隔时间</li>
</ul>
<h5 id="3、非当前-Reactor-线程调用-Channel-的各种方法"><a href="#3、非当前-Reactor-线程调用-Channel-的各种方法" class="headerlink" title="3、非当前 Reactor 线程调用 Channel 的各种方法"></a>3、非当前 Reactor 线程调用 Channel 的各种方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Server端的ServerBootstrap的配置中的childHandler进行初始化的时候就可以将客户端的SocketChannel维护在一个集合里面，方便之后的获取</span></span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">    <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br></pre></td></tr></table></figure>



<h4 id="8、方案再说明"><a href="#8、方案再说明" class="headerlink" title="8、方案再说明"></a>8、方案再说明</h4><ol>
<li>Netty 抽象出两组<strong>线程池</strong>，<strong>BossGroup 专门负责接收客户端连接</strong>，<strong>WorkerGroup 专门负责网络读写操作</strong>。</li>
<li>NioEventLoop 表示一个不断循环执行处理任务的线程，<strong>每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道</strong>。</li>
<li>NioEventLoop 内部采用==串行化设计==，从<strong>消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 IO 线程 NioEventLoop 负责（如果在处理方面需要花费长时间的话就会阻塞这个流程，所以通常将花费长时间的任务放在taskQueue当中取异步执行）<ul>
<li>NioEventLoopGroup 下包含多个 NioEventLoop</li>
<li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue</li>
<li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel</li>
<li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</li>
<li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6、异步模型"><a href="#6、异步模型" class="headerlink" title="6、异步模型"></a>6、异步模型</h2><h3 id="1、基本介绍-3"><a href="#1、基本介绍-3" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li>Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。</li>
<li>调用者并不能立刻获得结果，而是通过 ==Future-Listener 机制==，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果</li>
<li><strong>Netty 的异步模型是建立在 future 和 callback 的之上的</strong>。callback 就是回调。重点说 Future，它的核心思想是：<strong>假设一个方法 fun，计算过程可能非常耗时，等待 fun返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future去监控方法 fun 的处理过程(即 ： Future-Listener 机制)</strong></li>
</ol>
<h3 id="2、Future说明"><a href="#2、Future说明" class="headerlink" title="2、Future说明"></a>2、Future说明</h3><ol>
<li><p>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</p>
</li>
<li><p>ChannelFuture 是一个接口，我们可以添加监听器，当监听的事件发生时，就会通知到监听器。</p>
<ul>
<li><pre><code class="java">public interface ChannelFuture extends Future&lt;Void&gt; &#123;&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">### 3、工作原理图</span><br><span class="line"></span><br><span class="line">![image-20210819212841178](Netty&#x2F;image-20210819212841178.png)</span><br><span class="line"></span><br><span class="line">![image-20210819212905885](Netty&#x2F;image-20210819212905885.png)</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">1. 在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用future 即可。这使得**链式操作**简单、高效, 并有利于编写可重用的、通用的代码。</span><br><span class="line">2. Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4、Future-Listener 机制</span><br><span class="line"></span><br><span class="line">1. 当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。</span><br><span class="line"></span><br><span class="line">2. 常见有如下操作</span><br><span class="line"></span><br><span class="line">   - 通过 &#96;isDone&#96; 方法来**判断当前操作是否完成**；</span><br><span class="line">   - 通过 &#96;isSuccess&#96; 方法来**判断已完成的当前操作是否成功**；</span><br><span class="line">   - 通过 &#96;getCause&#96; 方法来**获取已完成的当前操作失败的原因**；</span><br><span class="line">   - 通过 &#96;isCancelled&#96; 方法来**判断已完成的当前操作是否被取消**；</span><br><span class="line">   - 通过 &#96;addListener&#96; 方法来注册监听器，**当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器**</span><br><span class="line"></span><br><span class="line">3. 举例说明</span><br><span class="line"></span><br><span class="line">   - 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">         if(future.isSuccess()) &#123;</span><br><span class="line">             System.out.println(newDate() + &quot;: 端口[&quot;+ port + &quot;]绑定成功!&quot;);</span><br><span class="line">         &#125; else&#123;</span><br><span class="line">             System.err.println(&quot;端口[&quot;+ port + &quot;]绑定失败!&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>小结：</strong>相比传统阻塞 I/O，执行 I/O 操作后线程会被阻塞住，直到操作完成；异步处理的好处是不会造成线程阻塞，线程在 I/O 操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。</p>
<h3 id="5、快速入门实例——HTTP服务"><a href="#5、快速入门实例——HTTP服务" class="headerlink" title="5、快速入门实例——HTTP服务"></a>5、快速入门实例——HTTP服务</h3><ol>
<li>实例要求：使用IDEA 创建Netty项目</li>
<li>Netty 服务器在 7777端口监听，浏览器发出请求 “<a target="_blank" rel="noopener" href="http://localhost:7777/">http://localhost:7777/</a> “</li>
<li>服务器可以回复消息给客户端 “Hello! 我是服务器 5 “ ，并对特定请求资源进行过滤。</li>
<li>目的：Netty 可以做Http服务开发，并且理解Handler实例和客户端及其请求的关系。</li>
<li>效果：<ul>
<li><img src="/2021/08/15/Netty/image-20210819213544007.png" alt="image-20210819213544007"></li>
</ul>
</li>
</ol>
<p>代码:</p>
<p>Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7777</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestServerInitializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 说明</span></span><br><span class="line">        <span class="comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//2. 增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">        System.out.println(<span class="string">&quot;ok~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestHttpServerHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.http;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * channelRead0 读取客户端数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="string">&quot; pipeline=&quot;</span> + ctx</span><br><span class="line">                .pipeline() + <span class="string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断 msg 是不是 httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ctx 类型=&quot;</span>+ctx.getClass());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型=&quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri, 过滤指定的资源</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回复信息给浏览器 [http协议]</span></span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的相应，即 httpresponse</span></span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>Http是无状态协议，而且建立的一般都是长链接，所以在刷新浏览器后，服务端会为本次的http请求创建新的handler和pipeline（一个handler与一个pipeline对应，为一组。多个http请求就会有多组handler与pipeline）</li>
</ul>
<hr>
<h2 id="7、Netty-核心模块组件"><a href="#7、Netty-核心模块组件" class="headerlink" title="7、Netty 核心模块组件"></a>7、Netty 核心模块组件</h2><h3 id="1、Bootstrap、ServerBootstrap"><a href="#1、Bootstrap、ServerBootstrap" class="headerlink" title="1、Bootstrap、ServerBootstrap"></a>1、Bootstrap、ServerBootstrap</h3><ul>
<li>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件。</li>
<li>Netty 中 <code>Bootstrap</code> 类是==客户端==程序的启动引导类，<code>ServerBootstrap</code> 是==服务端==启动引导类</li>
</ul>
<p>常见的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法用于服务器端，用来设置两个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法用于客户端，用来设置一个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法用来设置一个服务器端的通道实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来给 ServerChannel 添加配置</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来给接收到的通道添加配置</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法用来设置业务处理类（自定义的 handler）</span></span><br><span class="line"><span class="comment">// handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法用于服务器端，用来设置占用的端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法用于客户端，用来连接服务器端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h3><ol>
<li>Netty 网络通信的组件，能够用于执行网络 I/O 操作。</li>
<li>通过Channel 可获得 当前网络连接的通道的状态</li>
<li>通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</li>
<li>Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成</li>
<li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方</li>
<li>支持关联 I/O 操作与对应的处理程序</li>
<li>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型：<ul>
<li><code>NioSocketChannel</code>：<strong>异步的客户端 TCP Socket 连接。</strong></li>
<li><code>NioServerSocketChannel</code>：<strong>异步的服务器端 TCP Socket 连接。</strong></li>
<li><code>NioDatagramChannel</code>：<strong>异步的 UDP 连接。</strong></li>
<li><code>NioSctpChannel</code>：<strong>异步的客户端 Sctp 连接。</strong></li>
<li><code>NioSctpServerChannel</code>：<strong>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</strong></li>
</ul>
</li>
</ol>
<h3 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h3><ol>
<li>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</li>
<li>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel</li>
</ol>
<h3 id="4、ChannelHandler-及其实现类"><a href="#4、ChannelHandler-及其实现类" class="headerlink" title="4、ChannelHandler 及其实现类"></a>4、ChannelHandler 及其实现类</h3><ol>
<li>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</li>
<li>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
</ol>
<p>ChannelHandler 及其实现类一览图：</p>
<p><img src="/2021/08/15/Netty/image-20210819233354647.png" alt="image-20210819233354647"></p>
<ul>
<li><code>ChannelInboundHandler</code>：用于处理入站 I/O 事件。</li>
<li><code>ChannelOutboundHandler</code>：用于处理出站 I/O 操作。</li>
</ul>
<p>适配器模式：</p>
<ul>
<li><code>ChannelInboundHandlerAdapter</code>：用于处理入站 I/O 事件。</li>
<li><code>ChannelOutboundHandlerAdapter</code>：用于处理出站 I/O 操作。</li>
<li><code>ChannelDuplexHandler</code>：用于处理入站和出站事件。</li>
</ul>
<p>为什么ChannelDuplexHandler既能解决入站事件，又能解决出站事件？</p>
<p>查看ChannelDuplexHandler的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ChannelDuplexHandler继承了ChannelInboundHandlerAdapter类，所以能解决入站事件</li>
<li>ChannelDuplexHandler实现了ChannelOutboundHandler接口，所以能解决出站事件</li>
</ul>
<p>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelInboundHandlerAdapter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通道就绪事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通道读取数据事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据读取完毕事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通道发生异常事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelInboundHandlerAdapter的所有实现方法：</p>
<p><img src="/2021/08/15/Netty/image-20210819234347536.png" alt="image-20210819234347536"></p>
<p><img src="/2021/08/15/Netty/image-20210819234419147.png" alt="image-20210819234419147"></p>
<h3 id="5、Pipeline-和-ChannelPipeline"><a href="#5、Pipeline-和-ChannelPipeline" class="headerlink" title="5、Pipeline 和 ChannelPipeline"></a>5、Pipeline 和 ChannelPipeline</h3><p>ChannelPipeline 是一个重点：</p>
<ol>
<li><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解：<strong>ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作</strong>)</p>
</li>
<li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互</p>
</li>
<li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p>
<ul>
<li><p><img src="/2021/08/15/Netty/image-20210819234704352.png" alt="image-20210819234704352"></p>
</li>
<li><p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler</p>
<ul>
<li><p>可以通过Channel拿到ChannelPipeline，也可以通过ChannelPipeline拿到Channel（双方都包含对方的引用）</p>
</li>
<li><p>ChannelHandlerContext实际上是一个接口，在双向链表当中的ChannelHandlerContext实际上是ChannelHandlerContext的实现类 <code>DefaultChannelHandlerContext</code></p>
<ul>
<li><pre><code class="java">public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker &#123;...&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</span><br><span class="line"></span><br><span class="line">     - ChannelPipeline提供了ChannelHandler链的容器。以&#x3D;&#x3D;客户端&#x3D;&#x3D;应用程序为例：</span><br><span class="line">       - **如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的**，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理，以上图就是从链表 tail 往前传递到最前一个出站的 handler （head）</span><br><span class="line">       - **如果事件的运动方向是从服务端到客户端的，那么我们称这些事件为入站的**，即服务端发送给客户端的数据会通过pipeline中的一系列ChannelInboundHandler，并被这些Handler处理，以上图就是从链表 head 往后传递到最后一个入站的 handler（tail）。</span><br><span class="line">       - 前面客户端和服务端都是Inbound是因为他们都要读对方的消息，读取对方的消息就是入站</span><br><span class="line"></span><br><span class="line">4. 常用方法</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     &#x2F;&#x2F; 把一个业务处理类（handler）添加到链中的第一个位置</span><br><span class="line">     ChannelPipeline addFirst(ChannelHandler... handlers);</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 把一个业务处理类（handler）添加到链中的最后一个位置</span><br><span class="line">     ChannelPipeline addLast(ChannelHandler... handlers);</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6、ChannelHandlerContext"><a href="#6、ChannelHandlerContext" class="headerlink" title="6、ChannelHandlerContext"></a>6、ChannelHandlerContext</h3><ol>
<li><p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象</p>
</li>
<li><p>即ChannelHandlerContext 中包含一个具体的事件处理器 ChannelHandler ， 同时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler进行调用。</p>
</li>
<li><p>常用方法</p>
<ul>
<li><pre><code class="java">// 关闭通道
ChannelFuture close();

// 刷新
ChannelOutboundInvoker flush();

// 将数据写到 ChannelPipeline 中当前ChannelHandler 的下一个 ChannelHandler 开始处理（出站）
ChannelFuture writeAndFlush(Object msg);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7、ChannelOption</span><br><span class="line"></span><br><span class="line">1. Netty 在创建 Channel 实例后，一般都需要设置 ChannelOption 参数。</span><br><span class="line">2. ChannelOption 参数如下：</span><br><span class="line">   - &#96;ChannelOption.SO_BACKLOG&#96;：对应 TCP&#x2F;IP 协议 listen 函数中的 backlog 参数，**用来初始化服务器可连接队列大小**。服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定了队列的大小。</span><br><span class="line">   - &#96;ChannelOption.SO_KEEPALIVE&#96;：一直保持连接活动状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8、EventLoopGroup 和其实现类 NioEventLoopGroup</span><br><span class="line"></span><br><span class="line">1. EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。</span><br><span class="line"></span><br><span class="line">2. EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty &#x3D;&#x3D;服务器端&#x3D;&#x3D;编程中，我们一般都需要提供两个 EventLoopGroup，例如：&#96;BossEventLoopGroup&#96; 和 &#96;WorkerEventLoopGroup&#96;。</span><br><span class="line"></span><br><span class="line">3. 通常一个服务端口，即一个 ServerSocketChannel 对应一个Selector 和一个EventLoop线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</span><br><span class="line"></span><br><span class="line">   - ![image-20210820000928747](Netty&#x2F;image-20210820000928747.png)</span><br><span class="line">   - BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的 Selector 实例，BossEventLoop 不断轮询 Selector 将连接事件分离出来</span><br><span class="line">   - 通常是 &#96;OP_ACCEPT&#96; 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</span><br><span class="line">   - WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理</span><br><span class="line"></span><br><span class="line">4. 常用方法</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     &#x2F;&#x2F; 构造方法</span><br><span class="line">     public NioEventLoopGroup();</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 断开连接，关闭线程</span><br><span class="line">     public Future&lt;?&gt; shutdownGracefully();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="9、Unpooled-类"><a href="#9、Unpooled-类" class="headerlink" title="9、Unpooled 类"></a>9、Unpooled 类</h3><ol>
<li><p>Netty 提供一个<strong>专门用来操作缓冲区(即Netty的数据容器)的工具类</strong></p>
</li>
<li><p>常用方法如下所示</p>
<ul>
<li><pre><code class="java">//通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）
public static ByteBuf copiedBuffer(CharSequence string, Charset charset)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210820003558340](Netty&#x2F;image-20210820003558340.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 创建一个ByteBuf</span><br><span class="line">ByteBuf buffer &#x3D; Unpooled.buffer(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常用方法</span><br><span class="line">&#x2F;&#x2F; 写入</span><br><span class="line">buffer.writeByte(i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取</span><br><span class="line">buffer.readByte();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据下标读取</span><br><span class="line">buffer.getByte(i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取buffer的长度</span><br><span class="line">buffer.capacity()；</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>结合上图与代码对ByteBuf进行讲解：</p>
<ul>
<li>创建一个ByteBuf对象，该对象包含一个数组arr , 是一个byte[10]</li>
<li>在netty 的ByteBuf中，不需要先nio中的ByteBuffer一样，使用flip 进行读写反转<ul>
<li>原因：netty 的ByteBuf在底层维护了两个变量：<code>readerindex</code> 和 <code>writerIndex</code>（双指针模式）。其中<ul>
<li>readerindex：用于记录ByteBuf读时的位置</li>
<li>writerIndex：用于记录ByteBuf写时的位置</li>
</ul>
</li>
<li>netty 的ByteBuf在底层还维护了一个重要的变量：<code>capacity</code>——用来保存ByteBuf的底层byte[]数组的长度</li>
<li>通过这3个变量的合作，完成了netty的ByteBuf的读写相关操作</li>
</ul>
</li>
<li>通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域（从上图可以看出）<ul>
<li>[0,readerindex)：已经读取的区域</li>
<li>[readerindex,writerIndex)：可读的区域</li>
<li>[writerIndex,capacity)：可写的区域</li>
</ul>
</li>
<li>在ByteBuf读取的方法中，有着 getByte(int) 与 readByte()两个方法，两者的区别：<ul>
<li>对于readByte()方法：readerindex会随着readByte()方法的执行而增加</li>
<li>对于getByte(int)方法：readerindex不会随着readByte()方法的执行而增加</li>
</ul>
</li>
<li>对于ByteBuf的写方法：writeByte()——writerIndex会随着writeByte()方法的执行而增加</li>
<li>注意：<ul>
<li>如果使用了ByteBuf的readByte()方法进行读取的时候，由于readerindex会随着readByte()方法的执行而增加，所以在进行第二次读取的时候会发生<strong>数组下标越界异常</strong>，需要我们调用ByteBuf的<code>readerIndex(int readIndex)</code>方法重新设置读取位置。</li>
</ul>
</li>
</ul>
<p>也可以通过以下方法创建一个ByteBuf对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ByteBuf</span></span><br><span class="line">ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>ByteBuf的一些API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看当前的ByteBuf是否有数组支撑</span></span><br><span class="line">byteBuf.hasArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前ByteBuf转成char[]数组</span></span><br><span class="line"><span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 content 转成字符串</span></span><br><span class="line"><span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ByteBuf的偏移量</span></span><br><span class="line">byteBuf.arrayOffset(); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ByteBuf的readerindex</span></span><br><span class="line">byteBuf.readerIndex(); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ByteBuf的writerIndex</span></span><br><span class="line">byteBuf.writerIndex(); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ByteBuf的容量</span></span><br><span class="line">byteBuf.capacity(); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ByteBuf的可读的字节数，根据readerIndex推出来的</span></span><br><span class="line"><span class="comment">// 如果在这之前调用了ByteBuf的readByte()方法，则byteBuf.readableBytes();返回的值为11</span></span><br><span class="line">byteBuf.readableBytes(); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照某个范围读取，其中第一个参数：从哪里开始；第二个参数：读取的长度；第三参数：格式</span></span><br><span class="line">byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：通过这种方式创建出来的bytebuf对象的底层实际上是<code>UnpooledByteBufAllocator</code>的内部类<code>InstrumentedUnpooledUnsafeHeapByteBuf</code>类型。</p>
<p><img src="/2021/08/15/Netty/image-20210820035309447.png" alt="image-20210820035309447"></p>
</blockquote>
<h3 id="10、Netty应用实例-群聊系统"><a href="#10、Netty应用实例-群聊系统" class="headerlink" title="10、Netty应用实例-群聊系统"></a>10、Netty应用实例-群聊系统</h3><p>实例要求：</p>
<ol>
<li>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</li>
<li>目的：进一步理解Netty非阻塞网络编程机制</li>
<li>效果：<ul>
<li><img src="/2021/08/15/Netty/image-20210820001615735.png" alt="image-20210820001615735"></li>
</ul>
</li>
</ol>
<p>代码：</p>
<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写run方法，处理客户端的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                    .group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7777</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端的handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channle 组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line"><span class="comment">     * 将当前channel 加入到  channelGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span></span><br><span class="line"><span class="comment">        我们不需要自己遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;[客户端 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天&quot;</span> + <span class="string">&quot; \n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接, 将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;[客户端 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了&quot;</span> + <span class="string">&quot; \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于活动状态, 提示 xx上线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;[客户端 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于不活动状态, 提示 xx离线了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;[客户端 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != channel) &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户端 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 发送了消息&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;[自己 &quot;</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;]&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-------&quot;</span> + channel.localAddress()+ <span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">                String msg = <span class="keyword">null</span>;</span><br><span class="line">                msg = sc.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//channelFuture.channel().closeFuture().sync();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awo.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sync()是因为：本身bootstrap里的任务如：监听器等等是异步的。所以适用此方法等待异步方法处理完毕再完成启动</p>
</blockquote>
<h3 id="11、Netty心跳检测机制案例"><a href="#11、Netty心跳检测机制案例" class="headerlink" title="11、Netty心跳检测机制案例"></a>11、Netty心跳检测机制案例</h3><p><strong>实例要求</strong>: </p>
<ol>
<li>编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲</li>
<li>当服务器超过5秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li>
</ol>
<p>代码：</p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">7000</span>,<span class="number">7000</span>,<span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;--超时时间--&quot;</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器做相应处理..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上代码的几点说明：</p>
<ul>
<li><p>**handler(new LoggingHandler(LogLevel.INFO));**：这代码的作用是在bossGroup开启日志处理</p>
</li>
<li><p><code>IdleStateHandler</code>类的相关说明：</p>
<ul>
<li><p>IdleStateHandler 是netty 提供的处理空闲状态的处理器</p>
</li>
<li><p>文档说明：==triggers an {@link IdleStateEvent} when a {@link Channel} has not performed read, write, or both operation for a while.==</p>
</li>
<li><pre><code class="java">public class IdleStateHandler extends ChannelDuplexHandler &#123;

    public IdleStateHandler(long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit) &#123;
        this(false, readerIdleTime, writerIdleTime, allIdleTime, unit);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - IdleStateHandler继承了ChannelDuplexHandler，说明了它既能处理入站事件，也能处理出站事件</span><br><span class="line"></span><br><span class="line">  - IdleStateHandler的构造方法的参数说明：</span><br><span class="line"></span><br><span class="line">    1. **long readerIdleTime**：表示多长时间没有读，就会发送一个心跳检测包检测是否连接</span><br><span class="line">    2. **long writerIdleTime**：表示多长时间没有写，就会发送一个心跳检测包检测是否连接</span><br><span class="line">    3. **long allIdleTime**：表示多长时间没有读写，就会发送一个心跳检测包检测是否连接</span><br><span class="line">    4. **TimeUnit unit**：时间单位</span><br><span class="line"></span><br><span class="line">  - 当 IdleStateEvent 触发后，就会传递给管道 的下一个handler去处理</span><br><span class="line">     *                  通过调用(触发)下一个handler 的 &#96;userEventTiggered&#96;方法，在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12、Netty 通过WebSocket编程实现服务器和客户端长连接</span><br><span class="line"></span><br><span class="line">实例要求：</span><br><span class="line"></span><br><span class="line">1. Http协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</span><br><span class="line">2. 要求：实现基于webSocket的长连接的全双工的交互</span><br><span class="line">3. 改变Http协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</span><br><span class="line">4. 客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</span><br><span class="line">5. 效果：</span><br><span class="line">   - ![image-20210820001859808](Netty&#x2F;image-20210820001859808.png)</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">服务器端：（ChannelInitializer&lt;SocketChannel&gt;当中的内容，其他与上面类似）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipeline &#x3D; ch.pipeline();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;因为基于http协议，使用http的编码和解码器</span><br><span class="line">        pipeline.addLast(new HttpServerCodec());</span><br><span class="line">        &#x2F;&#x2F;是以块方式写，添加ChunkedWriteHandler处理器</span><br><span class="line">        pipeline.addLast(new ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         说明</span><br><span class="line">            1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span><br><span class="line">            2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求        </span><br><span class="line">        *&#x2F;</span><br><span class="line">        pipeline.addLast(new HttpObjectAggregator(8192));</span><br><span class="line">        &#x2F;*</span><br><span class="line">          说明</span><br><span class="line">           1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span><br><span class="line">           2. 可以看到WebSocketFrame 下面有六个子类</span><br><span class="line">           3. 浏览器请求时 ws:&#x2F;&#x2F;localhost:7000&#x2F;hello 表示请求的uri</span><br><span class="line">           4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span><br><span class="line">        *&#x2F;</span><br><span class="line">        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;&#x2F;hello2&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;自定义的handler ，处理业务逻辑</span><br><span class="line">        pipeline.addLast(new MyTextWebSocketFrameHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>服务器端的Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对以上代码的几点说明：</p>
<ul>
<li>由于建立的是webSocket长连接，http为短连接，需要将http协议升级为ws协议</li>
<li>对于http：<ul>
<li>http数据在传输过程中是分段传输，所以需要添加<code>HttpObjectAggregator</code> ，可以将多个段的数据进行聚合</li>
<li>这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</li>
</ul>
</li>
<li>对于webSocket：<ul>
<li>webSocket的数据是以 帧(frame) 形式传递，所以在进行数据处理的时候都是以帧为单位进行处理的</li>
<li>对于ws协议：<ul>
<li>浏览器请求时 ws://localhost:7000/xxx：表示请求的uri</li>
<li>http协议升级为ws协议的方法：是通过一个 状态码 <code>101</code><ul>
<li><img src="/2021/08/15/Netty/image-20210821000047461.png" alt="image-20210821000047461"></li>
</ul>
</li>
</ul>
</li>
<li>netty与ws协议的一些方法：<ul>
<li>webSocket数据对应类：<code>WebSocketFrame</code>，其下有六个子类，分别应用在不同的场景<ul>
<li><img src="/2021/08/15/Netty/image-20210820233534694.png" alt="image-20210820233534694"></li>
</ul>
</li>
<li><code>WebSocketServerProtocolHandler</code>：核心功能是将 http协议升级为 ws协议，保持长连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8、Google-Protobuf"><a href="#8、Google-Protobuf" class="headerlink" title="8、Google Protobuf"></a>8、<strong>Google</strong> <strong>Protobuf</strong></h2><h3 id="1、编码和解码的基本介绍"><a href="#1、编码和解码的基本介绍" class="headerlink" title="1、编码和解码的基本介绍"></a>1、编码和解码的基本介绍</h3><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码<ul>
<li><img src="/2021/08/15/Netty/image-20210821000350763.png" alt="image-20210821000350763"></li>
</ul>
</li>
<li>codec(编解码器) 的组成部分有两个：<code>decoder(解码器)</code>和 <code>encoder(编码器)</code>。<ul>
<li>encoder：负责把业务数据转换成字节码数据</li>
<li>decoder：负责把字节码数据转换成业务数据</li>
</ul>
</li>
</ol>
<h3 id="2、Netty-本身的编码解码的机制和问题分析"><a href="#2、Netty-本身的编码解码的机制和问题分析" class="headerlink" title="2、Netty 本身的编码解码的机制和问题分析"></a>2、Netty 本身的编码解码的机制和问题分析</h3><ol>
<li>Netty 自身提供了一些 codec(编解码器)</li>
<li>Netty 提供的编码器encoder<ul>
<li>StringEncoder：对字符串数据进行编码</li>
<li>ObjectEncoder：对 Java 对象进行编码</li>
<li>……</li>
</ul>
</li>
<li>Netty 提供的解码器decoder<ul>
<li>StringDecoder：对字符串数据进行解码</li>
<li>ObjectDecoder：对 Java 对象进行解码</li>
<li>……</li>
</ul>
</li>
<li>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，<strong>底层使用的仍是 Java 序列化技术</strong>，而Java 序列化技术本身效率就不高，存在如下问题：<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的 5 倍多。</li>
<li>序列化性能太低</li>
<li>=&gt; 引出 新的解决方案 [<strong>Google 的 Protobuf</strong>]</li>
</ul>
</li>
</ol>
<h3 id="3、Protobuf"><a href="#3、Protobuf" class="headerlink" title="3、Protobuf"></a>3、Protobuf</h3><h4 id="1、Protobuf基本介绍和使用示意图"><a href="#1、Protobuf基本介绍和使用示意图" class="headerlink" title="1、Protobuf基本介绍和使用示意图"></a>1、Protobuf基本介绍和使用示意图</h4><ol>
<li>Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做<strong>数据存储或 RPC[远程过程调用 remote procedure call ] 数据交换格式 。</strong><br> 目前很多公司将<code>http+json</code> 替换成 <code>tcp+protobuf</code></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto">参考文档</a> ：语言指南</li>
<li>Protobuf 是以 <code>message</code> 的方式来管理数据的</li>
<li>支持<strong>跨平台</strong>、<strong>跨语言</strong>，即[客户端和服务器端可以是不同的语言编写的] （<strong>支持目前绝大多数语言</strong>，例如 C++、C#、Java、python 等）</li>
<li>高性能，高可靠性</li>
<li><strong>使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描述</strong>。<ul>
<li>说明，在idea 中编写 .proto 文件时，会自动提示<strong>是否下载 .ptotot 编写插件</strong>. 可以让<strong>语法高亮</strong>。</li>
</ul>
</li>
<li>然后<strong>通过 protoc.exe 编译器根据.proto 自动生成.java 文件</strong></li>
<li>protobuf 使用示意图:<ul>
<li><img src="/2021/08/15/Netty/image-20210821023654601.png" alt="image-20210821023654601"></li>
</ul>
</li>
</ol>
<h4 id="2、Netty中Protobuf的使用流程"><a href="#2、Netty中Protobuf的使用流程" class="headerlink" title="2、Netty中Protobuf的使用流程"></a>2、Netty中Protobuf的使用流程</h4><ol>
<li><p>在Maven 项目中引入 Protobuf 坐标，下载相关的jar包</p>
<ul>
<li><pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;
        &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;
        &lt;version&gt;3.6.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在IDEA创建.proto文件，进行.proto文件的编写（以Student.proto为例）</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;protobuf</span><br><span class="line">     syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F;版本</span><br><span class="line">     option java_outer_classname &#x3D; &quot;StudentPOJO&quot;;&#x2F;&#x2F;生成的外部类名，同时也是文件名</span><br><span class="line">     &#x2F;&#x2F;protobuf 使用message 管理数据</span><br><span class="line">     message Student &#123; &#x2F;&#x2F;会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span><br><span class="line">     	int32 id &#x3D; 1; &#x2F;&#x2F; Student 类中有一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span><br><span class="line">     	string name &#x3D; 2;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>利用protoc.exe 编译器对刚刚编写好的.proto文件进行编译，生成一个java文件</p>
<ul>
<li><p>执行指令(cmd)</p>
<ul>
<li><pre><code class="sh">protoc.exe --java_out=. Student.proto
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - idea里面也可以下载相应的maven插件进行编译：有工具mave  protobuf-java-util</span><br><span class="line"></span><br><span class="line">4. 之后会生成一个Student.java文件</span><br><span class="line"></span><br><span class="line">   - 这里主要是看两点：</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     &#x2F;&#x2F; DO NOT EDIT!</span><br><span class="line">     public  static final class Student extends com.google.protobuf.GeneratedMessageV3 implements &#x2F;&#x2F; 说明真正的PoJo 类是Student</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>把生成的 StudentPoJo.java 拷贝到自己的项目中打开</p>
</li>
<li><p>在项目的服务端<code>ChannelInitializer&lt;SocketChannel&gt;</code>中的<code>initChannel</code>方法里面添加解码的handler（服务端&lt;—&gt;解码），在解码的handler中添加<code>StudentPOJO.Student.getDefaultInstance()</code></p>
<ul>
<li><pre><code class="java">serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个通道初始化对象(匿名对象)
    //给pipeline 设置处理器
    @Override
    protected void initChannel(SocketChannel ch) throws Exception &#123;
        ChannelPipeline pipeline = ch.pipeline();
        //在pipeline加入ProtoBufDecoder
        //指定对哪种对象进行解码
        pipeline.addLast(&quot;decoder&quot;, new ProtobufDecoder(StudentPOJO.Student.getDefaultInstance()));
        pipeline.addLast(new NettyServerHandler());
    &#125;
&#125;); // 给我们的workerGroup 的 EventLoop 对应的管道设置处理器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 在项目的客户端&#96;ChannelInitializer&lt;SocketChannel&gt;&#96;中的&#96;initChannel&#96;方法里面添加编码的handler（客户端&lt;---&gt;编码）</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">             ChannelPipeline pipeline &#x3D; ch.pipeline();</span><br><span class="line">             &#x2F;&#x2F;在pipeline中加入 ProtoBufEncoder</span><br><span class="line">             pipeline.addLast(&quot;encoder&quot;, new ProtobufEncoder());</span><br><span class="line">             pipeline.addLast(new NettyClientHandler()); &#x2F;&#x2F;加入自己的处理器</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>在服务端的自定义handler中可以选择继承<code>SimpleChannelInboundHandler</code>并设置泛型<code>StudentPOJO.Student</code>，这样一来重写的<code>channelRead0</code>方法的第二个参数就变成了<code>StudentPOJO.Student msg</code>（而不是Object，还需要我们去判断Object类型向下转型），我可以通过该msg获取Student的相关信息</p>
</li>
<li><p>而在客户端就需要我们去生成一个StudentPOJO.Student，往StudentPOJO.Student设置一些信息：</p>
<ul>
<li><pre><code class="java">StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(4).setName(&quot;智多星 吴用&quot;).build();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3、使用Protobuf的几点说明</span><br><span class="line"></span><br><span class="line">1. Protobuf是以&#96;message&#96;的方式来管理数据的</span><br><span class="line"></span><br><span class="line">2. 在.proto文件的编写中使用message声明的变量，在之后生成java文件后会成为java文件的内部类，也是真正存储PoJo 类信息的地方，使用option java_outer_classname方式生成的类对象其实是java的外部类，包裹着存储PoJo 类信息的内部类</span><br><span class="line"></span><br><span class="line">3. java PoJo 类的属性数据类型 与 Protobuf文件中的属性数据类型的对比：</span><br><span class="line"></span><br><span class="line">   ![image-20210821025959285](Netty&#x2F;image-20210821025959285.png)</span><br><span class="line"></span><br><span class="line">4. 在Protobuf文件中 &#96;int32 id &#x3D; 1&#96;中的&#96;1&#96;并不是属性的值，而是该属性在Protobuf文件的属性序号，即该属性是Protobuf文件的第几个属性（**从1开始**）</span><br><span class="line"></span><br><span class="line">5. 通过以上的项目的服务端与客户端可以发现一个问题：项目的handler与PoJo的耦合很高。基本上一个handler只能为一个PoJo服务</span><br><span class="line"></span><br><span class="line">6. 解决方法：**Protobuf可以使用 message 管理其他的message**</span><br><span class="line"></span><br><span class="line">7. Protobuf文件中可以使用一个总的message作为大包裹，里面包含了各式各样的PoJo信息——使用枚举的方式（注意：**在proto3 要求enum的编号从0开始**）</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;protobuf</span><br><span class="line">     syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">     option optimize_for &#x3D; SPEED; &#x2F;&#x2F; 加快解析</span><br><span class="line">     option java_package&#x3D;&quot;com.atguigu.netty.codec2&quot;;   &#x2F;&#x2F;指定生成到哪个包下</span><br><span class="line">     option java_outer_classname&#x3D;&quot;MyDataInfo&quot;; &#x2F;&#x2F; 外部类名, 文件名</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F;protobuf 可以使用message 管理其他的message</span><br><span class="line">     message MyMessage &#123;</span><br><span class="line">     </span><br><span class="line">         &#x2F;&#x2F;定义一个枚举类型</span><br><span class="line">         enum DataType &#123;</span><br><span class="line">             StudentType &#x3D; 0; &#x2F;&#x2F;在proto3 要求enum的编号从0开始</span><br><span class="line">             WorkerType &#x3D; 1;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         &#x2F;&#x2F;用data_type 来标识传的是哪一个枚举类型</span><br><span class="line">         DataType data_type &#x3D; 1;</span><br><span class="line">     </span><br><span class="line">         &#x2F;&#x2F;表示每次枚举类型最多只能出现其中的一个, 节省空间</span><br><span class="line">         oneof dataBody &#123;</span><br><span class="line">             Student student &#x3D; 2;</span><br><span class="line">             Worker worker &#x3D; 3;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     message Student &#123;</span><br><span class="line">         int32 id &#x3D; 1;&#x2F;&#x2F;Student类的属性</span><br><span class="line">         string name &#x3D; 2; &#x2F;&#x2F;</span><br><span class="line">     &#125;</span><br><span class="line">     message Worker &#123;</span><br><span class="line">         string name&#x3D;1;</span><br><span class="line">         int32 age&#x3D;2;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>这样的话，在服务端的<code>ChannelInitializer&lt;SocketChannel&gt;</code>中的<code>initChannel</code>方法的里面<code>ProtobufDecoder</code>的里面就不能写某个PoJo的getDefaultInstance()，而是得写整个大包裹的getDefaultInstance()</p>
<ul>
<li><pre><code class="java">pipeline.addLast(&quot;decoder&quot;, new ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. 各种PoJo的信息的设置与获取在各自的handler中</span><br><span class="line"></span><br><span class="line">   - 设置（客户端）</span><br><span class="line"></span><br><span class="line">     - &#96;&#96;&#96;java</span><br><span class="line">       MyDataInfo.MyMessage myMessage &#x3D; null;</span><br><span class="line">       myMessage &#x3D; MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(5).setName(&quot;玉麒麟 卢俊义&quot;).build()).build();</span><br><span class="line">       </span><br><span class="line">       myMessage &#x3D; MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setAge(20).setName(&quot;老李&quot;).build()).build();</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>获取（服务端）（继承的SimpleChannelInboundHandler的泛型要修改成大包裹：<code>MyDataInfo.MyMessage</code>）</p>
<ul>
<li><pre><code class="java">//根据dataType 来显示不同的信息
MyDataInfo.MyMessage.DataType dataType = msg.getDataType();
if(dataType == MyDataInfo.MyMessage.DataType.StudentType) &#123;
    MyDataInfo.Student student = msg.getStudent();
    System.out.println(&quot;学生id=&quot; + student.getId() + &quot; 学生名字=&quot; + student.getName());

&#125; else if(dataType == MyDataInfo.MyMessage.DataType.WorkerType) &#123;
    MyDataInfo.Worker worker = msg.getWorker();
    System.out.println(&quot;工人的名字=&quot; + worker.getName() + &quot; 年龄=&quot; + worker.getAge());
&#125; else &#123;
    System.out.println(&quot;传输的类型不正确&quot;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 9、Netty编解码器和handler的调用机制</span><br><span class="line"></span><br><span class="line">### 1、基本说明</span><br><span class="line"></span><br><span class="line">1. netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe等</span><br><span class="line">2. **ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器**。例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的。</span><br><span class="line">3. **ChannelPipeline提供了ChannelHandler链的容器**。**以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理**，反之则称为入站的</span><br><span class="line"></span><br><span class="line">![image-20210821034142241](Netty&#x2F;image-20210821034142241.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2、编码解码器</span><br><span class="line"></span><br><span class="line">1. **当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。&#x3D;&#x3D;入站消息会被解码&#x3D;&#x3D;：从字节转换为另一种格式（比如java对象）；如果是&#x3D;&#x3D;出站消息，它会被编码成字节&#x3D;&#x3D;**。</span><br><span class="line">2. **Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了**。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3、解码器——ByteToMessageDecoder（服务器端，入站）</span><br><span class="line"></span><br><span class="line">1. 关系继承图</span><br><span class="line"></span><br><span class="line">   - ![image-20210821034417112](Netty&#x2F;image-20210821034417112.png)</span><br><span class="line"></span><br><span class="line">2. **由于不可能知道远程节点是否会一次性发送一个完整的信息，&#x3D;&#x3D;tcp有可能出现粘包拆包的问题&#x3D;&#x3D;**，这个类会对入站数据进行缓冲，直到它准备好被处理。</span><br><span class="line"></span><br><span class="line">3. 一个关于ByteToMessageDecoder实例分析</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     public class ToIntegerDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line">         &#x2F;&#x2F; 读取一个int类型</span><br><span class="line">         @Override</span><br><span class="line">         protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">             if (in.readableBytes() &gt;&#x3D; 4) &#123;</span><br><span class="line">                 out.add(in.readInt());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>这个例子，<strong>每次入站从ByteBuf中读取4字节，将其解码为一个int，然后将它添加到下一个List中。当没有更多元素可以被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。int在被添加到List中时，会被自动装箱为Integer</strong>。</li>
<li>在调用readInt()方法前必须验证所输入的ByteBuf是否具有足够的数据。</li>
<li>关于if还是while的问题，”decode”方法确实会被循环调用，只要还有可读就会一直循环，除非”decode”没有再读出数据，则会退出循环。</li>
<li>所以如果把”if”改成”while”也是可以的没有区别，相当于自己先把buf处理完了，外层循环就不会再调用了</li>
<li>decode 会根据接收的数据，被调用多次，直到确定没有新的元素被添加到list，或者是ByteBuf 没有更多的可读字节为止</li>
<li>如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理，该channelinboundhandler的方法也会被调用多次（不管是if还是while，因为循环调用的依据是list的内容）</li>
</ul>
<p><img src="/2021/08/15/Netty/image-20210821035333607.png" alt="image-20210821035333607"></p>
</li>
</ul>
</li>
</ol>
<h4 id="Netty的handler链的调用机制"><a href="#Netty的handler链的调用机制" class="headerlink" title="Netty的handler链的调用机制"></a>Netty的handler链的调用机制</h4><p>实例要求：使用自定义的编码器和解码器来说明Netty的handler 调用机制</p>
<ul>
<li>客户端发送long -&gt; 服务器</li>
<li>服务端发送long -&gt; 客户端</li>
</ul>
<p>思路：</p>
<p><img src="/2021/08/15/Netty/image-20210821050856155.png" alt="image-20210821050856155"></p>
<p>注意：</p>
<ul>
<li>ctx.write 会去调用outbound的方法</li>
<li>outbound一定要放到最后一个inbound之前，保证inbound在write的时候，可以往前找到outbound</li>
</ul>
<p>代码：</p>
<p>自定义编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//编码方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyLongToByteEncoder encode 被调用&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;msg=&quot;</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义解码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理, 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端的处理器的初始化：MyServerInitializer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();<span class="comment">//一会下断点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码 MyByteToLongDecoder</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//出站的handler进行编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//自定义的handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">        System.out.println(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端的自定义处理器：MyServerHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot; 读取到long &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端发送一个long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的处理器的初始化：MyClientInitializer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个出站的handler 对数据进行一个编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时一个入站的解码器(入站handler )</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//加入一个自定义的handler ， 处理业务</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的自定义处理器：MyServerHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的ip=&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器消息=&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler 发送数据&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(<span class="number">123456L</span>); <span class="comment">//发送的是一个long</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1. &quot;abcdabcdabcdabcd&quot; 是 16个字节</span></span><br><span class="line">        <span class="comment">//2. 该处理器的前一个handler 是  MyLongToByteEncoder</span></span><br><span class="line">        <span class="comment">//3. MyLongToByteEncoder 父类  MessageToByteEncoder</span></span><br><span class="line">        <span class="comment">//4. 父类  MessageToByteEncoder</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        ByteBuf buf = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (acceptOutboundMessage(msg)) &#123; //判断当前msg 是不是应该处理的类型，如果是就处理，不是就跳过encode</span></span><br><span class="line"><span class="comment">                @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">                I cast = (I) msg;</span></span><br><span class="line"><span class="comment">                buf = allocateBuffer(ctx, cast, preferDirect);</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    encode(ctx, cast, buf);</span></span><br><span class="line"><span class="comment">                &#125; finally &#123;</span></span><br><span class="line"><span class="comment">                    ReferenceCountUtil.release(cast);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                if (buf.isReadable()) &#123;</span></span><br><span class="line"><span class="comment">                    ctx.write(buf, promise);</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    buf.release();</span></span><br><span class="line"><span class="comment">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                buf = null;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                ctx.write(msg, promise);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        4. 因此我们编写 Encoder 是要注意传入的数据类型和处理的数据类型一致</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;abcdabcdabcdabcd&quot;,CharsetUtil.UTF_8));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p><img src="/2021/08/15/Netty/image-20210821035744141.png" alt="image-20210821035744141"></p>
<p>结论：</p>
<ul>
<li><p><strong>不论解码器handler 还是 编码器handler 即接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</strong></p>
<ul>
<li><p>底层调用了父类  MessageToByteEncoder的write方法，源码：</p>
</li>
<li><pre><code class="java">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
    ByteBuf buf = null;
    try &#123;
        //判断当前msg 是不是应该处理的类型，如果是就处理，不是就跳过encode
        if (acceptOutboundMessage(msg)) &#123; 
            @SuppressWarnings(&quot;unchecked&quot;)
            I cast = (I) msg;
            buf = allocateBuffer(ctx, cast, preferDirect);
            try &#123;
                encode(ctx, cast, buf);
            &#125; finally &#123;
                ReferenceCountUtil.release(cast);
            &#125;

            if (buf.isReadable()) &#123;
                ctx.write(buf, promise);
            &#125; else &#123;
                buf.release();
                ctx.write(Unpooled.EMPTY_BUFFER, promise);
            &#125;
            buf = null;
        &#125; else &#123;
            ctx.write(msg, promise);
        &#125;
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **在解码器 进行数据解码时，需要判断 缓存区(ByteBuf)的数据是否足够 ，否则接收到的结果会期望结果可能不一致**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4、解码器——ReplayingDecoder（客户端，出站）</span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;java</span><br><span class="line">   public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>ReplayingDecoder扩展了ByteToMessageDecoder类，使用这个类，我们不必调用readableBytes()方法。<strong>参数S指定了用户状态管理的类型，其中<code>Void</code>代表不需要状态管理</strong></p>
</li>
<li><p>ReplayingDecoder使用方便，但它也有一些局限性：</p>
<ul>
<li><strong>并不是所有的 ByteBuf 操作都被支持</strong>，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li>
<li><strong>ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</strong></li>
</ul>
</li>
</ol>
<h3 id="5、其它编解码器"><a href="#5、其它编解码器" class="headerlink" title="5、其它编解码器"></a>5、其它编解码器</h3><ul>
<li>其它解码器：<ol>
<li><code>LineBasedFrameDecoder</code>：这个类在Netty内部也有使用，它<strong>使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据</strong>。</li>
<li><code>DelimiterBasedFrameDecoder</code>：<strong>使用自定义的特殊字符作为消息的分隔符</strong>。</li>
<li><code>HttpObjectDecoder</code>：一个<strong>HTTP数据的解码器</strong></li>
<li><code>LengthFieldBasedFrameDecoder</code>：<strong>通过指定长度来标识整包消息，这样就可以自动的处理==黏包==和==半包==消息</strong>。</li>
<li><img src="/2021/08/15/Netty/image-20210821053430472.png" alt="image-20210821053430472"></li>
<li><img src="/2021/08/15/Netty/image-20210821053547439.png" alt="image-20210821053547439"></li>
</ol>
</li>
<li>其它编码器：<ol>
<li><img src="/2021/08/15/Netty/image-20210821053839116.png" alt="image-20210821053839116"></li>
<li><img src="/2021/08/15/Netty/image-20210821053849720.png" alt="image-20210821053849720"></li>
</ol>
</li>
<li>例子：如果客户端传输大量数据到服务端的时候，为了节省时间与开销。可以在客户端使用<code>ZlibEncoder</code>对数据进行压缩编码，然后在服务端使用<code>ZlibDecoder</code>进行压缩阶码就能得到数据。这些操作Netty都帮助我们完成了，我们只需要在将Initializer对象的initChennel方法中将对应的编解码器加入pipeline当中</li>
</ul>
<h3 id="6、Log4j-整合到Netty"><a href="#6、Log4j-整合到Netty" class="headerlink" title="6、Log4j 整合到Netty"></a>6、Log4j 整合到Netty</h3><ol>
<li><p>在Maven 中添加对Log4j的依赖 在 pom.xml</p>
<ul>
<li><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 配置 Log4j，在 resources&#x2F;log4j.properties</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;properties</span><br><span class="line">     log4j.rootLogger&#x3D;DEBUG, stdout</span><br><span class="line">     log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">     log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">     log4j.appender.stdout.layout.ConversionPattern&#x3D;[%p] %C&#123;1&#125; - %m%n</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>演示：</p>
<ul>
<li><img src="/2021/08/15/Netty/image-20210821054850668.png" alt="image-20210821054850668"></li>
</ul>
</li>
</ol>
<hr>
<h2 id="10、TCP-粘包和拆包-及解决方案"><a href="#10、TCP-粘包和拆包-及解决方案" class="headerlink" title="10、TCP 粘包和拆包 及解决方案"></a>10、TCP 粘包和拆包 及解决方案</h2><h3 id="1、TCP-粘包和拆包基本介绍"><a href="#1、TCP-粘包和拆包基本介绍" class="headerlink" title="1、TCP 粘包和拆包基本介绍"></a>1、TCP 粘包和拆包基本介绍</h3><ol>
<li><strong>TCP是面向连接的，面向流的，提供高可靠性服务</strong>。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（==Nagle算法==），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为<strong>面向流的通信是无消息保护边界</strong>的</li>
<li><strong>由于TCP无消息保护边界，需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题</strong>，看一张图：<ul>
<li><img src="/2021/08/15/Netty/image-20210821155622581.png" alt="image-20210821155622581"></li>
</ul>
</li>
<li>客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为==TCP粘包==</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为==TCP拆包==</li>
<li>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</li>
</ol>
</li>
</ol>
<h3 id="2、TCP-粘包和拆包解决方案"><a href="#2、TCP-粘包和拆包解决方案" class="headerlink" title="2、TCP 粘包和拆包解决方案"></a>2、TCP 粘包和拆包解决方案</h3><ol>
<li>使用自定义协议 + 编解码器 来解决</li>
<li>关键就是要解决 <strong>服务器端每次读取数据长度的问题</strong>，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</li>
</ol>
<p>看一个具体的实例：</p>
<ol>
<li>要求客户端发送 5 个 Message 对象，客户端每次发送一个 Message 对象</li>
<li>服务器端每次接收一个Message，分5次进行解码， 每读取到 一个Message，会回复一个Message 对象 给客户端。</li>
</ol>
<p><img src="/2021/08/15/Netty/image-20210821155936176.png" alt="image-20210821155936176"></p>
<p>代码：</p>
<p>由于我们是自定义协议，需要我们编写一个协议包类，规定每次发送的协议包的内容和大小（重要）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们是自定义协议，需要我们自定义编解码器，将我们自定义的协议包进行编解码</p>
<p>编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageDecoder decode 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line">		<span class="comment">// 将协议包放入list当中</span></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理业务的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到数据，并处理</span></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到信息如下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span> + len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        String responseContent = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> responseLen = responseContent.getBytes(<span class="string">&quot;utf-8&quot;</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[]  responseContent2 = responseContent.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//构建一个协议包</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(responseLen);</span><br><span class="line">        messageProtocol.setContent(responseContent2);</span><br><span class="line">        ctx.writeAndFlush(messageProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">//加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">//加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String mes = <span class="string">&quot;今天天气冷，吃火锅&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="keyword">int</span> length = mes.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>)).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建协议包对象</span></span><br><span class="line">            MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">            messageProtocol.setLen(length);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息如下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span> + len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常消息=&quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>客户端：</p>
<p><img src="/2021/08/15/Netty/image-20210821160639783.png" alt="image-20210821160639783"></p>
<p>服务端：</p>
<p><img src="/2021/08/15/Netty/image-20210821160731328.png" alt="image-20210821160731328"></p>
<p>调用流程说明：</p>
<ol>
<li>客户端发送5条数据到服务端（编码5次）</li>
<li>服务端调用解码器将客户端发送过来的数据进行解码，收到信息后，发送一个协议包给客户端（编码1次），由于客户端发送了5条数据，所以这个过程会执行5次</li>
<li>客户端接收到服务端发送过来的协议包，调用解码器进行解码，接收数据。由于服务端会回发5次数据，所以客户端也会接收到5次数据，每一次接收都要调用一次解码器进行数据解码</li>
<li>由于数据都是通过自定义的协议包进行传输的，协议包中规定了每一次传输的数据的长度，所以不会出现TCP的粘包拆包问题。</li>
</ol>
<hr>
<h2 id="11、Netty-核心源码剖析"><a href="#11、Netty-核心源码剖析" class="headerlink" title="11、Netty 核心源码剖析"></a>11、Netty 核心源码剖析</h2><h3 id="1、Netty-启动过程源码剖析"><a href="#1、Netty-启动过程源码剖析" class="headerlink" title="1、Netty 启动过程源码剖析"></a>1、Netty 启动过程源码剖析</h3><p>说明：</p>
<ol>
<li>源码需要剖析到Netty 调用doBind方法， 追踪到 NioServerSocketChannel的doBind</li>
<li>并且要Debug 程序到 NioEventLoop类 的<strong>run代码 ，无限循环</strong>，在服务器端运行。</li>
</ol>
<p><img src="/2021/08/15/Netty/image-20210823041445976.png" alt="image-20210823041445976"></p>
<p>Netty启动过程梳理：</p>
<ol>
<li>创建2个 EventLoopGroup 线程池数组。数组默认大小CPU*2，方便chooser选择线程池时提高性能</li>
<li>BootStrap 将 boss 设置为 group属性，将 worker 设置为 childer 属性</li>
<li>通过 bind 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li>
<li><strong>initAndRegister 方法会反射创建 NioServerSocketChannel 及其相关的 NIO 的对象， pipeline ， unsafe，同时也为 pipeline 初始了 head 节点和 tail 节点。</strong></li>
<li>在<code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，<strong>该方法会 调用 NioServerSocketChannel 的 doBind 方法对 JDK 的 channel 和端口进行绑定，完成 Netty 服务器的所有启动，并开始监听连接事件</strong></li>
</ol>
<h3 id="2、Netty-接受请求过程源码剖析"><a href="#2、Netty-接受请求过程源码剖析" class="headerlink" title="2、Netty 接受请求过程源码剖析"></a>2、Netty 接受请求过程源码剖析</h3><p>说明：</p>
<ol>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 Accept 事件等待客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线程池（reactor 线程）上，也就是 EventLoop 。</li>
<li>先简单说下EventLoop的逻辑(后面我们详细讲解EventLoop)<ul>
<li>EventLoop 的作用是一个死循环，而这个循环中做3件事情：<ol>
<li>有条件的等待 Nio 事件。</li>
<li>处理 Nio 事件。</li>
<li>处理消息队列中的任务。</li>
</ol>
</li>
</ul>
</li>
<li><strong>仍用前面的项目来分析</strong>：进入到 NioEventLoop 源码中后，在<code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试</li>
<li>最终我们要分析到AbstractNioChannel 的 <code>doBeginRead</code> 方法， 当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<p>Netty接受请求过程梳理：</p>
<p><strong>总体流程</strong>：</p>
<p>接受连接 —–&gt; 创建一个新的NioSocketChannel ———–&gt; 注册到一个 worker EventLoop 上 ——–&gt; 注册selecot Read 事件。</p>
<ol>
<li>服务器轮询 Accept 事件，获取事件后调用 unsafe 的 read 方法，这个 unsafe 是 ServerSocket 的内部类，该方法内部由2部分组成</li>
<li><strong>doReadMessages 用于创建 NioSocketChannel 对象，该对象包装 JDK 的 Nio Channel 客户端。该方法会像创建 ServerSocketChanel 类似创建相关的 pipeline ， unsafe，config</strong></li>
<li><strong>随后执行 pipeline.fireChannelRead 方法，并将自己绑定到一个 chooser 选择器选择的 workerGroup 中的一个 EventLoop。并且注册一个0，表示注册成功，但并没有注册读（1）事件</strong></li>
</ol>
<h3 id="3、Pipeline-Handler-HandlerContext创建源码剖析"><a href="#3、Pipeline-Handler-HandlerContext创建源码剖析" class="headerlink" title="3、Pipeline Handler HandlerContext创建源码剖析"></a>3、Pipeline Handler HandlerContext创建源码剖析</h3><ol>
<li>每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成<strong>最初的链表</strong>。</li>
<li>在调用 pipeline 的 addLast 方法的时候，会根据给定的 handler 创建一个 Context，<strong>然后将这个 Context 插入到链表的尾端（tail 前面）</strong>。</li>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表</li>
<li><strong>入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始</strong></li>
</ol>
<h3 id="4、ChannelPipeline-调度-handler-的源码剖析"><a href="#4、ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="4、ChannelPipeline 调度 handler 的源码剖析"></a>4、ChannelPipeline 调度 handler 的源码剖析</h3><ol>
<li>当一个请求进来的时候，ChannelPipeline 是如何调用内部的这些 handler 的呢？</li>
<li>首先，当一个请求进来的时候，会第一个调用 pipeline 的 相关方法，如果是入站事件，这些方法由 fire 开头，表示开始管道的流动。让后面的 handler 继续处理</li>
</ol>
<p><img src="/2021/08/15/Netty/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></p>
<p>ChannelPipeline 调度 handler 梳理：</p>
<ol>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始。</li>
<li>而节点中间的传递通过 AbstractChannelHandlerContext 类内部的 fire 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对handler 的调度</li>
</ol>
<h3 id="5、Netty-心跳-heartbeat-服务源码剖析"><a href="#5、Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="5、Netty 心跳(heartbeat)服务源码剖析"></a>5、Netty 心跳(heartbeat)服务源码剖析</h3><p>Netty 作为一个网络框架，提供了诸多功能，比如编码解码等，Netty 还提供了非常重要的一个服务——心跳机制heartbeat。通过心跳检查对方是否有效，这是 RPC 框架中是必不可少的功能。</p>
<p>说明：</p>
<ol>
<li>Netty 提供了 <code>IdleStateHandler</code> ，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个<strong>Handler</strong> 检测连接的有效性，重点分析 <strong>IdleStateHandler</strong> 。</li>
<li><img src="/2021/08/15/Netty/image-20210823042900872.png" alt="image-20210823042900872"></li>
</ol>
<p><code>hasOutputChanged</code>流程图：</p>
<p><img src="/2021/08/15/Netty/hasOutputChanged%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="hasOutputChanged流程图"></p>
<h3 id="6、Netty-核心组件-EventLoop-源码剖析"><a href="#6、Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="6、Netty 核心组件 EventLoop 源码剖析"></a>6、Netty 核心组件 EventLoop 源码剖析</h3><p>eventloop继承图：</p>
<p><img src="/2021/08/15/Netty/eventloop%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="eventloop继承图"></p>
<h4 id="handler-中加入线程池和Context-中添加线程池的源码剖析"><a href="#handler-中加入线程池和Context-中添加线程池的源码剖析" class="headerlink" title="handler 中加入线程池和Context 中添加线程池的源码剖析"></a>handler 中加入线程池和Context 中添加线程池的源码剖析</h4><ol>
<li>在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。</li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有2种方式，而且这2种方式实现的区别也蛮大的。<ul>
<li>处理耗时业务的第一种方式——handler 中加入线程池</li>
<li>处理耗时业务的第二种方式——Context 中添加线程池</li>
</ul>
</li>
</ol>
<p>将这些任务从handler中提交到channel对应的NIOEventLoop 的 TaskQueue的方法：</p>
<p>用户程序自定义的普通任务 -&gt; 提交到该channel 对应的NioEventLoop 的 taskQueue中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户程序自定义的普通任务</span></span><br><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ctx.channel().eventLoop().execute(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void run() &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(20 * 1000);</span></span><br><span class="line"><span class="comment">            ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;, CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;发生异常&quot; + ex.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>该方法是通过ctx获得channel对象，在通过channel对象去获取该channel所在的evevtLoop，最后在将任务提交到eventLoop的taskQueue中</p>
</li>
<li><p>eventLoop会起<strong>一个线程</strong>去异步解决taskQueue当中的任务，==注意是一个线程==。如果taskQueue当中有多个任务的话，那么该线程会按照taskQueue中任务的顺序依次执行任务，即执行taskQueue任务的时间是累加的</p>
<ul>
<li>eg：taskQueue的第一个任务花费10s，taskQueue的第二个任务花费20s，那么该线程执行完taskQueue当中的任务总共要花费30s</li>
</ul>
</li>
<li><p>解决方法：</p>
<ol>
<li><p><strong>在当前Handler中创建一个业务线程池</strong>，把耗时任务放到创建的线程池中执行。此时就变成了一个线程有一个业务线程池，来完成耗时任务的异步操作。（局部异步）</p>
<ul>
<li><p>创建线程池的方法：</p>
<ul>
<li><pre><code class="java">// 创建一个线程池，线程数为16
// 这里是用static 创建的全局线程池，即在整一个Handler都可以使用该业务线程池
static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);

// 调用一下方法将耗时任务放在线程池创建的线程中进行执行
group.sumbit(Callable task);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **在Server端中创建一个业务线程池（Context中添加线程池）**（整个异步）</span><br><span class="line"></span><br><span class="line">   - 创建线程池的方法：</span><br><span class="line"></span><br><span class="line">     - &#96;&#96;&#96;java</span><br><span class="line">       &#x2F;&#x2F; 创建一个线程池，线程数为16</span><br><span class="line">       &#x2F;&#x2F; 这里是用static 创建的全局线程池，即在整一个Handler都可以使用该业务线程池</span><br><span class="line">       static final EventExecutorGroup group &#x3D; new DefaultEventExecutorGroup(16);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 在ChannelInitializer的initChannel方法中</span><br><span class="line">       ChannelPipeline p &#x3D; chpipeline();</span><br><span class="line">       &#x2F;&#x2F; 在这里将group设置进去：如果这样设置的话，该handler会优先加入到该线程池中，这样一来，workerGroup主要接收任务 然后在将任务提交给线程池来处理。</span><br><span class="line">       &#x2F;&#x2F; 默认没添加group的话，handler会进入workerLoopGroup的某一个workerLoop子线程</span><br><span class="line">       p.addLast(group,new MyServerHandler());</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>流程图：</p>
<p><img src="/2021/08/15/Netty/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<hr>
<h2 id="12、用Netty-自己-实现-dubbo-RPC"><a href="#12、用Netty-自己-实现-dubbo-RPC" class="headerlink" title="12、用Netty 自己 实现 dubbo RPC"></a>12、用Netty 自己 实现 dubbo RPC</h2><h3 id="1、RPC基本介绍"><a href="#1、RPC基本介绍" class="headerlink" title="1、RPC基本介绍"></a>1、RPC基本介绍</h3><ol>
<li><strong>RPC（Remote Procedure Call）——远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</strong></li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样<ul>
<li><img src="/2021/08/15/Netty/image-20210823043804591.png" alt="image-20210823043804591"></li>
</ul>
</li>
<li>常见的 RPC 框架有：比较知名的如：<ul>
<li>阿里的Dubbo</li>
<li>google的gRPC</li>
<li>Go语言的rpcx</li>
<li>Apache的thrift</li>
<li>Spring 旗下的 Spring Cloud</li>
</ul>
</li>
</ol>
<h3 id="2、RPC调用流程"><a href="#2、RPC调用流程" class="headerlink" title="2、RPC调用流程"></a>2、RPC调用流程</h3><h4 id="1、RPC调用流程图"><a href="#1、RPC调用流程图" class="headerlink" title="1、RPC调用流程图"></a>1、RPC调用流程图</h4><p><img src="/2021/08/15/Netty/image-20210823043954338.png" alt="image-20210823043954338"></p>
<p><strong>术语说明</strong>：在RPC 中， Client 叫服务消费者，Server 叫服务提供者</p>
<h4 id="2、RPC调用流程说明"><a href="#2、RPC调用流程说明" class="headerlink" title="2、RPC调用流程说明"></a>2、RPC调用流程说明</h4><ol>
<li><strong>服务消费方(client)以本地调用方式调用服务</strong></li>
<li>client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li>client stub 将消息进行编码并发送到服务端</li>
<li>server stub 收到消息后进行解码</li>
<li>server stub 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 server stub</li>
<li>server stub 将返回导入结果进行编码并发送至消费方</li>
<li>client stub 接收到消息并进行解码</li>
<li><strong>服务消费方(client)得到结果</strong></li>
</ol>
<p>小结：<strong>RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用。</strong></p>
<h3 id="3、自己实现-dubbo-RPC-基于Netty"><a href="#3、自己实现-dubbo-RPC-基于Netty" class="headerlink" title="3、自己实现 dubbo RPC(基于Netty)"></a>3、自己实现 dubbo RPC(基于Netty)</h3><h4 id="1、需求说明"><a href="#1、需求说明" class="headerlink" title="1、需求说明"></a>1、需求说明</h4><ol>
<li>dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框架</li>
<li><strong>模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20</strong></li>
</ol>
<h4 id="2、设计说明"><a href="#2、设计说明" class="headerlink" title="2、设计说明"></a>2、设计说明</h4><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求提供者返回数据</li>
</ol>
<p><img src="/2021/08/15/Netty/image-20210823044457880.png" alt="image-20210823044457880"></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20817327/article/details/108508151">linux I/O–IO原理和几种零拷贝机制</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42447959/article/details/103499353">由传统IO演化至零拷贝的过程</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/08/15/Netty/" title="Netty">http://xgh-user.github.io/2021/08/15/Netty/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Netty/" rel="tag"># Netty</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/19/JUC/" rel="prev" title="JUC高并发编程">
      <i class="fa fa-chevron-left"></i> JUC高并发编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/15/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="java网络编程">
      java网络编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty"><span class="nav-number">1.</span> <span class="nav-text">Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">1、Netty的介绍以及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Netty%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、Netty的基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Netty%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、Netty的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1、互联网行业</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%B8%B8%E6%88%8F%E8%A1%8C%E4%B8%9A"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2、游戏行业</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%86%E5%9F%9F"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">3、大数据领域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%85%B6%E5%AE%83%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E5%88%B0Netty"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">4、其它开源项目使用到Netty</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Netty%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、Netty的学习参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Java-BIO%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2、Java BIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81I-O%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81I-O%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1、I&#x2F;O模型的基本说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2、BIO、NIO、AIO适用场景分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Java-BIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、Java BIO 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Java-BIO-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、Java BIO 工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1、工作原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BIO%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2、BIO编程简单流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Java-BIO-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、Java BIO 应用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Java-BIO-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、Java BIO 问题分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Java-NIO%E7%BC%96%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">3、Java NIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Java-NIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、Java NIO 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81NIO-%E5%92%8C-BIO%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、NIO 和 BIO的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、NIO 三大核心原理示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、缓冲区(Buffer)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2、Buffer 类及其子类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Buffer%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.4.2.1.</span> <span class="nav-text">1、Buffer类继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Buffer%E7%9A%84%E5%9B%9B%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.4.2.2.</span> <span class="nav-text">2、Buffer的四个主要属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Buffer%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88"><span class="nav-number">1.3.4.2.3.</span> <span class="nav-text">3、Buffer类相关方法一览</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81ByteBuffer%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.3.4.2.4.</span> <span class="nav-text">4、ByteBuffer（最常用）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%80%9A%E9%81%93-Channel"><span class="nav-number">1.3.5.</span> <span class="nav-text">5、通道(Channel)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3、应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B1%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.5.2.1.</span> <span class="nav-text">1、应用实例1——本地文件写数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B2%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.5.2.2.</span> <span class="nav-text">2、应用实例2——本地文件读数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B3%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AABuffer%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">1.3.5.2.3.</span> <span class="nav-text">3、应用实例3——使用一个Buffer完成文件读取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B4%E2%80%94%E2%80%94%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6transferFrom-%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.5.2.4.</span> <span class="nav-text">4、应用实例4——拷贝文件transferFrom 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E4%BA%8EBuffer-%E5%92%8C-Channel%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">4、关于Buffer 和 Channel的注意事项和细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8EMappedByteBuffer%E7%9A%84%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.3.5.3.1.</span> <span class="nav-text">1、关于MappedByteBuffer的相关示例：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8E-Scattering-%E5%92%8C-Gathering%E7%9A%84%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.5.3.2.</span> <span class="nav-text">2、关于 Scattering 和 Gathering的相关示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Selector-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">1.3.6.</span> <span class="nav-text">6、Selector(选择器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Selector%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%92%8C%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">2、Selector示意图和特点说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Selector%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">1.3.6.2.1.</span> <span class="nav-text">1、Selector示意图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.6.2.2.</span> <span class="nav-text">2、特点说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Selector%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">3、Selector类相关方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">4、注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81SelectionKey"><span class="nav-number">1.3.7.</span> <span class="nav-text">8、SelectionKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81SelectionKey%E5%92%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E9%81%93%E7%9A%84%E6%B3%A8%E5%86%8C%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">1、SelectionKey和网络通道的注册关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81SelectionKey%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">2、SelectionKey相关方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81ServerSocketChannel"><span class="nav-number">1.3.8.</span> <span class="nav-text">9、ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81SocketChannel"><span class="nav-number">1.3.9.</span> <span class="nav-text">10、SocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81NIO-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.10.</span> <span class="nav-text">11、NIO 网络编程应用实例——群聊系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E4%BE%8B%E8%A6%81%E6%B1%82"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">1、实例要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E4%BE%8B%E9%9C%80%E6%B1%82%E5%9B%BE"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">2、实例需求图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.10.3.</span> <span class="nav-text">3、分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.10.4.</span> <span class="nav-text">4、代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.11.</span> <span class="nav-text">12、NIO与零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">1、零拷贝基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BC%A0%E7%BB%9FIO%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">2、传统IO数据读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BC%A0%E7%BB%9FIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">3、传统IO模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81mmap%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">4、mmap优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81sendFile%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.11.5.</span> <span class="nav-text">5、sendFile优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3"><span class="nav-number">1.3.11.6.</span> <span class="nav-text">6、零拷贝的再次理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81mmap%E4%B8%8EsendFile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.11.7.</span> <span class="nav-text">7、mmap与sendFile的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.11.8.</span> <span class="nav-text">8、NIO零拷贝案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Java-AIO-%E4%BB%A5%E5%8F%8A-%E4%B8%89%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.3.12.</span> <span class="nav-text">4、Java AIO 以及 三种IO模型的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Java-AIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">1、Java AIO 基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-number">1.3.12.2.</span> <span class="nav-text">2、BIO、NIO、AIO对比表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Netty%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.</span> <span class="nav-text">4、Netty概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%94%9FNIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、原生NIO存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Netty%E5%AE%98%E7%BD%91"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、Netty官网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Netty%E5%AE%98%E7%BD%91%E8%AF%B4%E6%98%8E"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、Netty官网说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Netty%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.4.4.</span> <span class="nav-text">4、Netty的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Netty%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="nav-number">1.4.5.</span> <span class="nav-text">5、Netty版本说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.</span> <span class="nav-text">5、Netty 高性能架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">1、线程模型基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.2.</span> <span class="nav-text">2、传统阻塞 I&#x2F;O 服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1、工作原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">2、模型特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">3、问题分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%95%B4%E4%BD%93%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">3、Reactor 模式（整体）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%92%88%E5%AF%B9%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E7%9A%84-2-%E4%B8%AA%E7%BC%BA%E7%82%B9%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">1、针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">2、工作原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">3、模型特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F%E4%B8%AD-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">4、Reactor 模式中 核心组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">5、Reactor 模式分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.4.</span> <span class="nav-text">4、单 Reactor 单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-2"><span class="nav-number">1.5.4.0.1.</span> <span class="nav-text">1、工作原理图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E"><span class="nav-number">1.5.4.0.2.</span> <span class="nav-text">2、原理图说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.4.0.3.</span> <span class="nav-text">3、单 Reactor 单线程的优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8D%95Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">5、单Reactor 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-3"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">1、工作原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E-1"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">2、原理图说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8D%95Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">3、单Reactor 多线程的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.6.</span> <span class="nav-text">6、主从 Reactor 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-4"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">1、工作原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E-2"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">2、原理图说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Scalable-IO-in-Java-%E5%AF%B9-Multiple-Reactors-%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">3、Scalable IO in Java 对 Multiple Reactors 的原理图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.6.4.</span> <span class="nav-text">4、主从 Reactor 多线程的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="nav-number">1.5.7.</span> <span class="nav-text">7、Reactor 模式小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%813-%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%94%A8%E7%94%9F%E6%B4%BB%E6%A1%88%E4%BE%8B%E6%9D%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">1、3 种模式用生活案例来理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">2、Reactor 模式具有如下的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81Netty%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.8.</span> <span class="nav-text">8、Netty模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%89%88"><span class="nav-number">1.5.8.1.</span> <span class="nav-text">1、工作原理图1——简单版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE2%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88"><span class="nav-number">1.5.8.2.</span> <span class="nav-text">2、工作原理图2——进阶版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE3%E2%80%94%E2%80%94%E8%AF%A6%E7%BB%86%E7%89%88"><span class="nav-number">1.5.8.3.</span> <span class="nav-text">3、工作原理图3——详细版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E"><span class="nav-number">1.5.8.4.</span> <span class="nav-text">4、原理图说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94TCP%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.5.8.5.</span> <span class="nav-text">5、Netty快速入门实例——TCP服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E7%AD%94"><span class="nav-number">1.5.8.6.</span> <span class="nav-text">6、相关问题以及解答</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9AbossGroup%E4%B8%8EworkerGroup%E5%90%AB%E6%9C%89%E7%9A%84%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.5.8.6.1.</span> <span class="nav-text">问题1：bossGroup与workerGroup含有的子线程的数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9ANetty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E7%9A%84%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%88%B0worker%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%EF%BC%88%E5%8D%B3worker%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%89%EF%BC%9F"><span class="nav-number">1.5.8.6.2.</span> <span class="nav-text">问题2：Netty服务端接收的新连接是如何绑定到worker线程池的（即worker线程池是怎么分配线程的）？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9Actx-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1-%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">1.5.8.6.3.</span> <span class="nav-text">问题3：ctx(上下文对象)里面包含的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%984%EF%BC%9Achannel%E4%B8%8E-pipeline-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.8.6.4.</span> <span class="nav-text">问题4：channel与 pipeline 之间的关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84-Task-%E6%9C%89-3-%E7%A7%8D%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.8.7.</span> <span class="nav-text">7、任务队列中的 Task 有 3 种典型使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%99%AE%E9%80%9A%E4%BB%BB%E5%8A%A1-gt-%E6%8F%90%E4%BA%A4%E5%88%B0%E8%AF%A5channel-%E5%AF%B9%E5%BA%94%E7%9A%84NioEventLoop-%E7%9A%84-taskQueue%E4%B8%AD"><span class="nav-number">1.5.8.7.1.</span> <span class="nav-text">1、用户程序自定义的普通任务 -&gt; 提交到该channel 对应的NioEventLoop 的 taskQueue中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-gt-%E6%8F%90%E4%BA%A4%E5%88%B0%E8%AF%A5channel-%E5%AF%B9%E5%BA%94%E7%9A%84NioEventLoop-%E7%9A%84-scheduleTaskQueue%E4%B8%AD"><span class="nav-number">1.5.8.7.2.</span> <span class="nav-text">2、用户自定义定时任务 -&gt; 提交到该channel 对应的NioEventLoop 的  scheduleTaskQueue中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%9D%9E%E5%BD%93%E5%89%8D-Reactor-%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8-Channel-%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.8.7.3.</span> <span class="nav-text">3、非当前 Reactor 线程调用 Channel 的各种方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%96%B9%E6%A1%88%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="nav-number">1.5.8.8.</span> <span class="nav-text">8、方案再说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">6、异步模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">1.6.1.</span> <span class="nav-text">1、基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Future%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.2.</span> <span class="nav-text">2、Future说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94HTTP%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.6.3.</span> <span class="nav-text">5、快速入门实例——HTTP服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="nav-number">1.7.</span> <span class="nav-text">7、Netty 核心模块组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Bootstrap%E3%80%81ServerBootstrap"><span class="nav-number">1.7.1.</span> <span class="nav-text">1、Bootstrap、ServerBootstrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Channel"><span class="nav-number">1.7.2.</span> <span class="nav-text">2、Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Selector"><span class="nav-number">1.7.3.</span> <span class="nav-text">3、Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81ChannelHandler-%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.7.4.</span> <span class="nav-text">4、ChannelHandler 及其实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Pipeline-%E5%92%8C-ChannelPipeline"><span class="nav-number">1.7.5.</span> <span class="nav-text">5、Pipeline 和 ChannelPipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81ChannelHandlerContext"><span class="nav-number">1.7.6.</span> <span class="nav-text">6、ChannelHandlerContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81Unpooled-%E7%B1%BB"><span class="nav-number">1.7.7.</span> <span class="nav-text">9、Unpooled 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.7.8.</span> <span class="nav-text">10、Netty应用实例-群聊系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81Netty%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">1.7.9.</span> <span class="nav-text">11、Netty心跳检测机制案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81Google-Protobuf"><span class="nav-number">1.8.</span> <span class="nav-text">8、Google Protobuf</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.8.1.</span> <span class="nav-text">1、编码和解码的基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Netty-%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%88%B6%E5%92%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">1.8.2.</span> <span class="nav-text">2、Netty 本身的编码解码的机制和问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Protobuf"><span class="nav-number">1.8.3.</span> <span class="nav-text">3、Protobuf</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Protobuf%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">1、Protobuf基本介绍和使用示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Netty%E4%B8%ADProtobuf%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">2、Netty中Protobuf的使用流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty%E7%9A%84handler%E9%93%BE%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">Netty的handler链的调用机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%85%B6%E5%AE%83%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.8.4.</span> <span class="nav-text">5、其它编解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Log4j-%E6%95%B4%E5%90%88%E5%88%B0Netty"><span class="nav-number">1.8.5.</span> <span class="nav-text">6、Log4j 整合到Netty</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85-%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.9.</span> <span class="nav-text">10、TCP 粘包和拆包 及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.9.1.</span> <span class="nav-text">1、TCP 粘包和拆包基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.9.2.</span> <span class="nav-text">2、TCP 粘包和拆包解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.</span> <span class="nav-text">11、Netty 核心源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Netty-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.1.</span> <span class="nav-text">1、Netty 启动过程源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Netty-%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.2.</span> <span class="nav-text">2、Netty 接受请求过程源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Pipeline-Handler-HandlerContext%E5%88%9B%E5%BB%BA%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.3.</span> <span class="nav-text">3、Pipeline Handler HandlerContext创建源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81ChannelPipeline-%E8%B0%83%E5%BA%A6-handler-%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.4.</span> <span class="nav-text">4、ChannelPipeline 调度 handler 的源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Netty-%E5%BF%83%E8%B7%B3-heartbeat-%E6%9C%8D%E5%8A%A1%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.5.</span> <span class="nav-text">5、Netty 心跳(heartbeat)服务源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.6.</span> <span class="nav-text">6、Netty 核心组件 EventLoop 源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#handler-%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CContext-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.10.6.1.</span> <span class="nav-text">handler 中加入线程池和Context 中添加线程池的源码剖析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81%E7%94%A8Netty-%E8%87%AA%E5%B7%B1-%E5%AE%9E%E7%8E%B0-dubbo-RPC"><span class="nav-number">1.11.</span> <span class="nav-text">12、用Netty 自己 实现 dubbo RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81RPC%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.11.1.</span> <span class="nav-text">1、RPC基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.11.2.</span> <span class="nav-text">2、RPC调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">1、RPC调用流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">2、RPC调用流程说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-dubbo-RPC-%E5%9F%BA%E4%BA%8ENetty"><span class="nav-number">1.11.3.</span> <span class="nav-text">3、自己实现 dubbo RPC(基于Netty)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">1、需求说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">2、设计说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.12.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
