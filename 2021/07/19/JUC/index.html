<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] JUC高并发编程1、Java并发知识体系详解1、知识体系 2、java高并发      2、Java 并发 - 理论基础从理论的角度引入并发安全问题以及JMM应对并发问题的原理。 1、BAT大厂的面试问题 多线程的出现是要解决什么问题的? 线程不安全是指什么? 举例说明 并发出现线程不安全的本质什么?  并发的三要素：可见性，原子性和有序性。   Java是怎么解决并发问题的?  3个">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC高并发编程">
<meta property="og:url" content="http://xgh-user.github.io/2021/07/19/JUC/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="[TOC] JUC高并发编程1、Java并发知识体系详解1、知识体系 2、java高并发      2、Java 并发 - 理论基础从理论的角度引入并发安全问题以及JMM应对并发问题的原理。 1、BAT大厂的面试问题 多线程的出现是要解决什么问题的? 线程不安全是指什么? 举例说明 并发出现线程不安全的本质什么?  并发的三要素：可见性，原子性和有序性。   Java是怎么解决并发问题的?  3个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-concurrent-overview-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%911.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%912.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%913.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%914.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%88%E5%90%AB%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210802205153125.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210802204936365.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/2755780-1G20P92Q5230.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/2755780-1G20P92R3121.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-674f0d37fca4fac1bd2df28a2b78e633_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/2755780-1G20P92S13T.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210721233218350.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210721233249742.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806220551047.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806220613006.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806220634123.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-13.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-x01.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-x02.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-x03.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-x04.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-jmm-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/single-thread-rule.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/monitor-lock-rule.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/volatile-variable-rule.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/thread-start-rule.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/thread-join-rule.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/3646544a-cb57-451d-9e03-d3c4f5e4434a.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210803042737724.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-6.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210803043141966.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/ace830df-9919-48ca-91b5-60b193f593d2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-4.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804223435390.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804232649899.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804233935482.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804233158129.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804233645213.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804234421675.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805013827060.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805013917321.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-schronized-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805043937707.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805044214898.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805044307591.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805044616494.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805044906263.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805045205698.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805045456551.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806223239737.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-volatile-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-volatile-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-volatile-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-volatile-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806223239737.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806224057799.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806224747694.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806225125974.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-final-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-final-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-final-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210810231107766.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210810231345476.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210810232209213.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210810232531747.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-key-final-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-overview-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-overview-lock.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-overview-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-executors-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210721220607339.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020090410304694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzMyMTk1,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-atomicinteger-unsafe.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807034923018.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807035727427.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/JUC%5Cimage-20210807040114815.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807040735271.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807042131270.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807042151516.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210807042217185.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806000710338.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806000820108.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806000922500.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-locksupport-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-13.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-14.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-15.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-17-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-16.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-17.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-18.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-19.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-20.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-21.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-aqs-22.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-overview-lock.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812043816368.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812043900546.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812044213292.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812044725103.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812045121967.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812045347108.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812045538702.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812045816095.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812050213728.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812233522165.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812233738920.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812234025126.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812234152831.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812234448884.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812234608451.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812234954747.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813022016104.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813023347980.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813023500583.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813023653011.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813023151128.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813024250098.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813024836077.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813024953061.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813025411978.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813025646877.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813030410741.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813030740325.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813031008456.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813031102400.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-readwritelock-13.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726213514196.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813015618419.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813015913860.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813021033756.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726213440799.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804150447015.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804152755128.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804152921570.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804152947980.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804154458987.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210804154522110.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210722025741403.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-overview-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813203912863.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210723213936543.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814045103054.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-concurrent-hashmap-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814031243376.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814031359616.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814031416319.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-concurrent-hashmap-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-blocking-queue-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-blocking-deque-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814034851138.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814034913187.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814034931731.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814035037609.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814035055942.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814035113682.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814035130035.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814035147199.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814043528344.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-ede1b517df68a503291c48f7405bdc0b_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-76e9a9a9dfb5b14660b6b96367fa5f3f_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-3377fd02f2c0b65304c7449b33a3c112_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-e95055fb06912adbd0f13e2d9b3e128a_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-a55d05b65f58984e5632b4ab18c7fcb8_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-9b55c499d1d012e56bb124d52ad6b469_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-c2109ccde8193517f686d1aeda955eca_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-dcdc7a00cf64cdb961063b19a2fd12dc_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-89e7b1f27f62fd035173ed87c4046f7e_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-7a280921de91d6d5d89f027ec4faa3b3_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/v2-84816ac8172eeb9519bd783334a99815_1440w.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210723031848803.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-2.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-3.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210723034133100.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/70.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/71.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/73.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806020827445.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210806020910048.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726192457057.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726202536158.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726205202616.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726205505114.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726210610999.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210726210629126.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-futuretask-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-futuretask-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-countdownlatch-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-countdownlatch-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-countdownlatch-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-countdownlatch-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-countdownlatch-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-cyclicbarrier-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-reentrantlock-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813191406684.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813192404706.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813192655068.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210813193133463.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-7.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-8.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-9.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-10.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-11.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-semaphore-12.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-juc-phaser-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210728133227349.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210728134755032.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-executors-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210811040044445.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-executors-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-executors-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-stpe-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210812012018371.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-forkjoin-2.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210729225650517.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-forkjoin-3.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-forkjoin-5.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/blog/XGH-blog/source_posts/JUC/java-thread-x-forkjoin-1.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-forkjoin-4.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-thread-x-forkjoin-6.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814195444348.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814195510264.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210814195531931.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-5.jpg">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805201137709.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805215400468.png">
<meta property="og:image" content="http://xgh-user.github.io/2021/07/19/JUC/image-20210805231147322.png">
<meta property="article:published_time" content="2021-07-19T10:55:51.000Z">
<meta property="article:modified_time" content="2021-08-14T20:31:36.424Z">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="JUC高并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xgh-user.github.io/2021/07/19/JUC/java-concurrent-overview-1.png">

<link rel="canonical" href="http://xgh-user.github.io/2021/07/19/JUC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JUC高并发编程 | _little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/07/19/JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC高并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 18:55:51" itemprop="dateCreated datePublished" datetime="2021-07-19T18:55:51+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 04:31:36" itemprop="dateModified" datetime="2021-08-15T04:31:36+08:00">2021-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">JUC高并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="JUC高并发编程"><a href="#JUC高并发编程" class="headerlink" title="JUC高并发编程"></a>JUC高并发编程</h1><h2 id="1、Java并发知识体系详解"><a href="#1、Java并发知识体系详解" class="headerlink" title="1、Java并发知识体系详解"></a>1、Java并发知识体系详解</h2><h3 id="1、知识体系"><a href="#1、知识体系" class="headerlink" title="1、知识体系"></a>1、知识体系</h3><p><img src="/2021/07/19/JUC/java-concurrent-overview-1.png" alt="img"></p>
<h3 id="2、java高并发"><a href="#2、java高并发" class="headerlink" title="2、java高并发"></a>2、java高并发</h3><p><img src="/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%911.png" alt="Java并发1"></p>
<p><img src="/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%912.png" alt="Java并发2"></p>
<p><img src="/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%913.png" alt="Java并发3"></p>
<p><img src="/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%914.png" alt="Java并发4"></p>
<p><img src="/2021/07/19/JUC/Java%E5%B9%B6%E5%8F%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%88%E5%90%AB%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89.jpg" alt="Java并发思维导图（含面试问题整理）"></p>
<hr>
<h2 id="2、Java-并发-理论基础"><a href="#2、Java-并发-理论基础" class="headerlink" title="2、Java 并发 - 理论基础"></a>2、Java 并发 - 理论基础</h2><p>从理论的角度引入并发安全问题以及JMM应对并发问题的原理。</p>
<h3 id="1、BAT大厂的面试问题"><a href="#1、BAT大厂的面试问题" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h3><ul>
<li>多线程的出现是要解决什么问题的?</li>
<li>线程不安全是指什么? 举例说明</li>
<li>并发出现线程不安全的本质什么? <ul>
<li>并发的三要素：可见性，原子性和有序性。</li>
</ul>
</li>
<li>Java是怎么解决并发问题的? <ul>
<li>3个关键字，JMM和8个Happens-Before</li>
</ul>
</li>
<li>线程安全是不是非真即假? <ul>
<li>不是</li>
</ul>
</li>
<li>线程安全有哪些实现思路?</li>
<li>如何理解并发和并行的区别?</li>
</ul>
<h3 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h3><h4 id="1、串行模式"><a href="#1、串行模式" class="headerlink" title="1、串行模式"></a>1、串行模式</h4><p>串行表示<strong>所有任务都按先后顺序进行</strong>。</p>
<p>串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p>
<p><strong>串行是一次只能取得一个任务，并执行这个任务</strong>。</p>
<h4 id="2、并行模式"><a href="#2、并行模式" class="headerlink" title="2、并行模式"></a>2、并行模式</h4><p>并行意味着<strong>可以同时取得多个任务，并同时去执行所取得的这些任务</strong>。</p>
<p>并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。</p>
<p>并行的效率<strong>从代码层次上强依赖于多进程/多线程代码</strong>，<strong>从硬件角度上则依赖于多核 CPU</strong>。 </p>
<p>多核 cpu下，每个<code>核（core）</code>都可以调度运行线程，这时候线程可以是并行的。</p>
<p><img src="/2021/07/19/JUC/image-20210802205153125.png" alt="image-20210802205153125"></p>
<h4 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h4><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。</strong>但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，==并发的重点在于它是一种现象==, ==并发描述的是多进程同时运行的现象==。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程，线程实际还是<code>串行执行</code>的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是<code>同时运行</code>的 。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。 总结为一句话就是： ==微观串行，宏观并行== ，一般会将这种 线程轮流使用 CPU 的做法称为并发（ <code>concurrent</code>）</p>
<p><img src="/2021/07/19/JUC/image-20210802204936365.png" alt="image-20210802204936365"></p>
<p><strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>，由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象： </p>
<ul>
<li><strong>可能出现一个小任务执行了多次，还没开始下个任务的情况</strong>。这时一般会采用队列或类似的数据结构来存放各个小任务的成果；</li>
<li><strong>可能出现还没准备好第一步就执行第二步的可能</strong>。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务；</li>
<li><strong>可以多进程/多线程的方式并行执行这些小任务</strong>。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率。</li>
</ul>
<h4 id="4、并发与并行的区别"><a href="#4、并发与并行的区别" class="headerlink" title="4、并发与并行的区别"></a>4、并发与并行的区别</h4><ul>
<li><p>并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</p>
</li>
<li><p>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><img src="/2021/07/19/JUC/2755780-1G20P92Q5230.jpg" alt="并行和并发哪个好?并行和并发的概念和区别"></p>
</li>
<li><p>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p>
<p><img src="/2021/07/19/JUC/2755780-1G20P92R3121.jpg" alt="并行和并发哪个好?并行和并发的概念和区别"></p>
</li>
<li><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。（下图来自Erlang 之父 Joe Armstrong）</p>
<p><img src="/2021/07/19/JUC/v2-674f0d37fca4fac1bd2df28a2b78e633_1440w.jpg" alt="img"></p>
</li>
<li><p>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发（Concurrent）。</p>
</li>
<li><p>当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p>
<p><img src="/2021/07/19/JUC/2755780-1G20P92S13T.jpg" alt="并行和并发哪个好?并行和并发的概念和区别"></p>
</li>
<li><p>引用 Rob Pike(golang 语言的创造者) 的一段描述：</p>
<ul>
<li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li>
<li>例子：<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li>
<li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li>
<li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li>
</ul>
</li>
</ul>
</li>
<li><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点</p>
<ul>
<li>例子：春运抢票  电商秒杀… </li>
</ul>
</li>
<li><p>并行：多项工作一起执行，之后再汇总</p>
<ul>
<li>例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</li>
</ul>
</li>
</ul>
<h4 id="5、管程"><a href="#5、管程" class="headerlink" title="5、管程"></a>5、管程</h4><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动，即**管程内定义的操作在同一时刻只被一个进程调用(由编译器实现)**。但是这样并不能保证进程以设计的顺序执行。</p>
<p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁。</p>
<p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程。</p>
<p><strong>管程，在java中叫锁，在操作系统中叫监视器</strong>，是一种同步机制。</p>
<p><img src="/2021/07/19/JUC/image-20210721233218350.png" alt="image-20210721233218350"></p>
<h4 id="6、用户线程和守护线程"><a href="#6、用户线程和守护线程" class="headerlink" title="6、用户线程和守护线程"></a>6、用户线程和守护线程</h4><ul>
<li><p>用户线程：平时用到的普通线程、自定义线程 </p>
</li>
<li><p>守护线程：运行在后台，是一种特殊的线程。比如垃圾回收线程。</p>
</li>
<li><p>当主线程结束后，用户线程还在运行，JVM 存活；</p>
</li>
<li><p>如果没有用户线程，都是守护线程，JVM 结束 。</p>
<p><img src="/2021/07/19/JUC/image-20210721233249742.png" alt="image-20210721233249742"></p>
</li>
<li><p>可以通过调用<code>Thread.currentThread().isDaemon()</code>查看当前线程是不是守护线程</p>
</li>
<li><p>可以通过调用<code>当前线程.setDaemon(true)</code>将当前线程设置为守护线程</p>
<ul>
<li>这个方法应该在<code>当前线程.start()</code>执行之前设置</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<h3 id="3、为什么需要多线程"><a href="#3、为什么需要多线程" class="headerlink" title="3、为什么需要多线程"></a>3、为什么需要多线程</h3><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异；<ul>
<li>导致 <code>可见性</code>问题</li>
</ul>
</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；<ul>
<li>导致 <code>原子性</code>问题</li>
</ul>
</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。<ul>
<li>导致 <code>有序性</code>问题</li>
</ul>
</li>
</ul>
<h3 id="4、多线程的应用"><a href="#4、多线程的应用" class="headerlink" title="4、多线程的应用"></a>4、多线程的应用</h3><h4 id="1、应用之异步调用"><a href="#1、应用之异步调用" class="headerlink" title="1、应用之异步调用"></a>1、应用之异步调用</h4><h5 id="1、异步与同步"><a href="#1、异步与同步" class="headerlink" title="1、异步与同步"></a>1、异步与同步</h5><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<h5 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h5><p><strong>多线程可以让方法执行变为异步的</strong>（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<h5 id="3、结论"><a href="#3、结论" class="headerlink" title="3、结论"></a>3、结论</h5><ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li>
<li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li>
</ul>
<h4 id="2、应用之提高效率"><a href="#2、应用之提高效率" class="headerlink" title="2、应用之提高效率"></a>2、应用之提高效率</h4><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费 10 ms</span><br><span class="line">计算 2 花费 11 ms</span><br><span class="line">计算 3 花费 9 ms</span><br><span class="line">汇总需要 1 ms</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</li>
<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms  最后加上汇总时间只会花费 12ms</li>
</ul>
<blockquote>
<p>注意：需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>
</blockquote>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li>
</ol>
<h3 id="5、线程不安全示例"><a href="#5、线程不安全示例" class="headerlink" title="5、线程不安全示例"></a>5、线程不安全示例</h3><p>如果<strong>多个线程</strong>对<strong>同一个共享数据进行访问而不采取同步操作</strong>的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">997 // 结果总是小于1000</span><br></pre></td></tr></table></figure>



<h3 id="6、并发出现问题的根源：并发三要素"><a href="#6、并发出现问题的根源：并发三要素" class="headerlink" title="6、并发出现问题的根源：并发三要素"></a>6、并发出现问题的根源：并发三要素</h3><p>上述代码输出的值为什么总是小于1000？并发出现问题的根源是什么？</p>
<ul>
<li>并发的三要素<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
</li>
</ul>
<h4 id="1、可见性：CPU缓存引起"><a href="#1、可见性：CPU缓存引起" class="headerlink" title="1、可见性：CPU缓存引起"></a>1、可见性：CPU缓存引起</h4><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p>
<p>例子：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 在主存中的值</span></span><br><span class="line">i = <span class="number">10</span>; <span class="comment">// 在CPU1中高速缓存中</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i; <span class="comment">// 读取的依旧是主存当中i的值，对于CPU修改的i的值不可见</span></span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p>
<p>这就是可见性问题，<strong>线程1对变量i修改了之后，线程2没有立即看到线程1修改的值</strong>。</p>
<h4 id="2、原子性：分时复用引起"><a href="#2、原子性：分时复用引起" class="headerlink" title="2、原子性：分时复用引起"></a>2、原子性：分时复用引起</h4><p>原子性：即<strong>一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断</strong>，要么就都不执行。</p>
<p>经典的<strong>银行取钱问题</strong>：比如从账户A和账户B同时对一个银行账号取钱1000元，那么必然包括2个操作：</p>
<ol>
<li>从银行账号读取余额，取钱1000元</li>
<li>取完钱之后，银行将账号的余额进行更新（-1000）</li>
</ol>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A取钱1000元之后，操作突然中止。然后又从B取出了1000元，取出1000元之后，再执行银行余额更新减去1000元的操作。这样就会导致账号减去了1000元，但是账户A与账户B一共取到了2000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<h4 id="3、有序性：重排序引起"><a href="#3、有序性：重排序引起" class="headerlink" title="3、有序性：重排序引起"></a>3、有序性：重排序引起</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？</p>
<ul>
<li>不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</li>
</ul>
<h5 id="1、CPU的指令重排序"><a href="#1、CPU的指令重排序" class="headerlink" title="1、CPU的指令重排序"></a>1、CPU的指令重排序</h5><h6 id="1、名词"><a href="#1、名词" class="headerlink" title="1、名词"></a>1、名词</h6><ul>
<li><code>Clock Cycle Time</code>：主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.25 ns，作为对比，我们墙上挂钟的Cycle Time 是 1s<ul>
<li>例如，运行一条加法指令一般需要一个时钟周期时间</li>
</ul>
</li>
<li><code>CPI</code>：有的指令需要更多的时钟周期时间，所以引出了 CPI （Cycles Per Instruction）指令平均时钟周期数</li>
<li><code>IPC</code>：IPC（Instruction Per Clock Cycle） 即 CPI 的倒数，表示每个时钟周期能够运行的指令数</li>
<li><code>CPU 执行时间</code>：程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示<ul>
<li> 程序 CPU 执行时间 = 指令数 * CPI * Clock Cycle Time </li>
</ul>
</li>
</ul>
<h6 id="2、指令重排序优化"><a href="#2、指令重排序优化" class="headerlink" title="2、指令重排序优化"></a>2、指令重排序优化</h6><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？</p>
<p>可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 这 5 个阶段</p>
<p><img src="/2021/07/19/JUC/image-20210806220551047.png" alt="image-20210806220551047"></p>
<blockquote>
<p>术语参考：</p>
<ul>
<li>instruction fetch (IF) </li>
<li>instruction decode (ID) </li>
<li>execute (EX)</li>
<li>memory access (MEM) </li>
<li>register write back (WB)</li>
</ul>
</blockquote>
<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在 80’s 中叶到 90’s 中叶占据了计算架构的重要地位。</p>
<p>指令重排的前提是，重排指令不能影响结果，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 可以重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// 指令2</span></span><br><span class="line">System.out.println( a + b );</span><br><span class="line"><span class="comment">// 不能重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = a - <span class="number">5</span>; <span class="comment">// 指令2</span></span><br></pre></td></tr></table></figure>

<h6 id="3、支持流水线的处理器"><a href="#3、支持流水线的处理器" class="headerlink" title="3、支持流水线的处理器"></a>3、支持流水线的处理器</h6><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p>
<p><img src="/2021/07/19/JUC/image-20210806220613006.png" alt="image-20210806220613006"></p>
<h6 id="4、SuperScalar-处理器"><a href="#4、SuperScalar-处理器" class="headerlink" title="4、SuperScalar 处理器"></a>4、SuperScalar 处理器</h6><p>大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC &gt; 1</p>
<p><img src="/2021/07/19/JUC/image-20210806220634123.png" alt="image-20210806220634123"></p>
<h5 id="2、重排序（Java-内存模型JMM）"><a href="#2、重排序（Java-内存模型JMM）" class="headerlink" title="2、重排序（Java 内存模型JMM）"></a>2、重排序（Java 内存模型JMM）</h5><h6 id="1、重排序的分类"><a href="#1、重排序的分类" class="headerlink" title="1、重排序的分类"></a>1、重排序的分类</h6><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ul>
<li><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="/2021/07/19/JUC/java-jmm-3.png" alt="img"></p>
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h6 id="2、处理器重排序与内存屏障指令"><a href="#2、处理器重排序与内存屏障指令" class="headerlink" title="2、处理器重排序与内存屏障指令"></a>2、处理器重排序与内存屏障指令</h6><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor A</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//A1  </span></span><br><span class="line">x = b; <span class="comment">//A2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor B</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//B1  </span></span><br><span class="line">y = a; <span class="comment">//B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0</span></span><br></pre></td></tr></table></figure>

<p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-jmm-4.png" alt="img"></p>
<p>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。</p>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody><tr>
<td>sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>x86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p>
<p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p>
<ul>
<li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li>
<li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li>
<li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li>
<li>※注 4：数据依赖性后文会专门说明。</li>
</ul>
<p><strong>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序</strong>。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
</tbody></table>
<p><code>StoreLoad Barriers</code> 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p>
<p><strong><code>StoreLoad Barriers</code> 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）</strong>。</p>
<h6 id="3、数据依赖性"><a href="#3、数据依赖性" class="headerlink" title="3、数据依赖性"></a>3、数据依赖性</h6><p>如果<strong>两个操作访问同一个变量</strong>，且<strong>这两个操作中有一个为<code>写</code>操作</strong>，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody></table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。<strong>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序</strong>。</p>
<p>注意：</p>
<ul>
<li>这里所说的数据依赖性仅针对<strong>单个处理器</strong>中执行的指令序列和<strong>单个线程</strong>中执行的操作，</li>
<li><strong>不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</strong>。</li>
</ul>
<h6 id="4、as-if-serial-语义"><a href="#4、as-if-serial-语义" class="headerlink" title="4、as-if-serial 语义"></a>4、as-if-serial 语义</h6><p>as-if-serial 语义的意思指：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<p>上面三个操作的数据依赖关系如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-jmm-6.png" alt="img"></p>
<p>如上图所示：</p>
<ol>
<li>A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。</li>
<li>因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。</li>
<li>但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。</li>
</ol>
<p>下图是该程序的两种执行顺序：</p>
<p><img src="/2021/07/19/JUC/java-jmm-7.png" alt="img"></p>
<p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h6 id="5、程序顺序规则"><a href="#5、程序顺序规则" class="headerlink" title="5、程序顺序规则"></a>5、程序顺序规则</h6><p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p>
<p>这里 A happens- before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。<strong>如果 A happens- before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前</strong>。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens- before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：<strong>在不改变程序执行结果的前提下，尽可能的开发并行度</strong>。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h6 id="6、重排序对多线程的影响"><a href="#6、重排序对多线程的影响" class="headerlink" title="6、重排序对多线程的影响"></a>6、重排序对多线程的影响</h6><p>重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;             <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a * a;        <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag 变量是个标记，用来标识变量 a 是否已被写入。</p>
<p>这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入?</p>
<p>答案是：不一定能看到。</p>
<p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p>
<p>当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：（注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。）</p>
<p><img src="/2021/07/19/JUC/java-jmm-8.png" alt="img"></p>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-9.png" alt="img"></p>
<p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，<strong>编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。</strong>以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>结论：</p>
<ul>
<li><strong>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果</strong>（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；</li>
<li>但<strong>在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果</strong>。</li>
</ul>
<h5 id="3、顺序一致性-Java-内存模型JMM"><a href="#3、顺序一致性-Java-内存模型JMM" class="headerlink" title="3、顺序一致性(Java 内存模型JMM)"></a>3、顺序一致性(Java 内存模型JMM)</h5><h6 id="1、数据竞争与顺序一致性保证"><a href="#1、数据竞争与顺序一致性保证" class="headerlink" title="1、数据竞争与顺序一致性保证"></a>1、数据竞争与顺序一致性保证</h6><p>当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下：</p>
<ul>
<li><strong>在一个线程中写一个变量</strong>，</li>
<li><strong>在另一个线程读同一个变量</strong>，</li>
<li>而且<strong>写和读没有通过同步来排序</strong>。</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。<strong>如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序</strong>。</p>
<p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p>
<ul>
<li>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）</li>
<li>即<strong>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</strong>。</li>
<li>这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。</li>
</ul>
<h6 id="2、顺序一致性内存模型"><a href="#2、顺序一致性内存模型" class="headerlink" title="2、顺序一致性内存模型"></a>2、顺序一致性内存模型</h6><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li><strong>一个线程中的所有操作必须按照程序的顺序来执行</strong>。</li>
<li><strong>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序</strong>。</li>
</ul>
<p>在顺序一致性内存模型中，<strong>每个操作都必须原子执行且立刻对所有线程可见</strong>。 顺序一致性内存模型为程序员提供的视图如下：</p>
<p><img src="/2021/07/19/JUC/java-jmm-10.png" alt="img"></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。从上图我们可以看出，<strong>在任意时间点最多只能有一个线程可以连接到内存</strong>。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<ul>
<li>假设有两个线程 A 和 B 并发执行。<ul>
<li>其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。</li>
<li>B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</li>
</ul>
</li>
<li>假设这两个线程使用监视器来正确同步：<ul>
<li>A 线程的三个操作执行后释放监视器，</li>
<li>随后 B 线程获取同一个监视器。</li>
</ul>
</li>
</ul>
<p>那么程序在顺序一致性模型中的执行效果将如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-jmm-11.png" alt="img"></p>
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-12.png" alt="img"></p>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如：在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h6 id="3、同步程序的顺序一致性效果"><a href="#3、同步程序的顺序一致性效果" class="headerlink" title="3、同步程序的顺序一致性效果"></a>3、同步程序的顺序一致性效果</h6><p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例代码中，假设 A 线程执行 writer() 方法后，B 线程执行 reader() 方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。</p>
<p>下面是该程序在两个内存模型中的执行时序对比图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-13.png" alt="img"></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到 JMM 在具体实现上的基本方针：<strong>在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门</strong>。</p>
<h6 id="4、未同步程序的执行特性"><a href="#4、未同步程序的执行特性" class="headerlink" title="4、未同步程序的执行特性"></a>4、未同步程序的执行特性</h6><p>对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：<strong>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来</strong>。</p>
<p>为了实现最小安全性，<strong>JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM 内部会同步这两个操作）</strong>。因此，在已清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ul>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</li>
<li>JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。</li>
</ul>
<p>第 3 个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 / 写内存中一个或多个物理上连续的字。这里的关键是，<strong>总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写</strong>。下面让我们通过一个示意图来说明总线的工作机制：</p>
<p><img src="/2021/07/19/JUC/java-jmm-14.png" alt="img"></p>
<p>如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性。</p>
<p>在一些 32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 / 写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-15.png" alt="img"></p>
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个 32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A”写了一半”的无效值。</p>
<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><h6 id="1、处理器内存模型"><a href="#1、处理器内存模型" class="headerlink" title="1、处理器内存模型"></a>1、处理器内存模型</h6><p>顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ul>
<li>放松了程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。</li>
<li>在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。</li>
<li>在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。</li>
</ul>
<p>注意：</p>
<ul>
<li><strong>这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的</strong>（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</li>
</ul>
<p>下面的表格展示了常见处理器内存模型的细节特征：</p>
<table>
<thead>
<tr>
<th>内存模型名称</th>
<th>对应的处理器</th>
<th>Store-Load 重排序</th>
<th>Store-Store 重排序</th>
<th>Load-Load 和 Load-Store 重排序</th>
<th>可以更早读取到其它处理器的写</th>
<th>可以更早读取到当前处理器的写</th>
</tr>
</thead>
<tbody><tr>
<td>TSO</td>
<td>sparc-TSO X64</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PSO</td>
<td>sparc-PSO</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>RMO</td>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写 - 读重排序，原因在前面说明过：它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，我们可以看到<strong>这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写</strong>。</p>
<p>上面表格中的各种处理器内存模型，<strong>从上到下，模型由强变弱</strong>。<strong>越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能</strong>。</p>
<p>由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-x01.png" alt="img"></p>
<p>如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>
<h6 id="2、JMM、处理器内存模型与顺序一致性内存模型之间的关系"><a href="#2、JMM、处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="2、JMM、处理器内存模型与顺序一致性内存模型之间的关系"></a>2、JMM、处理器内存模型与顺序一致性内存模型之间的关系</h6><ul>
<li><strong>JMM 是一个语言级的内存模型</strong></li>
<li><strong>处理器内存模型是硬件级的内存模型</strong></li>
<li><strong>顺序一致性内存模型是一个理论参考模型</strong>。</li>
</ul>
<p>下面是语言内存模型、处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-x02.png" alt="img"></p>
<p>从上图我们可以看出：</p>
<ul>
<li>常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱</li>
<li>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。</li>
<li>同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</li>
</ul>
<h6 id="3、JMM-的设计"><a href="#3、JMM-的设计" class="headerlink" title="3、JMM 的设计"></a>3、JMM 的设计</h6><p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>
<ul>
<li><strong>程序员对内存模型的使用</strong>。程序员希望内存模型易于理解，易于编程。<strong>程序员希望基于一个强内存模型来编写代码</strong>。</li>
<li><strong>编译器和处理器对内存模型的实现</strong>。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。<strong>编译器和处理器希望实现一个弱内存模型</strong>。</li>
</ul>
<p>由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：</p>
<ol>
<li>一方面要**为程序员提供足够强的<code>内存可见性保证</code>**；</li>
<li>另一方面，**对编译器和处理器的<code>限制</code>要尽可能的<code>放松</code>**。</li>
</ol>
<p>下面让我们看看 JSR-133 是如何实现这一目标的。为了具体说明，请看前面提到过的计算圆面积的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<p>上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ol>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ol>
<p>由于 A happens- before B，happens- before 的定义会要求：</p>
<ol>
<li>A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 </li>
<li>但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。</li>
<li>也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before 要求禁止的重排序分为了下面两类：<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
</li>
</ol>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li><strong>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序</strong>。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ul>
<p>下面是 JMM 的设计示意图：</p>
<p><img src="/2021/07/19/JUC/java-jmm-x03.png" alt="img"></p>
<p>从上图可以看出两点：</p>
<ul>
<li>JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens - before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens- before B）。</li>
<li><strong>JMM 对编译器和处理器的束缚已经尽可能的少</strong>。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除(<code>锁消除</code>)。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h6 id="4、JMM-的内存可见性保证"><a href="#4、JMM-的内存可见性保证" class="headerlink" title="4、JMM 的内存可见性保证"></a>4、JMM 的内存可见性保证</h6><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ul>
<li><strong>单线程程序</strong>。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li><strong>正确同步的多线程程序</strong>。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，<strong>JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证</strong>。</li>
<li><strong>未同步 / 未正确同步的多线程程序</strong>。JMM 为它们提供了最小安全性保障：<strong>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</strong></li>
</ul>
<p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p>
<p><img src="/2021/07/19/JUC/java-jmm-x04.png" alt="img"></p>
<p>只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h6 id="5、JSR-133-对旧内存模型的修补"><a href="#5、JSR-133-对旧内存模型的修补" class="headerlink" title="5、JSR-133 对旧内存模型的修补"></a>5、JSR-133 对旧内存模型的修补</h6><p>JSR-133 对 JDK5 之前的旧内存模型的修补主要有两个：</p>
<ul>
<li>增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义。</li>
<li>增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，JSR-133 为 final 增加了两个重排序规则。现在，final 具有了初始化安全性。</li>
</ul>
<h3 id="7、JAVA是怎么解决并发问题的：JMM-Java内存模型"><a href="#7、JAVA是怎么解决并发问题的：JMM-Java内存模型" class="headerlink" title="7、JAVA是怎么解决并发问题的：JMM(Java内存模型)"></a>7、JAVA是怎么解决并发问题的：JMM(Java内存模型)</h3><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p>JMM 体现在以下几个方面：</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<ul>
<li><p>理解的第一个维度：核心知识点</p>
<ul>
<li>JMM本质上可以理解为，<strong>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法</strong>。具体来说，这些方法包括：<ul>
<li><code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字</li>
<li><code>Happens-Before</code> 规则</li>
</ul>
</li>
</ul>
</li>
<li><p>理解的第二个维度：可见性，有序性，原子性</p>
<ul>
<li><p>原子性</p>
<ul>
<li><p><strong>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</strong></p>
</li>
<li><p>请分析以下哪些操作是原子性操作：</p>
<ol>
<li><pre><code class="java">x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;java</span><br><span class="line">   y &#x3D; x;         </span><br><span class="line">   &#x2F;&#x2F;语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="java">x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;java</span><br><span class="line">   x &#x3D; x + 1;     &#x2F;&#x2F;语句4： 同语句3</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ol>
</li>
<li><p>上面4个语句只有语句1的操作具备原子性。</p>
</li>
<li><p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
</li>
<li><p>从上面可以看出，<strong>Java内存模型只保证了基本读取和赋值是原子性操作</strong>，如果要实现更大范围操作的原子性，可以通过<code>synchronized</code>和<code>Lock</code>来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
</li>
</ul>
</li>
<li><p>可见性</p>
<ul>
<li>Java提供了<code>volatile</code>关键字来保证可见性。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li>
<li>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li>
<li>另外，通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>在Java里面，可以通过<code>volatile</code>关键字来保证一定的”有序性”（具体原理在下面讲述）。另外可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<strong>当然JMM是通过Happens-Before 规则来保证有序性的</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1、关键字：volatile、synchronized-和-final"><a href="#1、关键字：volatile、synchronized-和-final" class="headerlink" title="1、关键字：volatile、synchronized 和 final"></a>1、关键字：volatile、synchronized 和 final</h4><h5 id="1、volatile"><a href="#1、volatile" class="headerlink" title="1、volatile"></a>1、volatile</h5><h5 id="2、synchronized"><a href="#2、synchronized" class="headerlink" title="2、synchronized"></a>2、synchronized</h5><h5 id="3、final"><a href="#3、final" class="headerlink" title="3、final"></a>3、final</h5><h4 id="2、Happens-Before-规则"><a href="#2、Happens-Before-规则" class="headerlink" title="2、Happens-Before 规则"></a>2、Happens-Before 规则</h4><p>上面提到了可以用 <code>volatile</code> 和 <code>synchronized</code> 来<strong>保证有序性</strong>。除此之外，JVM 还规定了<strong>先行发生(Happens-Before)原则</strong>，<strong>让一个操作无需控制就能先于另一个操作完成</strong>。</p>
<p>从 JDK5 开始，java 使用新的 JSR-133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 <code>happens-before</code> 的概念，通过这个概念来阐述操作之间的内存可见性。<strong>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间</strong>。 happens-before 规则如下：</p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li>
<li><strong>传递性</strong>：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>
</ul>
<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见：(变量都是指成员变量或静态成员变量)</p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<ul>
<li><pre><code class="java">static int x;
static Object m = new Object();
new Thread(()-&gt;&#123;
    synchronized(m) &#123;
        x = 10;
    &#125;
&#125;,&quot;t1&quot;).start();

new Thread(()-&gt;&#123;
    synchronized(m) &#123;
        System.out.println(x);
    &#125;
&#125;,&quot;t2&quot;).start();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    volatile static int x;</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        x &#x3D; 10;</span><br><span class="line">    &#125;,&quot;t1&quot;).start();</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;,&quot;t2&quot;).start();</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
<ul>
<li><pre><code class="java">static int x;
x = 10;
new Thread(()-&gt;&#123;
    System.out.println(x); 
&#125;,&quot;t2&quot;).start();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    static int x;</span><br><span class="line">    Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">        x &#x3D; 10;</span><br><span class="line">    &#125;,&quot;t1&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    System.out.println(x);</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p>
<ul>
<li><pre><code class="java">static int x;
public static void main(String[] args) &#123;
    Thread t2 = new Thread(()-&gt;&#123;
        while(true) &#123;
            if(Thread.currentThread().isInterrupted()) &#123;
                System.out.println(x);
                break;
            &#125;
        &#125;
    &#125;,&quot;t2&quot;);
    t2.start();

    new Thread(()-&gt;&#123;
        sleep(1);
        x = 10;
        t2.interrupt();
    &#125;,&quot;t1&quot;).start();

    while(!t2.isInterrupted()) &#123;
        Thread.yield();
    &#125;
    System.out.println(x);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</span><br><span class="line"></span><br><span class="line">- 具有传递性，如果 &#96;x hb-&gt; y&#96; 并且 &#96;y hb-&gt; z&#96; 那么有 &#96;x hb-&gt; z&#96; ，配合 &#96;volatile&#96; 的防指令重排，有下面的例子</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    volatile static int x; </span><br><span class="line">    static int y;</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        y &#x3D; 10;</span><br><span class="line">        x &#x3D; 20;</span><br><span class="line">    &#125;,&quot;t1&quot;).start();</span><br><span class="line">    </span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; x&#x3D;20 对 t2 可见, 同时 y&#x3D;10 也对 t2 可见</span><br><span class="line">        System.out.println(x); </span><br><span class="line">    &#125;,&quot;t2&quot;).start();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><strong>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！</strong></li>
<li><strong>happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前</strong>（the first is visible to and ordered before the second）。</li>
</ul>
<p>happens-before 与 JMM 的关系如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-jmm-5.png" alt="img"></p>
<p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
<h5 id="1、单一线程原则（Single-Thread-rule）"><a href="#1、单一线程原则（Single-Thread-rule）" class="headerlink" title="1、单一线程原则（Single Thread rule）"></a>1、单一线程原则（Single Thread rule）</h5><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<p><img src="/2021/07/19/JUC/single-thread-rule.png" alt="image"></p>
<h5 id="2、管程锁定规则（Monitor-Lock-Rule）"><a href="#2、管程锁定规则（Monitor-Lock-Rule）" class="headerlink" title="2、管程锁定规则（Monitor Lock Rule）"></a>2、管程锁定规则（Monitor Lock Rule）</h5><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<p><img src="/2021/07/19/JUC/monitor-lock-rule.png" alt="image"></p>
<h5 id="3、volatile-变量规则（Volatile-Variable-Rule）"><a href="#3、volatile-变量规则（Volatile-Variable-Rule）" class="headerlink" title="3、volatile 变量规则（Volatile Variable Rule）"></a>3、volatile 变量规则（Volatile Variable Rule）</h5><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<p><img src="/2021/07/19/JUC/volatile-variable-rule.png" alt="image"></p>
<h5 id="4、线程启动规则（Thread-Start-Rule）"><a href="#4、线程启动规则（Thread-Start-Rule）" class="headerlink" title="4、线程启动规则（Thread Start Rule）"></a>4、线程启动规则（Thread Start Rule）</h5><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<p><img src="/2021/07/19/JUC/thread-start-rule.png" alt="image"></p>
<h5 id="5、线程加入规则（Thread-Join-Rule）"><a href="#5、线程加入规则（Thread-Join-Rule）" class="headerlink" title="5、线程加入规则（Thread Join Rule）"></a>5、线程加入规则（Thread Join Rule）</h5><p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<p><img src="/2021/07/19/JUC/thread-join-rule.png" alt="image"></p>
<h5 id="6、线程中断规则（Thread-Interruption-Rule）"><a href="#6、线程中断规则（Thread-Interruption-Rule）" class="headerlink" title="6、线程中断规则（Thread Interruption Rule）"></a>6、线程中断规则（Thread Interruption Rule）</h5><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h5 id="7、对象终结规则（Finalizer-Rule）"><a href="#7、对象终结规则（Finalizer-Rule）" class="headerlink" title="7、对象终结规则（Finalizer Rule）"></a>7、对象终结规则（Finalizer Rule）</h5><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p>
<h5 id="8、传递性（Transitivity）"><a href="#8、传递性（Transitivity）" class="headerlink" title="8、传递性（Transitivity）"></a>8、传递性（Transitivity）</h5><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h3 id="8、线程安全：不是一个非真即假的命题"><a href="#8、线程安全：不是一个非真即假的命题" class="headerlink" title="8、线程安全：不是一个非真即假的命题"></a>8、线程安全：不是一个非真即假的命题</h3><p>一个类在可以被多个线程安全调用时就是线程安全的。</p>
<p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类：</p>
<ol>
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立。</li>
</ol>
<h4 id="1、不可变-Immutable"><a href="#1、不可变-Immutable" class="headerlink" title="1、不可变(Immutable)"></a>1、不可变(Immutable)</h4><p><strong>不可变(Immutable)的对象一定是线程安全的</strong>，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p>
<p><strong>多线程环境下，应当尽量使对象成为不可变，来满足线程安全</strong>。</p>
<p>不可变的类型：</p>
<ul>
<li><p>final 关键字修饰的基本数据类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举类型</p>
</li>
<li><p>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。</p>
<ul>
<li>但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
</li>
<li><p>日期格式转换类  <code>DateTimeFormatter</code></p>
<ul>
<li><p>平常用的的日期格式转换类 <code>SimpleDateFormat</code> 在多线程下是不安全的，有很大几率出现 <code>java.lang.NumberFormatException</code> 或者出现<code>不正确的日期</code>解析结果</p>
</li>
<li><p>在 Java 8 后通过了 <code>DateTimeFormatter</code> 解决这个问题，在文档中你可以发现对<code>DateTimeFormatter</code>的描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implSpec</span></span><br><span class="line">This <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">immutable</span> <span class="title">and</span> <span class="title">thread</span>-<span class="title">safe</span>.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，<strong>需要对集合进行修改的方法都直接抛出异常</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:9)</span><br></pre></td></tr></table></figure>

<h5 id="1、不可变的设计要素"><a href="#1、不可变的设计要素" class="headerlink" title="1、不可变的设计要素"></a>1、不可变的设计要素</h5><p>以<code>String</code>为例，说明一下不可变设计的要素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String</code>整一个类被<code>final</code>修饰了，保证了<code>String</code>没有任何子类，所以也不用担心子类去修改重写它的方法而导致破坏不可变性</li>
<li>hash虽然没有加上什么final修饰，但是hash是私有的并且String类没有提供hash的set方法，外部没有办法修改hash的值，所以也算保证了hash的不可变性</li>
<li>char[]数组使用了<code>final</code>修饰，在构造方法当中赋值，保证了<code>value</code>值的不可变性；</li>
<li>但是这样只是保证了char[]数组这个引用变量的不可变性，怎么保证char[]数组里面的值具有不可变性呢？<ul>
<li>主要是依赖了String的构造方法。</li>
</ul>
</li>
</ul>
<p><code>String</code>的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个原始字符串，根据该字符串生成新字符串，它会与原始字符串共用一个value数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个char[]数组，它会对char[]数组的内容进行拷贝，就复制一个新数组，新数组在作为String的value数组</span></span><br><span class="line"><span class="comment">// 这种思想：保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、保护性拷贝（defensive-copy）"><a href="#2、保护性拷贝（defensive-copy）" class="headerlink" title="2、保护性拷贝（defensive copy）"></a>2、保护性拷贝（defensive copy）</h5><p>使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那不就破坏了String的不可变性了吗？那么下面就看一看这些方法是如何实现的，就以 substring 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些常规判断</span></span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主要是这里：它会新new一个String并把value作为参数传递进去，保证不可变性</span></span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 ﬁnal char[] value 做出了修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 它会对数组的内容进行拷贝，就复制一个新数组，新数组在作为String的value数组(保护性拷贝)</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种<strong>通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</strong></p>
<h4 id="2、绝对线程安全"><a href="#2、绝对线程安全" class="headerlink" title="2、绝对线程安全"></a>2、绝对线程安全</h4><p><strong>不管运行时环境如何，调用者都不需要任何额外的同步措施。</strong></p>
<h4 id="3、相对线程安全"><a href="#3、相对线程安全" class="headerlink" title="3、相对线程安全"></a>3、相对线程安全</h4><p><strong>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施</strong>。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<p>对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorUnsafeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-159738&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3</span><br><span class="line">    at java.util.Vector.remove(Vector.java:831)</span><br><span class="line">    at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)</span><br><span class="line">    at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="4、线程兼容"><a href="#4、线程兼容" class="headerlink" title="4、线程兼容"></a>4、线程兼容</h4><p><strong>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况</strong>。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>
<h4 id="5、线程对立"><a href="#5、线程对立" class="headerlink" title="5、线程对立"></a>5、线程对立</h4><p><strong>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</strong>。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，<strong>应当尽量避免</strong>。</p>
<h3 id="9、线程安全的实现方法"><a href="#9、线程安全的实现方法" class="headerlink" title="9、线程安全的实现方法"></a>9、线程安全的实现方法</h3><h4 id="1、互斥同步"><a href="#1、互斥同步" class="headerlink" title="1、互斥同步"></a>1、互斥同步</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code>。</p>
<h4 id="2、非阻塞同步"><a href="#2、非阻塞同步" class="headerlink" title="2、非阻塞同步"></a>2、非阻塞同步</h4><p>互斥同步最主要的问题就是<strong>线程阻塞和唤醒所带来的性能问题</strong>，因此这种同步也称为阻塞同步。</p>
<p><strong>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题</strong>。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h5 id="1、CAS（JUC中CAS-Unsafe和原子类相关）"><a href="#1、CAS（JUC中CAS-Unsafe和原子类相关）" class="headerlink" title="1、CAS（JUC中CAS, Unsafe和原子类相关）"></a>1、CAS（JUC中CAS, Unsafe和原子类相关）</h5><p>随着<strong>硬件指令集的发展</strong>，我们可以使用<strong>基于冲突检测的乐观并发策略：==先进行操作==**，如果没有其它线程争用共享数据，那操作就成功了，</strong>否则采取补偿措施(不断地重试，直到成功为止)**。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p><strong>乐观锁需要==操作和冲突检测这两个步骤具备原子性==，这里就不能再使用互斥同步来保证了，只能靠硬件来完成</strong>。硬件支持的原子性操作最典型的是：**比较并交换(Compare-and-Swap，CAS)**。</p>
<p>CAS 指令需要有 3 个操作数，分别是：</p>
<ul>
<li>内存地址 V</li>
<li>旧的预期值 A </li>
<li>新值 B。</li>
</ul>
<p>当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。（否则一直循环重试，直到成功为止）</p>
<h5 id="2、AtomicInteger"><a href="#2、AtomicInteger" class="headerlink" title="2、AtomicInteger"></a>2、AtomicInteger</h5><p>J.U.C 包里面的整数原子类 <code>AtomicInteger</code>，其中的 <code>compareAndSet()</code> 和 <code>getAndIncrement()</code> 等方法<strong>都使用了 Unsafe 类的 CAS 操作</strong>。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，其中：</p>
<ul>
<li><strong>var1 指示对象内存地址</strong>；</li>
<li><strong>var2 指示该字段相对对象内存地址的偏移</strong>；</li>
<li><strong>var4 指示操作需要加的数值，这里为 1</strong>。</li>
</ul>
<p>具体过程：</p>
<ol>
<li>通过 getIntVolatile(var1, var2) 得到旧的预期值；</li>
<li>通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</li>
<li>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、ABA"><a href="#3、ABA" class="headerlink" title="3、ABA"></a>3、ABA</h5><p>ABA问题：<strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过</strong>。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 <code>AtomicStampedReference</code> 来解决这个问题，<strong>它可以通过控制变量值的版本来保证 CAS 的正确性</strong>。大部分情况下 ABA 问题不会影响程序并发的正确性，<strong>如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效</strong>。</p>
<h4 id="3、无同步方案"><a href="#3、无同步方案" class="headerlink" title="3、无同步方案"></a>3、无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h5 id="1、栈封闭（JUC中线程池相关）"><a href="#1、栈封闭（JUC中线程池相关）" class="headerlink" title="1、栈封闭（JUC中线程池相关）"></a>1、栈封闭（JUC中线程池相关）</h5><p>多个线程访问同一个方法的==局部变量==时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h5 id="2、线程本地存储-Thread-Local-Storage-（JUC中ThreadLocal详解）"><a href="#2、线程本地存储-Thread-Local-Storage-（JUC中ThreadLocal详解）" class="headerlink" title="2、线程本地存储(Thread Local Storage)（JUC中ThreadLocal详解）"></a>2、线程本地存储(Thread Local Storage)（JUC中ThreadLocal详解）</h5><p><strong>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行</strong>。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“==一个请求对应一个服务器线程”(Thread-per-Request)==的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 ==java.lang.ThreadLocal== 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：1</p>
<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它所对应的底层结构图为：</p>
<p><img src="/2021/07/19/JUC/3646544a-cb57-451d-9e03-d3c4f5e4434a.png" alt="image"></p>
<p>每个 Thread 都有一个 ==ThreadLocal.ThreadLocalMap 对象==，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLoca -&gt; value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争</strong>。</p>
<p>注意：</p>
<ul>
<li>**在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ==ThreadLocal 有内存泄漏的情况==**；</li>
<li><strong>应该尽可能在每次使用 ThreadLocal 后==手动调用 remove()==，以==避免出现 ThreadLocal 经典的内存泄漏==甚至是造成自身业务混乱的风险。</strong></li>
</ul>
<h5 id="3、可重入代码-Reentrant-Code"><a href="#3、可重入代码-Reentrant-Code" class="headerlink" title="3、可重入代码(Reentrant Code)"></a>3、可重入代码(Reentrant Code)</h5><p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征：</p>
<ul>
<li>例如<strong>不依赖存储在堆上的数据和公用的系统资源</strong>；</li>
<li><strong>用到的状态量都由参数中传入</strong></li>
<li><strong>不调用非可重入的方法</strong>等。</li>
</ul>
<h5 id="4、无状态"><a href="#4、无状态" class="headerlink" title="4、无状态"></a>4、无状态</h5><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，<strong>不要为 Servlet 设置成员变量</strong>，这种<strong>没有任何成员变量的类是线程安全的</strong></p>
<blockquote>
<p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>
</blockquote>
<hr>
<h2 id="3、Java-并发-线程基础"><a href="#3、Java-并发-线程基础" class="headerlink" title="3、Java 并发 - 线程基础"></a>3、Java 并发 - 线程基础</h2><h3 id="1、BAT大厂的面试问题-1"><a href="#1、BAT大厂的面试问题-1" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h3><ul>
<li>线程有哪几种状态？分别说明从一种状态到另一种状态转变有哪些方式？</li>
<li>通常线程有哪几种使用方式？</li>
<li>基础线程机制有哪些？</li>
<li>线程的中断方式有哪些？</li>
<li>线程的互斥同步方式有哪些？如何比较和选择？</li>
<li>线程之间有哪些协作方式？</li>
</ul>
<h3 id="2、进程与线程"><a href="#2、进程与线程" class="headerlink" title="2、进程与线程"></a>2、进程与线程</h3><h4 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h4><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 </p>
<p>在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。</p>
<p>进程：</p>
<ul>
<li>是程序的实体；</li>
<li>是计算机中的程序关于某数据集合上的一次运行活动；</li>
<li>是系统进行资源分配和调度的基本单位；</li>
<li>是操作系统结构的基础。</li>
<li>程序是指令、数据及其组织形式的描述，进程是程序的实体。 </li>
</ul>
<p>进程：</p>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>线程：</p>
<ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>
<h4 id="3、进程与线程的区别"><a href="#3、进程与线程的区别" class="headerlink" title="3、进程与线程的区别"></a>3、进程与线程的区别</h4><ul>
<li>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；<ul>
<li>进程——资源分配的最小单位。</li>
</ul>
</li>
<li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。<ul>
<li>线程——程序执行的最小单位。</li>
</ul>
</li>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）<ul>
<li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li>
<li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li>
<li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，pipe文件<ul>
<li>匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信，只支持半双工通信</li>
<li>命名管道(Names Pipes)：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循FIFO</li>
</ul>
</li>
<li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供全双工通信，对比管道：<ul>
<li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
</li>
</ul>
</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<ul>
<li>套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信</li>
</ul>
</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<ul>
<li>Java中的通信机制：volatile、等待/通知机制、join方式、InheritableThreadLocal、MappedByteBuffer</li>
</ul>
</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h3 id="3、线程状态转换"><a href="#3、线程状态转换" class="headerlink" title="3、线程状态转换"></a>3、线程状态转换</h3><h4 id="1、线程的五状态模型（操作系统）"><a href="#1、线程的五状态模型（操作系统）" class="headerlink" title="1、线程的五状态模型（操作系统）"></a>1、线程的五状态模型（操作系统）</h4><p><img src="/2021/07/19/JUC/image-20210803042737724.png" alt="image-20210803042737724"></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h4 id="2、线程的七状态模型（操作系统）"><a href="#2、线程的七状态模型（操作系统）" class="headerlink" title="2、线程的七状态模型（操作系统）"></a>2、线程的七状态模型（操作系统）</h4><p><img src="/2021/07/19/JUC/image-6.jpg" alt="img"></p>
<h4 id="3、线程的六状态模型（java）"><a href="#3、线程的六状态模型（java）" class="headerlink" title="3、线程的六状态模型（java）"></a>3、线程的六状态模型（java）</h4><p>这是从 Java API 层面来描述的</p>
<p>根据 Thread.State 枚举，分为六种状态：</p>
<p><img src="/2021/07/19/JUC/image-20210803043141966.png" alt="image-20210803043141966"></p>
<ul>
<li><code>NEW</code>  线程刚被创建，但是还没有调用 start() 方法</li>
<li><code>RUNNABLE</code> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【==可运行状态==】、【==运行状态==】和【==阻塞状态==】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li>
<li><code>TERMINATED</code> 当线程代码运行结束</li>
</ul>
<p><img src="/2021/07/19/JUC/ace830df-9919-48ca-91b5-60b193f593d2.png" alt="image"></p>
<p>假设有线程 Thread t</p>
<ol>
<li><strong>NEW –&gt; RUNNABLE</strong><ul>
<li>当调用 <code>t.start()</code> 方法时，由 <code>NEW --&gt; RUNNABLE</code></li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 <code>obj.wait()</code> 方法时，t 线程从 <code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul>
<li>线程被notify之后直接从waitset进入entrylist，对应的状态就是<code>WAITING --&gt; BLOCKED</code></li>
<li>等到锁释放之后，t线程进入锁的竞争<ul>
<li>竞争锁成功，t 线程从  <code>WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，t 线程从  <code>WAITING --&gt; BLOCKED</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong><ul>
<li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE --&gt; WAITING</code><ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong><ul>
<li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul>
<li>线程被notify之后直接从waitset进入entrylist，对应的状态就是<code>WAITING --&gt; BLOCKED</code></li>
<li>等到锁释放之后，t线程进入锁的竞争<ul>
<li>竞争锁成功，t 线程从  <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，t 线程从  <code>TIMED_WAITING --&gt; BLOCKED</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从<code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从  <code>TIMED_WAITING --&gt; RUNNABLE</code> </li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; BLOCKED</strong><ul>
<li>t 线程用  synchronized(obj) 获取了对象锁时如果竞争失败，从  <code>RUNNABLE --&gt; BLOCKED</code> </li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code>  的线程重新竞争，如果其中 t 线程竞争成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然  <code>BLOCKED</code> </li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TERMINATED</strong><ul>
<li>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></li>
</ul>
</li>
</ol>
<p>线程一共有六种状态：</p>
<ul>
<li>新建（new）</li>
<li>可运行（runnable）</li>
<li>阻塞（blocking）</li>
<li>无限期等待（waiting）</li>
<li>限期等待（timed waiting）</li>
<li>死亡（terminated）</li>
</ul>
<h5 id="1、新建（New）"><a href="#1、新建（New）" class="headerlink" title="1、新建（New）"></a>1、新建（New）</h5><p><strong>创建后尚未启动</strong>。</p>
<h5 id="2、可运行（Runnable）"><a href="#2、可运行（Runnable）" class="headerlink" title="2、可运行（Runnable）"></a>2、可运行（Runnable）</h5><p>可能正在运行，也可能正在等待 CPU 时间片。</p>
<p><strong>包含了操作系统线程状态中的 <code>Running</code> 和 <code>Ready</code>。</strong></p>
<h5 id="3、阻塞-Blocking"><a href="#3、阻塞-Blocking" class="headerlink" title="3、阻塞(Blocking)"></a>3、阻塞(Blocking)</h5><p><strong>等待获取一个排它锁，如果其线程释放了锁就会结束此状态</strong>。</p>
<h5 id="4、无限期等待-Waiting"><a href="#4、无限期等待-Waiting" class="headerlink" title="4、无限期等待(Waiting)"></a>4、无限期等待(Waiting)</h5><p><strong>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片</strong>。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>-</td>
</tr>
</tbody></table>
<h5 id="5、限期等待-Timed-Waiting"><a href="#5、限期等待-Timed-Waiting" class="headerlink" title="5、限期等待(Timed Waiting)"></a>5、限期等待(Timed Waiting)</h5><p><strong>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</strong></p>
<ul>
<li>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</li>
<li>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</li>
</ul>
<p><strong>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态</strong>。</p>
<p>阻塞和等待的区别：</p>
<ul>
<li><strong>阻塞是被动的，它是在等待获取一个排它锁</strong>。</li>
<li>而<strong>等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>-</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>-</td>
</tr>
</tbody></table>
<h5 id="6、死亡-Terminated"><a href="#6、死亡-Terminated" class="headerlink" title="6、死亡(Terminated)"></a>6、死亡(Terminated)</h5><p><strong>可以是线程结束任务之后自己结束，或者产生了异常而结束。</strong></p>
<h3 id="4、线程的四种使用方式"><a href="#4、线程的四种使用方式" class="headerlink" title="4、线程的四种使用方式"></a>4、线程的四种使用方式</h3><p>有三种使用线程的方法：</p>
<ul>
<li><strong>实现 Runnable 接口</strong>；</li>
<li><strong>实现 Callable 接口</strong>；</li>
<li><strong>继承 Thread 类</strong>；</li>
<li><strong>使用线程池</strong></li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h4 id="1、实现-Runnable-接口"><a href="#1、实现-Runnable-接口" class="headerlink" title="1、实现 Runnable 接口"></a>1、实现 Runnable 接口</h4><ol>
<li>编写需要的类并实现Runnable接口，实现里面的 run() 方法。</li>
<li>通过 Thread 调用 start() 方法来启动线程。</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现 Runnable 接口的优缺点：</p>
<ul>
<li>缺点：代码复杂一点。</li>
<li>优点：<ol>
<li>线程任务类只是实现了Runnable接口，可以继续继承其他类，避免了单继承的局限性</li>
<li>同一个线程任务对象可以被包装成多个线程对象</li>
<li>适合多个多个线程去共享同一个资源</li>
<li>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</li>
<li>线程池可以放入实现Runnable或Callable线程任务对象</li>
</ol>
</li>
</ul>
<h4 id="2、实现-Callable-接口"><a href="#2、实现-Callable-接口" class="headerlink" title="2、实现 Callable 接口"></a>2、实现 Callable 接口</h4><p>与Runnable 接口大致相同：</p>
<ol>
<li>编写需要的类并实现Callable接口，实现里面的 call() 方法，<strong>该方法有返回值</strong>。</li>
<li>通过 Thread 调用 start() 方法来启动线程。</li>
</ol>
<p>区别是：与 Runnable 相比，<strong>Callable 可以有返回值，返回值通过 FutureTask 进行封装</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Callable 接口的优缺点：</p>
<ul>
<li>优点：同 Runnable，并且能得到线程执行的结果</li>
<li>缺点：编码复杂</li>
</ul>
<h4 id="3、继承-Thread-类"><a href="#3、继承-Thread-类" class="headerlink" title="3、继承 Thread 类"></a>3、继承 Thread 类</h4><p><strong>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</strong></p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<p>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承 Thread 类的优缺点：</p>
<ul>
<li>优点：编码简单</li>
<li>缺点：线程类已经继承了Thread类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li>
</ul>
<h4 id="4、使用线程池"><a href="#4、使用线程池" class="headerlink" title="4、使用线程池"></a>4、使用线程池</h4><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池的具体细节放在下面线程池篇具体说明</p>
</blockquote>
<h4 id="5、Thread-与-Runnable-的底层关系"><a href="#5、Thread-与-Runnable-的底层关系" class="headerlink" title="5、Thread 与 Runnable 的底层关系"></a>5、Thread 与 Runnable 的底层关系</h4><p>使用Runnable的方法创建线程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123; log.debug(<span class="string">&quot;running&quot;</span>); &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>Thread底层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread的一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init调用了Thread的init初始化函数，其中将Runnable作为target对象传入</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该init函数调用了重载的其他init函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="comment">// 主要是这一句代码：将Runnable对象的target赋值给Thread本身的target</span></span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在该init函数里面将Runnable对象的target赋值给Thread本身的target，然后在Thread内部调用了run方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>Thread类本身实现了Runnable接口</li>
<li>如果直接使用Thread的方式创建线程对象，则原理是重写了Thread的run方法</li>
<li>如果使用的Runnable的方式创建线程对象，在原理是将Runnable对象封装成target，在Thread中调用target.run方法</li>
</ul>
<h4 id="6、实现接口-VS-继承-Thread"><a href="#6、实现接口-VS-继承-Thread" class="headerlink" title="6、实现接口 VS 继承 Thread"></a>6、实现接口 VS 继承 Thread</h4><p>实现接口会更好一些，因为：</p>
<ul>
<li><strong>使用接口更容易与线程池等高级 API 配合</strong></li>
<li><strong>使用接口让任务类脱离了 Thread 继承体系，更灵活</strong></li>
<li><strong>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</strong></li>
<li><strong>类可能只要求可执行就行，继承整个 Thread 类开销过大</strong>。</li>
</ul>
<h4 id="7、调用start-方法，线程是否会马上创建？"><a href="#7、调用start-方法，线程是否会马上创建？" class="headerlink" title="7、调用start()方法，线程是否会马上创建？"></a>7、调用start()方法，线程是否会马上创建？</h4><ul>
<li>线程不一定马上创建的</li>
<li>看start()方法的源码知道start()方法底层调用了start0()方法，这是一个被<code>native</code>修饰的方法，它的调用依赖于操作系统</li>
<li>当操作系统认为当前可以创建线程的时候，线程才会被创建</li>
</ul>
<h4 id="8、查看进程线程的方法"><a href="#8、查看进程线程的方法" class="headerlink" title="8、查看进程线程的方法"></a>8、查看进程线程的方法</h4><ul>
<li>windows<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill</code> 杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li><code>ps -fe</code> 查看所有进程</li>
<li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
<li><code>kill</code>  杀死进程</li>
<li><code>top 按大写 H</code> 切换是否显示线程</li>
<li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
</ul>
</li>
<li>Java<ul>
<li><code>jps 命令</code> 查看所有 Java 进程</li>
<li><code>jstack &lt;PID&gt;</code> 查看某个 Java 进程（PID）的所有线程状态</li>
<li><code>jconsole</code> 来查看某个 Java 进程中线程的运行情况（图形界面）<ul>
<li>jconsole 远程监控配置：<ul>
<li>需要以如下方式运行你的 java 类<ul>
<li>java -Djava.rmi.server.hostname=<code>ip地址</code> -Dcom.sun.management.jmxremote -<br>Dcom.sun.management.jmxremote.port=<code>连接端口</code> -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 java类</li>
</ul>
</li>
<li>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</li>
<li>如果要认证访问，还需要做如下步骤：<ul>
<li>复制 jmxremote.password 文件</li>
<li>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</li>
<li>连接时填入 controlRole（用户名），R&amp;D（密码）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9、线程运行的原理"><a href="#9、线程运行的原理" class="headerlink" title="9、线程运行的原理"></a>9、线程运行的原理</h4><h5 id="1、栈与栈帧"><a href="#1、栈与栈帧" class="headerlink" title="1、栈与栈帧"></a>1、栈与栈帧</h5><p>JVM 中由堆、栈、方法区所组成。</p>
<p>Java Virtual Machine Stacks （Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p>
<p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p>
<p>其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h5 id="2、线程上下文切换（Thread-Context-Switch）"><a href="#2、线程上下文切换（Thread-Context-Switch）" class="headerlink" title="2、线程上下文切换（Thread Context Switch）"></a>2、线程上下文切换（Thread Context Switch）</h5><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码。原因：</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Java 创建的线程是内核级线程，<strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换，这是非常消耗性能</li>
<li>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程</li>
</ul>
<h3 id="5、线程的常见方法"><a href="#5、线程的常见方法" class="headerlink" title="5、线程的常见方法"></a>5、线程的常见方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static(静态)</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束,最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName（String）</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：<code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code></td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除==打断标记==</td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 <code>sleep</code>，<code>wait</code>，<code>join</code> 会导致被打断的线程抛出 InterruptedException，并清除==打断标记== ；如果打断的正在运行的线程，则会设置==打断标记==；park 的线程被打断，也会设置==打断标记==</td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除==打断标记==</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h3 id="6、不推荐的方法"><a href="#6、不推荐的方法" class="headerlink" title="6、不推荐的方法"></a>6、不推荐的方法</h3><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume()</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<h3 id="7、基础线程机制"><a href="#7、基础线程机制" class="headerlink" title="7、基础线程机制"></a>7、基础线程机制</h3><h4 id="1、Executor"><a href="#1、Executor" class="headerlink" title="1、Executor"></a>1、Executor</h4><p><strong><code>Executor</code> 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期</strong>。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li><code>CachedThreadPool</code>： 一个任务创建一个线程；</li>
<li><code>FixedThreadPool</code>：所有任务只能使用固定大小的线程；</li>
<li><code>SingleThreadExecutor</code>：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<p>具体使用：（代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、Daemon"><a href="#2、Daemon" class="headerlink" title="2、Daemon"></a>2、Daemon</h4><p><strong>守护线程是程序运行时在后台提供服务的线程，属于程序中不可或缺的一部分</strong>。</p>
<p><strong>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</strong>。</p>
<p>main() 属于非守护线程。</p>
<p>使用 <code>setDaemon()</code> 方法将一个线程设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、sleep"><a href="#3、sleep" class="headerlink" title="3、sleep()"></a>3、sleep()</h4><p><strong>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为==毫秒==。</strong></p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例——防止CPU占用100"><a href="#案例——防止CPU占用100" class="headerlink" title="案例——防止CPU占用100%"></a>案例——防止CPU占用100%</h5><p>在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权给其他程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCpu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用 wait 或 条件变量达到类似的效果</li>
<li>不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</li>
<li>sleep 适用于无需锁同步的场景</li>
</ul>
<h4 id="4、yield"><a href="#4、yield" class="headerlink" title="4、yield()"></a>4、yield()</h4><p>对静态方法 Thread.yield() 的调用<strong>声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</strong>(让位操作)。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、run-start、sleep-yield、线程优先级"><a href="#5、run-start、sleep-yield、线程优先级" class="headerlink" title="5、run/start、sleep/yield、线程优先级"></a>5、run/start、sleep/yield、线程优先级</h4><h5 id="1、run与start"><a href="#1、run与start" class="headerlink" title="1、run与start"></a>1、run与start</h5><h6 id="1、run"><a href="#1、run" class="headerlink" title="1、run"></a>1、run</h6><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p>
<h6 id="2、start"><a href="#2、start" class="headerlink" title="2、start"></a>2、start</h6><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p>
<p>说明：<strong>线程控制资源类</strong></p>
<h6 id="3、面试问题：run-方法中的异常不能抛出，只能-try-catch"><a href="#3、面试问题：run-方法中的异常不能抛出，只能-try-catch" class="headerlink" title="3、面试问题：run() 方法中的异常不能抛出，只能 try/catch"></a>3、<strong>面试问题</strong>：run() 方法中的异常不能抛出，只能 try/catch</h6><ul>
<li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li>
<li>异常不能跨线程传播回 main() 中，因此必须在本地进行处理</li>
</ul>
<h6 id="4、run与start之间的区别"><a href="#4、run与start之间的区别" class="headerlink" title="4、run与start之间的区别"></a>4、run与start之间的区别</h6><ul>
<li><p>直接调用 run 是在主线程中执行了 run，<strong>没有启动新的线程</strong>，相当于变成了普通类的执行，此时将只有主线程在执行该线程</p>
</li>
<li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p>
</li>
<li><p>调用start()方法之前与之后线程的状态：</p>
<ul>
<li><p>代码：</p>
<ul>
<li><pre><code class="java">public class Test5 &#123;
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(&quot;t1&quot;) &#123;
            @Override
            public void run() &#123;
                log.debug(&quot;running...&quot;);
            &#125;
        &#125;;

        System.out.println(t1.getState());
        t1.start();
        System.out.println(t1.getState());
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 结果：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;sh</span><br><span class="line">    NEW</span><br><span class="line">    RUNNABLE</span><br><span class="line">    12:51:05.298 [t1] c.Test5 - running...</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2、sleep与yield之间的区别"><a href="#2、sleep与yield之间的区别" class="headerlink" title="2、sleep与yield之间的区别"></a>2、sleep与yield之间的区别</h5><h6 id="1、sleep"><a href="#1、sleep" class="headerlink" title="1、sleep"></a>1、sleep</h6><ul>
<li>调用 sleep 会让当前线程从 <code>Running</code>  进入 <code>Timed Waiting</code> 状态（阻塞）<ul>
<li>使用sleep后，线程失去cpu的时间片。同时也不能在获取cpu的时间片。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>   其它线程可以使用  interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>   睡眠结束后的线程未必会立刻得到执行</li>
<li>   建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ol>
<h6 id="2、yield"><a href="#2、yield" class="headerlink" title="2、yield"></a>2、yield</h6><ul>
<li>调用 yield 会让当前线程从 <code>Running</code> 进入 <code>Runnable</code>  就绪状态，然后调度执行其它线程<ul>
<li>使用yield后，如果线程进入Runnable就绪状态还是有可能签到cpu时间片的，这是与sleep()最大的不同</li>
</ul>
</li>
</ul>
<ol start="2">
<li>   具体的实现依赖于操作系统的任务调度器</li>
<li>   <strong>会放弃 CPU 资源，锁资源不会释放</strong></li>
</ol>
<h6 id="3、线程优先级（priority）"><a href="#3、线程优先级（priority）" class="headerlink" title="3、线程优先级（priority）"></a>3、线程优先级（priority）</h6><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h3 id="8、线程中断"><a href="#8、线程中断" class="headerlink" title="8、线程中断"></a>8、线程中断</h3><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h4 id="1、InterruptedException"><a href="#1、InterruptedException" class="headerlink" title="1、InterruptedException"></a>1、InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是<strong>不能中断 I/O 阻塞和 synchronized 锁阻塞</strong>。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2、interrupted"><a href="#2、interrupted" class="headerlink" title="2、interrupted()"></a>2、interrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么<strong>调用线程的 interrupt() 方法就无法使线程提前结束</strong>。</p>
<p>但是<strong>调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure>



<h4 id="3、Executor-的中断操作"><a href="#3、Executor-的中断操作" class="headerlink" title="3、Executor 的中断操作"></a>3、Executor 的中断操作</h4><ol>
<li>调用 Executor 的 <code>shutdown()</code> 方法会等待线程都执行完毕之后再关闭，</li>
<li>但是如果调用的是 <code>shutdownNow()</code> 方法，则相当于调用每个线程的 interrupt() 方法。</li>
</ol>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p><strong>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<h3 id="9、线程互斥同步"><a href="#9、线程互斥同步" class="headerlink" title="9、线程互斥同步"></a>9、线程互斥同步</h3><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问：</p>
<ol>
<li>第一个是 JVM 实现的 synchronized；</li>
<li>而另一个是 JDK 实现的 ReentrantLock。</li>
</ol>
<h4 id="1、synchronized"><a href="#1、synchronized" class="headerlink" title="1、synchronized"></a>1、synchronized</h4><h5 id="1、同步一个代码块"><a href="#1、同步一个代码块" class="headerlink" title="1、同步一个代码块"></a>1、同步一个代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</strong>。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h5 id="2、同步一个方法"><a href="#2、同步一个方法" class="headerlink" title="2、同步一个方法"></a>2、同步一个方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它和同步代码块一样，作用于同一个对象。</strong></p>
<h5 id="3、同步一个类"><a href="#3、同步一个类" class="headerlink" title="3、同步一个类"></a>3、同步一个类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h5 id="4、同步一个静态方法"><a href="#4、同步一个静态方法" class="headerlink" title="4、同步一个静态方法"></a>4、同步一个静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用于整个类。</strong></p>
<h4 id="2、ReentrantLock（JUC中的ReentrantLock）"><a href="#2、ReentrantLock（JUC中的ReentrantLock）" class="headerlink" title="2、ReentrantLock（JUC中的ReentrantLock）"></a>2、ReentrantLock（JUC中的ReentrantLock）</h4><p>ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<h4 id="3、比较"><a href="#3、比较" class="headerlink" title="3、比较"></a>3、比较</h4><ul>
<li><strong>锁的实现</strong><ul>
<li>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li>
</ul>
</li>
<li><strong>性能</strong><ul>
<li>新版本 Java 对 synchronized 进行了很多优化，例如==自旋锁==等，synchronized 与 ReentrantLock 大致相同。</li>
</ul>
</li>
<li><strong>等待可中断</strong><ul>
<li><strong>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</strong>。<ul>
<li><strong>ReentrantLock 可中断</strong>；</li>
<li><strong>而 synchronized 不行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>公平锁</strong><ul>
<li><strong>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</strong>。<ul>
<li><strong>synchronized 中的锁是非公平的</strong>；</li>
<li><strong>ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>锁绑定多个条件</strong><ul>
<li>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li>
</ul>
</li>
</ul>
<h4 id="4、使用选择"><a href="#4、使用选择" class="headerlink" title="4、使用选择"></a>4、使用选择</h4><p><strong>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</strong>。</p>
<p>这是因为：</p>
<ol>
<li>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</li>
<li>并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li>
</ol>
<h3 id="10、线程之间的协作"><a href="#10、线程之间的协作" class="headerlink" title="10、线程之间的协作"></a>10、线程之间的协作</h3><p><strong>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</strong>。</p>
<h4 id="1、join"><a href="#1、join" class="headerlink" title="1、join()"></a>1、join()</h4><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>原理：调用者轮询检查线程 alive 状态，t1.join()等价于：原理：调用者轮询检查线程 alive 状态，t1.join()等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">    	t1.wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前线程的对象锁，而不是外面的锁</strong></li>
<li>t1 会强占 CPU 资源，直至线程执行结束，当调用某个线程的 join 方法后，该线程抢占到 CPU 资源，就不再释放，直到线程执行完毕</li>
</ul>
<p>线程同步：</p>
<ul>
<li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul>
<li>需要外部共享变量，不符合面向对象封装的思想</li>
<li>必须等待线程结束，不能配合线程池使用</li>
</ul>
</li>
<li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul>
<li>main 线程接收结果</li>
<li>get 方法是让调用线程同步等待</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//不等待线程执行结束，输出的10</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、为什么需要join"><a href="#1、为什么需要join" class="headerlink" title="1、为什么需要join()"></a>1、为什么需要join()</h5><p>如果想要某线程（A）优先于某线程（B）运行（场景：线程B需要线程A的运算结果），这个时候就得线程B就需要使用join()来挂起当前线程，直到目标线程（A）结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<h5 id="2、为什么不用sleep-，而使用join"><a href="#2、为什么不用sleep-，而使用join" class="headerlink" title="2、为什么不用sleep()，而使用join()"></a>2、为什么不用sleep()，而使用join()</h5><p>使用sleep也可以实现以上效果，但是不好：因为在设计情况下你不清楚A线程需要多次时间得到运算结果，所以B线程不知道要sleep多少时间。</p>
<h5 id="3、join-long"><a href="#3、join-long" class="headerlink" title="3、join(long)"></a>3、join(long)</h5><p>join(long)可以设置等待时间，单位是ms。</p>
<ul>
<li>如果到了设置的时间还没有结果，线程会结束等待，继续往下运行</li>
<li>如果在设置的时间之前就应经有结果了，线程会立即往下运行，不会等到设定的时间</li>
</ul>
<h5 id="4、join的底层原理——保护性暂停模式的时间增强"><a href="#4、join的底层原理——保护性暂停模式的时间增强" class="headerlink" title="4、join的底层原理——保护性暂停模式的时间增强"></a>4、join的底层原理——保护性暂停模式的时间增强</h5><p>先看一下join的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 经历时间</span></span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相关判断</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="comment">// 延迟时间，相当于保护性暂停中的waitTime</span></span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将join的底层实现与保护性暂停模式的时间增强进行对比，会发现join的底层用的是保护性暂停模式的时间增强</p>
<h4 id="2、wait-、notify-、notifyAll"><a href="#2、wait-、notify-、notifyAll" class="headerlink" title="2、wait()、notify()、notifyAll()"></a>2、wait()、notify()、notifyAll()</h4><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<ul>
<li><p><code>obj.wait()</code> 让进入 object 监视器的线程到 waitSet 等待</p>
<ul>
<li><p>wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</p>
</li>
<li><p>wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p>
</li>
<li><p>其实还有一个wait(long timeout, int nanos)方法，只是这个方法是一个无效方法：它的意思是可以把时间精确到纳秒，而实际上无论你在第二个参数填写什么值（大于0小于999999），他都只是将第一个参数的值加一</p>
</li>
<li><pre><code class="java">public final void wait(long timeout, int nanos) throws InterruptedException &#123;
    if (timeout &lt; 0) &#123;
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    &#125;

    if (nanos &lt; 0 || nanos &gt; 999999) &#123;
        throw new IllegalArgumentException(
            &quot;nanosecond timeout value out of range&quot;);
    &#125;

    if (nanos &gt; 0) &#123;
        timeout++;
    &#125;

    wait(timeout);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;obj.notify()&#96; 在 object 上正在 waitSet 等待的线程中挑一个唤醒</span><br><span class="line"></span><br><span class="line">-  &#96;obj.notifyAll()&#96; 让 object 上正在 waitSet 等待的线程全部唤醒</span><br><span class="line"></span><br><span class="line">**它们都属于 Object 的一部分，而不属于 Thread**。</span><br><span class="line"></span><br><span class="line">**&#x3D;&#x3D;只能用在同步方法或者同步控制块中使用&#x3D;&#x3D;**，否则会在运行时抛出 &#96;IllegalMonitorStateExeception&#96;。也侧面说明了wait&#x2F;notify只能用在重量级锁。</span><br><span class="line"></span><br><span class="line">**使用 wait() 挂起期间，线程会释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class WaitNotifyExample &#123;</span><br><span class="line">    public synchronized void before() &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void after() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h5 id="1、wait-和-sleep-的区别"><a href="#1、wait-和-sleep-的区别" class="headerlink" title="1、wait() 和 sleep() 的区别"></a>1、wait() 和 sleep() 的区别</h5><ul>
<li><strong>sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用</strong>；</li>
<li>**sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)**。</li>
<li><strong>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</strong></li>
</ul>
<h5 id="2、wait-和-sleep-的共同点"><a href="#2、wait-和-sleep-的共同点" class="headerlink" title="2、wait() 和 sleep() 的共同点"></a>2、wait() 和 sleep() 的共同点</h5><ul>
<li><strong>它们都可以被 interrupted 方法中断</strong>。</li>
<li><strong>它们状态 <code>TIMED_WAITING</code></strong></li>
<li><strong>在哪里睡着，就在哪里醒来</strong>。</li>
</ul>
<h4 id="3、await-、signal-、signalAll"><a href="#3、await-、signal-、signalAll" class="headerlink" title="3、await()、signal()、signalAll()"></a>3、await()、signal()、signalAll()</h4><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。<strong>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活</strong>。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>



<h4 id="4、interrupt"><a href="#4、interrupt" class="headerlink" title="4、interrupt"></a>4、interrupt</h4><h5 id="1、打断-sleep，wait，join-的线程"><a href="#1、打断-sleep，wait，join-的线程" class="headerlink" title="1、打断 sleep，wait，join 的线程"></a>1、打断 sleep，wait，join 的线程</h5><p>sleep，wait，join、这几个方法都会让线程进入阻塞状态（join底层就是wait，其实join与wait本质上是一样的）</p>
<p>可以使用interrupt方法来打断线程：</p>
<ul>
<li>如果打断的是阻塞的线程，会清空打断状态，打断状态为false</li>
<li>如果打断的是正常运行的线程，不会清空打断状态，打断状态为true<ul>
<li>对于Running的线程，也就是正常运行的线程被打断(interrupt)后，不会立刻中断它，而是将其的打断标记isInterrupted()设置为true，可以在正常运行的线程中通过这个打断标记来选择是否终止自身线程。</li>
<li>也就是说：因为直接把线程终结了，人家线程事情都没干完。不如跟他说一声，说我要打断你，他处理完事情后自行了断不更好</li>
</ul>
</li>
</ul>
<h5 id="2、多线程设计模式——两阶段终止"><a href="#2、多线程设计模式——两阶段终止" class="headerlink" title="2、多线程设计模式——两阶段终止"></a>2、多线程设计模式——两阶段终止</h5><p>详细请看——并发的相关多线程设计模式</p>
<h5 id="3、打断-park-线程"><a href="#3、打断-park-线程" class="headerlink" title="3、打断 park 线程"></a>3、打断 park 线程</h5><p>打断 park 线程，不会清空打断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21:11:19.373 [t1] c.TestInterrupt - park... </span><br><span class="line">21:11:20.371 [t1] c.TestInterrupt - unpark... </span><br><span class="line">21:11:20.371 [t1] c.TestInterrupt - 打断状态：<span class="literal">true</span> </span><br></pre></td></tr></table></figure>

<p>如果打断标记已经是 true，则 park 会失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">21:11:54.003 [t1] c.TestInterrupt - park... </span><br><span class="line">21:11:55.002 [t1] c.TestInterrupt - unpark... </span><br><span class="line">21:11:55.002 [t1] c.TestInterrupt - 打断状态：<span class="literal">true</span> </span><br><span class="line">21:11:55.005 [t1] c.TestInterrupt - unpark... </span><br></pre></td></tr></table></figure>

<p>提示：可以使用 <code>Thread.interrupted()</code> 清除打断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().interrupted());</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4、关键字：synchronized详解"><a href="#4、关键字：synchronized详解" class="headerlink" title="4、关键字：synchronized详解"></a>4、关键字：synchronized详解</h2><p>在C程序代码中我们可以利用操作系统提供的互斥锁来实现同步块的互斥访问及线程的阻塞及唤醒等工作。在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语。</p>
<h3 id="1、BAT大厂的面试问题-2"><a href="#1、BAT大厂的面试问题-2" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h3><ul>
<li>Synchronized可以作用在哪里？分别通过对象锁和类锁进行举例。</li>
<li>Synchronized本质上是通过什么保证线程安全的？<ul>
<li>分三个方面回答：<ul>
<li>加锁和释放锁的原理</li>
<li>可重入原理</li>
<li>保证可见性原理</li>
</ul>
</li>
</ul>
</li>
<li>Synchronized有什么样的缺陷？Java Lock是怎么弥补这些缺陷的？</li>
<li>Synchronized和Lock的对比，和选择？</li>
<li>Synchronized在使用时有何注意事项？</li>
<li>Synchronized修饰的方法在抛出异常时，会释放锁吗？</li>
<li>多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程？</li>
<li>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法？</li>
<li>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办？</li>
<li>什么是锁的升级和降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？</li>
<li>不同的JDK中对Synchronized有何优化？</li>
</ul>
<h3 id="2、Synchronized的使用"><a href="#2、Synchronized的使用" class="headerlink" title="2、Synchronized的使用"></a>2、Synchronized的使用</h3><p>在应用Sychronized关键字时需要把握如下注意点：</p>
<ul>
<li><strong>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待</strong>；</li>
<li><strong>每个实例都对应有自己的一把锁(this)，不同实例之间互不影响</strong>；</li>
<li>例外：*<em>锁对象是</em>.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁**。</li>
<li><strong>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会==释放锁==</strong></li>
</ul>
<h4 id="1、对象锁"><a href="#1、对象锁" class="headerlink" title="1、对象锁"></a>1、对象锁</h4><p>包括==方法锁==(<strong>默认锁对象为this</strong>，<strong>当前实例对象</strong>)和==同步代码块锁==(<strong>自己指定锁对象</strong>)</p>
<h5 id="1、代码块形式"><a href="#1、代码块形式" class="headerlink" title="1、代码块形式"></a>1、代码块形式</h5><p>手动指定锁定对象：</p>
<ul>
<li><p>可以是this：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以是自定义的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    Object block1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object block2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">block1锁,我是线程Thread-0</span><br><span class="line">block1锁,Thread-0结束</span><br><span class="line">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="line">block1锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-0结束</span><br><span class="line">block1锁,Thread-1结束</span><br><span class="line">block2锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-1结束</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、方法锁形式：synchronized修饰普通方法，锁对象默认为this"><a href="#2、方法锁形式：synchronized修饰普通方法，锁对象默认为this" class="headerlink" title="2、方法锁形式：synchronized修饰普通方法，锁对象默认为this"></a>2、方法锁形式：synchronized修饰普通方法，锁对象默认为this</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure>



<h4 id="2、类锁"><a href="#2、类锁" class="headerlink" title="2、类锁"></a>2、类锁</h4><p>指synchronize修饰静态的方法或指定锁对象为Class对象。</p>
<h5 id="1、synchronize修饰静态方法"><a href="#1、synchronize修饰静态方法" class="headerlink" title="1、synchronize修饰静态方法"></a>1、synchronize修饰静态方法</h5><p>synchronize修饰普通方法与修饰静态方法的区别：</p>
<ul>
<li>synchronized用在普通方法上，默认的锁就是this，当前实例</li>
<li>synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</li>
</ul>
<p>修饰普通方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence1 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence2 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在普通方法上，默认的锁就是this，当前实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// t1和t2对应的this是两个不同的实例，所以代码不会串行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line">Thread-0结束</span><br></pre></td></tr></table></figure>

<p>修饰静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence1 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence2 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure>

<h5 id="2、synchronized指定锁对象为Class对象"><a href="#2、synchronized指定锁对象为Class对象" class="headerlink" title="2、synchronized指定锁对象为Class对象"></a>2、synchronized指定锁对象为Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence1 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence2 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有线程需要的锁都是同一把</span></span><br><span class="line">        <span class="keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure>



<h4 id="3、关于synchronized锁的总结"><a href="#3、关于synchronized锁的总结" class="headerlink" title="3、关于synchronized锁的总结"></a>3、关于synchronized锁的总结</h4><p>对于Synchronized实现同步的基础：java中每一个对象都可以作为锁。</p>
<p>具体可以分为以下三种情况：</p>
<ul>
<li><strong>对于普通同步方法，锁是当前实例对象</strong>；（对象锁）</li>
<li><strong>对于静态同步方法，锁是当前类的Class 对象</strong>；（类锁）</li>
<li><strong>对于同步方法块，锁是Synchonized 括号里配置的对象</strong></li>
</ul>
<p>对于对象锁：</p>
<ul>
<li>如果<strong>一个实例对象</strong>的<strong>非静态同步方法</strong>获取锁后，<strong>该实例对象的其他非静态同步方法</strong>必须等待获取锁的方法释放锁后才能获取锁；</li>
<li><strong>别的实例对象的非静态同步方法</strong>因为跟该实例对象的非静态同步方法用的<strong>是不同的锁</strong>， 所以无须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁；</li>
<li><strong>每一个对象都有属于自己的对象锁（可以有多把对象锁）</strong>。</li>
</ul>
<p>对于类锁：</p>
<ul>
<li>所有的静态同步方法用的也是同一把锁——类对象本身（类锁），这与对象锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的；</li>
<li>一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁；</li>
<li>但不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，<strong>只要它们同一个类的实例对象</strong>！</li>
<li><strong>类锁只有一把</strong>。</li>
</ul>
<p>对于同步代码块：</p>
<ul>
<li>同步代码块的锁是Synchonized 括号里配置的对象；</li>
<li>如果Synchonized 括号里是对象，那么他就是对象锁；如果Synchonized 括号里是类，那么他就是类锁；</li>
<li>所以他可以有一把，也可以有多把（主要看如果Synchonized 括号里是类还是对象）</li>
</ul>
<p>举个例子：把synchronized的锁看成一座大楼</p>
<ul>
<li>类锁就是锁住大楼的锁</li>
<li>对象锁就是锁住大楼里面房间的锁，每一个房间都有属于它的一把锁</li>
</ul>
<h3 id="3、Synchronized的原理分析"><a href="#3、Synchronized的原理分析" class="headerlink" title="3、Synchronized的原理分析"></a>3、Synchronized的原理分析</h3><h4 id="1、加锁和释放锁的原理"><a href="#1、加锁和释放锁的原理" class="headerlink" title="1、加锁和释放锁的原理"></a>1、加锁和释放锁的原理</h4><p>现象、时机(内置锁this)、深入JVM看字节码(反编译看monitor指令)</p>
<ol>
<li><p>深入JVM看字节码，创建如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用javac命令进行编译生成.class文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;javac SynchronizedDemo2.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用javap命令反编译查看.class文件的信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;javap -verbose SynchronizedDemo2.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到如下的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">	stack=<span class="number">2</span>，locals=<span class="number">3</span>，args_size=<span class="number">1</span></span><br><span class="line">		0: getstatic		#2			// &lt;- lock引用( synchronized开始)</span><br><span class="line">		<span class="number">3</span>: dup</span><br><span class="line">		<span class="number">4</span>: astore_1 					<span class="comment">// lock引用 -&gt; slot 1</span></span><br><span class="line">		<span class="number">5</span>: monitorenter					<span class="comment">// 将lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line">		6: getstatic		#3			// &lt;- i</span><br><span class="line">		<span class="number">9</span>: iconst_1						<span class="comment">// 准备常数1</span></span><br><span class="line">		<span class="number">10</span>: iadd						<span class="comment">// +1</span></span><br><span class="line">		11: putstatic		#3			// -&gt; i</span><br><span class="line">		<span class="number">14</span>: aload_1						<span class="comment">// &lt;- lock引用</span></span><br><span class="line">		<span class="number">15</span>: monitorexit					<span class="comment">// 将lock对象 MarkWord 重置，唤醒EntryList</span></span><br><span class="line">		<span class="number">16</span>: goto			<span class="number">24</span></span><br><span class="line">		<span class="number">19</span>: astore_2					<span class="comment">// e -&gt; slot2</span></span><br><span class="line">        <span class="number">20</span>: aload_1						<span class="comment">// &lt;- lock引用</span></span><br><span class="line">		<span class="number">21</span>: monitorexit					<span class="comment">// 将 lock 对象 MarkWord 重置，唤醒EntryList</span></span><br><span class="line">		<span class="number">22</span>: aload_2						<span class="comment">// &lt;- slot 2 (e)</span></span><br><span class="line">		<span class="number">23</span>: athrow						<span class="comment">// throw e</span></span><br><span class="line">		<span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">	Exception table:</span><br><span class="line">		from	to	  target	type</span><br><span class="line">		<span class="number">6</span>		<span class="number">16</span>	  <span class="number">19</span>		any</span><br><span class="line">		<span class="number">19</span>		<span class="number">22</span>	  <span class="number">19</span>		any</span><br><span class="line">	LineNumberTable:</span><br><span class="line">		line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">		line <span class="number">9</span>: <span class="number">6</span></span><br><span class="line">		line <span class="number">10</span>: <span class="number">14</span></span><br><span class="line">		line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">	LocalVar iableTable:</span><br><span class="line">		Start  Length  Slot  Name  Signature</span><br><span class="line">		<span class="number">0</span>	   <span class="number">25</span>	   <span class="number">0</span>	 args  [Ljava/lang/String;</span><br><span class="line">	StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">		frame_type = <span class="number">255</span> <span class="comment">/* full_ _frame */</span></span><br><span class="line">			offset_delta = <span class="number">19</span></span><br><span class="line">			locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/object ]</span><br><span class="line">			stack = [ class java/lang/Throwable ]</span><br><span class="line">		frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">			offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意：</p>
<ul>
<li><strong>方法级别的 synchronized 不会在字节码指令中有所体现</strong></li>
<li>在字节码中的<code>16: goto            24</code>当中，执行到这里会跳转到第24行的字节码执行<code>24：return</code>返回</li>
<li>那么第19行到第23行的字节码的作用是什么？<ul>
<li>仔细阅读字节码的内容会发现：他们的作用是当同步代码块中的内容出现异常的时候，为了防止当前的锁得不到释放而造成死锁，在第19到第23行进行<strong>异常的抛出</strong>和<strong>锁的释放</strong></li>
</ul>
</li>
</ul>
<p>关注字节码当中的<code>monitorenter</code>和<code>monitorexit</code>即可。</p>
<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p>
<ul>
<li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li>
<li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p>
<p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-2.png" alt="img"></p>
<p>该图可以看出，任意线程对Object的访问，首先要获得Object的监视器monitor，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
<h4 id="2、可重入原理：加锁次数计数器"><a href="#2、可重入原理：加锁次数计数器" class="headerlink" title="2、可重入原理：加锁次数计数器"></a>2、可重入原理：加锁次数计数器</h4><p>上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是<strong>锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁</strong>。</p>
<p><strong>Synchronized先天具有重入性</strong>。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p>
<h4 id="3、保证可见性的原理：内存模型和happens-before规则"><a href="#3、保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="3、保证可见性的原理：内存模型和happens-before规则"></a>3、保证可见性的原理：内存模型和happens-before规则</h4><p>Synchronized的happens-before规则，即监视器锁规则：<strong>对同一个监视器的解锁，happens-before于对该监视器的加锁</strong>。继续来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">        a++;                                <span class="comment">// 2</span></span><br><span class="line">    &#125;                                       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">    &#125;                                      <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码的happens-before关系如图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-3.png" alt="img"></p>
<p>在图中每一个箭头连接的两个节点就代表之间的happens-before关系：</p>
<ul>
<li>黑色的是通过程序顺序规则推导出来，</li>
<li>红色的为监视器锁规则推导而出：<ul>
<li>线程A释放锁happens-before线程B加锁；</li>
</ul>
</li>
<li>蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。<ul>
<li>现在我们来重点关注：<code>2 happens-before 5</code>，通过这个关系我们可以得出什么？<ul>
<li>根据happens-before的定义中的一条：如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由<code>2 happens-before 5</code>关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、synchronized-是给对象加锁的原理——对象的对象头"><a href="#4、synchronized-是给对象加锁的原理——对象的对象头" class="headerlink" title="4、synchronized 是给对象加锁的原理——对象的对象头"></a>4、synchronized 是给对象加锁的原理——对象的对象头</h4><p>synchronized 对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：<strong>对象头</strong>（Header）、<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong>（Padding）。</p>
<ul>
<li><strong>对象头</strong>：我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：<ul>
<li>Mark Word（标记字段）</li>
<li>Klass Pointer（类型指针）</li>
</ul>
</li>
</ul>
<p>以 32 位虚拟机为例：</p>
<p>普通对象：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|--------------------------------------------------------------|</span></span><br><span class="line"><span class="params">|                     Object Header (64 bits)                  |</span> </span><br><span class="line"><span class="params">|------------------------------------|</span>-------------------------<span class="params">| </span></span><br><span class="line"><span class="params">|</span>        Mark Word (<span class="number">32</span> bits)         <span class="params">|    Klass Word (32 bits) |</span> </span><br><span class="line"><span class="params">|------------------------------------|</span>-------------------------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>数组对象：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|---------------------------------------------------------------------------------|</span> </span><br><span class="line"><span class="params">|                                 Object Header (96 bits)                         |</span> </span><br><span class="line"><span class="params">|--------------------------------|</span>-----------------------<span class="params">|------------------------|</span> </span><br><span class="line"><span class="params">|        Mark Word(32bits)       |</span>    Klass Word(<span class="number">32</span>bits) <span class="params">|  array length(32bits)  |</span> </span><br><span class="line"><span class="params">|--------------------------------|</span>-----------------------<span class="params">|------------------------|</span></span><br></pre></td></tr></table></figure>

<p>其中 Mark Word 结构为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------------------|</span>--------------------<span class="params">| </span></span><br><span class="line"><span class="params">|</span>                  Mark Word (<span class="number">32</span> bits)                  <span class="params">|       State        |</span> </span><br><span class="line"><span class="params">|-------------------------------------------------------|</span>--------------------<span class="params">| </span></span><br><span class="line"><span class="params">|</span>  <span class="symbol">hashcode:</span><span class="number">25</span>         <span class="params">| age:4 |</span> <span class="symbol">biased_lock:</span><span class="number">0</span> <span class="params">| 01     |</span>       Normal       <span class="params">| </span></span><br><span class="line"><span class="params">|</span>-------------------------------------------------------<span class="params">|--------------------|</span> </span><br><span class="line"><span class="params">|  thread:23 |</span> <span class="symbol">epoch:</span><span class="number">2</span> <span class="params">| age:4 |</span> <span class="symbol">biased_lock:</span><span class="number">1</span> <span class="params">| 01     |</span>       Biased       <span class="params">| </span></span><br><span class="line"><span class="params">|</span>-------------------------------------------------------<span class="params">|--------------------|</span> </span><br><span class="line"><span class="params">|               ptr_to_lock_record:30          |</span> <span class="number">00</span>     <span class="params">| Lightweight Locked |</span> </span><br><span class="line"><span class="params">|-------------------------------------------------------|</span>--------------------<span class="params">| </span></span><br><span class="line"><span class="params">|</span>               <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>  <span class="params">| 10     |</span> Heavyweight Locked <span class="params">| </span></span><br><span class="line"><span class="params">|</span>-------------------------------------------------------<span class="params">|--------------------|</span></span><br><span class="line"><span class="params">|                                              |</span> <span class="number">11</span>     <span class="params">|    Marked <span class="keyword">for</span> GC   |</span></span><br><span class="line"><span class="params">|-------------------------------------------------------|</span>--------------------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>64 位虚拟机 Mark Word：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span>                        Mark Word (<span class="number">64</span> bits)                         <span class="params">|       State        |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span> <span class="symbol">unused:</span><span class="number">25</span> <span class="params">| hashcode:31 |</span> <span class="symbol">unused:</span><span class="number">1</span> <span class="params">| age:4 |</span> <span class="symbol">biased_lock:</span><span class="number">0</span> <span class="params">| 01    |</span>       Normal       <span class="params">| |</span>--------------------------------------------------------------------<span class="params">|--------------------|</span> <span class="params">| thread:54 |</span> <span class="symbol">epoch:</span><span class="number">2</span>     <span class="params">| unused:1 |</span> <span class="symbol">age:</span><span class="number">4</span> <span class="params">| biased_lock:1 |</span> <span class="number">01</span>    <span class="params">|       Biased       |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span>             <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                          <span class="params">| 00    |</span> Lightweight Locked <span class="params">| |</span>--------------------------------------------------------------------<span class="params">|--------------------|</span> <span class="params">|             ptr_to_heavyweight_monitor:62                  |</span> <span class="number">10</span>    <span class="params">| Heavyweight Locked |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span>                                                            <span class="params">| 11    |</span>    Marked <span class="keyword">for</span> GC   <span class="params">|</span></span><br><span class="line"><span class="params">|</span>--------------------------------------------------------------------<span class="params">|--------------------|</span></span><br></pre></td></tr></table></figure>

<p><code>Monitor</code> 被翻译为<strong>监视器</strong>或<strong>管程</strong></p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针，如下图所示，右侧就是对象对应的 Monitor 对象。</p>
<p><img src="/2021/07/19/JUC/image-4.jpg" alt="图片"></p>
<p>当 Monitor 被某个线程持有后，就会处于锁定状态，如图中的 Owner 部分，会指向持有 Monitor 对象的线程。</p>
<p>另外 Monitor 中还有两个队列分别是<code>EntryList</code>和<code>WaitList</code>，主要是用来存放<strong>进入及等待获取锁的线程</strong>。</p>
<p>如果线程进入，则得到当前对象锁，那么别的线程在该类所有对象上的任何操作都不能进行。</p>
<ul>
<li><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li>
<li><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<p>Monitor 结构如下</p>
<p><img src="/2021/07/19/JUC/image-20210804223435390.png" alt="image-20210804223435390"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
</ul>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
<blockquote>
<p>在对象级使用锁通常是一种比较粗糙的方法，为什么要将整个对象都上锁，而不允许其他线程短暂地使用对象中其他同步方法来访问共享资源？</p>
</blockquote>
<p>如果一个对象拥有多个资源，就不需要只为了让一个线程使用其中一部分资源，就将所有线程都锁在外面。</p>
<p>由于每个对象都有锁，可以如下所示使用虚拟对象来上锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FineGrainLock</span></span>&#123;</span><br><span class="line">    MyMemberClass x,y;</span><br><span class="line">    Object xlock = <span class="keyword">new</span> Object(), ylock = newObject();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(xlock)&#123;</span><br><span class="line">            <span class="comment">//accessxhere</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomethinghere-butdon&#x27;tusesharedresources</span></span><br><span class="line">        <span class="keyword">synchronized</span>(ylock)&#123;</span><br><span class="line">            <span class="comment">//accessyhere</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//accessbothxandyhere</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomethinghere-butdon&#x27;tusesharedresources</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4、JVM中锁的优化"><a href="#4、JVM中锁的优化" class="headerlink" title="4、JVM中锁的优化"></a>4、JVM中锁的优化</h3><p><strong>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的</strong>，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)下，如果每次都调用Mutex Lock那么将严重的影响程序的性能。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p>
<ul>
<li><code>锁粗化(Lock Coarsening)</code>：也就是减少不必要的紧连在一起的unlock，lock操作，<strong>将多个连续的锁扩展成一个范围更大的锁</strong>。</li>
<li><code>锁消除(Lock Elimination)</code>：通<strong>过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护</strong>，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配（栈上分配）(同时还可以减少Heap上的垃圾收集开销)。</li>
<li><code>轻量级锁(Lightweight Locking)</code>：这种锁实现的背后基于这样一种假设，即<strong>在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</strong>(具体处理步骤下面详细讨论)。</li>
<li><code>偏向锁(Biased Locking)</code>：是<strong>为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令</strong>，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li>
<li><code>适应性自旋(Adaptive Spinning)</code>：<strong>当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态</strong>。</li>
</ul>
<h4 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h4><p>在Java SE 1.6里Synchronied同步锁，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级所</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级。<strong>锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率</strong>。</p>
<p>锁膨胀方向： <strong>无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</strong></p>
<h4 id="2、自旋锁与自适应自旋锁"><a href="#2、自旋锁与自适应自旋锁" class="headerlink" title="2、自旋锁与自适应自旋锁"></a>2、自旋锁与自适应自旋锁</h4><h5 id="1、自旋锁"><a href="#1、自旋锁" class="headerlink" title="1、自旋锁"></a>1、自旋锁</h5><p>引入背景：</p>
<p>大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。<strong>在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但==不放弃CPU的执行时间==。等待持有锁的线程是否很快就会释放锁</strong>。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p>
<p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。<strong>自旋锁本质上与阻塞并不相同</strong>，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的新能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，<strong>自旋锁默认的自旋次数为10次</strong>，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
<p>自旋重试成功的情况：</p>
<table>
<thead>
<tr>
<th>线程1 (core1上)</th>
<th>对象Mark</th>
<th>线程2 ( core2上)</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>10(重量锁)</td>
<td>-</td>
</tr>
<tr>
<td>访问同步块,获取monitor</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>成功(加锁)</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>访问同步块,获取monitor</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行完毕</td>
<td>10 (重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>成功(解锁)</td>
<td>01(无锁)</td>
<td>自旋重试</td>
</tr>
<tr>
<td>-</td>
<td>10 (重量锁)重量锁指针</td>
<td>成功(加锁)</td>
</tr>
<tr>
<td>-</td>
<td>10 (重量锁)重量锁指针</td>
<td>执行同步块</td>
</tr>
<tr>
<td>-</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>自旋重试失败的情况：</p>
<table>
<thead>
<tr>
<th>线程1 (core1上)</th>
<th>对象Mark</th>
<th>线程2 ( core2上)</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>10(重量锁)</td>
<td>-</td>
</tr>
<tr>
<td>访问同步块,获取monitor</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>成功(加锁)</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>-</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>访问同步块,获取monitor</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>自旋重试</td>
</tr>
<tr>
<td>执行同步块</td>
<td>10 (重量锁)重量锁指针</td>
<td>阻塞</td>
</tr>
<tr>
<td>-</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p>
<h5 id="2、自适应自旋锁"><a href="#2、自适应自旋锁" class="headerlink" title="2、自适应自旋锁"></a>2、自适应自旋锁</h5><p>在JDK 1.6中引入了自适应自旋锁。这就意味着<strong>自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</strong>。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。</p>
<p>总结：</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="3、锁消除"><a href="#3、锁消除" class="headerlink" title="3、锁消除"></a>3、锁消除</h4><p>锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。<strong>锁消除的主要判定依据来源于逃逸分析的数据支持</strong>。意思就是：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</p>
<p>当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。</p>
<p>比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象（线程安全）的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象（线程不安全）的连续append()操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test03</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    String s = s1 + s2 + s3;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述代码使用javap 编译的结果：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-4.png" alt="img"></p>
<p>众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)</p>
<h4 id="4、锁粗化"><a href="#4、锁粗化" class="headerlink" title="4、锁粗化"></a>4、锁粗化</h4><p>原则上，我们都知道<strong>在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围</strong>(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p>
<p>大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。</p>
<p>这里贴上根据上述Javap 编译地情况编写的实例java类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test04</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述地连续append()操作中就属于这类情况。JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展(粗化)到整个一系列操作的外部，使整个一连串地append()操作只需要加锁一次就可以了。</p>
<h4 id="5、轻量级锁"><a href="#5、轻量级锁" class="headerlink" title="5、轻量级锁"></a>5、轻量级锁</h4><p>在JDK 1.6之后引入的轻量级锁，需要注意的是<strong>轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化</strong>。它可以<strong>减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能</strong>。</p>
<p>如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。在对象头中(<code>Object Header</code>)存在两部分：（对象头的大小：（压缩指针）12字节，（不支持压缩指针）16字节）</p>
<ol>
<li>第一部分用于<strong>存储对象自身的运行时数据</strong>，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为32位或者64位(视操作系统位数定)。官方称之为<code>Mark Word</code>，<strong>它是实现轻量级锁和偏向锁的关键</strong>。 </li>
<li>另外一部分存储的是<strong>指向方法区对象类型数据的指针</strong>(<code>Klass Point</code>)，<strong>如果对象是数组的话，还会有一个额外的部分用于存储数据的长度</strong>。</li>
</ol>
<h5 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h5><p>在线程执行同步块之前，JVM会先在当前线程的<strong>栈帧</strong>中创建一个名为锁记录(<code>Lock Record</code>)的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>)这个时候线程堆栈与对象头的状态如图：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-5.png" alt="img"></p>
<p><img src="/2021/07/19/JUC/image-20210804232649899.png" alt="image-20210804232649899"></p>
<p>如上图所示：如果当前对象没有被锁定，那么<code>锁标志位为01状态</code>，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p>
<p><img src="/2021/07/19/JUC/image-20210804233935482.png" alt="image-20210804233935482"></p>
<p>然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的<code>锁标志位更新</code>为(<code>Mark Word</code>中最后的2bit)<code>00</code>，即表示此对象处于轻量级锁定状态，如图：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-6.png" alt="img"></p>
<p><img src="/2021/07/19/JUC/image-20210804233158129.png" alt="image-20210804233158129"></p>
<p>如果这个更新操作失败：</p>
<ul>
<li>JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。（可重入锁）<ul>
<li><img src="/2021/07/19/JUC/image-20210804233645213.png" alt="image-20210804233645213"></li>
</ul>
</li>
<li>如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那**轻量级锁就不再有效，直接膨胀为重量级锁(锁膨胀)**，没有获得锁的线程会被阻塞。此时，<code>锁的标志位为10</code>。<code>Mark Word</code>中存储的时指向重量级锁的指针。</li>
</ul>
<p>轻量级解锁时：</p>
<ul>
<li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一<ul>
<li><img src="/2021/07/19/JUC/image-20210804234421675.png" alt="image-20210804234421675"></li>
</ul>
</li>
<li>锁记录的值不为 null，这时会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中：<ul>
<li>如果成功，则表示没有发生竞争关系，解锁成功</li>
<li>如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁，进入重量级锁的解锁流程</li>
</ul>
</li>
</ul>
<h4 id="6、锁膨胀"><a href="#6、锁膨胀" class="headerlink" title="6、锁膨胀"></a>6、锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁<ul>
<li><img src="/2021/07/19/JUC/image-20210805013827060.png" alt="image-20210805013827060"></li>
</ul>
</li>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
<li><img src="/2021/07/19/JUC/image-20210805013917321.png" alt="image-20210805013917321"></li>
<li>此时Object的对象头的锁标志为<code>10</code>。</li>
</ul>
</li>
<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<p>两个线程同时争夺锁，导致锁膨胀的流程图如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-7.png" alt="img"></p>
<h4 id="7、偏向锁"><a href="#7、偏向锁" class="headerlink" title="7、偏向锁"></a>7、偏向锁</h4><p>引入背景：</p>
<p><strong>在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换</strong>。</p>
<p>为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。<strong>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁</strong>。</p>
<h5 id="1、偏向状态"><a href="#1、偏向状态" class="headerlink" title="1、偏向状态"></a>1、偏向状态</h5><p>64 位虚拟机 Mark Word：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span>                        Mark Word (<span class="number">64</span> bits)                         <span class="params">|       State        |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span> <span class="symbol">unused:</span><span class="number">25</span> <span class="params">| hashcode:31 |</span> <span class="symbol">unused:</span><span class="number">1</span> <span class="params">| age:4 |</span> <span class="symbol">biased_lock:</span><span class="number">0</span> <span class="params">| 01    |</span>       Normal       <span class="params">| |</span>--------------------------------------------------------------------<span class="params">|--------------------|</span> <span class="params">| thread:54 |</span> <span class="symbol">epoch:</span><span class="number">2</span>     <span class="params">| unused:1 |</span> <span class="symbol">age:</span><span class="number">4</span> <span class="params">| biased_lock:1 |</span> <span class="number">01</span>    <span class="params">|       Biased       |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">| |</span>             <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                          <span class="params">| 00    |</span> Lightweight Locked <span class="params">| |</span>--------------------------------------------------------------------<span class="params">|--------------------|</span> <span class="params">|             ptr_to_heavyweight_monitor:62                  |</span> <span class="number">10</span>    <span class="params">| Heavyweight Locked |</span> <span class="params">|--------------------------------------------------------------------|</span>--------------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span>                                                            <span class="params">| 11    |</span>    Marked <span class="keyword">for</span> GC   <span class="params">|</span></span><br><span class="line"><span class="params">|</span>--------------------------------------------------------------------<span class="params">|--------------------|</span></span><br></pre></td></tr></table></figure>

<p>一个对象创建时：</p>
<ul>
<li>如果<strong>开启了偏向锁（默认开启）</strong>，那么对象创建后，markword 值为 0x05 即最后 3 位为 <code>101</code>，这时<strong>它的 thread、epoch、age 都为 0</strong></li>
<li><strong>偏向锁是默认是延迟的，不会在程序启动时立即生效</strong>，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟<ul>
<li>注意：<strong>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</strong>（54位的threadID）</li>
</ul>
</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 <code>001</code>，这时<strong>它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</strong></li>
<li>如果你想禁用偏向锁，添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li>
</ul>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-8.png" alt="img"></p>
<h5 id="2、偏向锁的撤销"><a href="#2、偏向锁的撤销" class="headerlink" title="2、偏向锁的撤销"></a>2、偏向锁的撤销</h5><h6 id="1、方法一：调用对象的hashCode方法（对象仍可偏向）"><a href="#1、方法一：调用对象的hashCode方法（对象仍可偏向）" class="headerlink" title="1、方法一：调用对象的hashCode方法（对象仍可偏向）"></a>1、方法一：调用对象的hashCode方法（对象仍可偏向）</h6><ul>
<li>如果默认开启了偏向锁，但当调用了对象的hashCode方法则会破坏对象的偏向锁<ul>
<li>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</li>
<li>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
<li>偏向锁没有其它记录hashCode的方法，所以调用对象的hashCode会撤销对象的偏向锁</li>
</ul>
</li>
<li>在调用 hashCode 后使用偏向锁，记得去掉 <code>-XX:-UseBiasedLocking</code>（禁用偏向锁）</li>
</ul>
</li>
</ul>
<h6 id="2、方法二：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁（对象变为不可偏向）"><a href="#2、方法二：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁（对象变为不可偏向）" class="headerlink" title="2、方法二：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁（对象变为不可偏向）"></a>2、方法二：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁（对象变为不可偏向）</h6><p>演示代码：（加上了VM参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBiased</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug( ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                TestBiased.class.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestBiased.class.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug( ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:48:31.674 c.TestBiased [t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101</span><br><span class="line">20:48:31.677 c.TestBiased [t1] - 00000000 00000000 00000000 00000000 00011111 10110110 11101000 00000101</span><br><span class="line">20:48:31.677 c.TestBiased [t1] - 00000000 00000000 00000000 00000000 00011111 10110110 11101000 00000101</span><br><span class="line">20:48:31.677 c.TestBiased [t2] - 00000000 00000000 00000000 00000000 00011111 10110110 11101000 00000101</span><br><span class="line">20:48:31.678 c.TestBiased [t2] - 00000000 00000000 00000000 00000000 00100000 01001011 11110011 00100000</span><br><span class="line">20:48:31.678 c.TestBiased [t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>由于t2线程使用了wait，所以t2需要t1线程的notify唤醒，所以t1线程肯定由于t2线程，得到偏向锁。然后唤醒t2线程后，t2线程去争夺锁，导致了t1线程的偏向锁的破坏，并且t1线程变为不可偏向。</li>
<li>第一行：由于禁用延迟，所以t1线程一开始就处于<code>101</code>的偏向锁，只是此时t1线程还没得到锁，所以它的 thread、epoch、age 都为 0</li>
<li>第二行：t1线程拿到了锁，Mark Word记录了当前线程的ThreadID（54位）、epoch（2位）、unused（1位）和age（4位）</li>
<li>第三行：t1线程释放了锁，由于t1线程为偏向锁，所以Mark Word依旧记录了t1线程的ThreadID（54位）</li>
<li>递四行：t1线程唤醒了t2线程，当此时t2x线程还没有抢夺t1线程的偏向锁，所以Mark Word没变</li>
<li>第五行：t2线程抢夺t1的偏向锁，破坏了t1线程的偏向锁，偏向锁膨胀为轻量级锁（Mark Word后三位为<code>000</code>）<ul>
<li>此时Mark Word记录的是ptr_to_lock_record:62</li>
</ul>
</li>
<li>第六行：t2线程释放锁，Mark Word后三位为<code>001</code></li>
</ul>
<p>底层：</p>
<p><strong>偏向锁使用了一种==等待竞争出现才会释放锁==的机制</strong>。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。但是<strong>偏向锁的撤销需要等到全局安全点</strong>(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，<strong>栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁</strong>。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-schronized-9.png" alt="img"></p>
<h6 id="3、调用-wait-notify"><a href="#3、调用-wait-notify" class="headerlink" title="3、调用 wait/notify"></a>3、调用 wait/notify</h6><p>因为 wait/notify（等待唤醒）模式是应用在重量级锁上的，所以调用 wait/notify就意味着此时是重量级锁，而不是偏向锁与轻量级锁。</p>
<h5 id="3、批量重偏向"><a href="#3、批量重偏向" class="headerlink" title="3、批量重偏向"></a>3、批量重偏向</h5><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<p><strong>当撤销偏向锁阈值超过 <code>20</code> 次后</strong>，jvm 会这样觉得，我是不是偏向错了呢，于是<strong>会在给这些对象加锁时重新偏向至加锁线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">            list.add(d);</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            Dog d = list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>)); </span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">[t1] - 0 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 1 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 2 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 3 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 4 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 5 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 6 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 7 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 8 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 9 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 10 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 11 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 12 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 13 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 14 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 15 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 16 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 17 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 18 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 19 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 20 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 21 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 22 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 23 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 24 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 25 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 26 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 27 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 28 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t1] - 29 		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - ===============&gt; </span><br><span class="line">[t2] - 0		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 0		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 0		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 1		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 1		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 1		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 2		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 2		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 2		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 3		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 3		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 3		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 4		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 4		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 4		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 5		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 5		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 5		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 6		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 6		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 6		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 7		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 7		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 7		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 8		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 8		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 8		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 9		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 9		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 9		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 10		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 10		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 10		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 11		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 11		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 11		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 12		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 12		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 12		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 13		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 13		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 13		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 14		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 14		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 14		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 15		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 15		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 15		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 16		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 16		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 16		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 17		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 17		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 17		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 18		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 18		00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000</span><br><span class="line">[t2] - 18		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 20		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 20		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 20		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 21		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 21		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 21		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 22		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 22		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 22		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 23		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 23		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 23		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 24		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 24		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 24		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 25		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 25		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 25		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 26		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 26		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 26		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 27		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 27		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 27		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 28		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 28		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 28		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 29		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 29		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 29		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br><span class="line">[t2] - 19		00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101</span><br></pre></td></tr></table></figure>

<p>在第20次（从0开始，到19）后，批量重偏向</p>
<h5 id="4、批量撤销"><a href="#4、批量撤销" class="headerlink" title="4、批量撤销"></a>4、批量撤销</h5><p><strong>当撤销偏向锁阈值超过 <code>40</code> 次后</strong>，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。<strong>于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBiased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1,t2,t3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Vector&lt;Dog&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> loopNumber = <span class="number">39</span>;</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">                Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">                list.add(d);</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">                Dog d = list.get(i);</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">                Dog d = list.get(i);</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t3.join();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Dog()).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<ul>
<li>t1线程前面的39个对象全部拥有了偏向锁<ul>
<li><img src="/2021/07/19/JUC/image-20210805043937707.png" alt="image-20210805043937707"></li>
</ul>
</li>
<li>t2线程前19次因为破坏了t1线程对象的偏向锁，升级为轻量级锁<ul>
<li><img src="/2021/07/19/JUC/image-20210805044214898.png" alt="image-20210805044214898"></li>
</ul>
</li>
<li>t2线程从第20次后进入批量重偏向，从第20次到第39次全部都是批量重偏向，t2线程拥有偏向锁<ul>
<li><img src="/2021/07/19/JUC/image-20210805044307591.png" alt="image-20210805044307591"></li>
</ul>
</li>
<li>t3线程的前19个对象为轻量级锁(t2修改为轻量级锁)<ul>
<li><img src="/2021/07/19/JUC/image-20210805044616494.png" alt="image-20210805044616494"></li>
</ul>
</li>
<li>t3线程从第20个对象开始，此时对象的偏向锁是偏向t2线程的，所以t3线程会破坏t2线程的偏向锁，升级为轻量级锁，从第20个到第39个都是这样。<ul>
<li><img src="/2021/07/19/JUC/image-20210805044906263.png" alt="image-20210805044906263"></li>
</ul>
</li>
<li>由于JVM进行了前39次的偏向锁撤销，在进行第40次撤销操作时，JVM会将整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的<ul>
<li><img src="/2021/07/19/JUC/image-20210805045205698.png" alt="image-20210805045205698"></li>
</ul>
</li>
<li>如果把loopNumber的值修改为38，即只进行38次偏向锁撤销，那么在第39次偏向锁撤销，JVM依旧会采用偏向锁升级为轻量级锁，此时的对象依旧是可偏向的（<code>101</code>）<ul>
<li><img src="/2021/07/19/JUC/image-20210805045456551.png" alt="image-20210805045456551"></li>
</ul>
</li>
</ul>
<h4 id="8、锁的优缺点对比"><a href="#8、锁的优缺点对比" class="headerlink" title="8、锁的优缺点对比"></a>8、锁的优缺点对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步快的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了响应速度</td>
<td>如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td>
<td>追求响应时间，同步快执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步快执行速度较长</td>
</tr>
</tbody></table>
<h3 id="5、Synchronized与Lock"><a href="#5、Synchronized与Lock" class="headerlink" title="5、Synchronized与Lock"></a>5、Synchronized与Lock</h3><h4 id="1、synchronized的缺陷"><a href="#1、synchronized的缺陷" class="headerlink" title="1、synchronized的缺陷"></a>1、synchronized的缺陷</h4><ul>
<li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时；</li>
<li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活</li>
<li><code>无法知道是否成功获得锁</code>，相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..</li>
<li>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：<ul>
<li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li>
<li>线程执行发生异常，此时 JVM 会让线程自动释放锁。</li>
</ul>
</li>
<li>那么如果这个获取锁的线程由于要等待 I/O 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</li>
</ul>
<h4 id="2、Lock解决相应问题"><a href="#2、Lock解决相应问题" class="headerlink" title="2、Lock解决相应问题"></a>2、Lock解决相应问题</h4><p>Lock类这里不做过多解释，主要看里面的4个方法：</p>
<ul>
<li><code>lock()</code>：加锁</li>
<li><code>unlock()</code>：解锁</li>
<li><code>tryLock()</code>：尝试获取锁，返回一个boolean值</li>
<li><code>tryLock(long,TimeUtil)</code>：尝试获取锁，可以设置超时</li>
</ul>
<p>Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p>
<p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。</p>
<p>Lock可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断）。</p>
<p><code>ReentrantLock的lockInterruptibly()方法</code>可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，<strong>使用ReentrantLock时就不会像synchronized那样产生死锁了</strong>。</p>
<p>注：</p>
<ul>
<li><code>ReentrantLock</code>为常用类，它是一个<strong>可重入的互斥锁 Lock</strong>，它具有与使用 synchronized 方法和语句所访问的<strong>隐式监视器锁</strong>相同的一些基本行为和语义，但功能更强大</li>
<li>JUC中的JUC锁：ReentrantLock</li>
</ul>
<h4 id="3、总结：Lock-与的-Synchronized-区别"><a href="#3、总结：Lock-与的-Synchronized-区别" class="headerlink" title="3、总结：Lock 与的 Synchronized 区别"></a>3、总结：Lock 与的 Synchronized 区别</h4><ul>
<li>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到；</li>
<li>Lock 可以提高多个线程进行读操作的效率。</li>
</ul>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而<strong>当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于synchronized</strong>。</p>
<h3 id="6、再深入理解"><a href="#6、再深入理解" class="headerlink" title="6、再深入理解"></a>6、再深入理解</h3><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。</p>
<ul>
<li><strong>使用Synchronized有哪些要注意的？</strong><ul>
<li><strong>锁对象不能为空，因为锁的信息都保存在对象头里</strong>；</li>
<li><strong>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</strong>；</li>
<li><strong>避免死锁</strong>；</li>
<li><strong>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</strong></li>
</ul>
</li>
<li><strong>synchronized是公平锁吗？</strong><ul>
<li><strong>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待</strong>；</li>
<li>不过这种抢占的方式<strong>可以预防饥饿</strong>。</li>
</ul>
</li>
<li><strong>使用Synchronized可以解决可见性问题吗？</strong><ul>
<li>可以在Java内存模型中，synchronized规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5、关键字：volatile详解"><a href="#5、关键字：volatile详解" class="headerlink" title="5、关键字：volatile详解"></a>5、关键字：volatile详解</h2><p>相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种<strong>解决可见性和有序性问题</strong>的方案。</p>
<h3 id="1、BAT大厂的面试问题-3"><a href="#1、BAT大厂的面试问题-3" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h3><ul>
<li>volatile关键字的作用是什么？</li>
<li>volatile能保证原子性吗？</li>
<li>之前32位机器上共享的long和double变量的为什么要用volatile？现在64位机器上是否也要设置呢？</li>
<li>i++为什么不能保证原子性？</li>
<li>volatile是如何实现可见性的？<ul>
<li>内存屏障</li>
</ul>
</li>
<li>volatile是如何实现有序性的？<ul>
<li>happens-before等</li>
</ul>
</li>
<li>说下volatile的应用场景？</li>
</ul>
<h3 id="2、volatile的作用详解"><a href="#2、volatile的作用详解" class="headerlink" title="2、volatile的作用详解"></a>2、volatile的作用详解</h3><h4 id="1、防重排序"><a href="#1、防重排序" class="headerlink" title="1、防重排序"></a>1、防重排序</h4><p>我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉<strong>单例模式</strong>的实现，而在并发环境下的单例实现方式，我们通常可以采用<strong>双重检查加锁(DCL)的方式来实现</strong>。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 向外界通过一个getInstance()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>
<p>注意：加上volatile的变量会保证在它之前的指令不会被重排序。原因：在加上volatile的变量的地方会加上一个内存屏障，保证在它之前的指令不会重排序到它下面去。</p>
<h4 id="2、实现可见性"><a href="#2、实现可见性" class="headerlink" title="2、实现可见性"></a>2、实现可见性</h4><p><strong>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到</strong>。引起可见性问题的主要原因是<strong>每个线程拥有自己的一个高速缓存区——线程工作内存</strong>。volatile关键字能有效的解决这个问题，我们看下面的例子，就可以知道其作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b + <span class="string">&quot;;a=&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> VolatileTest test = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直观上说，这段代码的结果只可能有两种：</p>
<ol>
<li>b=3;a=3</li>
<li> b=2;a=1</li>
</ol>
<p>不过运行上面的代码(可能时间上要长一点，概率要小很多)，你会发现除了上两种结果之外，还出现了第三种结果：</p>
<ul>
<li>b=3;a=1</li>
</ul>
<p>分析：为什么会出现b=3;a=1这种结果呢? </p>
<ul>
<li>正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。</li>
<li>相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。</li>
<li>那b=3;a=1的结果是怎么出来的？<ul>
<li> 原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。</li>
<li>如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</li>
</ul>
</li>
</ul>
<h4 id="3、保证原子性：单次读-写"><a href="#3、保证原子性：单次读-写" class="headerlink" title="3、保证原子性：单次读/写"></a>3、保证原子性：单次读/写</h4><p><strong>volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性</strong>。</p>
<p>先从如下两个问题来理解（后文再从内存屏障的角度理解）：</p>
<ol>
<li><strong>问题1： i++为什么不能保证原子性?</strong></li>
<li><strong>问题2： 共享的long和double变量的为什么要用volatile?</strong></li>
</ol>
<h5 id="1、问题1：-i-为什么不能保证原子性"><a href="#1、问题1：-i-为什么不能保证原子性" class="headerlink" title="1、问题1： i++为什么不能保证原子性?"></a>1、问题1： i++为什么不能保证原子性?</h5><p>对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>
<p>现在我们就通过下列程序来演示一下这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VolatileTest01 test01 = <span class="keyword">new</span> VolatileTest01();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; n++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test01.addI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);<span class="comment">//等待10秒，保证上面程序执行完成</span></span><br><span class="line">        System.out.println(test01.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：<code>981</code> 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取i的值。</li>
<li>对i加1。</li>
<li>将i的值写回内存。 </li>
</ul>
<p>i++的相关字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_ <span class="number">1</span>   <span class="comment">//准备常量1</span></span><br><span class="line">iadd        <span class="comment">//自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>对于i–也是类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_ <span class="number">1</span>   <span class="comment">//准备常量1</span></span><br><span class="line">isub        <span class="comment">//自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 </p>
<p>注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</p>
<h5 id="2、问题2：-共享的long和double变量的为什么要用volatile"><a href="#2、问题2：-共享的long和double变量的为什么要用volatile" class="headerlink" title="2、问题2： 共享的long和double变量的为什么要用volatile?"></a>2、问题2： 共享的long和double变量的为什么要用volatile?</h5><p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，<strong>鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</strong></p>
<p>如下是JLS中的解释：</p>
<blockquote>
<p>17.7 Non-Atomic Treatment of double and long</p>
</blockquote>
<ul>
<li>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</li>
<li>Writes and reads of volatile long and double values are always atomic.</li>
<li>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</li>
<li>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.</li>
<li>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.</li>
</ul>
<p><strong>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</strong></p>
<h3 id="3、volatile的实现原理"><a href="#3、volatile的实现原理" class="headerlink" title="3、volatile的实现原理"></a>3、volatile的实现原理</h3><h4 id="1、volatile-可见性实现"><a href="#1、volatile-可见性实现" class="headerlink" title="1、volatile 可见性实现"></a>1、volatile 可见性实现</h4><p><strong>volatile 变量的内存可见性是基于<code>内存屏障(Memory Barrier)</code>实现</strong>：</p>
<ul>
<li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li>
<li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，<strong>通过插入==特定类型的内存屏障来禁止==+ ==特定类型的编译器重排序和处理器重排序==**，插入一条内存屏障会告诉编译器和 CPU：</strong>不管什么指令都不能和这条 Memory Barrier 指令重排序**。</li>
<li><strong>对 volatile 变量的写指令后会加入写屏障</strong><ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
</li>
<li><strong>对 volatile 变量的读指令前会加入读屏障</strong><ul>
<li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.II_Result;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读屏障</span></span><br><span class="line">        <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">        <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">            r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">        <span class="comment">// 写屏障</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/image-20210806223239737.png" alt="image-20210806223239737"></p>
<p>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  0x0000000002951563: and    <span class="variable">$0xffffffffffffff87</span>,%rdi</span><br><span class="line">  0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">  0x000000000295156d: <span class="built_in">test</span>   <span class="variable">$0x7</span>,%rdi</span><br><span class="line">  0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">  0x0000000002951576: <span class="built_in">test</span>   <span class="variable">$0x300</span>,%rdi</span><br><span class="line">  0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">  0x000000000295157f: and    <span class="variable">$0x37f</span>,%rax</span><br><span class="line">  0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">  0x0000000002951589: or     %r15,%rdi</span><br><span class="line">  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">  0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">  0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">  0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">  0x000000000295159f: shl    <span class="variable">$0x3</span>,%rdi</span><br><span class="line">  0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">  0x00000000029515aa: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>lock 前缀的指令在多核处理器下会引发两件事情：</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p>
<p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：<strong>当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值</strong>。</p>
<p><strong>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值</strong>。</p>
<h5 id="1、lock-指令"><a href="#1、lock-指令" class="headerlink" title="1、lock 指令"></a>1、lock 指令</h5><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，<strong>加锁操作是由高速缓存锁代替总线锁来处理</strong>。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 <strong>这种场景多缓存的数据一致通过<code>缓存一致性协议(MESI)</code>来保证</strong>。</p>
<h5 id="2、缓存一致性"><a href="#2、缓存一致性" class="headerlink" title="2、缓存一致性"></a>2、缓存一致性</h5><p><strong>缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节</strong>。 </p>
<p>LOCK# 因为锁总线效率太低，因此使用了<strong>多组缓存</strong>。 为了使其行为看起来如同一组缓存那样。因而设计了 <strong>缓存一致性协议</strong>。</p>
<p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ <code>嗅探(snooping)&quot; 协议</code>。</p>
<p>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 <strong>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效</strong>。</p>
<h4 id="2、volatile-有序性实现"><a href="#2、volatile-有序性实现" class="headerlink" title="2、volatile 有序性实现"></a>2、volatile 有序性实现</h4><h5 id="1、volatile-的-happens-before-关系"><a href="#1、volatile-的-happens-before-关系" class="headerlink" title="1、volatile 的 happens-before 关系"></a>1、volatile 的 happens-before 关系</h5><p>happens-before 规则中有一条是 volatile 变量规则：<strong>对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设线程A执行writer方法，线程B执行reader方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1 线程A修改共享变量</span></span><br><span class="line">        flag = <span class="keyword">true</span>;        <span class="comment">// 2 线程A写volatile变量</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3 线程B读同一个volatile变量</span></span><br><span class="line">        <span class="keyword">int</span> i = a;          <span class="comment">// 4 线程B读共享变量</span></span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p>
<ul>
<li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li>
<li>根据 volatile 规则：2 happens-before 3。</li>
<li>根据 happens-before 的传递性规则：1 happens-before 4。</li>
</ul>
<p><img src="/2021/07/19/JUC/java-thread-x-key-volatile-1.png" alt="img"></p>
<p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p>
<h5 id="2、volatile-禁止重排序"><a href="#2、volatile-禁止重排序" class="headerlink" title="2、volatile 禁止重排序"></a>2、volatile 禁止重排序</h5><p><strong>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序</strong>。</p>
<p>J<strong>ava 编译器会在==生成指令系列==时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序</strong>。</p>
<p>JMM 会针对编译器制定 volatile 重排序规则表：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-volatile-2.png" alt="img"></p>
<p>“ NO “ 表示禁止重排序。</p>
<p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>
<ul>
<li>写屏障会确保指令重排序时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li>
<li>读屏障会确保指令重排序时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li>
</ul>
<table>
<thead>
<tr>
<th>内存屏障</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StoreStore 屏障</td>
<td>禁止上面的普通写和下面的 volatile 写重排序。</td>
</tr>
<tr>
<td>StoreLoad 屏障</td>
<td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td>
</tr>
<tr>
<td>LoadLoad 屏障</td>
<td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td>
</tr>
<tr>
<td>LoadStore 屏障</td>
<td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td>
</tr>
</tbody></table>
<p><img src="/2021/07/19/JUC/java-thread-x-key-volatile-3.png" alt="img"></p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-volatile-4.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.II_Result;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读屏障</span></span><br><span class="line">        <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">        <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">            r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障 </span></span><br><span class="line">        <span class="comment">// 写屏障</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/image-20210806223239737.png" alt="image-20210806223239737"></p>
<p>还是那句话，不能解决指令交错：</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210806224057799.png" alt="image-20210806224057799"></p>
<h4 id="3、double-checked-locking-问题"><a href="#3、double-checked-locking-问题" class="headerlink" title="3、double-checked locking 问题"></a>3、double-checked locking 问题</h4><p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有</span></span><br><span class="line">            <span class="function"><span class="keyword">synchronized</span> <span class="title">synchronized</span><span class="params">(Singleton.class)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic    	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull		<span class="number">37</span></span><br><span class="line">6: ldc				#3		// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic		#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull 		<span class="number">27</span></span><br><span class="line">17: new				#3		// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line">21: invokespecial	#4		// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic     	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto          	<span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic     	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>其中:</p>
<ul>
<li>17 表示创建对象，将对象引用入栈  // new Singleton</li>
<li>20 表示复制一份对象引用  // 引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法 </li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p>
<p><img src="/2021/07/19/JUC/image-20210806224747694.png" alt="image-20210806224747694"></p>
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值</p>
<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p>
<p>可能有人注意到：在synchronized内部的变量不是可以保证原子性、有序性和可见性吗？为什么21与24还会被重排序？</p>
<ul>
<li>被synchronized完全接管的变量确实可以保证原子性、有序性和可见性，但是必须是被synchronized完全接管的变量；</li>
<li>在代码上<code>INSTANCE</code>并没有被synchronized完全接管，线程在synchronized内部使用<code>INSTANCE</code>的时候，在synchronized外部还是可能有其它线程接触<code>INSTANCE</code></li>
<li>所以在synchronized内部，<code>INSTANCE</code>还是有可能被重排序（24与21重排序）</li>
</ul>
<p>解决方法：对 <code>INSTANCE</code> 使用 <code>volatile</code> 修饰即可，可以禁用指令重排，但要注意<strong>在 JDK 5 以上的版本的 volatile 才会真正有效</strong></p>
<h4 id="4、double-checked-locking-解决"><a href="#4、double-checked-locking-解决" class="headerlink" title="4、double-checked locking 解决"></a>4、double-checked locking 解决</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有</span></span><br><span class="line">            <span class="function"><span class="keyword">synchronized</span> <span class="title">synchronized</span><span class="params">(Singleton.class)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码上看不出来 volatile 指令的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span></span><br><span class="line">0: getstatic    	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull		<span class="number">37</span></span><br><span class="line">6: ldc				#3		// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter			<span class="comment">// -----------------------&gt; 保证原子性、可见性</span></span><br><span class="line">11: getstatic		#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull 		<span class="number">27</span></span><br><span class="line">17: new				#3		// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line">21: invokespecial	#4		// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic     	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit				<span class="comment">// ------------------------&gt; 保证原子性、可见性</span></span><br><span class="line"><span class="number">29</span>: goto          	<span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic     	#2		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p>
<ol>
<li>可见性<ul>
<li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li>
<li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li>有序性<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
<li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li>
</ol>
<p><img src="/2021/07/19/JUC/image-20210806225125974.png" alt="image-20210806225125974"></p>
<h3 id="4、volatile的应用场景"><a href="#4、volatile的应用场景" class="headerlink" title="4、volatile的应用场景"></a>4、volatile的应用场景</h3><p>使用 volatile 必须具备的条件</p>
<ul>
<li><strong>对变量的写操作不依赖于当前值</strong>。</li>
<li><strong>该变量没有包含在具有其他变量的不变式中</strong>。</li>
<li><strong>只有在状态真正独立于程序内其他内容时才能使用 volatile</strong>。</li>
</ul>
<h4 id="1、模式1：状态标志"><a href="#1、模式1：状态标志" class="headerlink" title="1、模式1：状态标志"></a>1、模式1：状态标志</h4><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，<strong>用于指示发生了一个重要的一次性事件</strong>，例如<strong>完成初始化或请求停机</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、模式2：一次性安全发布-one-time-safe-publication"><a href="#2、模式2：一次性安全发布-one-time-safe-publication" class="headerlink" title="2、模式2：一次性安全发布(one-time safe publication)"></a>2、模式2：一次性安全发布(one-time safe publication)</h4><p><strong>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难</strong>。在缺乏同步的情况下，<strong>可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在</strong>。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、模式3：独立观察-independent-observation"><a href="#3、模式3：独立观察-independent-observation" class="headerlink" title="3、模式3：独立观察(independent observation)"></a>3、模式3：独立观察(independent observation)</h4><p>安全使用 volatile 的另一种简单模式是<strong>定期发布观察结果供程序内部使用</strong>。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> valid = passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、模式4：volatile-bean-模式"><a href="#4、模式4：volatile-bean-模式" class="headerlink" title="4、模式4：volatile bean 模式"></a>4、模式4：volatile bean 模式</h4><p><strong>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑</strong>。此外，<strong>对于对象引用的数据成员，引用的对象必须是有效不可变的</strong>。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。<strong>对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、模式5：开销较低的读－写锁策略"><a href="#5、模式5：开销较低的读－写锁策略" class="headerlink" title="5、模式5：开销较低的读－写锁策略"></a>5、模式5：开销较低的读－写锁策略</h4><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 <strong>如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销</strong>。 <strong>安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性</strong>。<strong>如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesyCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></span><br><span class="line">    <span class="comment">// All mutative operations MUST be done with the &#x27;this&#x27; lock held</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、模式6：双重检查-double-checked"><a href="#6、模式6：双重检查-double-checked" class="headerlink" title="6、模式6：双重检查(double-checked)"></a>6、模式6：双重检查(double-checked)</h4><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。</p>
<hr>
<h2 id="6、关键字：final详解"><a href="#6、关键字：final详解" class="headerlink" title="6、关键字：final详解"></a>6、关键字：final详解</h2><h3 id="1、BAT大厂的面试问题-4"><a href="#1、BAT大厂的面试问题-4" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h3><ul>
<li>所有的final修饰的字段都是编译期常量吗？</li>
<li>如何理解private所修饰的方法是隐式的final？</li>
<li>说说final类型的类如何拓展？比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做？</li>
<li>final方法可以被重载吗？<ul>
<li>可以</li>
</ul>
</li>
<li>父类的final方法能不能够被子类重写？<ul>
<li>不可以</li>
</ul>
</li>
<li>说说final域重排序规则？</li>
<li>说说final的原理？</li>
<li>使用 final 的限制条件和局限性？</li>
<li>看本文最后的一个思考题</li>
</ul>
<h3 id="2、final基础使用"><a href="#2、final基础使用" class="headerlink" title="2、final基础使用"></a>2、final基础使用</h3><h4 id="1、修饰类"><a href="#1、修饰类" class="headerlink" title="1、修饰类"></a>1、修饰类</h4><p><strong>当某个类的整体定义为final时</strong>，就表明了你不能打算继承该类，而且也不允许别人这么做。即<strong>这个类是不能有子类的</strong>。</p>
<p>注意：<strong>final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的</strong>。</p>
<p>那么final类型的类如何拓展？</p>
<ul>
<li>比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做？</li>
</ul>
<p>设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类)，应该考虑<strong>用组合</strong>，如下代码大概写个组合实现的意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@pdai</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toMyString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、修饰方法"><a href="#2、修饰方法" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h4><ul>
<li><p>private 方法是隐式的final</p>
</li>
<li><p>final方法是可以被重载的</p>
</li>
</ul>
<h5 id="1、private-final"><a href="#1、private-final" class="headerlink" title="1、private final"></a>1、private final</h5><p><strong>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处</strong>。</p>
<p>看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Base father = son;</span><br><span class="line">        <span class="comment">//father.test();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base和Son都有方法test()，但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。</p>
<h5 id="2、final方法是可以被重载的"><a href="#2、final方法是可以被重载的" class="headerlink" title="2、final方法是可以被重载的"></a>2、final方法是可以被重载的</h5><p>我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? </p>
<p>答案是可以的，下面代码是正确的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExampleParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、修饰参数"><a href="#3、修饰参数" class="headerlink" title="3、修饰参数"></a>3、修饰参数</h4><p><strong>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象</strong>。</p>
<p>这个特性主要用来<strong>向匿名内部类传递数据</strong>。</p>
<h4 id="4、修饰变量"><a href="#4、修饰变量" class="headerlink" title="4、修饰变量"></a>4、修饰变量</h4><h5 id="1、所有final修饰的字段都是编译器常量吗？"><a href="#1、所有final修饰的字段都是编译器常量吗？" class="headerlink" title="1、所有final修饰的字段都是编译器常量吗？"></a>1、所有final修饰的字段都是编译器常量吗？</h5><p>现在来看编译期常量和非编译期常量，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> J = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k = r.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p>
<h5 id="2、static-final"><a href="#2、static-final" class="headerlink" title="2、static final"></a>2、static final</h5><p><strong>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k = r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k2 = r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码某次输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=2 k2=7</span><br><span class="line">k=8 k2=7</span><br></pre></td></tr></table></figure>

<p>我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢？</p>
<ul>
<li>因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。</li>
<li>也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改</li>
</ul>
<h5 id="3、blank-final"><a href="#3、blank-final" class="headerlink" title="3、blank final"></a>3、blank final</h5><p><strong>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段，但是必须在该字段被使用之前被赋值</strong>，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白final)</li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。</li>
</ul>
<p>这增强了final的灵活性。</p>
<p>看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i2;<span class="comment">//空白final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i2 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到i2的赋值更为灵活。</p>
<p>但是请注意，<strong>如果字段由static和final修饰，仅能在定义处赋值</strong>，因为该字段不属于对象，属于这个类。</p>
<h3 id="3、final域重排序规则"><a href="#3、final域重排序规则" class="headerlink" title="3、final域重排序规则"></a>3、final域重排序规则</h3><p>上面final的使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? </p>
<p>在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。</p>
<p>那么，在多线程情况下，final会进行怎样的重排序? 会导致线程安全的问题吗? </p>
<p>下面，就来看看final的重排序。</p>
<h4 id="1、final域为基本类型"><a href="#1、final域为基本类型" class="headerlink" title="1、final域为基本类型"></a>1、final域为基本类型</h4><p>先看一段示例性的代码：（假设线程A在执行writer()方法，线程B执行reader()方法。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">//普通域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">//final域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1. 写普通域</span></span><br><span class="line">        b = <span class="number">2</span>; <span class="comment">// 2. 写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = demo.a;    <span class="comment">//4.读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = demo.b;    <span class="comment">//5.读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、写final域重排序规则"><a href="#1、写final域重排序规则" class="headerlink" title="1、写final域重排序规则"></a>1、写final域重排序规则</h5><p>写final域的重排序规则<strong>禁止对final域的写重排序到构造函数之外</strong>，这个规则的实现主要包含了两个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>
<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p>
<ul>
<li>构造了一个FinalDemo对象；</li>
<li>把这个对象赋值给成员变量finalDemo。</li>
</ul>
<p>我们来画下存在的一种可能执行时序图，如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-final-1.png" alt="img"></p>
<p>由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p>
<p>因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo</p>
<h5 id="2、读final域重排序规则"><a href="#2、读final域重排序规则" class="headerlink" title="2、读final域重排序规则"></a>2、读final域重排序规则</h5><p>读final域重排序规则为：<strong>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序</strong>。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
<p>read()方法主要包含了三个操作：</p>
<ul>
<li>初次读引用变量finalDemo;</li>
<li>初次读引用变量finalDemo的普通域a;</li>
<li>初次读引用变量finalDemo的final域b;</li>
</ul>
<p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-final-2.png" alt="img"></p>
<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>
<p>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用</strong>。</p>
<h4 id="2、final域为引用类型"><a href="#2、final域为引用类型" class="headerlink" title="2、final域为引用类型"></a>2、final域为引用类型</h4><h5 id="1、对final域修饰的对象的成员域写操作"><a href="#1、对final域修饰的对象的成员域写操作" class="headerlink" title="1、对final域修饰的对象的成员域写操作"></a>1、对final域修饰的对象的成员域写操作</h5><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：<strong>在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的</strong>。</p>
<p>注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-final-3.png" alt="img"></p>
<p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。<strong>由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序</strong>。</p>
<h5 id="2、对final域修饰的对象的成员域读操作"><a href="#2、对final域修饰的对象的成员域读操作" class="headerlink" title="2、对final域修饰的对象的成员域读操作"></a>2、对final域修饰的对象的成员域读操作</h5><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>
<h4 id="3、关于final重排序的总结"><a href="#3、关于final重排序的总结" class="headerlink" title="3、关于final重排序的总结"></a>3、关于final重排序的总结</h4><p>按照final修饰的数据类型分类：</p>
<ul>
<li>基本数据类型:<ul>
<li><code>final域写</code>：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li>
<li><code>final域读</code>：禁止初次读对象的引用与读该对象包含的final域的重排序。</li>
</ul>
</li>
<li>引用数据类型：<ul>
<li><code>额外增加约束</code>：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li>
</ul>
</li>
</ul>
<h3 id="4、final再深入理解"><a href="#4、final再深入理解" class="headerlink" title="4、final再深入理解"></a>4、final再深入理解</h3><h4 id="1、final的实现原理"><a href="#1、final的实现原理" class="headerlink" title="1、final的实现原理"></a>1、final的实现原理</h4><p>上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p>
<p>很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器</p>
<h5 id="1、设置-ﬁnal-变量的原理："><a href="#1、设置-ﬁnal-变量的原理：" class="headerlink" title="1、设置 ﬁnal 变量的原理："></a>1、设置 ﬁnal 变量的原理：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line">1: invokespecial	#1		// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="number">4</span>: aload_0			<span class="number">20</span></span><br><span class="line">5: bipush      		#2		// Field a:I</span><br><span class="line"><span class="number">7</span>: putfield</span><br><span class="line">    &lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>发现 ﬁnal 变量的赋值也会通过 putﬁeld 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p>
<h5 id="2、获取-ﬁnal-变量的原理"><a href="#2、获取-ﬁnal-变量的原理" class="headerlink" title="2、获取 ﬁnal 变量的原理"></a>2、获取 ﬁnal 变量的原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> B = Short.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">30</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseFinal1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">        System.out.println(TestFinal.B);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> TestFinal().a);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> TestFinal().b);</span><br><span class="line">        <span class="keyword">new</span> TestFinal().test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseFinal2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>如果<code>final static int A = 10;</code>加入<code>final</code>的话：那么在字节码的层面可以看到：<code>BIPUSH 10</code>，即在读取A的时候，它是从栈中直接复制了一个<code>10</code>给到了A，走的不是共享这条路（没有从其他类中读取数据）<ul>
<li><img src="/2021/07/19/JUC/image-20210810231107766.png" alt="image-20210810231107766"></li>
</ul>
</li>
<li>如果<code>static int A = 10;</code>没有加<code>final</code>的话：那么在字节码的层面可以看到：<code>GETSTATIC cn/itcast/n5/TestFinal.A : I</code>，即在读取A的时候，它是从TestFinal类中获取的到的10，走的是共享这条路（从其他类中读取数据），那么<code>A</code>就是==共享内存==，性能比==栈内存==要低。<ul>
<li><img src="/2021/07/19/JUC/image-20210810231345476.png" alt="image-20210810231345476"></li>
</ul>
</li>
<li>对于<code>final static int B = Short.MAX_VALUE+1;</code>来说，B是<code>Short</code>的最大值在加上1（超过了极限）。加入<code>final</code>的话：那么在字节码的层面可以看到：<code>LDC 32768</code>（Short的最大值是32767），即读取的是常量池当中的内容，同理也没有走共享内存这条路（没有从其他类中读取数据）<ul>
<li><img src="/2021/07/19/JUC/image-20210810232209213.png" alt="image-20210810232209213"></li>
</ul>
</li>
<li>如果<code>B</code>没有加<code>final</code>的话：那么在字节码的层面可以看到：<code>GETSTATIC cn/itcast/n5/TestFinal.B : I</code>，即在读取B的时候，它是从TestFinal类中获取的，走的是共享这条路（从其他类中读取数据）<ul>
<li><img src="/2021/07/19/JUC/image-20210810232531747.png" alt="image-20210810232531747"></li>
</ul>
</li>
<li>下面的成员变量<code>a</code>与<code>b</code>也是同样的道理：加入<code>final</code>修饰的，在引用到a/b的时候，会复制一份到调用方的常量池当中，直接从栈内存获取就行（==栈内存==），效率高。没有加<code>final</code>修饰的，在引用到a/b的时候，会直接到类中获取（==共享内存==），效率比较低。</li>
<li>总结：一个final修饰的基本变量可以完全等价于一个常量，整个jvm实例生命周期内都不会变化了，这个值在编译时就已经写死成直接引用了</li>
</ul>
<h4 id="2、为什么final引用不能从构造函数中”溢出”"><a href="#2、为什么final引用不能从构造函数中”溢出”" class="headerlink" title="2、为什么final引用不能从构造函数中”溢出”"></a>2、为什么final引用不能从构造函数中”溢出”</h4><p>这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。</p>
<p>但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。以下面的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">//1</span></span><br><span class="line">        referenceDemo = <span class="keyword">this</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = referenceDemo.a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的执行时序如图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-key-final-4.png" alt="img"></p>
<p>假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p>
<h4 id="3、使用final的限制条件和局限性"><a href="#3、使用final的限制条件和局限性" class="headerlink" title="3、使用final的限制条件和局限性"></a>3、使用final的限制条件和局限性</h4><ul>
<li><p>当声明一个 final 成员时，必须在构造函数退出前设置它的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> myField = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> myField;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    myField = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。</p>
<ul>
<li><p>下面的方法仍然可以修改该 list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明为 final 可以保证如下操作不合法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">myList = someOtherList;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。</p>
<ul>
<li>“ 其他方式 “ 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。</li>
</ul>
</li>
</ul>
<h4 id="4、再思考一个有趣的现象"><a href="#4、再思考一个有趣的现象" class="headerlink" title="4、再思考一个有趣的现象"></a>4、再思考一个有趣的现象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b3=b1+b2;<span class="comment">//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错</span></span><br></pre></td></tr></table></figure>

<p>如果对b1 b2加上final就不会出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b2=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b3=b1+b2;<span class="comment">//不会出错，相信你看了上面的解释就知道原因了。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7、JUC（java-util-concurrent）"><a href="#7、JUC（java-util-concurrent）" class="headerlink" title="7、JUC（java.util.concurrent）"></a>7、JUC（java.util.concurrent）</h2><h3 id="0、JUC-类汇总和学习总览"><a href="#0、JUC-类汇总和学习总览" class="headerlink" title="0、JUC - 类汇总和学习总览"></a>0、JUC - 类汇总和学习总览</h3><h4 id="1、BAT大厂的面试问题-5"><a href="#1、BAT大厂的面试问题-5" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>JUC框架包含几个部分?</li>
<li>每个部分有哪些核心的类?</li>
<li>最最核心的类有哪些?</li>
</ul>
<h4 id="2、Overview"><a href="#2、Overview" class="headerlink" title="2、Overview"></a>2、Overview</h4><p>JUC相关的五大类与框架：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-overview-1.png" alt="image"></p>
<p>主要包含: (注意: 上图是网上找的图，无法表述一些继承关系，同时少了部分类；但是主体上可以看出其分类关系也够了)</p>
<ul>
<li>Lock框架和Tools类(把图中这两个放到一起理解)</li>
<li>Collections: 并发集合</li>
<li>Atomic: 原子类</li>
<li>Executors: 线程池</li>
</ul>
<h4 id="3、相关类与框架"><a href="#3、相关类与框架" class="headerlink" title="3、相关类与框架"></a>3、相关类与框架</h4><h5 id="1、Lock框架和Tools类"><a href="#1、Lock框架和Tools类" class="headerlink" title="1、Lock框架和Tools类"></a>1、Lock框架和Tools类</h5><p>类结构总览：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-overview-lock.png" alt="image"></p>
<ul>
<li>接口<ul>
<li>Condition<ul>
<li>Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。</li>
<li>其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。</li>
</ul>
</li>
<li>Lock<ul>
<li>Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象</li>
</ul>
</li>
<li>ReadWriteLock<ul>
<li>ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</li>
</ul>
</li>
</ul>
</li>
<li>抽象类<ul>
<li>AbstractOwnableSynchonizer<ul>
<li>AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。</li>
<li>此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。</li>
<li>AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。</li>
</ul>
</li>
<li>（Long）AbstractQueuedLongSynchonizer<ul>
<li>AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。</li>
<li>此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。</li>
<li>当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。</li>
</ul>
</li>
<li>核心抽象类（int）：AbstractQueuedSynchonizer<ul>
<li>AbstractQueuedSynchonizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。</li>
<li>此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。</li>
</ul>
</li>
</ul>
</li>
<li>锁常用类<ul>
<li>LockSupport<ul>
<li>LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。</li>
<li>LockSupport的功能和”Thread中的 Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。</li>
<li>但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</li>
</ul>
</li>
<li>ReentrantLock<ul>
<li>ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</li>
</ul>
</li>
<li>ReentrantReadWriteLock<ul>
<li>ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。</li>
</ul>
</li>
<li>StampedLock<ul>
<li>它是java8在java.util.concurrent.locks新增的一个API。</li>
<li>StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</li>
</ul>
</li>
</ul>
</li>
<li>工具常用类<ul>
<li>CountDownLatch<ul>
<li>CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li>
</ul>
</li>
<li>CyclicBarrier<ul>
<li>CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。</li>
<li>在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</li>
</ul>
</li>
<li>Phaser<ul>
<li>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</li>
</ul>
</li>
<li>Semaphore<ul>
<li>Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。</li>
</ul>
</li>
<li>Exchanger<ul>
<li>Exchanger是用于线程协作的工具类，主要用于两个线程之间的数据交换。</li>
<li>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2、Collections：并发集合"><a href="#2、Collections：并发集合" class="headerlink" title="2、Collections：并发集合"></a>2、Collections：并发集合</h5><p>类结构关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-overview-2.png" alt="image"></p>
<ul>
<li>Queue<ul>
<li>ArrayBlockingQueue<ul>
<li>一个由数组支持的有界阻塞队列。此队列按 FIFO(先进先出)原则对元素进行排序。</li>
<li>队列的头部是在队列中存在时间最长的元素。队列的尾部是在队列中存在时间最短的元素。</li>
<li>新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</li>
</ul>
</li>
<li>LinkedBlockingQueue<ul>
<li>一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO(先进先出)排序元素。</li>
<li>队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。</li>
<li>新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。</li>
<li>链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</li>
</ul>
</li>
<li>LinkedBlockingDeque<ul>
<li>一个基于已链接节点的、任选范围的阻塞双端队列。</li>
</ul>
</li>
<li>ConcurrentLinkedQueue<ul>
<li>一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。</li>
<li>队列的头部是队列中时间最长的元素。队列的尾部是队列中时间最短的元素。</li>
<li>新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。</li>
<li>当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</li>
</ul>
</li>
<li>ConcurrentLinkedDeque<ul>
<li>是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。</li>
</ul>
</li>
<li>DelayQueue<ul>
<li>延时无界阻塞队列，使用Lock机制实现并发访问。</li>
<li>队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。</li>
<li>如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。</li>
</ul>
</li>
<li>PriorityBlockingQueue<ul>
<li>无界优先级阻塞队列，使用Lock机制实现并发访问。</li>
<li>priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。</li>
</ul>
</li>
<li>SynchronousQueue<ul>
<li>没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。</li>
</ul>
</li>
<li>LinkedTransferQueue<ul>
<li>JDK 7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO(先进先出)方式。</li>
<li>LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue(公平模式)和LinkedBlockingQueue的超集，它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</li>
</ul>
</li>
</ul>
</li>
<li>List<ul>
<li>CopyOnWriteArrayList<ul>
<li>ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。</li>
<li>这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。</li>
</ul>
</li>
</ul>
</li>
<li>Set<ul>
<li>CopyOnWriteArraySet<ul>
<li>对其所有操作使用内部CopyOnWriteArrayList的Set。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。</li>
<li>在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList。</li>
</ul>
</li>
<li>ConcurrentSkipListSet<ul>
<li>一个基于ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li>ConcurrentHashMap<ul>
<li>是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。</li>
</ul>
</li>
<li>ConcurrentSkipListMap<ul>
<li>线程安全的有序的哈希表(相当于线程安全的TreeMap)；映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、Atomic-原子类"><a href="#3、Atomic-原子类" class="headerlink" title="3、Atomic: 原子类"></a>3、Atomic: 原子类</h5><p>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p>
<ul>
<li>基础类型<ul>
<li>AtomicBoolean<ul>
<li>针对bool的原子类。</li>
</ul>
</li>
<li>AtomicInteger<ul>
<li>针对interger的原子类。</li>
</ul>
</li>
<li>AtomicLong<ul>
<li>针对long的原子类。</li>
</ul>
</li>
</ul>
</li>
<li>数组<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>BooleanArray</li>
</ul>
</li>
<li>引用<ul>
<li>AtomicReference</li>
<li>AtomicMarkedReference</li>
<li>AtomicStampedReference</li>
</ul>
</li>
<li>FieldUpdater<ul>
<li>AtomicLongFieldUpdater</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
</ul>
<h5 id="4、Executors：线程池"><a href="#4、Executors：线程池" class="headerlink" title="4、Executors：线程池"></a>4、Executors：线程池</h5><p>类结构关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-executors-1.png" alt="img"></p>
<ul>
<li>接口：Executor<ul>
<li>Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。</li>
</ul>
</li>
<li>ExecutorService<ul>
<li>ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。</li>
</ul>
</li>
<li>ScheduledExecutorService<ul>
<li>ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。</li>
</ul>
</li>
<li>AbstractExecutorService<ul>
<li>AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。</li>
</ul>
</li>
<li>FutureTask<ul>
<li>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。</li>
<li>如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。</li>
<li>FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。</li>
<li>除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。</li>
<li>FutureTask 的线程安全由CAS来保证。</li>
</ul>
</li>
<li>核心<ul>
<li>ThreadPoolExecutor<ul>
<li>ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 </li>
<li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li>
</ul>
</li>
<li>ScheduledThreadExecutor<ul>
<li>ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。</li>
</ul>
</li>
<li>Fork/Join框架<ul>
<li>ForkJoinPool 是JDK 7加入的一个线程池类。</li>
<li>Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。</li>
<li>目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</li>
</ul>
</li>
</ul>
</li>
<li>工具类：Executors<ul>
<li>Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。</li>
<li>它的使用融入到了ThreadPoolExecutor、ScheduledThreadExecutor和ForkJoinPool中。</li>
</ul>
</li>
</ul>
<h3 id="1、JUC概述"><a href="#1、JUC概述" class="headerlink" title="1、JUC概述"></a>1、JUC概述</h3><h4 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h4><p>在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK 1.5 开始出现的。 </p>
<p><img src="/2021/07/19/JUC/image-20210721220607339.png" alt="image-20210721220607339"></p>
<h4 id="2、多线程编程步骤"><a href="#2、多线程编程步骤" class="headerlink" title="2、多线程编程步骤"></a>2、多线程编程步骤</h4><ol>
<li>第一：创建资源类，创建属性和操作方法</li>
<li>第二：在资源类的操作方法中<ol>
<li>判断（使用while，不使用if，或者会出现虚假唤醒问题）</li>
<li>干活</li>
<li>通知</li>
</ol>
</li>
<li>第三：创建多线程调用资源类的方法</li>
<li>第四：防止出现虚假唤醒问题</li>
</ol>
<h5 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h5><h6 id="1、什么是虚假唤醒问题？"><a href="#1、什么是虚假唤醒问题？" class="headerlink" title="1、什么是虚假唤醒问题？"></a>1、什么是虚假唤醒问题？</h6><p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用的唤醒；这些无用的唤醒会导致出现一些问题。</p>
<h6 id="2、为什么会出现虚假唤醒问题？"><a href="#2、为什么会出现虚假唤醒问题？" class="headerlink" title="2、为什么会出现虚假唤醒问题？"></a>2、为什么会出现虚假唤醒问题？</h6><p>在多线程编程步骤的第二步中的判断中，<strong>如果使用的是if语句的话，就会出现虚假唤醒问题</strong>。原因：</p>
<ul>
<li>if语句块只会判断一次</li>
<li>wait()方法的特性：在哪里等待，就在哪里开始</li>
</ul>
<p>在官方文档中就明确规定要**==使用while语句块==，不要使用if语句块**：（因为while语句块可以不断的进行判断）</p>
<p><img src="https://img-blog.csdnimg.cn/2020090410304694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzMyMTk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="3、示例（参考下面进程间通信的代码——将其中的while修改为if，并运行发现）"><a href="#3、示例（参考下面进程间通信的代码——将其中的while修改为if，并运行发现）" class="headerlink" title="3、示例（参考下面进程间通信的代码——将其中的while修改为if，并运行发现）"></a>3、示例（参考下面<code>进程间通信</code>的代码——将其中的<code>while</code>修改为<code>if</code>，并运行发现）</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A=&gt;1</span><br><span class="line">B=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">C=&gt;3</span><br><span class="line">B=&gt;2</span><br><span class="line">B=&gt;1</span><br><span class="line">B=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">C=&gt;3</span><br><span class="line">B=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">D=&gt;-1</span><br><span class="line">C=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">C=&gt;3</span><br><span class="line">D=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">C=&gt;3</span><br><span class="line">D=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">C=&gt;1</span><br><span class="line">D=&gt;0</span><br></pre></td></tr></table></figure>

<h6 id="4、分析（假设一开始为0）"><a href="#4、分析（假设一开始为0）" class="headerlink" title="4、分析（假设一开始为0）"></a>4、分析（假设一开始为0）</h6><ul>
<li>调用A  –&gt; 1</li>
<li>调用C  –&gt; 1    C wait</li>
<li>如果再调用A，那么A也会wait，A wait    –&gt; 1</li>
<li>再调用B减1后，  –&gt; 0</li>
<li>唤醒了A和C，执行A（C没抢到）， –&gt; 1</li>
<li>A执行完后，C抢到了CPU，此时C没有再进行判断，直接执行+1操作， –&gt; 2</li>
</ul>
<h6 id="5、使用wait-notify的正确姿势——防止虚假唤醒问题"><a href="#5、使用wait-notify的正确姿势——防止虚假唤醒问题" class="headerlink" title="5、使用wait/notify的正确姿势——防止虚假唤醒问题"></a>5、使用wait/notify的正确姿势——防止虚假唤醒问题</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、JUC原子类：CAS，Unsafe和原子类详解"><a href="#2、JUC原子类：CAS，Unsafe和原子类详解" class="headerlink" title="2、JUC原子类：CAS，Unsafe和原子类详解"></a>2、JUC原子类：CAS，Unsafe和原子类详解</h3><p>JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案；java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的。</p>
<h4 id="1、BAT大厂的面试问题-6"><a href="#1、BAT大厂的面试问题-6" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>线程安全的实现方法有哪些？</li>
<li>什么是CAS？</li>
<li>CAS使用示例，结合AtomicInteger给出示例？</li>
<li>CAS会有哪些问题？</li>
<li>针对这这些问题，Java提供了哪几个解决的？</li>
<li>AtomicInteger底层实现？<ul>
<li><code>CAS</code> + <code>volatile</code></li>
</ul>
</li>
<li>请阐述你对Unsafe类的理解？</li>
<li>说说你对Java原子类的理解？包含13个，4组分类，说说作用和使用场景。</li>
<li>AtomicStampedReference是什么？</li>
<li>AtomicStampedReference是怎么解决ABA的？<ul>
<li>内部使用Pair来存储元素值及其版本号</li>
</ul>
</li>
<li>java中还有哪些类可以解决ABA的问题？<ul>
<li><code>AtomicMarkableReference</code></li>
</ul>
</li>
</ul>
<h4 id="2、CAS"><a href="#2、CAS" class="headerlink" title="2、CAS"></a>2、CAS</h4><p>前面我们说到，<strong>线程安全的实现方法</strong>包含：</p>
<ul>
<li>互斥同步：<code>synchronized</code> 和 <code>ReentrantLock</code></li>
<li>非阻塞同步：<code>CAS</code>、<code>AtomicXXXX</code></li>
<li>无同步方案：<code>栈封闭</code>、<code>Thread Local</code>、<code>可重入代码</code></li>
</ul>
<h5 id="1、什么是CAS"><a href="#1、什么是CAS" class="headerlink" title="1、什么是CAS"></a>1、什么是CAS</h5><p>CAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是<strong>让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值</strong>，其实现方式是基于硬件平台的汇编指令，就是说<strong>CAS是靠硬件实现的</strong>，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。  </p>
<p>简单解释：<strong>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</strong></p>
<p><strong>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁</strong>。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。</p>
<p>相信sql大家都熟悉，类似sql中的条件更新一样：update set id=3 from table where id=2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功。但如果有多条sql的话，要保证操作的原子性，就要使用事务了。</p>
<h5 id="2、CAS使用实例"><a href="#2、CAS使用实例" class="headerlink" title="2、CAS使用实例"></a>2、CAS使用实例</h5><p>如果不使用CAS，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java中为我们提供了AtomicInteger 原子类(底层基于CAS进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.addAndGet(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、为什么无锁效率高"><a href="#3、为什么无锁效率高" class="headerlink" title="3、为什么无锁效率高"></a>3、为什么无锁效率高</h5><ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li>
<li>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li>
</ul>
<h5 id="4、CAS-的特点"><a href="#4、CAS-的特点" class="headerlink" title="4、CAS 的特点"></a>4、CAS 的特点</h5><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思：<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h5 id="5、CAS问题"><a href="#5、CAS问题" class="headerlink" title="5、CAS问题"></a>5、CAS问题</h5><p>CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。</p>
<p>但使用 CAS 方式也会有几个问题：</p>
<ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h6 id="1、ABA问题"><a href="#1、ABA问题" class="headerlink" title="1、ABA问题"></a>1、ABA问题</h6><p>因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是<strong>使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个类的compareAndSet方法的作用是<strong>首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</strong>。</p>
<h6 id="2、循环时间长开销大"><a href="#2、循环时间长开销大" class="headerlink" title="2、循环时间长开销大"></a>2、循环时间长开销大</h6><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。</p>
<p>pause指令有两个作用：</p>
<ol>
<li>第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li>
<li>第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。</li>
</ol>
<h6 id="3、只能保证一个共享变量的原子操作"><a href="#3、只能保证一个共享变量的原子操作" class="headerlink" title="3、只能保证一个共享变量的原子操作"></a>3、只能保证一个共享变量的原子操作</h6><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<p>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。</p>
<p>从Java 1.5开始，JDK提供了<code>AtomicReference</code>类来<strong>保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作</strong>。</p>
<h4 id="3、Unsafe类详解"><a href="#3、Unsafe类详解" class="headerlink" title="3、Unsafe类详解"></a>3、Unsafe类详解</h4><p>Java原子类是通过UnSafe类实现的，UnSafe类在J.U.C中CAS操作有很广泛的应用。</p>
<p>Unsafe是位于sun.misc包下的一个类，<strong>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等</strong>，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p>
<p>但<strong>由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险</strong>。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取一个unsafe对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>); </span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看下这张图，对UnSafe类总体功能：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-atomicinteger-unsafe.png" alt="img"></p>
<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类。</p>
<h5 id="1、Unsafe与CAS"><a href="#1、Unsafe与CAS" class="headerlink" title="1、Unsafe与CAS"></a>1、Unsafe与CAS</h5><p>反编译出来的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      l = getLongVolatile(paramObject, paramLong1);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, paramInt));</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      l = getLongVolatile(paramObject, paramLong1);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object localObject;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      localObject = getObjectVolatile(paramObject1, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2));</span><br><span class="line">    <span class="keyword">return</span> localObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中发现，**内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)**。</p>
<p>又从Unsafe类中发现，原子操作其实只支持下面3种CAS方法：（都是native方法）</p>
<ol>
<li><code>compareAndSwapObject</code></li>
<li><code>compareAndSwapInt</code></li>
<li><code>compareAndSwapLong</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>三个方法都是有四个参数，这四个参数的含义都是一样的，分别是：（以<code>compareAndSwapInt</code>为例）</p>
<ul>
<li><code>Object paramObject</code>：操作的对象</li>
<li><code>long paramLong</code>：操作对象的操作域的偏移地址</li>
<li><code>int paramInt1</code>：原值</li>
<li><code>int paramInt2</code>：修改值</li>
</ul>
<h5 id="2、使用unsafe"><a href="#2、使用unsafe" class="headerlink" title="2、使用unsafe"></a>2、使用unsafe</h5><p>我们使用反射得到的unsafe来完成一些操作</p>
<h6 id="1、使用unsafe去修改一个对象的字段-域-的取值"><a href="#1、使用unsafe去修改一个对象的字段-域-的取值" class="headerlink" title="1、使用unsafe去修改一个对象的字段(域)的取值"></a>1、使用unsafe去修改一个对象的字段(域)的取值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(unsafe);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取域的偏移地址</span></span><br><span class="line">        <span class="keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">// 2. 执行 cas 操作</span></span><br><span class="line">        unsafe.compareAndSwapInt(t, idOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(t, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Theater&#123;id=1，name=<span class="string">&quot;张三&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、使用unsafe模拟实现原值整数"><a href="#2、使用unsafe模拟实现原值整数" class="headerlink" title="2、使用unsafe模拟实现原值整数"></a>2、使用unsafe模拟实现原值整数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.n4.UnsafeAccessor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test42&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> MyAtomicInteger(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNSAFE = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAtomicInteger</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        decrement(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2、Unsafe底层"><a href="#2、Unsafe底层" class="headerlink" title="2、Unsafe底层"></a>2、Unsafe底层</h5><p>Unsafe的compareAndSwap方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>可以看到它通过 <code>Atomic::cmpxchg</code> 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>
<p>如果是Linux的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而windows的x86的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mp = os::isMP(); <span class="comment">//判断是否是多处理器</span></span><br><span class="line">    _asm &#123;</span><br><span class="line">        mov edx, dest</span><br><span class="line">        mov ecx, exchange_value</span><br><span class="line">        mov eax, compare_value</span><br><span class="line">        LOCK_IF_MP(mp)</span><br><span class="line">        cmpxchg dword ptr [edx], ecx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="comment">// VC++ doesn&#x27;t like the lock prefix to be on a single line</span></span><br><span class="line"><span class="comment">// so we can&#x27;t insert a label after the lock prefix.</span></span><br><span class="line"><span class="comment">// By emitting a lock prefix, we can define a label after it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br></pre></td></tr></table></figure>

<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>
<blockquote>
<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>
</blockquote>
<h5 id="3、Unsafe其他功能"><a href="#3、Unsafe其他功能" class="headerlink" title="3、Unsafe其他功能"></a>3、Unsafe其他功能</h5><p>Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p>
<p>举两个例子，比方说：这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field paramField)</span></span>;</span><br></pre></td></tr></table></figure>

<p>再比如说：前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class paramClass)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class paramClass)</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后看三个方法：分别用来分配内存，扩充内存和释放内存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多相关功能，推荐你看下这篇文章：来自美团技术团队：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></p>
</blockquote>
<h4 id="4、AutomicIntrger"><a href="#4、AutomicIntrger" class="headerlink" title="4、AutomicIntrger"></a>4、AutomicIntrger</h4><h5 id="1、使用举例"><a href="#1、使用举例" class="headerlink" title="1、使用举例"></a>1、使用举例</h5><p>以 AtomicInteger 为例，常用 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>：获取当前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span>：获取当前的值，并设置新的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>：获取当前的值，并自增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span>：获取当前的值，并自减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span>：获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span>: 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p>相比 Integer 的优势，多线程中让变量自增：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 若要线程安全执行执行 count++，需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 AtomicInteger 后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 AtomicInteger 后，不需要加锁，也可以实现线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、源码解析"><a href="#2、源码解析" class="headerlink" title="2、源码解析"></a>2、源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。</p>
<ul>
<li>volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值</li>
<li>CAS 保证数据更新的原子性。</li>
</ul>
<h4 id="5、延伸到所有原子类：共13个"><a href="#5、延伸到所有原子类：共13个" class="headerlink" title="5、延伸到所有原子类：共13个"></a>5、延伸到所有原子类：共13个</h4><p>JDK中提供了13个原子操作类。</p>
<h5 id="1、原子更新基本类型"><a href="#1、原子更新基本类型" class="headerlink" title="1、原子更新基本类型"></a>1、原子更新基本类型</h5><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p>
<ul>
<li><code>AtomicBoolean</code>：原子更新布尔类型。</li>
<li><code>AtomicInteger</code>：原子更新整型。</li>
<li><code>AtomicLong</code>：原子更新长整型。</li>
</ul>
<p>以上3个类提供的方法几乎一模一样，可以参考上面AtomicInteger中的相关方法。</p>
<p>其它方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line"><span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final </span></span><br><span class="line">System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure>

<h5 id="2、原子更新数组"><a href="#2、原子更新数组" class="headerlink" title="2、原子更新数组"></a>2、原子更新数组</h5><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下的4个类：</p>
<ul>
<li><p><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。</p>
</li>
<li><p><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</p>
</li>
<li><p><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。 </p>
<p>这三个类的最常用的方法是如下两个方法：</p>
</li>
<li><p><code>get(int index)</code>：获取索引为index的元素值。</p>
</li>
<li><p><code>compareAndSet(int i, E expect, E update)</code>：如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。</p>
</li>
</ul>
<p>举个AtomicIntegerArray例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        System.out.println(array.getAndAdd(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0]</span><br><span class="line">0</span><br><span class="line">[0, 2]</span><br></pre></td></tr></table></figure>

<h5 id="3、原子更新引用类型"><a href="#3、原子更新引用类型" class="headerlink" title="3、原子更新引用类型"></a>3、原子更新引用类型</h5><p>Atomic包提供了以下三个类：</p>
<ul>
<li><code>AtomicReference</code>：原子更新引用类型。</li>
<li><code>AtomicStampedReference</code>：原子更新引用类型，<strong>内部使用Pair来存储元素值及其版本号</strong>。（可以解决CAS的ABA问题）</li>
<li><code>AtomicMarkableReferce</code>：原子更新带有标记位的引用类型。<ul>
<li>有时候，并不关心引用变量更改了几次（ABA问题），只是单纯的关心<strong>是否更改过</strong>，所以就有了<code>AtomicMarkableReference</code></li>
</ul>
</li>
</ul>
<p>这三个类提供的方法都差不多：</p>
<ol>
<li>首先构造一个引用对象；</li>
<li>然后把引用对象set进Atomic类；</li>
<li>然后调用compareAndSet等一些方法去进行原子操作。</li>
</ol>
<p>原理都是基于Unsafe实现，但<code>AtomicReferenceFieldUpdater</code>略有不同，<strong>更新的字段必须用<code>volatile</code>修饰</strong>。</p>
<p>举个<code>AtomicReference</code>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个Person对象，它们的id分别是101和102。</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">101</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">102</span>);</span><br><span class="line">        <span class="comment">// 新建AtomicReference对象，初始化它的值为p1对象</span></span><br><span class="line">        AtomicReference ar = <span class="keyword">new</span> AtomicReference(p1);</span><br><span class="line">        <span class="comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span></span><br><span class="line">        ar.compareAndSet(p1, p2);</span><br><span class="line"></span><br><span class="line">        Person p3 = (Person)ar.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;p3 is &quot;</span>+p3);</span><br><span class="line">        System.out.println(<span class="string">&quot;p3.equals(p2)=&quot;</span>+p3.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3 is id:102</span><br><span class="line">p3.equals(p2)=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>结果说明：</p>
<ul>
<li>新建AtomicReference对象ar时，将它初始化为p1。</li>
<li>紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。</li>
<li>最后，获取ar对应的对象，并打印结果。p3.equals(p2)的结果为false。<ul>
<li>这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用”==”去比较两个对象，即比较两个对象的地址是否相等。</li>
</ul>
</li>
</ul>
<p>举个<code>AtomicMarkableReference</code>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> cn.itcast.n2.util.Sleeper.sleep;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test38&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test38</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GarbageBag bag = <span class="keyword">new</span> GarbageBag(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        GarbageBag prev = ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            ref.compareAndSet(bag, bag, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;,<span class="string">&quot;保洁阿姨&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> success = ref.compareAndSet(prev, <span class="keyword">new</span> GarbageBag(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GarbageBag</span> </span>&#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GarbageBag</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、原子更新字段类（原子更新器）"><a href="#4、原子更新字段类（原子更新器）" class="headerlink" title="4、原子更新字段类（原子更新器）"></a>4、原子更新字段类（原子更新器）</h5><p>Atomic包提供了四个类进行原子字段更新：</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器。</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li>
<li><code>AtomicStampedFieldUpdater</code>：原子更新带有版本号的引用类型。</li>
<li><code>AtomicReferenceFieldUpdater</code>：上面已经说过此处不在赘述。</li>
</ul>
<p>这四个类的使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步：</p>
<ol>
<li>第一步，因为原子更新字段类都是抽象类，每次使用的时候<strong>必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性</strong>。</li>
<li>第二步，<strong>更新类的字段必须使用public volatile修饰。</strong></li>
</ol>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicIntegerFieldUpdater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestAtomicIntegerFieldUpdater tIA = <span class="keyword">new</span> TestAtomicIntegerFieldUpdater();</span><br><span class="line">        tIA.doIt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AtomicIntegerFieldUpdater&lt;DataDemo&gt; <span class="title">updater</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AtomicIntegerFieldUpdater.newUpdater(DataDemo.class,name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DataDemo data = <span class="keyword">new</span> DataDemo();</span><br><span class="line">        System.out.println(<span class="string">&quot;publicVar = &quot;</span>+updater(<span class="string">&quot;publicVar&quot;</span>).getAndAdd(data, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于在DataDemo类中属性value2/value3,在TestAtomicIntegerFieldUpdater中不能访问</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="comment">//System.out.println(&quot;protectedVar = &quot;+updater(&quot;protectedVar&quot;).getAndAdd(data,2));</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;privateVar = &quot;+updater(&quot;privateVar&quot;).getAndAdd(data,2));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//报java.lang.IllegalArgumentException</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;staticVar = &quot;+updater(&quot;staticVar&quot;).getAndIncrement(data));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 下面报异常：must be integer</span></span><br><span class="line"><span class="comment">         */</span>   </span><br><span class="line">        <span class="comment">//System.out.println(&quot;integerVar = &quot;+updater(&quot;integerVar&quot;).getAndIncrement(data));</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;longVar = &quot;+updater(&quot;longVar&quot;).getAndIncrement(data));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> publicVar=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> protectedVar=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">int</span> privateVar=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//public final int finalVar = 11;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Integer integerVar = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Long longVar = <span class="number">18L</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再说下对于<code>AtomicIntegerFieldUpdater</code> 的使用稍微有一些限制和约束，约束如下：</p>
<ul>
<li><strong>字段必须是volatile类型的，在线程之间共享变量时保证立即可见</strong>。<ul>
<li>eg：volatile int value = 3</li>
</ul>
</li>
<li><strong>字段的描述类型(修饰符public/protected/default/private)是与调用者与操作对象字段的关系一致</strong>。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li>
<li><strong>只能是实例变量，不能是类变量，也就是说不能加static关键字</strong>。</li>
<li><strong>只能是可修改变量，不能是final变量，因为final的语义就是不可修改</strong>。<strong>实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</strong></li>
<li><strong>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型(Integer/Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater</strong>。</li>
</ul>
<h5 id="5、原子累加器"><a href="#5、原子累加器" class="headerlink" title="5、原子累加器"></a>5、原子累加器</h5><p><strong>原子类型累加器</strong>是<strong>JDK1.8</strong>引进的并发新技术，它可以看做<strong>AtomicLong</strong>和<strong>AtomicDouble</strong>的部分加强类型。</p>
<p><strong>原子类型累加器</strong>有如下四种：</p>
<ul>
<li><code>DoubleAccumulator</code></li>
<li><code>DoubleAdder</code></li>
<li><code>LongAccumulator</code></li>
<li><code>LongAdder</code></li>
</ul>
<p>由于上面四种累加器的原理类似，下面以LongAdder为列来介绍累加器的使用。</p>
<p>已经有AtomicLong的getAndIncrement()方法进行累加效果，为什么还要有LongAdder累加器？</p>
<ul>
<li><p>我们知道，<strong>AtomicLong</strong>是利用了底层的CAS操作来提供并发性的，比如<strong>addAndGet</strong>方法：</p>
</li>
<li><pre><code class="java">public final long addAndGet(long delta) &#123;
    return unsafe.getAndAddLong(this, valueOffset, delta) + delta;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上述方法调用了**Unsafe**类的**getAndAddLong**方法，该方法是个**native**方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。</span><br><span class="line"></span><br><span class="line">- 在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时**AtomicLong**的自旋会成为瓶颈。</span><br><span class="line"></span><br><span class="line">- 这就是**LongAdder**引入的初衷——解决高并发环境下**AtomicLong**的自旋瓶颈问题。</span><br><span class="line"></span><br><span class="line">- 而**LongAdder**的基本思路就是**分散热点**，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。</span><br><span class="line"></span><br><span class="line">- 如果要获取真正的long值，只要将各个槽中的变量值累加返回。</span><br><span class="line"></span><br><span class="line">  - ConcurrentHashMap中的“分段锁”其实就是类似的思路。</span><br><span class="line"></span><br><span class="line">###### 1、累加器性能比较——比较 AtomicLong 与 LongAdder</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) &#123;</span><br><span class="line">    T adder &#x3D; adderSupplier.get();</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;Thread&gt; ts &#x3D; new ArrayList&lt;&gt;();     &#x2F;&#x2F; 4 个线程，每人累加 50 万</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 40; i++) &#123;</span><br><span class="line">        ts.add(new Thread(() -&gt; &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 500000; j++) &#123;</span><br><span class="line">                action.accept(adder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    long end &#x3D; System.nanoTime();</span><br><span class="line">    System.out.println(adder + &quot; cost:&quot; + (end - start)&#x2F;1000_000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>比较 AtomicLong 与 LongAdder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1000000 cost:43 </span><br><span class="line">1000000 cost:9 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line"></span><br><span class="line">1000000 cost:31 </span><br><span class="line">1000000 cost:27 </span><br><span class="line">1000000 cost:28 </span><br><span class="line">1000000 cost:24 </span><br><span class="line">1000000 cost:22 </span><br></pre></td></tr></table></figure>

<p>性能提升的原因很简单，就是<strong>在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总</strong>。这样它们在累加时操作的不同的 Cell 变量，因此<strong>减少了 CAS 重试失败</strong>，从而提高性能。</p>
<h6 id="2、LongAdder源码"><a href="#2、LongAdder源码" class="headerlink" title="2、LongAdder源码"></a>2、LongAdder源码</h6><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧</p>
<p>类的继承关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// Striped64这个类实现一些核心操作，处理64位数据。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>LongAdder 类有几个关键域：（这几个的关键域定义在Striped64抽象类中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁（cas锁）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<p>其中 Cell 即为累加单元</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、缓存（伪共享问题）"><a href="#3、缓存（伪共享问题）" class="headerlink" title="3、缓存（伪共享问题）"></a>3、缓存（伪共享问题）</h6><p>缓存与内存的速度比较：</p>
<p><img src="/2021/07/19/JUC/image-20210807034923018.png" alt="image-20210807034923018"></p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。</p>
<p>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）</p>
<p>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</p>
<p>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p>
<p>可以通过<code>缓存一致性协议(MESI)</code>保证：</p>
<p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ <code>嗅探(snooping)&quot; 协议</code>。</p>
<p>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 <strong>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效</strong>。</p>
<p>伪共享：</p>
<p><img src="/2021/07/19/JUC/image-20210807035727427.png" alt="image-20210807035727427"></p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>
<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加Cell[0]=6001, Cell[1]=8000 Q，这时会让 Core-1 的缓存行失效。这种问题被叫做伪共享问题。</p>
<p>@sun.misc.Contended 用来解决这个伪共享问题，它的原理是<strong>在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</strong></p>
<p><img src="/2021/07/19/JUC/JUC%5Cimage-20210807040114815.png" alt="image-20210807040114815"></p>
<h6 id="4、核心方法——increment"><a href="#4、核心方法——increment" class="headerlink" title="4、核心方法——increment()"></a>4、核心方法——increment()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：increment()方法调用了add()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">            as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 流程图：</p>
<p><img src="/2021/07/19/JUC/image-20210807040735271.png" alt="image-20210807040735271"></p>
<p>说明：</p>
<ul>
<li>cells是懒惰式创建的，当有竞争的才会创建cells数组，进而创建cells数组里面的cell对象</li>
<li>当cells为空是说明当前竞争并不激烈，累加操作交给<code>base</code>去操作<ul>
<li>成功：返回</li>
<li>失败：进入longAccumulate()方法</li>
</ul>
</li>
<li>当cells不为空说明当前存在竞争，查看当前线程cell是否创建<ul>
<li>没创建：进入longAccumulate()方法创建cell</li>
<li>创建：累加操作交给创建的<code>cell</code>去操作<ul>
<li>成功：返回</li>
<li>失败：进入longAccumulate()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由此刻看出，当累加失败或者没有创建cell时都会调用<code>longAccumulate</code>()方法，以下为longAccumulate()方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe</span></span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">// 已经有了 cells</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x </span></span><br><span class="line">                <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">// 创建cell对象</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="comment">// 上锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// cells数组不为空</span></span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; <span class="comment">// cells大小大于0</span></span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123; <span class="comment">// cells是否有空槽位</span></span><br><span class="line">                                <span class="comment">// 如果槽位为空，则将创建的cell设置到空槽位当中</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 解锁</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 创建成功</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 三个判断：</span></span><br><span class="line"><span class="comment">        * 1、判断cellsBusy锁是否上锁</span></span><br><span class="line"><span class="comment">        * 2、是否有其他线程创建了cells</span></span><br><span class="line"><span class="comment">        * 3、尝试对cellsBusy上锁：把cellsBusy的值从0改到1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell </span></span><br><span class="line">            <span class="comment">// 成功则 break;</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">// 再次判断是否其他线程已经了创建cells</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    <span class="comment">// 创建cells，初始大小是2，</span></span><br><span class="line">                    <span class="comment">// 但是同时创建了一个cell(只创建了一个cell，有一个cells的空间是空的)</span></span><br><span class="line">                    <span class="comment">// 线程不到万不得已才会使用到这个空的cell，体现了：线程对cell的懒惰初始化</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化成功</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上两种情况失败, 尝试给 base 累加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>longAccumulate流程图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁成功，进入下面else if块的逻辑：创建cells</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁失败，进入下面else if块的逻辑：尝试给 base 累加</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/image-20210807042131270.png" alt="image-20210807042131270"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cells不为空且cells的长度大于0：创建cell</span></span><br><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/image-20210807042151516.png" alt="image-20210807042151516"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                             fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"><span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">    collide = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">            <span class="comment">// 先将长度进行翻倍 n&lt;&lt;1</span></span><br><span class="line">            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 把老数组的对象复制到新数组当中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            <span class="comment">// 用新数组替换掉旧数组</span></span><br><span class="line">            cells = rs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">h = advanceProbe(h);</span><br></pre></td></tr></table></figure>

<p>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>
<p><img src="/2021/07/19/JUC/image-20210807042217185.png" alt="image-20210807042217185"></p>
<p>获取最终结果通过 sum 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6、再说AutomicStampedReference解决CAS的ABA问题"><a href="#6、再说AutomicStampedReference解决CAS的ABA问题" class="headerlink" title="6、再说AutomicStampedReference解决CAS的ABA问题"></a>6、再说AutomicStampedReference解决CAS的ABA问题</h4><h5 id="1、AutomicStampedReference解决CAS的ABA问题"><a href="#1、AutomicStampedReference解决CAS的ABA问题" class="headerlink" title="1、AutomicStampedReference解决CAS的ABA问题"></a>1、AutomicStampedReference解决CAS的ABA问题</h5><p>AtomicStampedReference主要维护<strong>包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象</strong>来解决ABA问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;  <span class="comment">//维护对象引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//用于标志版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * expectedReference ：更新之前的原始值</span></span><br><span class="line"><span class="comment">      * newReference : 将要更新的新值</span></span><br><span class="line"><span class="comment">      * expectedStamp : 期待更新的标志版本</span></span><br><span class="line"><span class="comment">      * newStamp : 将要更新的标志版本</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的(元素值，版本号)对</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 引用没变</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 版本号没变</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            <span class="comment">// 新引用等于旧引用</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 新版本号等于旧版本号</span></span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            <span class="comment">// 构造新的Pair对象并CAS更新</span></span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果元素值和版本号都没有变化，并且和新的也相同，返回true；</li>
<li>如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。</li>
</ul>
<p>可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。</p>
<ul>
<li>首先，使用版本号控制；</li>
<li>其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；</li>
<li>最后，外部传入元素值及版本号，而不是节点(Pair)的引用。</li>
</ul>
<h5 id="2、使用举例"><a href="#2、使用举例" class="headerlink" title="2、使用举例"></a>2、使用举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">        <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,初始值 a = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">        <span class="keyword">int</span> stamp = atomicStampedRef.getStamp(); <span class="comment">//获取当前标识别</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待1秒 ，以便让干扰线程执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isCASSuccess = atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,stamp +<span class="number">1</span>);  <span class="comment">//此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败</span></span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,CAS操作结果: &quot;</span> + isCASSuccess);</span><br><span class="line">    &#125;,<span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.yield(); <span class="comment">// 确保thread-main 优先执行</span></span><br><span class="line">atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,【increment】 ,值 = &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">        atomicStampedRef.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,【decrement】 ,值 = &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">    &#125;,<span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    main.start();</span><br><span class="line">    other.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">&gt; 操作线程Thread[主操作线程,5,main],初始值 a = 2</span><br><span class="line">&gt; 操作线程Thread[干扰线程,5,main],【increment】 ,值 = 2</span><br><span class="line">&gt; 操作线程Thread[干扰线程,5,main],【decrement】 ,值 = 1</span><br><span class="line">&gt; 操作线程Thread[主操作线程,5,main],CAS操作结果: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="3、java中还有哪些类可以解决ABA问题？"><a href="#3、java中还有哪些类可以解决ABA问题？" class="headerlink" title="3、java中还有哪些类可以解决ABA问题？"></a>3、java中还有哪些类可以解决ABA问题？</h5><p><code>AtomicMarkableReference</code>，它不是维护一个版本号，而是<strong>维护一个boolean类型的标记，标记值有修改</strong>，了解一下。</p>
<h5 id="4、在日常的业务中怎么解决ABA问题？（用乐观锁的方法）"><a href="#4、在日常的业务中怎么解决ABA问题？（用乐观锁的方法）" class="headerlink" title="4、在日常的业务中怎么解决ABA问题？（用乐观锁的方法）"></a>4、在日常的业务中怎么解决ABA问题？（用乐观锁的方法）</h5><ul>
<li><strong>加标志位做版本号</strong>，例如搞个自增的字段，操作一次就自增加一；</li>
<li><strong>加个时间戳</strong>，比较时间戳的值</li>
</ul>
<h3 id="3、JUC锁：LockSupport详解"><a href="#3、JUC锁：LockSupport详解" class="headerlink" title="3、JUC锁：LockSupport详解"></a>3、JUC锁：LockSupport详解</h3><p>LockSupport是锁中的基础，是一个提供锁机制的工具类。</p>
<h4 id="1、BAT大厂的面试问题-7"><a href="#1、BAT大厂的面试问题-7" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>为什么LockSupport也是核心基础类？<ul>
<li>AQS框架借助于两个类：<code>Unsafe(提供CAS操作)</code>和<code>LockSupport(提供park/unpark操作)</code></li>
</ul>
</li>
<li>写出分别通过wait/notify和LockSupport的park/unpark实现同步？</li>
<li>LockSupport.park()会释放锁资源吗？那么Condition.await()呢？</li>
<li>Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别？重点</li>
<li>如果在wait()之前执行了notify()会怎样？</li>
<li>如果在park()之前执行了unpark()会怎样？</li>
</ul>
<h4 id="2、LockSupport简介"><a href="#2、LockSupport简介" class="headerlink" title="2、LockSupport简介"></a>2、LockSupport简介</h4><p><strong>LockSupport用来创建锁和其他同步类的基本线程阻塞原语</strong>。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。</p>
<h4 id="3、LockSupport源码分析"><a href="#3、LockSupport源码分析" class="headerlink" title="3、LockSupport源码分析"></a>3、LockSupport源码分析</h4><h5 id="1、类的属性"><a href="#1、类的属性" class="headerlink" title="1、类的属性"></a>1、类的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取Unsafe实例</span></span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            <span class="comment">// 线程类类型</span></span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            <span class="comment">// 获取Thread的parkBlocker字段的内存偏移地址</span></span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomSeed字段的内存偏移地址</span></span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSeed&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomProbe字段的内存偏移地址</span></span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址</span></span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSecondarySeed&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：UNSAFE字段表示sun.misc.Unsafe类，查看其源码，点击在这里，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。</p>
<h5 id="2、类的构造函数"><a href="#2、类的构造函数" class="headerlink" title="2、类的构造函数"></a>2、类的构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有构造函数，无法被实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：LockSupport只有一个私有构造函数，无法被实例化。</p>
<h5 id="3、核心函数分析"><a href="#3、核心函数分析" class="headerlink" title="3、核心函数分析"></a>3、核心函数分析</h5><p>在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明：对两个函数的说明如下：</p>
<ul>
<li>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞：<ol>
<li>调用unpark函数，释放该线程的许可。</li>
<li>该线程被中断。</li>
<li>设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li>
</ol>
</li>
<li>unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li>
</ul>
<h6 id="1、park函数"><a href="#1、park函数" class="headerlink" title="1、park函数"></a>1、park函数</h6><p>park函数有两个重载版本，方法摘要如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span>；</span></span><br></pre></td></tr></table></figure>

<p>说明：两个函数的区别在于park()函数没有没有blocker，即<strong>没有设置线程的parkBlocker字段</strong>。park(Object)型函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 设置Blocker</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 重新可运行后再此设置Blocker</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。</p>
<p>那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? </p>
<p>原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。</p>
<p>如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。</p>
<p>setBlocker方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置线程t的parkBlocker字段的值为arg</span></span><br><span class="line">    UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此方法用于设置线程t的parkBlocker字段的值为arg。</p>
<p>另外一个无参重载版本，park()函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取许可，设置时间为无限长，直到可以获取许可</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>调用了park函数后，会禁用当前线程，除非许可可用</strong>。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行：</p>
<ul>
<li>其他某个线程将当前线程作为目标调用 unpark。</li>
<li>其他某个线程中断当前线程。</li>
<li>该调用不合逻辑地(即毫无理由地)返回。</li>
</ul>
<h6 id="2、parkNanos函数"><a href="#2、parkNanos函数" class="headerlink" title="2、parkNanos函数"></a>2、parkNanos函数</h6><p>此函数表示在<strong>许可可用前禁用当前线程，并最多等待指定的等待时间</strong>。具体函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123; <span class="comment">// 时间大于0</span></span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 设置Blocker</span></span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        <span class="comment">// 获取许可，并设置了时间</span></span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">        <span class="comment">// 设置许可</span></span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该函数也是调用了两次setBlocker函数，nanos参数表示相对时间，表示等待多长时间。</p>
<h6 id="3、parkUntil函数"><a href="#3、parkUntil函数" class="headerlink" title="3、parkUntil函数"></a>3、parkUntil函数</h6><p>此函数表示<strong>在指定的时限前禁用当前线程，除非许可可用</strong>，具体函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 设置Blocker</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">    <span class="comment">// 设置Blocker为null</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该函数也调用了两次setBlocker函数，deadline参数表示绝对时间，表示指定的时间。</p>
<h6 id="4、unpark函数"><a href="#4、unpark函数" class="headerlink" title="4、unpark函数"></a>4、unpark函数</h6><p>此函数表示<strong>如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果</strong>。具体函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>) <span class="comment">// 线程为不空</span></span><br><span class="line">        UNSAFE.unpark(thread); <span class="comment">// 释放该线程许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：释放许可，指定线程可以继续运行。</p>
<h4 id="4、park-unpark-原理"><a href="#4、park-unpark-原理" class="headerlink" title="4、park/unpark 原理"></a>4、park/unpark 原理</h4><p>每个线程都有自己的一个 Parker 对象(有C++编写)，由三部分组成 <code>_counter</code> ， <code>_cond</code> 和 <code>_mutex</code> 打个比喻</p>
<ul>
<li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li>
<li>调用 park 就是要看需不需要停下来歇息<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li>调用 unpark，就好比令干粮充足<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1、先调用park"><a href="#1、先调用park" class="headerlink" title="1、先调用park()"></a>1、先调用park()</h5><p><img src="/2021/07/19/JUC/image-20210806000710338.png" alt="image-20210806000710338"></p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>   检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li>
<li>   线程进入 _cond 条件变量阻塞</li>
<li>   <strong>设置 _counter = 0</strong></li>
</ol>
<h5 id="2、再调用unpark-："><a href="#2、再调用unpark-：" class="headerlink" title="2、再调用unpark()："></a>2、再调用unpark()：</h5><p><img src="/2021/07/19/JUC/image-20210806000820108.png" alt="image-20210806000820108"></p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>   唤醒 _cond 条件变量中的 Thread_0</li>
<li>   Thread_0 恢复运行</li>
<li>   设置 _counter 为 0</li>
</ol>
<h5 id="3、先调用unpark-，再调用park-："><a href="#3、先调用unpark-，再调用park-：" class="headerlink" title="3、先调用unpark()，再调用park()："></a>3、先调用unpark()，再调用park()：</h5><p><img src="/2021/07/19/JUC/image-20210806000922500.png" alt="image-20210806000922500"></p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>   当前线程调用 Unsafe.park() 方法</li>
<li>   检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li>
<li>   设置 _counter 为 0</li>
</ol>
<h4 id="5、LockSupport示例说明"><a href="#5、LockSupport示例说明" class="headerlink" title="5、LockSupport示例说明"></a>5、LockSupport示例说明</h4><h5 id="1、使用wait-notify实现线程同步"><a href="#1、使用wait-notify实现线程同步" class="headerlink" title="1、使用wait/notify实现线程同步"></a>1、使用wait/notify实现线程同步</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before notify&quot;</span>);            </span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;after notify&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();            </span><br><span class="line">        <span class="keyword">synchronized</span> (myThread) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                myThread.start();</span><br><span class="line">                <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">                <span class="comment">// 阻塞主线程</span></span><br><span class="line">                myThread.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before <span class="built_in">wait</span></span><br><span class="line">before notify</span><br><span class="line">after notify</span><br><span class="line">after <span class="built_in">wait</span></span><br></pre></td></tr></table></figure>

<p>说明：具体的流程图如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-locksupport-1.png" alt="img"></p>
<p>使用wait/notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before notify&quot;</span>);            </span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;after notify&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();        </span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (myThread) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                System.out.println(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">                <span class="comment">// 阻塞主线程</span></span><br><span class="line">                myThread.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before notify</span><br><span class="line">after notify</span><br><span class="line">before <span class="built_in">wait</span></span><br></pre></td></tr></table></figure>

<p>说明：由于先调用了notify，再调用的wait，此时主线程还是会一直阻塞。</p>
<h5 id="2、使用park-unpark实现线程同步"><a href="#2、使用park-unpark实现线程同步" class="headerlink" title="2、使用park/unpark实现线程同步"></a>2、使用park/unpark实现线程同步</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before unpark&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取blocker</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));</span><br><span class="line">        <span class="comment">// 释放许可</span></span><br><span class="line">        LockSupport.unpark((Thread) object);</span><br><span class="line">        <span class="comment">// 休眠500ms，保证先执行park中的setBlocker(t, null);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次获取blocker</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;after unpark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(Thread.currentThread());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;before park&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        LockSupport.park(<span class="string">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before park</span><br><span class="line">before unpark</span><br><span class="line">Blocker info ParkAndUnparkDemo</span><br><span class="line">after park</span><br><span class="line">Blocker info null</span><br><span class="line">after unpark</span><br></pre></td></tr></table></figure>

<p>说明：本程序先执行park，然后在执行unpark，进行同步，并且在unpark的前后都调用了getBlocker，可以看到两次的结果不一样，并且第二次调用的结果为null，这是因为在调用unpark之后，执行了Lock.park(Object blocker)函数中的setBlocker(t, null)函数，所以第二次调用getBlocker时为null。</p>
<p>上例是先调用park，然后调用unpark，现在修改程序，先调用unpark，然后调用park，看能不能正确同步。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before unpark&quot;</span>);        </span><br><span class="line">        <span class="comment">// 释放许可</span></span><br><span class="line">        LockSupport.unpark((Thread) object);</span><br><span class="line">        System.out.println(<span class="string">&quot;after unpark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkAndUnparkDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(Thread.currentThread());</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;before park&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        LockSupport.park(<span class="string">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before unpark</span><br><span class="line">after unpark</span><br><span class="line">before park</span><br><span class="line">after park</span><br></pre></td></tr></table></figure>

<p>说明：可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait/notify调用顺序不当所引起的阻塞。因此park/unpark相比wait/notify更加的灵活。</p>
<h5 id="3、中断响应"><a href="#3、中断响应" class="headerlink" title="3、中断响应"></a>3、中断响应</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before interrupt&quot;</span>);        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠3s</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">        Thread thread = (Thread) object;</span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;after interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(Thread.currentThread());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;before park&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        LockSupport.park(<span class="string">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before park</span><br><span class="line">before interrupt</span><br><span class="line">after interrupt</span><br><span class="line">after park</span><br></pre></td></tr></table></figure>

<p>说明：可以看到，在主线程调用park阻塞后，在myThread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时interrupt起到的作用与unpark一样。</p>
<h4 id="6、更深入的理解"><a href="#6、更深入的理解" class="headerlink" title="6、更深入的理解"></a>6、更深入的理解</h4><h5 id="1、Thread-sleep-和Object-wait-的区别"><a href="#1、Thread-sleep-和Object-wait-的区别" class="headerlink" title="1、Thread.sleep()和Object.wait()的区别"></a>1、Thread.sleep()和Object.wait()的区别</h5><p>首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点：</p>
<ul>
<li>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</li>
<li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</li>
<li>Thread.sleep()到时间了会自动唤醒，然后继续执行；</li>
<li>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</li>
<li>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</li>
</ul>
<p>其实，<strong>他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</strong></p>
<h5 id="2、Thread-sleep-和Condition-await-的区别"><a href="#2、Thread-sleep-和Condition-await-的区别" class="headerlink" title="2、Thread.sleep()和Condition.await()的区别"></a>2、Thread.sleep()和Condition.await()的区别</h5><p><strong>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</strong></p>
<p>实际上，它在阻塞当前线程之前还干了两件事：</p>
<ol>
<li>一是把当前线程添加到条件队列中</li>
<li>二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</li>
</ol>
<h5 id="3、Thread-sleep-和LockSupport-park-的区别"><a href="#3、Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="3、Thread.sleep()和LockSupport.park()的区别"></a>3、Thread.sleep()和LockSupport.park()的区别</h5><p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p>
<ul>
<li>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</li>
<li>Thread.sleep()没法从外部唤醒，只能自己醒过来；</li>
<li>LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li>
<li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</li>
<li>LockSupport.park()方法不需要捕获中断异常；</li>
<li>Thread.sleep()本身就是一个native方法；</li>
<li>LockSupport.park()底层是调用的Unsafe的native方法；</li>
</ul>
<h5 id="4、Object-wait-和LockSupport-park-的区别"><a href="#4、Object-wait-和LockSupport-park-的区别" class="headerlink" title="4、Object.wait()和LockSupport.park()的区别"></a>4、Object.wait()和LockSupport.park()的区别</h5><p>二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！</p>
<ul>
<li>Object.wait()方法需要在synchronized块中执行；</li>
<li>LockSupport.park()可以在任意地方执行；</li>
<li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</li>
<li>LockSupport.park()不需要捕获中断异常；</li>
<li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</li>
<li>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</li>
<li>如果在wait()之前执行了notify()会怎样? 抛出IllegalMonitorStateException异常；</li>
<li>如果在park()之前执行了unpark()会怎样? 线程不会被阻塞，直接跳过park()，继续执行后续内容；</li>
</ul>
<p><strong>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</strong></p>
<h5 id="5、LockSupport-park-会释放锁资源吗？"><a href="#5、LockSupport-park-会释放锁资源吗？" class="headerlink" title="5、LockSupport.park()会释放锁资源吗？"></a>5、LockSupport.park()会释放锁资源吗？</h5><p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>
<h3 id="4、AbstractQueuedSynchronizer（AQS）"><a href="#4、AbstractQueuedSynchronizer（AQS）" class="headerlink" title="4、AbstractQueuedSynchronizer（AQS）"></a>4、AbstractQueuedSynchronizer（AQS）</h3><p>AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。</p>
<h4 id="1、BAT大厂的面试问题-8"><a href="#1、BAT大厂的面试问题-8" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>什么是AQS？为什么它是核心？</li>
<li>AQS的核心思想是什么？它是怎么实现的？底层数据结构等</li>
<li>AQS有哪些核心的方法？</li>
<li>AQS定义什么样的资源获取方式？<ul>
<li>AQS定义了两种资源获取方式：<ul>
<li><code>独占</code>(只有一个线程能访问执行，又根据是否按队列的顺序分为<code>公平锁</code>和<code>非公平锁</code>，如<code>ReentrantLock</code>) </li>
<li><code>共享</code>(多个线程可同时访问执行，如<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code> )。<code>ReentrantReadWriteLock</code>可以看成是组合式，允许多个线程同时对某一资源进行读。</li>
</ul>
</li>
</ul>
</li>
<li>AQS底层使用了什么样的设计模式？<ul>
<li>模板</li>
</ul>
</li>
<li>AQS的应用示例？</li>
</ul>
<h4 id="2、AbstractQueuedSynchronizer简介"><a href="#2、AbstractQueuedSynchronizer简介" class="headerlink" title="2、AbstractQueuedSynchronizer简介"></a>2、AbstractQueuedSynchronizer简介</h4><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h5 id="1、AQS核心思想"><a href="#1、AQS核心思想" class="headerlink" title="1、AQS核心思想"></a>1、AQS核心思想</h5><p>AQS核心思想是：<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig，Landin，and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p>
</blockquote>
<p><strong>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</strong></p>
<p><strong>AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、AQS对资源的共享方式"><a href="#2、AQS对资源的共享方式" class="headerlink" title="2、AQS对资源的共享方式"></a>2、AQS对资源的共享方式</h5><p>AQS定义两种资源共享方式：</p>
<ul>
<li>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。<ul>
<li>又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的（抢不到就乖乖排队吧）</li>
</ul>
</li>
</ul>
</li>
<li>Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。</p>
<h5 id="3、AQS底层使用了模板方法模式"><a href="#3、AQS底层使用了模板方法模式" class="headerlink" title="3、AQS底层使用了模板方法模式"></a>3、AQS底层使用了模板方法模式</h5><blockquote>
<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)</p>
</blockquote>
<p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。这和我们以往通过实现接口的方式有很大区别。</p>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以ReentrantLock为例：</p>
<ol>
<li>state初始化为0，表示未锁定状态。</li>
<li>A线程lock()时，会调用tryAcquire()独占该锁并将state+1。</li>
<li>此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。</li>
<li>当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</li>
</ol>
<h5 id="4、总结-1"><a href="#4、总结-1" class="headerlink" title="4、总结"></a>4、总结</h5><p>AbstractQueuedSynchronizer是阻塞式锁和相关的同步器工具的框架，特点：</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 <code>EntryList</code></li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 <code>WaitSet</code></li>
<li>子类主要实现这样一些方法（默认抛出 <code>UnsupportedOperationException</code>）<ul>
<li><code>tryAcquire</code></li>
<li><code>tryRelease</code></li>
<li><code>tryAcquireShared</code></li>
<li><code>tryReleaseShared</code></li>
<li><code>isHeldExclusively</code></li>
</ul>
</li>
</ul>
<h4 id="3、AbstractQueuedSynchronizer数据结构"><a href="#3、AbstractQueuedSynchronizer数据结构" class="headerlink" title="3、AbstractQueuedSynchronizer数据结构"></a>3、AbstractQueuedSynchronizer数据结构</h4><p>AbstractQueuedSynchronizer类底层的数据结构是使用<code>CLH(Craig,Landin,and Hagersten)队列</code>是一个<strong>虚拟的双向队列</strong>(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。<strong>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配</strong>。</p>
<ul>
<li>其中<code>Sync queue</code>，即<strong>同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度</strong>。</li>
<li>而<code>Condition queue</code>不是必须的，其是<strong>一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue</strong>。</li>
</ul>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-1.png" alt="image"></p>
<h4 id="4、AbstractQueuedSynchronizer源码分析"><a href="#4、AbstractQueuedSynchronizer源码分析" class="headerlink" title="4、AbstractQueuedSynchronizer源码分析"></a>4、AbstractQueuedSynchronizer源码分析</h4><h5 id="1、类的继承关系"><a href="#1、类的继承关系" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h5><p>AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>其中AbstractOwnableSynchronizer抽象类的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3737899427754241961L</span>;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnableSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 独占模式下的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置独占线程 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取独占线程 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractOwnableSynchronizer抽象类中，<strong>可以设置独占资源线程和获取独占资源线程</strong>。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。</p>
<h5 id="2、类的内部类"><a href="#2、类的内部类" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h5><p>AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类。</p>
<h5 id="3、类的内部类——Node类"><a href="#3、类的内部类——Node类" class="headerlink" title="3、类的内部类——Node类"></a>3、类的内部类——Node类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模式，分为共享与独占</span></span><br><span class="line">    <span class="comment">// 共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;        </span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="comment">// CANCELLED，值为1，表示当前的线程被取消</span></span><br><span class="line">    <span class="comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span></span><br><span class="line">    <span class="comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span></span><br><span class="line">    <span class="comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span></span><br><span class="line">    <span class="comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;        </span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;    </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;        </span><br><span class="line">    <span class="comment">// 结点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;        </span><br><span class="line">    <span class="comment">// 下一个等待者</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点是否在共享模式下等待</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱结点，若前驱结点为空，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="comment">// 保存前驱结点</span></span><br><span class="line">        Node p = prev; </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="comment">// 前驱结点为空，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 前驱结点不为空，返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;    <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下：</p>
<ul>
<li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li>
<li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li>
<li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。</li>
<li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li>
<li>值为0，表示当前节点在sync queue中，等待着获取锁。</li>
</ul>
<h5 id="4、类的内部类——ConditionObject类"><a href="#4、类的内部类——ConditionObject类" class="headerlink" title="4、类的内部类——ConditionObject类"></a>4、类的内部类——ConditionObject类</h5><p>这个类有点长，耐心看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">    <span class="comment">// condition队列的头结点</span></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">    <span class="comment">// condition队列的尾结点</span></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Internal methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 添加新的Node（waiter）到wait队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123; <span class="comment">// 尾结点不为空，并且尾结点的状态不为CONDITION</span></span><br><span class="line">            <span class="comment">// 清除状态为CONDITION的结点</span></span><br><span class="line">            unlinkCancelledWaiters(); </span><br><span class="line">            <span class="comment">// 将最后一个结点重新赋值给t</span></span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) <span class="comment">// 尾结点为空</span></span><br><span class="line">            <span class="comment">// 设置condition队列的头结点</span></span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 尾结点不为空</span></span><br><span class="line">            <span class="comment">// 设置为节点的nextWaiter域为node结点</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        <span class="comment">// 更新condition队列的尾结点</span></span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">        * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">        * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) <span class="comment">// 该节点的nextWaiter为空</span></span><br><span class="line">                <span class="comment">// 设置尾结点为空</span></span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 设置first结点的nextWaiter域</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="comment">// 将结点从condition队列转移到sync队列失败并且condition队列中的头结点不为空，一直循环</span></span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环</span></span><br><span class="line">            !transferForSignal(first) &amp;&amp;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// condition队列的头结点尾结点都设置为空</span></span><br><span class="line">        lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取first结点的nextWaiter域结点</span></span><br><span class="line">            Node next = first.nextWaiter;</span><br><span class="line">            <span class="comment">// 设置first结点的nextWaiter域为空</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将first结点从condition队列转移到sync队列</span></span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            <span class="comment">// 重新设置first</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">        * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">        * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">        * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">        * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">        * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">        * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">        * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">        * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">        * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">        * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">        * storms.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 从condition队列中清除状态为CANCEL的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">        Node t = firstWaiter;</span><br><span class="line">        Node trail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">// t不为空</span></span><br><span class="line">            <span class="comment">// 下一个结点</span></span><br><span class="line">            Node next = t.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123; <span class="comment">// t结点的状态不为CONDTION状态</span></span><br><span class="line">                <span class="comment">// 设置t节点的nextWaiter域为空</span></span><br><span class="line">                t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="keyword">null</span>) <span class="comment">// trail为空</span></span><br><span class="line">                    <span class="comment">// 重新设置condition队列的头结点</span></span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// trail不为空</span></span><br><span class="line">                    <span class="comment">// 设置trail结点的nextWaiter域为next结点</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">// next结点为空</span></span><br><span class="line">                    <span class="comment">// 设置condition队列的尾结点</span></span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// t结点的状态为CONDTION状态</span></span><br><span class="line">                <span class="comment">// 设置trail结点</span></span><br><span class="line">                trail = t;</span><br><span class="line">            <span class="comment">// 设置t结点</span></span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">        * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">        * owning lock.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">        *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头结点不为空</span></span><br><span class="line">            <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">        * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">        *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头结点不为空</span></span><br><span class="line">            <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">        * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">        *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Block until signalled.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">        *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">        * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加一个结点到等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 获取释放的状态,释放节点持有的锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">// 判断当前结点在不在同步队列之中</span></span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 当前线程被中断</span></span><br><span class="line">                <span class="comment">// 设置interrupted状态</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">// </span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">        * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">        * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">        * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">        * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">        * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">        * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 应用打断模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">        * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">        *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">        *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 当前线程被中断，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 在wait队列上添加一个结点</span></span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 获取释放的状态</span></span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 检查结点等待时的中断类型</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">        * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">        *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">        *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span></span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">        * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">        *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">        *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">        * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span></span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">        * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">        *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">        *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">        * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">        * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span></span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  support for instrumentation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns true if this condition was created by the given</span></span><br><span class="line"><span class="comment">        * synchronization object.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if owned</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Queries whether any threads are waiting on this condition.</span></span><br><span class="line"><span class="comment">        * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">        *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//  查询是否有正在等待此条件的任何线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns an estimate of the number of threads waiting on</span></span><br><span class="line"><span class="comment">        * this condition.</span></span><br><span class="line"><span class="comment">        * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">        *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 返回正在等待此条件的线程数估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">        * waiting on this Condition.</span></span><br><span class="line"><span class="comment">        * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">        *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 返回包含那些可能正在等待此条件的线程集合</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类实现了Condition接口，Condition接口定义了条件操作规范，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition接口中定义了await、signal方法，用来等待条件、释放条件。之后会详细分析CondtionObject的源码。</p>
<h5 id="5、类的属性"><a href="#5、类的属性" class="headerlink" title="5、类的属性"></a>5、类的属性</h5><p>属性中包含了<code>头结点head</code>，<code>尾结点tail</code>，<code>状态state</code>、<code>自旋时间spinForTimeoutThreshold</code>，还有AbstractQueuedSynchronizer抽象的<code>属性在内存中的偏移地址</code>，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于<code>加载内存偏移地址</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;    </span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;    </span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;    </span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;    </span><br><span class="line">    <span class="comment">// 自旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="comment">// head内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="comment">// tail内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">    <span class="comment">// next内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、类的构造方法"><a href="#6、类的构造方法" class="headerlink" title="6、类的构造方法"></a>6、类的构造方法</h5><p>此类构造方法为从抽象构造方法，供子类调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、类的核心方法——acquire方法"><a href="#7、类的核心方法——acquire方法" class="headerlink" title="7、类的核心方法——acquire方法"></a>7、类的核心方法——acquire方法</h5><p>该方法<strong>以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的</strong>。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用AQS的addWaiter , 接着 acquireQueued</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">        !tryAcquire(arg) &amp;&amp; </span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">        <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-2.png" alt="java-thread-x-juc-aqs-2"></p>
<ul>
<li>首先调用tryAcquire方法，<strong>调用此方法的线程会试图在独占模式下获取对象状态</strong>。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。</li>
<li>若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是<strong>将调用此方法的线程封装成为一个结点并放入Sync queue</strong>。</li>
<li>调用acquireQueued方法，此方法完成的功能是<strong>Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false</strong>。</li>
<li>由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。</li>
</ul>
<p>首先分析addWaiter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加等待者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点不为空，即已经被初始化</span></span><br><span class="line">        <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">        node.prev = pred; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 比较pred是否为尾结点，是则将尾结点设置为node </span></span><br><span class="line">            <span class="comment">// 双向链表</span></span><br><span class="line">            <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回新生成的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试将 Node 加入 AQS</span></span><br><span class="line">    enq(node); <span class="comment">// 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">            <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头结点为空，并设置头结点为新生成的结点</span></span><br><span class="line">                tail = head; <span class="comment">// 头结点与尾结点都指向同一个新生结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">            <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">            <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">            node.prev = t; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                t.next = node; </span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>enq方法会使用无限循环来确保节点的成功插入</strong>。</p>
<p>现在，分析acquireQueue方法。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取node节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); </span><br><span class="line">            <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 前驱为头结点并且成功获得锁</span></span><br><span class="line">                <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                setHead(node); <span class="comment">// 设置头结点</span></span><br><span class="line">                <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 设置标志</span></span><br><span class="line">                <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                <span class="keyword">return</span> interrupted; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">// 判断是否应当 park,</span></span><br><span class="line">                shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL </span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取当前节点的前驱节点，如果前驱节点是头结点并且能够获取(资源)，代表该当前节点能够占有锁，设置头结点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法，首先，我们看shouldParkAfterFailedAcquire方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱结点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 状态为SIGNAL，为-1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">// 前驱节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">        <span class="comment">// 可以进行park操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 表示状态为CANCELLED，为1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class="line">        <span class="comment">// 赋值pred结点的next域</span></span><br><span class="line">        pred.next = node; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">		<span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">        <span class="comment">// 比较并设置前驱结点的状态为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能进行park操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行park操作并且返回该线程是否被中断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在许可可用之前禁用当前线程，并且设置了blocker</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parkAndCheckInterrupt方法里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire方法，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消继续获取(资源)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="comment">// node为空，返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置node结点的thread为空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 保存node的前驱结点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    <span class="comment">// 获取pred结点的下一个结点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    <span class="comment">// 设置node结点的状态为CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">// node结点为尾结点，则设置尾结点为pred结点</span></span><br><span class="line">        <span class="comment">// 比较并设置pred结点的next节点为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node结点不为尾结点，或者比较设置不成功</span></span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123; <span class="comment">// (pred结点不为头结点，并且pred结点的状态为SIGNAL)或者 </span></span><br><span class="line">                                <span class="comment">// pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空</span></span><br><span class="line">            <span class="comment">// 保存结点的后继</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 后继不为空并且后继的状态小于等于0</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next); <span class="comment">// 比较并设置pred.next = next;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 释放node的前一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法完成的功能就是<strong>取消当前线程对资源的获取，即设置该结点的状态为CANCELLED</strong>，接着我们再看unparkSuccessor方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 获取node结点的等待状态</span></span><br><span class="line">    <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0 </span></span><br><span class="line">    <span class="comment">// 不成功也可以</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span></span><br><span class="line">        <span class="comment">// 比较并且设置结点等待状态，设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 获取node节点的下一个结点</span></span><br><span class="line">    <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span></span><br><span class="line">        <span class="comment">// s赋值为空</span></span><br><span class="line">        s = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">// 从尾结点开始从后往前开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span></span><br><span class="line">                <span class="comment">// 保存结点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// 该结点不为为空，释放许可</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的作用就是<strong>为了释放node节点的后继结点</strong>。</p>
<p>对于cancelAcquire与unparkSuccessor方法，如下示意图可以清晰的表示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-3.png" alt="image"></p>
<p>其中node为参数，<strong>在执行完cancelAcquire方法后的效果就是unpark了s结点所包含的t4线程</strong>。</p>
<p>现在，再来看acquireQueued方法的整个的逻辑。逻辑如下：</p>
<ol>
<li>判断结点的前驱是否为head并且是否成功获取(资源)。</li>
<li>若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。</li>
<li>若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。</li>
<li>若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。</li>
</ol>
<p>注意：</p>
<ul>
<li>是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定</li>
</ul>
<h5 id="8、类的核心方法——release方法"><a href="#8、类的核心方法——release方法" class="headerlink" title="8、类的核心方法——release方法"></a>8、类的核心方法——release方法</h5><p>以独占模式释放对象，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">        <span class="comment">// 保存头结点</span></span><br><span class="line">        <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">        Node h = head; </span><br><span class="line">        <span class="comment">// 队列不为 null</span></span><br><span class="line">        <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头结点不为空并且头结点状态不为0</span></span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头结点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点，unparkSuccessor方法已经分析过，不再累赘。</p>
<p>除了release()方法之外，还有一个方法——fullyRelease()用来释放锁：因为某线程可能重入，需要将 state 全部释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为某线程可能重入，需要将 state 全部释放</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState(); <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其他方法我们也可以分析，与前面分析的方法大同小异，所以，不再累赘。</p>
<h4 id="5、AbstractQueuedSynchronizer示例详解一"><a href="#5、AbstractQueuedSynchronizer示例详解一" class="headerlink" title="5、AbstractQueuedSynchronizer示例详解一"></a>5、AbstractQueuedSynchronizer示例详解一</h4><p>借助下面示例来分析AbstractQueuedSyncrhonizer内部的工作机制。示例源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchonizerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, lock);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, lock);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(可能的一种)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[t1,5,main] running</span><br><span class="line">Thread[t2,5,main] running</span><br></pre></td></tr></table></figure>

<p>结果分析：从示例可知，线程t1与t2共用了一把锁，即同一个lock。可能会存在如下一种时序：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-4.png" alt="image"></p>
<p>说明：首先线程t1先执行lock.lock操作，然后t2执行lock.lock操作，然后t1执行lock.unlock操作，最后t2执行lock.unlock操作。基于这样的时序，分析AbstractQueuedSynchronizer内部的工作机制：</p>
<ul>
<li>t1线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-5.png" alt="image"></li>
<li>说明：其中，前面的部分表示哪个类，后面是具体的类中的哪个方法，AQS表示AbstractQueuedSynchronizer类，AOS表示AbstractOwnableSynchronizer类。</li>
</ul>
</li>
<li>t2线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-6.png" alt="image"></li>
<li>说明：经过一系列的方法调用，最后达到的状态是禁用t2线程，因为调用了LockSupport.lock。</li>
</ul>
</li>
<li>t1线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-7.png" alt="image"></li>
<li>说明：t1线程中调用lock.unlock后，经过一系列的调用，最终的状态是释放了许可，因为调用了LockSupport.unpark。这时，t2线程就可以继续运行了。此时，会继续恢复t2线程运行环境，继续执行LockSupport.park后面的语句，即进一步调用如下：</li>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-8.png" alt="image"></li>
<li>说明：在上一步调用了LockSupport.unpark后，t2线程恢复运行，则运行parkAndCheckInterrupt，之后，继续运行acquireQueued方法，最后达到的状态是头结点head与尾结点tail均指向了t2线程所在的结点，并且之前的头结点已经从sync队列中断开了。</li>
</ul>
</li>
<li>t2线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-9.png" alt="image"></li>
<li>说明：t2线程执行lock.unlock后，最终达到的状态还是与之前的状态一样。</li>
</ul>
</li>
</ul>
<h4 id="6、AbstractQueuedSynchronizer示例详解二"><a href="#6、AbstractQueuedSynchronizer示例详解二" class="headerlink" title="6、AbstractQueuedSynchronizer示例详解二"></a>6、AbstractQueuedSynchronizer示例详解二</h4><p>下面我们结合Condition实现生产者与消费者，来进一步分析AbstractQueuedSynchronizer的内部工作机制。</p>
<p>Depot(仓库)类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Depot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition fullCondition;</span><br><span class="line">    <span class="keyword">private</span> Condition emptyCondition;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Depot</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;    </span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        fullCondition = lock.newCondition();</span><br><span class="line">        emptyCondition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> left = no;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity)  &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; before await&quot;</span>);</span><br><span class="line">                    fullCondition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; after await&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> inc = (left + size) &gt; capacity ? (capacity - size) : left;</span><br><span class="line">                left -= inc;</span><br><span class="line">                size += inc;</span><br><span class="line">                System.out.println(<span class="string">&quot;produce = &quot;</span> + inc + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">                emptyCondition.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> left = no;</span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; before await&quot;</span>);</span><br><span class="line">                    emptyCondition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; after await&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> dec = (size - left) &gt; <span class="number">0</span> ? left : size;</span><br><span class="line">                left -= dec;</span><br><span class="line">                size -= dec;</span><br><span class="line">                System.out.println(<span class="string">&quot;consume = &quot;</span> + dec + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">                fullCondition.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.consume(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, no + <span class="string">&quot; consume thread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.produce(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, no + <span class="string">&quot; produce thread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Depot depot = <span class="keyword">new</span> Depot(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Producer(depot).produce(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Producer(depot).produce(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">new</span> Consumer(depot).consume(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Consumer(depot).consume(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(可能的一种)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">produce = 500, size = 500</span><br><span class="line">Thread[200 produce thread,5,main] before await</span><br><span class="line">consume = 500, size = 0</span><br><span class="line">Thread[200 consume thread,5,main] before await</span><br><span class="line">Thread[200 produce thread,5,main] after await</span><br><span class="line">produce = 200, size = 200</span><br><span class="line">Thread[200 consume thread,5,main] after await</span><br><span class="line">consume = 200, size = 0</span><br></pre></td></tr></table></figure>

<p>说明：根据结果，我们猜测一种可能的时序如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-10.png" alt="image"></p>
<p>说明：p1代表produce 500的那个线程，p2代表produce 200的那个线程，c1代表consume 500的那个线程，c2代表consume 200的那个线程。</p>
<ol>
<li>p1线程调用lock.lock，获得锁，继续运行，方法调用顺序在前面已经给出。</li>
<li>p2线程调用lock.lock，由前面的分析可得到如下的最终状态：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-11.png" alt="java-thread-x-juc-aqs-11"></li>
<li>说明：p2线程调用lock.lock后，会禁止p2线程的继续运行，因为执行了LockSupport.park操作。</li>
</ul>
</li>
<li>c1线程调用lock.lock，由前面的分析得到如下的最终状态：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-12.png" alt="image"></li>
<li>说明：最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含p2的结点)的waitStatus变为了SIGNAL。</li>
</ul>
</li>
<li>c2线程调用lock.lock，由前面的分析得到如下的最终状态：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-13.png" alt="image"></li>
<li>说明：最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含c1的结点)的waitStatus变为了SIGNAL。</li>
</ul>
</li>
<li>p1线程执行emptyCondition.signal，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-14.png" alt="image"></li>
<li>说明：AQS.CO表示AbstractQueuedSynchronizer.ConditionObject类。此时调用signal方法不会产生任何其他效果。</li>
</ul>
</li>
<li>p1线程执行lock.unlock，根据前面的分析可知，最终的状态如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-15.png" alt="image"></li>
<li>说明：此时，p2线程所在的结点为头结点，并且其他两个线程(c1、c2)依旧被禁止，所以，此时p2线程继续运行，执行用户逻辑。</li>
</ul>
</li>
<li>p2线程执行fullCondition.await，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-17-1.png" alt="image"></li>
<li>说明：最终到达的状态是新生成了一个结点，包含了p2线程，此结点在condition queue中；并且sync queue中p2线程被禁止了，因为在执行了LockSupport.park操作。从方法一些调用可知，在await操作中线程会释放锁资源，供其他线程获取。同时，head结点后继结点的包含的线程的许可被释放了，故其可以继续运行。由于此时，只有c1线程可以运行，故运行c1。</li>
</ul>
</li>
<li>继续运行c1线程，c1线程由于之前被park了，所以此时恢复，继续之前的步骤，即还是执行前面提到的acquireQueued方法，之后，c1判断自己的前驱结点为head，并且可以获取锁资源，最终到达的状态如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-16.png" alt="image"></li>
<li>说明：其中，head设置为包含c1线程的结点，c1继续运行。</li>
</ul>
</li>
<li>c1线程执行fullCondtion.signal，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-17.png" alt="java-thread-x-juc-aqs-17"></li>
<li>说明：signal方法达到的最终结果是将包含p2线程的结点从condition queue中转移到sync queue中，之后condition queue为null，之前的尾结点的状态变为SIGNAL。</li>
</ul>
</li>
<li>c1线程执行lock.unlock操作，根据之前的分析，经历的状态变化如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-18.png" alt="image"></li>
<li>说明：最终c2线程会获取锁资源，继续运行用户逻辑。</li>
</ul>
</li>
<li>c2线程执行emptyCondition.await，由前面的第七步分析，可知最终的状态如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-19.png" alt="image"></li>
<li>说明：await操作将会生成一个结点放入condition queue中与之前的一个condition queue是不相同的，并且unpark头结点后面的结点，即包含线程p2的结点。</li>
</ul>
</li>
<li>p2线程被unpark，故可以继续运行，经过CPU调度后，p2继续运行，之后p2线程在AQS:await方法中被park，继续AQS.CO:await方法的运行，其方法调用顺序如下，只给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-20.png" alt="java-thread-x-juc-aqs-20"></li>
</ul>
</li>
<li>p2继续运行，执行emptyCondition.signal，根据第九步分析可知，最终到达的状态如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-21.png" alt="java-thread-x-juc-aqs-21"></li>
<li>说明：最终，将condition queue中的结点转移到sync queue中，并添加至尾部，condition queue会为空，并且将head的状态设置为SIGNAL。</li>
</ul>
</li>
<li>p2线程执行lock.unlock操作，根据前面的分析可知，最后的到达的状态如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-aqs-22.png" alt="image"></li>
<li>说明: unlock操作会释放c2线程的许可，并且将头结点设置为c2线程所在的结点。<ul>
<li>c2线程继续运行，执行fullCondition. signal，由于此时fullCondition的condition queue已经不存在任何结点了，故其不会产生作用。</li>
<li>c2执行lock.unlock，由于c2是sync队列中最后一个结点，故其不会再调用unparkSuccessor了，直接返回true。即整个流程就完成了。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="7、AbstractQueuedSynchronizer总结"><a href="#7、AbstractQueuedSynchronizer总结" class="headerlink" title="7、AbstractQueuedSynchronizer总结"></a>7、AbstractQueuedSynchronizer总结</h4><p>对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。</p>
<ul>
<li><strong>每一个结点都是由前一个结点唤醒</strong>；</li>
<li><strong>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行</strong>。</li>
<li><strong>condition queue中的结点向sync queue中转移是通过signal操作完成的</strong>。</li>
<li><strong>当结点的状态为SIGNAL时，表示后面的结点需要运行</strong>。</li>
</ul>
<h4 id="8、使用AQS自定义同步器——实现不可重入锁"><a href="#8、使用AQS自定义同步器——实现不可重入锁" class="headerlink" title="8、使用AQS自定义同步器——实现不可重入锁"></a>8、使用AQS自定义同步器——实现不可重入锁</h4><p>自定义锁（不可重入锁）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 注意这里：把setState放在后面是因为state是有volatile修饰的，会在setState处放入写屏障</span></span><br><span class="line">            <span class="comment">// 用来保证写屏障前面的写操作对其他线程可见</span></span><br><span class="line">            <span class="comment">// 而setExclusiveOwnerThread(null);设置的exclusiveOwnerThread没有用volatile修饰</span></span><br><span class="line">            <span class="comment">// 所以如果没把setState放在后面，exclusiveOwnerThrea不能保证可见性</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// lock.lock();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、Lock接口"><a href="#5、Lock接口" class="headerlink" title="5、Lock接口"></a>5、Lock接口</h3><p>类结构总览：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-overview-lock.png" alt="image"></p>
<h4 id="1、什么是Lock"><a href="#1、什么是Lock" class="headerlink" title="1、什么是Lock"></a>1、什么是Lock</h4><p>Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</p>
<p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。 </p>
<h4 id="2、Lock接口（源码）"><a href="#2、Lock接口（源码）" class="headerlink" title="2、Lock接口（源码）"></a>2、Lock接口（源码）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来逐个讲述 Lock 接口中每个方法的使用。</p>
<h5 id="1、lock-方法-与-unlock-方法"><a href="#1、lock-方法-与-unlock-方法" class="headerlink" title="1、lock()方法 与 unlock()方法"></a>1、lock()方法 与 unlock()方法</h5><ul>
<li>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。<ul>
<li>lock锁是不会被打断interrupt的，要想被interrupt打断的话，就得使用<code>lock.lockInterruptibly()</code>进行上锁</li>
</ul>
</li>
<li>unlock()方法也是平常使用得最多的一个方法，就是用来释放锁。一般与lock()方法搭配使用。</li>
</ul>
<p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try{}catch{}finally{}块中进行，并且将释放锁的操作放在finally 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;<span class="comment">// 具体实现类</span></span><br><span class="line">lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要预防可能发生的死锁，可以尝试使用下面这个方法：tryLock(long time, TimeUnit unit)方法</p>
<h5 id="2、tryLock-方法-与-tryLock-long-time-TimeUnit-unit-方法"><a href="#2、tryLock-方法-与-tryLock-long-time-TimeUnit-unit-方法" class="headerlink" title="2、tryLock()方法 与 tryLock(long time, TimeUnit unit)方法"></a>2、tryLock()方法 与 tryLock(long time, TimeUnit unit)方法</h5><p>tryLock()方法：尝试获取锁，返回一个boolean值</p>
<p>tryLock(long time, TimeUnit unit)方法：尝试获取锁，可以设置超时</p>
<p>这是一个比单纯lock()更具有工程价值的方法，如果大家阅读过JDK的一些内部代码，就不难发现，tryLock()在JDK内部被大量的使用。</p>
<p>Lock可以通过这两个方法拿到当前线程的锁的状态，并且可以数组超时时间。并根据当前线程是否获得锁，做不同的选择：如果成功获取锁，….，如果获取失败，…..</p>
<p>与lock()相比，tryLock()至少有下面一个好处：</p>
<ul>
<li>可以不用进行无限等待。直接打破形成死锁的条件。如果一段时间等不到锁，可以直接放弃，同时释放自己已经得到的资源。这样，就可以在很大程度上，避免死锁的产生。因为线程之间出现了一种谦让机制。（这也是解决死锁问题的一种方案）</li>
<li>可以在应用程序这层进行进行自旋，你可以自己决定尝试几次，或者是放弃。</li>
<li>等待锁的过程中可以响应中断interrupt，如果此时，程序正好收到关机信号，中断就会触发，进入中断异常后，线程就可以做一些清理工作，从而防止在终止程序时出现数据写坏，数据丢失等悲催的情况。</li>
<li>对于tryLock(空参)来说特别适合在应用层自己对锁进行管理，在应用层进行自旋等待。</li>
</ul>
<h5 id="3、newCondition-方法"><a href="#3、newCondition-方法" class="headerlink" title="3、newCondition()方法"></a>3、newCondition()方法</h5><p>lock可以通过newCondition()方法获得一个Condition对象。</p>
<p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， Lock 锁通过 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。 </p>
<p>用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的三个方法： </p>
<ul>
<li><code>await()</code>：会使当前线程等待，同时会释放锁，当其他线程调用 signal()时，线程会重新获得锁并继续执行。</li>
<li><code>signal()</code>：用于唤醒一个等待的线程。</li>
<li><code>signaAll()</code>：用于唤醒所有等待的线程。</li>
</ul>
<p>==注意：在调用 Condition 的 await()/signal()方法前，也需要线程持有相关的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。==</p>
<h4 id="3、Lock接口的实现类——ReentrantLock（重点）"><a href="#3、Lock接口的实现类——ReentrantLock（重点）" class="headerlink" title="3、Lock接口的实现类——ReentrantLock（重点）"></a>3、Lock接口的实现类——<strong>ReentrantLock</strong>（重点）</h4><p>ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
<p>ReentrantLock 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更多的方法。</p>
<p>相对于 synchronized 它具备如下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
</ul>
<p>与 synchronized 一样，都支持可重入</p>
<h5 id="1、BAT大厂的面试问题-9"><a href="#1、BAT大厂的面试问题-9" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>什么是可重入，什么是可重入锁？它用来解决什么问题？</li>
<li>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗？说说其类内部结构关系。</li>
<li>ReentrantLock是如何实现公平锁的？</li>
<li>ReentrantLock是如何实现非公平锁的？</li>
<li>ReentrantLock默认实现的是公平还是非公平锁？</li>
<li>使用ReentrantLock实现公平和非公平锁的示例？</li>
<li>ReentrantLock和Synchronized的对比？</li>
</ul>
<h5 id="2、ReentrantLock源码分析"><a href="#2、ReentrantLock源码分析" class="headerlink" title="2、ReentrantLock源码分析"></a>2、ReentrantLock源码分析</h5><h6 id="1、类的继承关系-1"><a href="#1、类的继承关系-1" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><p>ReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个Condition条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h6 id="2、类的内部类-1"><a href="#2、类的内部类-1" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h6><p>ReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-1.png" alt="image"></p>
<p>说明：ReentrantLock类内部总共存在<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code>三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p>
<ul>
<li><p>Sync类</p>
<ul>
<li><p>源码</p>
<ul>
<li><pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;
    // 序列号
    private static final long serialVersionUID = -5179523762034025860L;

    // 获取锁
    abstract void lock();

    // 非公平方式获取
    final boolean nonfairTryAcquire(int acquires) &#123;
        // 当前线程
        final Thread current = Thread.currentThread();
        // 获取状态
        int c = getState();
        if (c == 0) &#123; // 表示没有线程正在竞争该锁
            if (compareAndSetState(0, acquires)) &#123; // 比较并设置状态成功，状态0表示锁没有被占用，这里体现了非公平性: 不去检查 AQS 队列
                // 设置当前线程独占
                setExclusiveOwnerThread(current); 
                return true; // 成功
            &#125;
        &#125;
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) &#123; // 当前线程拥有该锁
            int nextc = c + acquires; // 增加重入次数
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            // 设置状态
            setState(nextc); 
            // 成功
            return true; 
        &#125;
        // 失败，回到调用处
        return false;
    &#125;

    // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它
    protected final boolean tryRelease(int releases) &#123;
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread()) // 当前线程不为独占线程
            throw new IllegalMonitorStateException(); // 抛出异常
        // 释放标识
        boolean free = false; 
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) &#123;
            free = true;
            // 已经释放，清空独占
            setExclusiveOwnerThread(null); 
        &#125;
        // 设置标识
        setState(c); 
        return free; 
    &#125;

    // 判断资源是否被当前线程占有
    protected final boolean isHeldExclusively() &#123;
        // While we must in general read state before owner,
        // we don&#39;t need to do so to check if current thread is owner
        return getExclusiveOwnerThread() == Thread.currentThread();
    &#125;

    // 新生一个条件
    final ConditionObject newCondition() &#123;
        return new ConditionObject();
    &#125;

    // Methods relayed from outer class
    // 返回资源的占用线程
    final Thread getOwner() &#123;        
        return getState() == 0 ? null : getExclusiveOwnerThread();
    &#125;
    // 返回状态
    final int getHoldCount() &#123;            
        return isHeldExclusively() ? getState() : 0;
    &#125;

    // 资源是否被占用
    final boolean isLocked() &#123;        
        return getState() != 0;
    &#125;

    /**
        * Reconstitutes the instance from a stream (that is, deserializes it).
        */
    // 自定义反序列化逻辑
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        s.defaultReadObject();
        setState(0); // reset to unlocked state
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - Sync类存在如下方法和作用如下：</span><br><span class="line"></span><br><span class="line">    - ![image](JUC&#x2F;java-thread-x-juc-reentrantlock-2.png)</span><br><span class="line"></span><br><span class="line">- NonfairSync类</span><br><span class="line"></span><br><span class="line">  - NonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法，源码如下：</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      &#x2F;&#x2F; 非公平锁</span><br><span class="line">      static final class NonfairSync extends Sync &#123;</span><br><span class="line">          &#x2F;&#x2F; 版本号</span><br><span class="line">          private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F; 获得锁</span><br><span class="line">          final void lock() &#123;</span><br><span class="line">              &#x2F;&#x2F; 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span><br><span class="line">              if (compareAndSetState(0, 1)) &#x2F;&#x2F; 比较并设置状态成功，状态0表示锁没有被占用</span><br><span class="line">                  &#x2F;&#x2F; 把当前线程设置独占了锁</span><br><span class="line">                  setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              else &#x2F;&#x2F; 锁已经被占用，或者set失败</span><br><span class="line">                  &#x2F;&#x2F; 以独占模式获取对象，忽略中断</span><br><span class="line">                  &#x2F;&#x2F; 如果尝试失败，进入 AQS的acquire方法</span><br><span class="line">                  acquire(1); </span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">              return nonfairTryAcquire(acquires);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。</p>
</li>
</ul>
</li>
<li><p>FairSyn类</p>
<ul>
<li><p>FairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法，源码如下：</p>
<ul>
<li><pre><code class="java">// 公平锁
static final class FairSync extends Sync &#123;
    // 版本序列化
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() &#123;
        // 以独占模式获取对象，忽略中断
        acquire(1);
    &#125;

    /**
        * Fair version of tryAcquire.  Don&#39;t grant access unless
        * recursive call or no waiters or is first.
        */
    // 尝试公平获取锁
    protected final boolean tryAcquire(int acquires) &#123;
        // 获取当前线程
        final Thread current = Thread.currentThread();
        // 获取状态
        int c = getState();
        if (c == 0) &#123; // 状态为0
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) &#123; // 不存在已经等待更久的线程并且比较并且设置状态成功
                // 设置当前线程独占
                setExclusiveOwnerThread(current);
                return true;
            &#125;
        &#125;
        else if (current == getExclusiveOwnerThread()) &#123; // 状态不为0，即资源已经被线程占据
            // 下一个状态
            int nextc = c + acquires;
            if (nextc &lt; 0) // 超过了int的表示范围
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            // 设置状态
            setState(nextc);
            return true;
        &#125;
        return false;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 说明：</span><br><span class="line">  </span><br><span class="line">      - 跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。</span><br><span class="line">      - 其中，FairSync类的lock的方法调用如下，只给出了主要的方法。</span><br><span class="line">        - ![image](JUC&#x2F;java-thread-x-juc-reentrantlock-3.png)</span><br><span class="line">      - 说明：可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和Nonfair最大的区别，Nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。</span><br><span class="line"></span><br><span class="line">###### 3、类的属性</span><br><span class="line"></span><br><span class="line">ReentrantLock类的sync非常重要，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7373984872572414699L;    </span><br><span class="line">    &#x2F;&#x2F; 同步队列</span><br><span class="line">    private final Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4、类的构造函数（默认是采用的非公平策略获取锁）"><a href="#4、类的构造函数（默认是采用的非公平策略获取锁）" class="headerlink" title="4、类的构造函数（默认是采用的非公平策略获取锁）"></a>4、类的构造函数（默认是采用的非公平策略获取锁）</h6><ul>
<li><p>ReentrantLock()型构造函数（默认是采用的非公平策略获取锁）</p>
<ul>
<li><pre><code class="java">public ReentrantLock() &#123;
    // 默认非公平策略
    sync = new NonfairSync();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ReentrantLock(boolean)型构造函数（可以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略）</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="5、核心函数分析——加锁与解锁"><a href="#5、核心函数分析——加锁与解锁" class="headerlink" title="5、核心函数分析——加锁与解锁"></a>5、核心函数分析——加锁与解锁</h6><p>加锁与解锁：（默认为非公平锁实现）(配合上面的源码进行分析)</p>
<ul>
<li><p>没有竞争时</p>
<ul>
<li><img src="/2021/07/19/JUC/image-20210812043816368.png" alt="image-20210812043816368"></li>
</ul>
</li>
<li><p>第一个竞争出现时</p>
<ul>
<li><p><img src="/2021/07/19/JUC/image-20210812043900546.png" alt="image-20210812043900546"></p>
</li>
<li><p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败</li>
<li>   进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
<li><img src="/2021/07/19/JUC/image-20210812044213292.png" alt="image-20210812044213292"></li>
</ul>
</li>
</ol>
</li>
<li><p>当前线程进入 acquireQueued 逻辑</p>
<ol>
<li><p>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</p>
</li>
<li><p>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p>
</li>
<li><p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false.（waitStatue为-1表示该结点有责任唤醒它的后继结点）</p>
<p><img src="/2021/07/19/JUC/image-20210812044725103.png" alt="image-20210812044725103"></p>
</li>
<li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</p>
</li>
<li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true</p>
</li>
<li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p>
<p><img src="/2021/07/19/JUC/image-20210812045121967.png" alt="image-20210812045121967"></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="/2021/07/19/JUC/image-20210812045347108.png" alt="image-20210812045347108"></p>
</li>
<li><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state = 0</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210812045538702.png" alt="image-20210812045538702"></p>
</li>
<li><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p>
</li>
<li><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
</li>
<li><p>回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="/2021/07/19/JUC/image-20210812045816095.png" alt="image-20210812045816095"></p>
</li>
<li><p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<p><img src="/2021/07/19/JUC/image-20210812050213728.png" alt="image-20210812050213728"></p>
</li>
<li><p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
</li>
</ul>
<h6 id="6、核心函数分析——可重入原理"><a href="#6、核心函数分析——可重入原理" class="headerlink" title="6、核心函数分析——可重入原理"></a>6、核心函数分析——可重入原理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>); setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state-- </span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7、核心函数分析——可打断原理"><a href="#7、核心函数分析——可打断原理" class="headerlink" title="7、核心函数分析——可打断原理"></a>7、核心函数分析——可打断原理</h6><p>不可打断模式</p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; </span><br><span class="line">                   parkAndCheckInterrupt()</span><br><span class="line">                  ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true </span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true </span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可打断模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg)) </span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); </span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC </span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此 </span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;) </span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析ReentrantLock的源码，可知对其操作都转化为对Sync对象的操作，由于Sync继承了AQS，所以基本上都可以转化为对AQS的操作。如将ReentrantLock的lock函数转化为对Sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到Sync的不同子类。</p>
<p>所以可知，在ReentrantLock的背后，是AQS对其服务提供了支持，下面还是通过例子来更进一步分析源码。</p>
<h6 id="8、核心函数分析——条件变量实现原理"><a href="#8、核心函数分析——条件变量实现原理" class="headerlink" title="8、核心函数分析——条件变量实现原理"></a>8、核心函数分析——条件变量实现原理</h6><p>每个条件变量其实就对应着一个等待队列，其实现类是 <code>ConditionObject</code></p>
<p><strong><code>await</code> 流程</strong>：</p>
<ul>
<li><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p>
</li>
<li><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="/2021/07/19/JUC/image-20210812233522165.png" alt="image-20210812233522165"></p>
</li>
<li><p>接下来进入 AQS 的 <code>fullyRelease</code> 流程，释放同步器上的锁（为什么调用fullyRelease而不是调用realease：因为该线程可能有重入锁，调用fullyRelease可以将该线程所占的所有锁全部释放掉）</p>
<p><img src="/2021/07/19/JUC/image-20210812233738920.png" alt="image-20210812233738920"></p>
</li>
<li><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="/2021/07/19/JUC/image-20210812234025126.png" alt="image-20210812234025126"></p>
</li>
<li><p>park 阻塞 Thread-0</p>
<p><img src="/2021/07/19/JUC/image-20210812234152831.png" alt="image-20210812234152831"></p>
</li>
</ul>
<p>这里其实是thread0 unpark thread1，但此时1并没有竞争到锁因为0还持有锁，等到thread0 park自己时，1才竞争到锁，因为unpark和park可以互换顺序</p>
<p><strong><code>signal</code> 流程</strong>：</p>
<ul>
<li><p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="/2021/07/19/JUC/image-20210812234448884.png" alt="image-20210812234448884"></p>
</li>
<li><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="/2021/07/19/JUC/image-20210812234608451.png" alt="image-20210812234608451"></p>
</li>
<li><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p>
<p><img src="/2021/07/19/JUC/image-20210812234954747.png" alt="image-20210812234954747"></p>
</li>
<li><p>Thread-1 释放锁，进入 unlock 流程，略</p>
</li>
</ul>
<h5 id="3、示例分析"><a href="#3、示例分析" class="headerlink" title="3、示例分析"></a>3、示例分析</h5><h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchonizerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, lock);        </span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, lock);</span><br><span class="line">        MyThread t3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t3&quot;</span>, lock);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[t1,5,main] running</span><br><span class="line">Thread[t2,5,main] running</span><br><span class="line">Thread[t3,5,main] running</span><br></pre></td></tr></table></figure>

<p>说明：该示例使用的是公平策略，由结果可知，可能会存在如下一种时序。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-4.png" alt="image"></p>
<p>说明：首先，t1线程的lock操作 -&gt; t2线程的lock操作 -&gt; t3线程的lock操作 -&gt; t1线程的unlock操作 -&gt; t2线程的unlock操作 -&gt; t3线程的unlock操作。根据这个时序图来进一步分析源码的工作流程：</p>
<ul>
<li>t1线程执行lock.lock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-5.png" alt="image"></li>
<li>说明：由调用流程可知，t1线程成功获取了资源，可以继续执行。</li>
</ul>
</li>
<li>t2线程执行lock.lock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-6.png" alt="image"></li>
<li>说明：由上图可知，最后的结果是t2线程会被禁止，因为调用了LockSupport.park。</li>
</ul>
</li>
<li>t3线程执行lock.lock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-7.png" alt="image"></li>
<li>说明：由上图可知，最后的结果是t3线程会被禁止，因为调用了LockSupport.park。</li>
</ul>
</li>
<li>t1线程调用了lock.unlock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-8.png" alt="image"></li>
<li>说明：如上图所示，最后，head的状态会变为0，t2线程会被unpark，即t2线程可以继续运行。此时t3线程还是被禁止。</li>
</ul>
</li>
<li>t2获得cpu资源，继续运行，由于t2之前被park了，现在需要恢复之前的状态，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-9.png" alt="image"></li>
<li>说明：在setHead函数中会将head设置为之前head的下一个结点，并且将pre域与thread域都设置为null，在acquireQueued返回之前，sync queue就只有两个结点了。</li>
</ul>
</li>
<li>t2执行lock.unlock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-10.png" alt="image"></li>
<li>说明：由上图可知，最终unpark t3线程，让t3线程可以继续运行。</li>
</ul>
</li>
<li>t3线程获取cpu资源，恢复之前的状态，继续运行。<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-11.png" alt="image"></li>
<li>说明：最终达到的状态是sync queue中只剩下了一个结点，并且该节点除了状态为0外，其余均为null。</li>
</ul>
</li>
<li>t3执行lock.unlock，下图给出了方法调用中的主要方法：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-12.png" alt="image"></li>
<li>说明：最后的状态和之前的状态是一样的，队列中有一个空节点，头结点为尾节点均指向它。</li>
</ul>
</li>
</ul>
<h3 id="6、ReadWriteLock接口"><a href="#6、ReadWriteLock接口" class="headerlink" title="6、ReadWriteLock接口"></a>6、ReadWriteLock接口</h3><p>ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p>
<p>在ReadWriteLock接口里面只定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的<code>ReentrantReadWriteLock</code> 实现了 ReadWriteLock 接口。 </p>
<h4 id="1、ReadWriteLock接口实现类——ReentrantReadWriteLock读写锁（重要）"><a href="#1、ReadWriteLock接口实现类——ReentrantReadWriteLock读写锁（重要）" class="headerlink" title="1、ReadWriteLock接口实现类——ReentrantReadWriteLock读写锁（重要）"></a>1、<strong>ReadWriteLock接口实现类——ReentrantReadWriteLock</strong>读写锁（重要）</h4><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源， 就不应该允许其他线程对该资源进行读和写的操作了。类似于数据库中的<code>select ...from ... lock in share mode</code></p>
<p>针对这种场景，JAVA 的并发包JUC提供了读写锁 ReentrantReadWriteLock， ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。<strong>ReadLock是共享锁，WriteLock是独占锁</strong>。</p>
<p>读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享。</p>
<p>ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和 writeLock()用来获取读锁和写锁。 </p>
<ol>
<li>线程进入读锁的前提条件：<ul>
<li>没有其他线程的写锁</li>
<li>没有写请求，或者==有写请求，但调用线程和持有锁的线程是同一个(可重入锁)==。</li>
</ul>
</li>
<li>线程进入写锁的前提条件：<ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
</li>
</ol>
<p>而读写锁有以下三个重要的特性：</p>
<ol>
<li>==公平选择性==：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>
<li>==重进入==：读锁和写锁都支持线程重进入。</li>
<li>==锁降级==：遵循<strong>获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</strong>。</li>
</ol>
<h5 id="1、BAT大厂的面试问题-10"><a href="#1、BAT大厂的面试问题-10" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>为了有了ReentrantLock还需要ReentrantReadWriteLock？</li>
<li>ReentrantReadWriteLock底层实现原理？</li>
<li>ReentrantReadWriteLock底层读写状态如何设计的？<ul>
<li>高16位为读锁，低16位为写锁</li>
</ul>
</li>
<li>读锁和写锁的最大数量是多少？</li>
<li>本地线程计数器ThreadLocalHoldCounter是用来做什么的？</li>
<li>缓存计数器HoldCounter是用来做什么的？</li>
<li>写锁的获取与释放是怎么实现的？</li>
<li>读锁的获取与释放是怎么实现的？</li>
<li>RentrantReadWriteLock为什么不支持锁升级？</li>
<li>什么是锁的升降级？RentrantReadWriteLock为什么不支持锁升级？</li>
</ul>
<h5 id="2、ReentrantReadWriteLock数据结构"><a href="#2、ReentrantReadWriteLock数据结构" class="headerlink" title="2、ReentrantReadWriteLock数据结构"></a>2、ReentrantReadWriteLock数据结构</h5><p>ReentrantReadWriteLock底层是基于<code>ReentrantLock</code>和<code>AbstractQueuedSynchronizer</code>来实现的，所以，ReentrantReadWriteLock的数据结构也依托于AQS的数据结构。</p>
<h5 id="3、ReentrantReadWriteLock源码分析"><a href="#3、ReentrantReadWriteLock源码分析" class="headerlink" title="3、ReentrantReadWriteLock源码分析"></a>3、ReentrantReadWriteLock源码分析</h5><h6 id="1、类的继承关系-2"><a href="#1、类的继承关系-2" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，<strong>ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现</strong>；同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看到ReentrantReadWriteLock实现了自己的序列化逻辑。</p>
<h6 id="2、类的内部类-2"><a href="#2、类的内部类-2" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h6><p>ReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-readwritelock-1.png" alt="img"></p>
<p>说明：如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。</p>
<h6 id="3、内部类——Sync类"><a href="#3、内部类——Sync类" class="headerlink" title="3、内部类——Sync类"></a>3、内部类——Sync类</h6><ul>
<li><p>类的继承关系</p>
<ul>
<li><pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：Sync抽象类继承自AQS抽象类，Sync类提供了对ReentrantReadWriteLock的支持。</span><br><span class="line"></span><br><span class="line">- 类的内部类</span><br><span class="line"></span><br><span class="line">  - Sync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用，其中，HoldCounter源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F; 计数器</span><br><span class="line">    static final class HoldCounter &#123;</span><br><span class="line">        &#x2F;&#x2F; 计数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; Use id, not reference, to avoid garbage retention</span><br><span class="line">        &#x2F;&#x2F; 获取当前线程的TID属性的值</span><br><span class="line">        final long tid &#x3D; getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：HoldCounter主要有两个属性，count和tid，其中<strong>count表示某个读线程重入的次数</strong>，<strong>tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程</strong>。</p>
</li>
<li><p>ThreadLocalHoldCounter的源码如下：</p>
<ul>
<li><pre><code class="java">// 本地线程计数器
static final class ThreadLocalHoldCounter
    extends ThreadLocal&lt;HoldCounter&gt; &#123;
    // 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值
    public HoldCounter initialValue() &#123;
        return new HoldCounter();
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 说明：ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。</span><br><span class="line"></span><br><span class="line">- 类的属性</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        &#x2F;&#x2F; 版本序列号</span><br><span class="line">        private static final long serialVersionUID &#x3D; 6317671515068378041L;        </span><br><span class="line">        &#x2F;&#x2F; 高16位为读锁，低16位为写锁</span><br><span class="line">        static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class="line">        &#x2F;&#x2F; 读锁单位</span><br><span class="line">        static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        &#x2F;&#x2F; 读锁最大数量</span><br><span class="line">        static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">        &#x2F;&#x2F; 写锁最大数量</span><br><span class="line">        static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">        &#x2F;&#x2F; 本地线程计数器</span><br><span class="line">        private transient ThreadLocalHoldCounter readHolds;</span><br><span class="line">        &#x2F;&#x2F; 缓存的计数器</span><br><span class="line">        private transient HoldCounter cachedHoldCounter;</span><br><span class="line">        &#x2F;&#x2F; 第一个读线程</span><br><span class="line">        private transient Thread firstReader &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 第一个读线程的计数</span><br><span class="line">        private transient int firstReaderHoldCount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>说明：该属性中包括了<strong>读锁</strong>、<strong>写锁线程的最大量</strong>、<strong>本地线程计数器</strong>等。</p>
</li>
</ul>
</li>
<li><p>类的构造函数</p>
<ul>
<li><pre><code class="java">// 构造函数
Sync() &#123;
    // 本地线程计数器
    readHolds = new ThreadLocalHoldCounter();
    // 设置AQS的状态
    setState(getState()); // ensures visibility of readHolds
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：在Sync的构造函数中**设置了本地线程计数器和AQS的状态state**。</span><br><span class="line"></span><br><span class="line">###### 4、内部类——Sync核心函数分析</span><br><span class="line"></span><br><span class="line">对ReentrantReadWriteLock对象的操作绝大多数都转发至Sync对象进行处理。下面对Sync类中的重点函数进行分析：</span><br><span class="line"></span><br><span class="line">- sharedCount函数</span><br><span class="line"></span><br><span class="line">  - 表示**占有读锁的线程数量**，源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：直接将state右移16位，就可以得到读锁的线程数量，因为<strong>state的高16位表示读锁，对应的低十六位表示写锁数量</strong>。</p>
</li>
</ul>
</li>
<li><p>exclusiveCount函数</p>
<ul>
<li><p>表示<strong>占有写锁的线程数量</strong>，源码如下：</p>
</li>
<li><pre><code class="java">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：直接将状态state和(2^16 - 1)做与运算，其等效于将state模上2^16。**写锁数量由state的低十六位表示**。</span><br><span class="line"></span><br><span class="line">- tryRelease函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * Note that tryRelease and tryAcquire can be called by</span><br><span class="line">    * Conditions. So it is possible that their arguments contain</span><br><span class="line">    * both read and write holds that are all released during a</span><br><span class="line">    * condition wait and re-established in tryAcquire.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">    protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否伪独占线程</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#x2F;&#x2F; 计算释放资源后的写锁的数量</span><br><span class="line">        int nextc &#x3D; getState() - releases;</span><br><span class="line">        &#x2F;&#x2F; 因为可重入的原因, 写锁计数为 0, 才算释放成功</span><br><span class="line">        boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0; &#x2F;&#x2F; 是否释放成功</span><br><span class="line">        if (free)</span><br><span class="line">            setExclusiveOwnerThread(null); &#x2F;&#x2F; 设置独占线程为空</span><br><span class="line">        setState(nextc); &#x2F;&#x2F; 设置状态</span><br><span class="line">        return free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：此函数用于<strong>释放写锁资源</strong>：首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其函数流程图如下：</p>
</li>
<li><p><img src="/2021/07/19/JUC/java-thread-x-readwritelock-2.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>tryAcquire函数</p>
<ul>
<li><pre><code class="java">protected final boolean tryAcquire(int acquires) &#123;
    /*
        * Walkthrough:
        * 1. If read count nonzero or write count nonzero
        *    and owner is a different thread, fail.
        * 2. If count would saturate, fail. (This can only
        *    happen if count is already nonzero.)
        * 3. Otherwise, this thread is eligible for lock if
        *    it is either a reentrant acquire or
        *    queue policy allows it. If so, update state
        *    and set owner.
        */
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 获取状态
    // 获得低 16 位, 代表写锁的 state 计数
    int c = getState();
    // 写线程数量
    int w = exclusiveCount(c);
    if (c != 0) &#123; // 状态不为0
        // (Note: if c != 0 and w == 0 then shared count != 0)
        // 写线程数量为0或者当前线程没有占有独占资源
        if (
            // c != 0 and w == 0 表示有读锁, 或者
            w == 0 || 
            // 如果 exclusiveOwnerThread 不是自己(可重入)
            current != getExclusiveOwnerThread()) 
            // 获得锁失败
            return false;
        // 写锁计数超过低 16 位, 报异常
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 判断是否超过最高写线程数量
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        // 设置AQS状态
        // 写锁重入, 获得锁成功
        setState(c + acquires);
        return true;
    &#125;
    if (
        // 判断写锁是否该阻塞, 或者
        writerShouldBlock() ||
        // 尝试更改计数失败
        !compareAndSetState(c, c + acquires))
        // 获得锁失败
        return false;
    // 设置独占线程
    // 获得锁成功
    setExclusiveOwnerThread(current);
    return true;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - 说明：此函数用于**获取写锁**：首先会获取state，判断是否为0，若为0，表示此时没有读锁线程，再判断写线程是否应该被阻塞，而**在非公平策略下总是不会被阻塞，在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞**)，之后在设置状态state，然后返回true。若state不为0，则表示此时存在读锁或写锁线程，若写锁线程数量为0或者当前线程为独占锁线程，则返回false，表示不成功，否则，判断写锁线程的重入次数是否大于了最大值，若是，则抛出异常，否则，设置状态state，返回true，表示成功。其函数流程图如下：</span><br><span class="line"></span><br><span class="line">  - ![img](JUC&#x2F;java-thread-x-readwritelock-3.png)</span><br><span class="line"></span><br><span class="line">- tryReleaseShared函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取当前线程</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        if (firstReader &#x3D;&#x3D; current) &#123; &#x2F;&#x2F; 当前线程为第一个读线程</span><br><span class="line">            &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            if (firstReaderHoldCount &#x3D;&#x3D; 1) &#x2F;&#x2F; 读线程占用的资源数为1</span><br><span class="line">                firstReader &#x3D; null;</span><br><span class="line">            else &#x2F;&#x2F; 减少占用的资源</span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 当前线程不为第一个读线程</span><br><span class="line">            &#x2F;&#x2F; 获取缓存的计数器</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#x2F;&#x2F; 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span><br><span class="line">                &#x2F;&#x2F; 获取当前线程对应的计数器</span><br><span class="line">                rh &#x3D; readHolds.get();</span><br><span class="line">            &#x2F;&#x2F; 获取计数</span><br><span class="line">            int count &#x3D; rh.count;</span><br><span class="line">            if (count &lt;&#x3D; 1) &#123; &#x2F;&#x2F; 计数小于等于1</span><br><span class="line">                &#x2F;&#x2F; 移除</span><br><span class="line">                readHolds.remove();</span><br><span class="line">                if (count &lt;&#x3D; 0) &#x2F;&#x2F; 计数小于等于0，抛出异常</span><br><span class="line">                    throw unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 减少计数</span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            &#x2F;&#x2F; 获取状态</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            &#x2F;&#x2F; 获取状态</span><br><span class="line">            int nextc &#x3D; c - SHARED_UNIT;</span><br><span class="line">            if (compareAndSetState(c, nextc)) &#x2F;&#x2F; 比较并进行设置</span><br><span class="line">                &#x2F;&#x2F; Releasing the read lock has no effect on readers,</span><br><span class="line">                &#x2F;&#x2F; but it may allow waiting writers to proceed if</span><br><span class="line">                &#x2F;&#x2F; both read and write locks are now free.</span><br><span class="line">                &#x2F;&#x2F; 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span><br><span class="line">                &#x2F;&#x2F; 计数为 0 才是真正释放</span><br><span class="line">                return nextc &#x3D;&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：此函数表示<strong>读锁线程释放锁</strong>：首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器(上一个读锁线程对应的计数器 )，若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下：</p>
</li>
<li><p><img src="/2021/07/19/JUC/java-thread-x-readwritelock-4.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>tryAcquireShared函数</p>
<ul>
<li><pre><code class="java">private IllegalMonitorStateException unmatchedUnlockException() &#123;
    return new IllegalMonitorStateException(
        &quot;attempt to unlock read lock, not locked by current thread&quot;);
&#125;

// 共享模式下获取资源
protected final int tryAcquireShared(int unused) &#123;
    /*
        * Walkthrough:
        * 1. If write lock held by another thread, fail.
        * 2. Otherwise, this thread is eligible for
        *    lock wrt state, so ask if it should block
        *    because of queue policy. If not, try
        *    to grant by CASing state and updating count.
        *    Note that step does not check for reentrant
        *    acquires, which is postponed to full version
        *    to avoid having to check hold count in
        *    the more typical non-reentrant case.
        * 3. If step 2 fails either because thread
        *    apparently not eligible or CAS fails or count
        *    saturated, chain to version with full retry loop.
        */
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 获取状态
    int c = getState();
    // 如果是其它线程持有写锁, 获取读锁失败
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current) // 写线程数不为0并且占有资源的不是当前线程
        return -1;
    // 读锁数量
    int r = sharedCount(c);
    if (// 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功
        // 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且
        !readerShouldBlock() &amp;&amp;
        // 小于读锁计数, 并且
        r &lt; MAX_COUNT &amp;&amp;
        // 尝试增加计数成功
        compareAndSetState(c, c + SHARED_UNIT)) &#123; 
        if (r == 0) &#123; // 读锁数量为0
            // 设置第一个读线程
            firstReader = current;
            // 读线程占用的资源数为1
            firstReaderHoldCount = 1;
        &#125; else if (firstReader == current) &#123; // 当前线程为第一个读线程
            // 占用资源数加1
            firstReaderHoldCount++;
        &#125; else &#123; // 读锁数量不为0并且不为当前线程
            // 获取计数器
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid
                // 获取当前线程对应的计数器
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0) // 计数为0
                // 设置
                readHolds.set(rh);
            rh.count++;
        &#125;
        return 1;
    &#125;
    return fullTryAcquireShared(current);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - 说明：此函数表示**读锁线程获取读锁**。首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount；若当前线程线程为第一个读线程，则增加firstReaderHoldCount；否则，将设置当前线程对应的HoldCounter对象的值。流程图如下：</span><br><span class="line"></span><br><span class="line">  - ![img](JUC&#x2F;java-thread-x-readwritelock-5.png)</span><br><span class="line"></span><br><span class="line">- fullTryAcquireShared函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F; 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span><br><span class="line">    &#x2F;&#x2F; true 则该阻塞, false 则不阻塞</span><br><span class="line">    final boolean readerShouldBlock() &#123;</span><br><span class="line">    	return apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span><br><span class="line">    final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">            * This code is in part redundant with that in</span><br><span class="line">            * tryAcquireShared but is simpler overall by not</span><br><span class="line">            * complicating tryAcquireShared with interactions between</span><br><span class="line">            * retries and lazily reading hold counts.</span><br><span class="line">            *&#x2F;</span><br><span class="line">        HoldCounter rh &#x3D; null;</span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            &#x2F;&#x2F; 获取状态</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (exclusiveCount(c) !&#x3D; 0) &#123; &#x2F;&#x2F; 写线程数量不为0</span><br><span class="line">                if (getExclusiveOwnerThread() !&#x3D; current) &#x2F;&#x2F; 不为当前线程</span><br><span class="line">                    return -1;</span><br><span class="line">                &#x2F;&#x2F; else we hold the exclusive lock; blocking here</span><br><span class="line">                &#x2F;&#x2F; would cause deadlock.</span><br><span class="line">            &#125; else if (readerShouldBlock()) &#123; &#x2F;&#x2F; 写线程数量为0并且读线程被阻塞</span><br><span class="line">                &#x2F;&#x2F; Make sure we&#39;re not acquiring read lock reentrantly</span><br><span class="line">                if (firstReader &#x3D;&#x3D; current) &#123; &#x2F;&#x2F; 当前线程为第一个读线程</span><br><span class="line">                    &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F; 当前线程不为第一个读线程</span><br><span class="line">                    if (rh &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 计数器不为空</span><br><span class="line">                        &#x2F;&#x2F; </span><br><span class="line">                        rh &#x3D; cachedHoldCounter;</span><br><span class="line">                        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#123; &#x2F;&#x2F; 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span><br><span class="line">                            rh &#x3D; readHolds.get();</span><br><span class="line">                            if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT) &#x2F;&#x2F; 读锁数量为最大值，抛出异常</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            if (compareAndSetState(c, c + SHARED_UNIT)) &#123; &#x2F;&#x2F; 比较并且设置成功</span><br><span class="line">                if (sharedCount(c) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 读线程数量为0</span><br><span class="line">                    &#x2F;&#x2F; 设置第一个读线程</span><br><span class="line">                    firstReader &#x3D; current;</span><br><span class="line">                    &#x2F;&#x2F; </span><br><span class="line">                    firstReaderHoldCount &#x3D; 1;</span><br><span class="line">                &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (rh &#x3D;&#x3D; null)</span><br><span class="line">                        rh &#x3D; cachedHoldCounter;</span><br><span class="line">                    if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                        rh &#x3D; readHolds.get();</span><br><span class="line">                    else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                    cachedHoldCounter &#x3D; rh; &#x2F;&#x2F; cache for release</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：在tryAcquireShared函数中，如果下列三个条件不满足：</p>
<ul>
<li>读线程是否应该被阻塞</li>
<li>小于最大值</li>
<li>比较设置成功</li>
</ul>
</li>
<li><p>则会进行fullTryAcquireShared函数中，<strong>它用来保证相关操作可以成功</strong>。其逻辑与tryAcquireShared逻辑类似，不再累赘。</p>
</li>
</ul>
</li>
<li><p>doAcquireShared()函数</p>
<ul>
<li><pre><code class="java">private void doAcquireShared(int arg) &#123;
    // 将当前线程关联到一个 Node 对象上, 模式为共享模式
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try &#123;
        boolean interrupted = false;
        for (;;) &#123;
            final Node p = node.predecessor();
            if (p == head) &#123;
                // 再一次尝试获取读锁
                int r = tryAcquireShared(arg); // 成功
                if (r &gt;= 0) &#123;
                    // ㈠
                    // r 表示可用资源数, 在这里总是 1 允许传播
                    //（唤醒 AQS 中下一个 Share 节点） 
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                &#125;
            &#125;
            if (
                // 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL） 
                shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                // park 当前线程
                parkAndCheckInterrupt()
            )&#123;
                interrupted = true;
            &#125;
        &#125;
    &#125;  finally &#123;
        if (failed)
            cancelAcquire(node);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">而其他内部类的操作基本上都是转化到了对Sync对象的操作，在此不再累赘。</span><br><span class="line"></span><br><span class="line">###### 5、类的属性</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class ReentrantReadWriteLock</span><br><span class="line">        implements ReadWriteLock, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号    </span><br><span class="line">    private static final long serialVersionUID &#x3D; -6992448646407690164L;    </span><br><span class="line">    &#x2F;&#x2F; 读锁</span><br><span class="line">    private final ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    &#x2F;&#x2F; 写锁</span><br><span class="line">    private final ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    &#x2F;&#x2F; 同步队列</span><br><span class="line">    final Sync sync;</span><br><span class="line">    </span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    &#x2F;&#x2F; 线程ID的偏移地址</span><br><span class="line">    private static final long TID_OFFSET;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk &#x3D; Thread.class;</span><br><span class="line">            &#x2F;&#x2F; 获取线程的tid字段的内存地址</span><br><span class="line">            TID_OFFSET &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;tid&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>说明：可以看到ReentrantReadWriteLock属性包括了一个ReentrantReadWriteLock.ReadLock对象，表示读锁；一个ReentrantReadWriteLock.WriteLock对象，表示写锁；一个Sync对象，表示同步队列。</p>
<h6 id="6、类的构造函数"><a href="#6、类的构造函数" class="headerlink" title="6、类的构造函数"></a>6、类的构造函数</h6><ul>
<li><p>ReentrantReadWriteLock()型构造函数</p>
<ul>
<li><pre><code class="java">public ReentrantReadWriteLock() &#123;
    this(false);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：此构造函数会调用另外一个有参构造函数。</span><br><span class="line"></span><br><span class="line">- ReentrantReadWriteLock(boolean)型构造函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">        &#x2F;&#x2F; 公平策略或者是非公平策略</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">        &#x2F;&#x2F; 读锁</span><br><span class="line">        readerLock &#x3D; new ReadLock(this);</span><br><span class="line">        &#x2F;&#x2F; 写锁</span><br><span class="line">        writerLock &#x3D; new WriteLock(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：<strong>可以指定设置公平策略或者非公平策略，并且该构造函数中生成了读锁与写锁两个对象</strong>。如果调用的是<strong>空参的构造函数，则默认是非公平的策略</strong>。</p>
</li>
</ul>
</li>
</ul>
<h6 id="7、核心函数分析"><a href="#7、核心函数分析" class="headerlink" title="7、核心函数分析"></a>7、核心函数分析</h6><p>对ReentrantReadWriteLock的操作基本上都转化为了对Sync对象的操作，而Sync的函数已经分析过，不再累赘。</p>
<h6 id="8、图解ReentrantReadWriteLock执行流程"><a href="#8、图解ReentrantReadWriteLock执行流程" class="headerlink" title="8、图解ReentrantReadWriteLock执行流程"></a>8、图解ReentrantReadWriteLock执行流程</h6><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个。</p>
<p>t1 w.lock，t2 r.lock：t1线程为写锁，t2线程为读锁（默认为非公平锁）</p>
<ol>
<li><p>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</p>
<p><img src="/2021/07/19/JUC/image-20210813022016104.png" alt="image-20210813022016104"></p>
</li>
<li><p>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</p>
<ul>
<li>tryAcquireShared 返回值表示<ul>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210813023347980.png" alt="image-20210813023347980"></p>
</li>
<li><p>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>
<p><img src="/2021/07/19/JUC/image-20210813023500583.png" alt="image-20210813023500583"></p>
</li>
<li><p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p>
</li>
<li><p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p>
<p><img src="/2021/07/19/JUC/image-20210813023653011.png" alt="image-20210813023653011"></p>
</li>
<li><p>t3 r.lock，t4 w.lock：t3线程为读锁，t4线程为写锁。这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子(由于t3是读锁，为共享锁，所以状态是Shared，而t4是写锁，为独占锁，所以状态是Ex)这里状态的不同是为了之后的解锁做准备，不同状态的解锁方式不同</p>
<p><img src="/2021/07/19/JUC/image-20210813023151128.png" alt="image-20210813023151128"></p>
</li>
<li><p>t1 w.unlock：t1线程释放了写锁。这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p>
<p><img src="/2021/07/19/JUC/image-20210813024250098.png" alt="image-20210813024250098"></p>
</li>
<li><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</p>
</li>
<li><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一(其中的readerShouldBlock()方法是区别公平锁和非公平锁的关键，非公平锁不阻塞，公平锁就阻塞)（同样的writerShouldBlock()也是区别写锁公平和非公平的关键）</p>
<p><img src="/2021/07/19/JUC/image-20210813024836077.png" alt="image-20210813024836077"></p>
</li>
<li><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/2021/07/19/JUC/image-20210813024953061.png" alt="image-20210813024953061"></p>
</li>
<li><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行((setHead(node)之后的代码的意思是，当阻塞队列中有多个连续的读线程时，会传播式地逐一唤醒，if(s.isShared()){doReleaseShared()}这段代码是关键，吧读锁的状态设置成Shared也是为了这里))</p>
<p><img src="/2021/07/19/JUC/image-20210813025411978.png" alt="image-20210813025411978"></p>
</li>
<li><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/2021/07/19/JUC/image-20210813025646877.png" alt="image-20210813025646877"></p>
</li>
<li><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/2021/07/19/JUC/image-20210813030410741.png" alt="image-20210813030410741"></p>
</li>
<li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
</li>
<li><p>t2 r.unlock，t3 r.unlock：t2线程解锁，t3线程解锁：t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p>
<p><img src="/2021/07/19/JUC/image-20210813030740325.png" alt="image-20210813030740325"></p>
</li>
<li><p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p>
<p><img src="/2021/07/19/JUC/image-20210813031008456.png" alt="image-20210813031008456"></p>
</li>
<li><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<p><img src="/2021/07/19/JUC/image-20210813031102400.png" alt="image-20210813031102400"></p>
</li>
</ol>
<h5 id="4、ReentrantReadWriteLock示例"><a href="#4、ReentrantReadWriteLock示例" class="headerlink" title="4、ReentrantReadWriteLock示例"></a>4、ReentrantReadWriteLock示例</h5><p>下面给出了一个使用ReentrantReadWriteLock的示例，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rrwLock;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadThread</span><span class="params">(String name, ReentrantReadWriteLock rrwLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.rrwLock = rrwLock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rrwLock.readLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; lock successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwLock.readLock().unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; unlock successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rrwLock;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteThread</span><span class="params">(String name, ReentrantReadWriteLock rrwLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.rrwLock = rrwLock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rrwLock.writeLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; lock successfully&quot;</span>);    </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwLock.writeLock().unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; unlock successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock rrwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReadThread rt1 = <span class="keyword">new</span> ReadThread(<span class="string">&quot;rt1&quot;</span>, rrwLock);</span><br><span class="line">        ReadThread rt2 = <span class="keyword">new</span> ReadThread(<span class="string">&quot;rt2&quot;</span>, rrwLock);</span><br><span class="line">        WriteThread wt1 = <span class="keyword">new</span> WriteThread(<span class="string">&quot;wt1&quot;</span>, rrwLock);</span><br><span class="line">        rt1.start();</span><br><span class="line">        rt2.start();</span><br><span class="line">        wt1.start();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rt1 trying to lock</span><br><span class="line">rt2 trying to lock</span><br><span class="line">wt1 trying to lock</span><br><span class="line">rt1 lock successfully</span><br><span class="line">rt2 lock successfully</span><br><span class="line">rt1 unlock successfully</span><br><span class="line">rt2 unlock successfully</span><br><span class="line">wt1 lock successfully</span><br><span class="line">wt1 unlock successfully</span><br></pre></td></tr></table></figure>

<p>说明：程序中生成了一个ReentrantReadWriteLock对象，并且设置了两个读线程，一个写线程。根据结果，可能存在如下的时序图：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-readwritelock-6.png" alt="img"></p>
<ul>
<li>rt1线程执行rrwLock.readLock().lock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-7.png" alt="img"></li>
<li>说明：此时，AQS的状态state为2^16 次方，即<strong>表示此时读线程数量为1</strong>。</li>
</ul>
</li>
<li>rt2线程执行rrwLock.readLock().lock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-8.png" alt="img"></li>
<li>说明：此时，AQS的状态state为2 * 2^16次方，即表示<strong>此时读线程数量为2</strong>。</li>
</ul>
</li>
<li>wt1线程执行rrwLock.writeLock().lock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-9.png" alt="img"></li>
<li>说明：此时，在同步队列Sync queue中存在两个结点，并且wt1线程会被禁止运行。</li>
</ul>
</li>
<li>rt1线程执行rrwLock.readLock().unlock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-10.png" alt="img"></li>
<li>说明：此时，AQS的state为2^16次方，表示还有一个读线程。</li>
</ul>
</li>
<li>rt2线程执行rrwLock.readLock().unlock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-11.png" alt="img"></li>
<li>说明：当rt2线程执行unlock操作后，AQS的state为0，并且wt1线程将会被unpark，其获得CPU资源就可以运行。</li>
</ul>
</li>
<li>wt1线程获得CPU资源，继续运行，需要恢复。由于之前acquireQueued函数中的parkAndCheckInterrupt函数中被禁止的，所以，恢复到parkAndCheckInterrupt函数中，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-12.png" alt="img"></li>
<li>说明：最后，sync queue队列中只有一个结点，并且头结点尾节点均指向它，AQS的state值为1，表示此时有一个写线程。</li>
</ul>
</li>
<li>wt1执行rrwLock.writeLock().unlock操作，主要的函数调用如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-readwritelock-13.png" alt="img"></li>
<li>说明：此时，AQS的state为0，表示没有任何读线程或者写线程了。并且Sync queue结构与上一个状态的结构相同，没有变化。</li>
</ul>
</li>
</ul>
<h5 id="5、更深入理解"><a href="#5、更深入理解" class="headerlink" title="5、更深入理解"></a>5、更深入理解</h5><h6 id="1、什么是锁升降级？"><a href="#1、什么是锁升降级？" class="headerlink" title="1、什么是锁升降级？"></a>1、什么是锁升降级？</h6><p><strong>锁降级指的是写锁降级成为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程</strong>。</p>
<p>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程(略)</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数据的流程(略)</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，当数据发生变更后，update变量(布尔类型且volatile修饰)被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。</p>
<p><img src="/2021/07/19/JUC/image-20210726213514196.png" alt="image-20210726213514196"></p>
<h6 id="2、锁降级中读锁的获取是否必要呢"><a href="#2、锁降级中读锁的获取是否必要呢" class="headerlink" title="2、锁降级中读锁的获取是否必要呢?"></a>2、锁降级中读锁的获取是否必要呢?</h6><p>答案是必要的。<strong>主要是为了==保证数据的可见性==，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程(记作线程T)获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</strong></p>
<h6 id="3、RentrantReadWriteLock支不支持锁升级？"><a href="#3、RentrantReadWriteLock支不支持锁升级？" class="headerlink" title="3、RentrantReadWriteLock支不支持锁升级？"></a>3、RentrantReadWriteLock支不支持锁升级？</h6><p>RentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是**==保证数据可见性==，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。**</p>
<h5 id="6、使用读写锁实现一致性缓存（保证缓存与数据库数据一致）"><a href="#6、使用读写锁实现一致性缓存（保证缓存与数据库数据一致）" class="headerlink" title="6、使用读写锁实现一致性缓存（保证缓存与数据库数据一致）"></a>6、使用读写锁实现一致性缓存（保证缓存与数据库数据一致）</h5><h6 id="1、缓存更新策略"><a href="#1、缓存更新策略" class="headerlink" title="1、缓存更新策略"></a>1、缓存更新策略</h6><p>更新时，是先清缓存还是先更新数据库？</p>
<p>先清缓存：</p>
<p><img src="/2021/07/19/JUC/image-20210813015618419.png" alt="image-20210813015618419"></p>
<p>先更新数据库：</p>
<p><img src="/2021/07/19/JUC/image-20210813015913860.png" alt="image-20210813015913860"></p>
<p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p>
<p><img src="/2021/07/19/JUC/image-20210813021033756.png" alt="image-20210813021033756"></p>
<p>这种情况的出现几率非常小，见 facebook 论文</p>
<h6 id="2、使用读写锁实现一个简单的按需加载缓存"><a href="#2、使用读写锁实现一个简单的按需加载缓存" class="headerlink" title="2、使用读写锁实现一个简单的按需加载缓存"></a>2、使用读写锁实现一个简单的按需加载缓存</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericDao dao = <span class="keyword">new</span> GenericDaoCached();</span><br><span class="line">        System.out.println(<span class="string">&quot;============&gt; 查询&quot;</span>);</span><br><span class="line">        String sql = <span class="string">&quot;select * from emp where empno = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> empno = <span class="number">7369</span>;</span><br><span class="line">        Emp emp = dao.queryOne(Emp.class, sql, empno);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        emp = dao.queryOne(Emp.class, sql, empno);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        emp = dao.queryOne(Emp.class, sql, empno);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============&gt; 更新&quot;</span>);</span><br><span class="line">        dao.update(<span class="string">&quot;update emp set sal = ? where empno = ?&quot;</span>, <span class="number">800</span>, empno);</span><br><span class="line">        emp = dao.queryOne(Emp.class, sql, empno);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDaoCached</span> <span class="keyword">extends</span> <span class="title">GenericDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GenericDao dao = <span class="keyword">new</span> GenericDao();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;SqlPair, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryList</span><span class="params">(Class&lt;T&gt; beanClass, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.queryList(beanClass, sql, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryOne</span><span class="params">(Class&lt;T&gt; beanClass, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从缓存中找，找到直接返回</span></span><br><span class="line">        SqlPair key = <span class="keyword">new</span> SqlPair(sql, args);;</span><br><span class="line">        rw.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T value = (T) map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rw.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        rw.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 多个线程</span></span><br><span class="line">            T value = (T) map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 缓存中没有，查询数据库</span></span><br><span class="line">                value = dao.queryOne(beanClass, sql, args);</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rw.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        rw.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先更新库</span></span><br><span class="line">            <span class="keyword">int</span> update = dao.update(sql, args);</span><br><span class="line">            <span class="comment">// 清空缓存</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rw.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlPair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String sql;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SqlPair</span><span class="params">(String sql, Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sql = sql;</span><br><span class="line">            <span class="keyword">this</span>.args = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SqlPair sqlPair = (SqlPair) o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(sql, sqlPair.sql) &amp;&amp;</span><br><span class="line">                    Arrays.equals(args, sqlPair.args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = Objects.hash(sql);</span><br><span class="line">            result = <span class="number">31</span> * result + Arrays.hashCode(args);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑<ul>
<li>适合读多写少，如果写操作比较频繁，以上实现性能低</li>
<li>没有考虑缓存容量</li>
<li>没有考虑缓存过期</li>
<li>只适合单机</li>
<li>并发性还是低，目前只会用一把锁（其实可以把锁再细化，不同的表用不同的锁）</li>
<li>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</li>
</ul>
</li>
<li>乐观锁实现：用 CAS 去更新</li>
</ul>
<h5 id="7、ReentrantReadWriteLock总结"><a href="#7、ReentrantReadWriteLock总结" class="headerlink" title="7、ReentrantReadWriteLock总结"></a>7、ReentrantReadWriteLock总结</h5><ul>
<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>
<li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li>
</ul>
<p>原因：当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p>
<p><img src="/2021/07/19/JUC/image-20210726213440799.png" alt="image-20210726213440799"></p>
<p>注意事项：</p>
<ul>
<li><p>读锁不支持条件变量</p>
</li>
<li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p>
<ul>
<li><pre><code class="java">r.lock();
try &#123;
    // ...
    w.lock();
    try &#123;
        // ...
    &#125; finally&#123;
        w.unlock();
    &#125;
&#125; finally&#123;
    r.unlock();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 重入时降级支持：即持有写锁的情况下去获取读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、对ReentrantReadWriteLock性能再提升——&#96;StampedLock&#96;</span><br><span class="line"></span><br><span class="line">##### 1、StampedLock概述</span><br><span class="line"></span><br><span class="line">该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是**在使用读锁、写锁时都必须配合【戳】使用**</span><br><span class="line"></span><br><span class="line">**加解读锁**：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">long stamp &#x3D; lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>加解写锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p><strong>乐观读</strong>，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、StampedLock示例"><a href="#2、StampedLock示例" class="headerlink" title="2、StampedLock示例"></a>2、StampedLock示例</h5><p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainerStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataContainerStamped</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> readTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> newData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 读-读 （乐观读）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestStampedLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStampedLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainerStamped dataContainer = <span class="keyword">new</span> DataContainerStamped(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，可以看到实际没有加读锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15:58:50.217 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - <span class="built_in">read</span> finish...256, data:1 </span><br><span class="line">15:58:51.220 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...256, data:1 </span><br></pre></td></tr></table></figure>

<p>测试 读-写 时优化读补加读锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestStampedLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStampedLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainerStamped dataContainer = <span class="keyword">new</span> DataContainerStamped(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.write(<span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:57:00.219 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:57:00.717 c.DataContainerStamped [t2] - write lock 384 </span><br><span class="line">15:57:01.225 c.DataContainerStamped [t1] - updating to <span class="built_in">read</span> lock... 256 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> lock 513 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...513, data:1000 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> unlock 513 </span><br></pre></td></tr></table></figure>

<h5 id="3、StampedLock是否可以替代ReentrantReadWriteLock"><a href="#3、StampedLock是否可以替代ReentrantReadWriteLock" class="headerlink" title="3、StampedLock是否可以替代ReentrantReadWriteLock"></a>3、StampedLock是否可以替代ReentrantReadWriteLock</h5><p>当然是不可以，虽然StampedLock在读写锁上的性能比ReentrantReadWriteLock好，但是它有以下几个缺点：</p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
<h3 id="7、线程间通信"><a href="#7、线程间通信" class="headerlink" title="7、线程间通信"></a>7、线程间通信</h3><p>线程间通信的模型有两种：==共享内存==和==消息传递==</p>
<h4 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h4><p>我们来基本一道面试常见的题目来分析：场景——四个线程，两个线程对当前数值加 1，另外两个线程对当前数值减 1，要求用线程间通信。</p>
<h4 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h4><h5 id="1、关于i-与i–的字节码及其执行流程"><a href="#1、关于i-与i–的字节码及其执行流程" class="headerlink" title="1、关于i++与i–的字节码及其执行流程"></a>1、关于i++与i–的字节码及其执行流程</h5><p>i++其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取i的值。</li>
<li>对i加1。</li>
<li>将i的值写回内存。 </li>
</ul>
<p>i++的相关字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_ <span class="number">1</span>   <span class="comment">//准备常量1</span></span><br><span class="line">iadd        <span class="comment">//自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>对于i–也是类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_ <span class="number">1</span>   <span class="comment">//准备常量1</span></span><br><span class="line">isub        <span class="comment">//自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>而Java的内存模型如下,完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：(下图只显示了两个线程，分别做自增和自减)</p>
<p><img src="/2021/07/19/JUC/image-20210804150447015.png" alt="image-20210804150447015"></p>
<p>如果是单线程以上 8 行字节码是顺序执行（不会交错）没有问题：</p>
<p><img src="/2021/07/19/JUC/image-20210804152755128.png" alt="image-20210804152755128"></p>
<p>但多线程下这 8 行字节码可能交错运行：</p>
<p>出现负数的情况：</p>
<p><img src="/2021/07/19/JUC/image-20210804152921570.png" alt="image-20210804152921570"></p>
<p>出现正数的情况：</p>
<p><img src="/2021/07/19/JUC/image-20210804152947980.png" alt="image-20210804152947980"></p>
<h5 id="2、临界区-Critical-Section"><a href="#2、临界区-Critical-Section" class="headerlink" title="2、临界区 Critical Section"></a>2、<strong>临界区 Critical Section</strong></h5><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ul>
<h5 id="3、竞态条件-Race-Condition"><a href="#3、竞态条件-Race-Condition" class="headerlink" title="3、竞态条件 Race Condition"></a>3、竞态条件 Race Condition</h5><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<h4 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h4><p><img src="/2021/07/19/JUC/image-20210804154458987.png" alt="image-20210804154458987"></p>
<p><img src="/2021/07/19/JUC/image-20210804154522110.png" alt="image-20210804154522110"></p>
<p>使用Lock的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Share</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Share share = <span class="keyword">new</span> Share();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.incr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.decr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.incr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.decr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8、线程间定制化通信"><a href="#8、线程间定制化通信" class="headerlink" title="8、线程间定制化通信"></a>8、线程间定制化通信</h3><p>案例介绍：</p>
<p>问题：A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮。</p>
<p>实现方法：</p>
<p><img src="/2021/07/19/JUC/image-20210722025741403.png" alt="image-20210722025741403"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步 创建资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;  <span class="comment">// 1 AA     2 BB     3 CC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印5次，参数第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            flag = <span class="number">2</span>; <span class="comment">//修改标志位 2</span></span><br><span class="line">            c2.signal(); <span class="comment">//通知BB线程</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印10次，参数第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知CC线程</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印15次，参数第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知AA线程</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print5(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print10(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print15(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9、集合的线程安全"><a href="#9、集合的线程安全" class="headerlink" title="9、集合的线程安全"></a>9、集合的线程安全</h3><p>类结构关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-overview-2.png" alt="image"></p>
<p><img src="/2021/07/19/JUC/image-20210813203912863.png" alt="image-20210813203912863"></p>
<p>线程安全集合类可以分为三大类：</p>
<ul>
<li>遗留的线程安全集合如 Hashtable ， Vector</li>
<li>使用 Collections 装饰的线程安全集合，如：<ul>
<li><code>Collections.synchronizedCollection</code></li>
<li><code>Collections.synchronizedList</code></li>
<li><code>Collections.synchronizedMap</code></li>
<li><code>Collections.synchronizedSet</code></li>
<li><code>Collections.synchronizedNavigableMap</code></li>
<li><code>Collections.synchronizedNavigableSet</code></li>
<li><code>Collections.synchronizedSortedMap</code></li>
<li><code>Collections.synchronizedSortedSet</code></li>
</ul>
</li>
<li><code>java.util.concurrent.*</code></li>
</ul>
<p>重点介绍 <code>java.util.concurrent.*</code> 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<code>Blocking</code>、<code>CopyOnWrite</code>、<code>Concurrent</code></p>
<ul>
<li><code>Blocking</code> <strong>大部分实现基于锁，并提供用来阻塞的方法</strong></li>
<li><code>CopyOnWrite</code> 之类<strong>容器修改开销相对较重</strong></li>
<li><code>Concurrent</code> 类型的<strong>容器</strong><ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li><strong>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</strong></li>
<li><strong>求大小弱一致性，size 操作未必是 100% 准确</strong></li>
<li><strong>读取弱一致性</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 <code>fail-fast</code> 机制也就是让遍历立刻失败，抛出ConcurrentModiﬁcationException，不再继续遍历</p>
</blockquote>
<h4 id="1、ArrayList不安全"><a href="#1、ArrayList不安全" class="headerlink" title="1、ArrayList不安全"></a>1、ArrayList不安全</h4><p>ArrayList的底层没有用synchronized修饰，本身也没有使用CAS等轻量级锁。所以在多线程环境下，ArrayList是不安全的。</p>
<p>示例：(在一边添加一遍读取的时候，可能会出现内容还没有添加进去就被读取的情况，而且会报：<code>java.util.ConcurrentModificationException</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建ArrayList集合</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//向集合添加内容</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                <span class="comment">//从集合获取内容</span></span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;27&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList<span class="variable">$Itr</span>.checkForComodification(ArrayList.java:901)</span><br><span class="line">	at java.util.ArrayList<span class="variable">$Itr</span>.next(ArrayList.java:851)</span><br><span class="line">	at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><br><span class="line">	at java.lang.String.valueOf(String.java:2994)</span><br><span class="line">	at java.io.PrintStream.println(PrintStream.java:821)</span><br><span class="line">	at test.ThreadDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(ThreadDemo.java:17)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">[cca2ec16, 6e8894c8, 30ace70b, 622ecfd3, 81951d12]</span><br><span class="line">[cca2ec16, 6e8894c8, 30ace70b, 622ecfd3, 81951d12, 7e3fd2db, beca20aa, 7d121289]</span><br><span class="line">[cca2ec16, 6e8894c8, 30ace70b, 622ecfd3, 81951d12, 7e3fd2db, beca20aa]</span><br><span class="line">[cca2ec16, 6e8894c8, 30ace70b, 622ecfd3, 81951d12, 7e3fd2db]</span><br><span class="line">[cca2ec16, 6e8894c8, 30ace70b, 622ecfd3, 81951d12, 7e3fd2db, beca20aa, 7d121289]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>解决ArrayList在多线程环境下不安全的问题：</p>
<ol>
<li>方案1：用<code>Vector</code>代替ArrayList</li>
<li>方案2：<code>Collections.synchronizedList</code>创建一个同步的ArrayList</li>
<li>方案3：所以JUC的<code>CopyOnWriteArrayList</code></li>
</ol>
<h5 id="1、方案1：用Vector代替ArrayList"><a href="#1、方案1：用Vector代替ArrayList" class="headerlink" title="1、方案1：用Vector代替ArrayList"></a>1、方案1：用<code>Vector</code>代替ArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector解决</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在Vector底层的几乎所有方法都有Synchronized进行修饰，所以在多线程下Vector是安全的。</p>
<p>但是这种方法会导致程序的效率变得很低，所以一般不会使用这种方法。</p>
<h5 id="2、方案2：Collections-synchronizedList创建一个同步的ArrayList"><a href="#2、方案2：Collections-synchronizedList创建一个同步的ArrayList" class="headerlink" title="2、方案2：Collections.synchronizedList创建一个同步的ArrayList"></a>2、方案2：<code>Collections.synchronizedList</code>创建一个同步的ArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections解决</span></span><br><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>同理这种方法会导致程序的效率变得很低，所以一般不会使用这种方法。</p>
<p>那么有没有好的方法，既解决了ArrayList不安全的问题，又不会对程序的效率造成很大的影响？</p>
<p>答：方案3：所以JUC的<code>CopyOnWriteArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList解决</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h4 id="2、JUC的CopyOnWriteArrayList"><a href="#2、JUC的CopyOnWriteArrayList" class="headerlink" title="2、JUC的CopyOnWriteArrayList"></a>2、JUC的<code>CopyOnWriteArrayList</code></h4><p><code>CopyOnWriteArraySet</code> 是它的马甲 底层实现采用了 <code>写入时拷贝</code> 的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的<strong>并发读，读写分离</strong>。</p>
<h5 id="1、BAT大厂的面试问题-11"><a href="#1、BAT大厂的面试问题-11" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>请先说说非并发集合中Fail-fast机制？</li>
<li>再为什么说ArrayList查询快而增删慢？</li>
<li>对比ArrayList说说CopyOnWriteArrayList的增删改查实现原理？<ul>
<li>COW基于拷贝</li>
</ul>
</li>
<li>再说下弱一致性的迭代器原理是怎么样的？<ul>
<li><code>COWIterator&lt;E&gt;</code></li>
</ul>
</li>
<li>CopyOnWriteArrayList为什么并发安全且性能比Vector好？</li>
<li>CopyOnWriteArrayList有何缺陷，说说其应用场景？</li>
</ul>
<h5 id="2、CopyOnWriteArrayList源码分析"><a href="#2、CopyOnWriteArrayList源码分析" class="headerlink" title="2、CopyOnWriteArrayList源码分析"></a>2、CopyOnWriteArrayList源码分析</h5><h6 id="1、类的继承关系-3"><a href="#1、类的继承关系-3" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><p>CopyOnWriteArrayList</p>
<ul>
<li>实现了<strong>List接口</strong>，List接口定义了对列表的基本操作；</li>
<li>同时实现了<strong>RandomAccess接口</strong>，表示可以随机访问(数组具有随机访问的特性)；</li>
<li>同时实现了<strong>Cloneable接口</strong>，表示可克隆；</li>
<li>同时也实现了<strong>Serializable接口</strong>，表示可被序列化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、类的内部类——COWIterator类"><a href="#2、类的内部类——COWIterator类" class="headerlink" title="2、类的内部类——COWIterator类"></a>2、类的内部类——COWIterator类</h6><p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 <code>ConcurrentModificationException</code>。</p>
<p>创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 <code>UnsupportedOperationException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="comment">// 游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否还有下一项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有上一项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next项</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext()) <span class="comment">// 不存在下一项，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 返回下一项</span></span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下一项索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一项索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持remove操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> set&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持set操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> add&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持add操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Object[] elements = snapshot;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cursor; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) elements[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、类的属性"><a href="#3、类的属性" class="headerlink" title="3、类的属性"></a>3、类的属性</h6><p>属性中有<strong>一个可重入锁</strong>，用来保证线程安全访问，还有<strong>一个Object类型的数组</strong>，用来存放具体的元素。当然，也使用到了<code>反射机制</code>和<code>CAS来保证原子性</code>的修改lock域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 对象数组，用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// lock域的内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;lock&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4、类的构造函数"><a href="#4、类的构造函数" class="headerlink" title="4、类的构造函数"></a>4、类的构造函数</h6><ul>
<li><p>默认构造函数</p>
<ul>
<li><pre><code class="java">public CopyOnWriteArrayList() &#123;
    // 设置数组
    setArray(new Object[0]);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;CopyOnWriteArrayList(Collection&lt;? extends E&gt;)&#96;型构造函数——该构造函数用于创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] elements;</span><br><span class="line">        if (c.getClass() &#x3D;&#x3D; CopyOnWriteArrayList.class) &#x2F;&#x2F; 类型相同</span><br><span class="line">            &#x2F;&#x2F; 获取c集合的数组</span><br><span class="line">            elements &#x3D; ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">        else &#123; &#x2F;&#x2F; 类型不相同</span><br><span class="line">            &#x2F;&#x2F; 将c集合转化为数组并赋值给elements</span><br><span class="line">            elements &#x3D; c.toArray();</span><br><span class="line">            &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">            if (elements.getClass() !&#x3D; Object[].class) &#x2F;&#x2F; elements类型不为Object[]类型</span><br><span class="line">                &#x2F;&#x2F; 将elements数组转化为Object[]类型的数组</span><br><span class="line">                elements &#x3D; Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 设置数组</span><br><span class="line">        setArray(elements);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><code>CopyOnWriteArrayList(Collection&lt;? extends E&gt;)</code>型构造函数的处理流程如下：</p>
<ol>
<li>判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组(Object[])，并且设置当前CopyOnWriteArrayList的数组(Object[]数组)，进入步骤③；否则，进入步骤②</li>
<li>将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型(toArray方法可能不会返回Object类型的数组)，若不是，则将elements转化为Object类型的数组。进入步骤③</li>
<li>设置当前CopyOnWriteArrayList的Object[]为elements。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>CopyOnWriteArrayList(E[])</code>型构造函数</p>
<ul>
<li><p>该构造函数用于创建一个保存给定数组的副本的列表。</p>
</li>
<li><pre><code class="java">public CopyOnWriteArrayList(E[] toCopyIn) &#123;
    // 将toCopyIn转化为Object[]类型数组，然后设置当前数组
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 5、核心函数</span><br><span class="line"></span><br><span class="line">- copyOf</span><br><span class="line">- add</span><br><span class="line">- addIfAbsent</span><br><span class="line">- set</span><br><span class="line">- remove</span><br><span class="line"></span><br><span class="line">对于CopyOnWriteArrayList的函数分析，主要明白**Arrays.copyOf方法**即可理解CopyOnWriteArrayList其他函数的意义。</span><br><span class="line"></span><br><span class="line">###### 6、核心函数分析——copyOf</span><br><span class="line"></span><br><span class="line">该函数用于**复制指定的数组，截取或用 null 填充(如有必要)，以使副本具有指定的长度**。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    &#x2F;&#x2F; 确定copy的类型(将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组</span><br><span class="line">    &#x2F;&#x2F; 否则,生成指定长度的新类型的数组)</span><br><span class="line">    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    &#x2F;&#x2F; 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中(也从下标0开始)</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="7、核心函数分析——add"><a href="#7、核心函数分析——add" class="headerlink" title="7、核心函数分析——add"></a>7、核心函数分析——add</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 元素数组</span></span><br><span class="line">        <span class="comment">// 获取旧的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        <span class="comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 存放元素e</span></span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        <span class="comment">// 替换旧的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p>
</blockquote>
<p>此函数用于<strong>将指定元素添加到此列表的尾部</strong>，处理流程如下（写时复制技术）（并发读，独立写）</p>
<ul>
<li>获取锁(保证多线程的安全访问)，获取当前的Object数组，获取Object数组的长度为length，进入步骤②。</li>
<li>根据Object数组复制一个长度为length+1的Object数组为newElements(此时，newElements[length]为null)，进入下一步骤。</li>
<li>将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。</li>
</ul>
<p>其实就是写时复制技术，并发读，独立写</p>
<ul>
<li>读进程读的是原来的版本</li>
<li>写进程写的是原来的版本的复制版本</li>
<li>在写进程完成好写之后，再将复制的版本与原来的版本进行合并</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210723213936543.png" alt="image-20210723213936543"></p>
<h6 id="8、核心函数分析——addIfAbsent"><a href="#8、核心函数分析——addIfAbsent" class="headerlink" title="8、核心函数分析——addIfAbsent"></a>8、核心函数分析——addIfAbsent</h6><p>该函数用于<strong>添加元素(如果数组中不存在，则添加；否则，不添加，直接返回)，可以保证多线程环境下不会重复添加元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123; <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="comment">// 取较小者</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++) <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                    <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                    <span class="comment">// 返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>) <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">                    <span class="comment">// 返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的流程如下：</p>
<ol>
<li>获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④</li>
<li>不相等，表示在snapshot与current之间，对数组进行了修改(如进行了add、set、remove等操作)，获取长度(snapshot与current之间的较小者)，对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等(可能进行了set操作)，进入步骤⑤，否则，进入步骤③</li>
<li>在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④</li>
<li>复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤</li>
<li>释放锁，返回。</li>
</ol>
<h6 id="9、核心函数分析——set"><a href="#9、核心函数分析——set" class="headerlink" title="9、核心函数分析——set"></a>9、核心函数分析——set</h6><p>此函数用于<strong>用指定的元素替代此列表指定位置上的元素，也是基于数组的复制来实现的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取index索引的元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; <span class="comment">// 旧值不等于element</span></span><br><span class="line">            <span class="comment">// 数组长度</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 重新赋值index索引的值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="10、核心函数分析——remove"><a href="#10、核心函数分析——remove" class="headerlink" title="10、核心函数分析——remove"></a>10、核心函数分析——remove</h6><p>此函数用于<strong>移除此列表指定位置上的元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// 移动个数为0</span></span><br><span class="line">            <span class="comment">// 复制后设置数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 移动个数不为0</span></span><br><span class="line">            <span class="comment">// 新生数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制index索引之前的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 复制index索引之后的元素</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">            <span class="comment">// 设置索引</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理流程如下：</p>
<ol>
<li>获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数(length - index - 1),若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②</li>
<li>先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</li>
<li>释放锁，返回旧值。</li>
</ol>
<h5 id="3、CopyOnWriteArrayList示例"><a href="#3、CopyOnWriteArrayList示例" class="headerlink" title="3、CopyOnWriteArrayList示例"></a>3、CopyOnWriteArrayList示例</h5><p>下面通过一个示例来了解CopyOnWriteArrayList的使用：</p>
<p>在程序中，有一个PutThread线程会每隔50ms就向CopyOnWriteArrayList中添加一个元素，并且两次使用了迭代器，迭代器输出的内容都是生成迭代器时，CopyOnWriteArrayList的Object数组的快照的内容，在迭代的过程中，往CopyOnWriteArrayList中添加元素也不会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Integer&gt; cowal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(CopyOnWriteArrayList&lt;Integer&gt; cowal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cowal = cowal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">110</span>; i++) &#123;</span><br><span class="line">                cowal.add(i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; cowal = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cowal.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        PutThread p1 = <span class="keyword">new</span> PutThread(cowal);</span><br><span class="line">        p1.start();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 100 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 100 101 102 103 </span><br></pre></td></tr></table></figure>

<h5 id="4、CopyOnWriteArrayList的弱一致性体现"><a href="#4、CopyOnWriteArrayList的弱一致性体现" class="headerlink" title="4、CopyOnWriteArrayList的弱一致性体现"></a>4、CopyOnWriteArrayList的弱一致性体现</h5><h6 id="1、get-弱一致性"><a href="#1、get-弱一致性" class="headerlink" title="1、get 弱一致性"></a>1、get 弱一致性</h6><p><img src="/2021/07/19/JUC/image-20210814045103054.png" alt="image-20210814045103054"></p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Thread-0 getArray()</td>
</tr>
<tr>
<td>2</td>
<td>Thread-1 getArray()</td>
</tr>
<tr>
<td>3</td>
<td>Thread-1 setArray(arrayCopy)</td>
</tr>
<tr>
<td>4</td>
<td>Thread-0 array[index]</td>
</tr>
</tbody></table>
<h6 id="2、迭代器弱一致性"><a href="#2、迭代器弱一致性" class="headerlink" title="2、迭代器弱一致性"></a>2、迭代器弱一致性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">sleep1s();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然线程t1已经将<code>1</code>从list中移除，但是迭代器当中迭代的list依旧是旧的list，有包括<code>1</code></p>
<h6 id="3、关于弱一致性"><a href="#3、关于弱一致性" class="headerlink" title="3、关于弱一致性"></a>3、关于弱一致性</h6><p>不要觉得弱一致性就不好</p>
<ul>
<li>数据库的 MVCC 都是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>
<h5 id="5、更深入理解-1"><a href="#5、更深入理解-1" class="headerlink" title="5、更深入理解"></a>5、更深入理解</h5><h6 id="1、CopyOnWriteArrayList的缺陷和使用场景"><a href="#1、CopyOnWriteArrayList的缺陷和使用场景" class="headerlink" title="1、CopyOnWriteArrayList的缺陷和使用场景"></a>1、CopyOnWriteArrayList的缺陷和使用场景</h6><p>CopyOnWriteArrayList 有几个缺点：</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，<strong>可能导致young gc或者full gc</strong>；</li>
<li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性，但是还是没法满足实时性要求；</li>
</ul>
<p><strong>CopyOnWriteArrayList 合适==读多写少==的场景，不过这类慎用</strong></p>
<p>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p>
<h6 id="2、CopyOnWriteArrayList为什么并发安全性能比Vector好？"><a href="#2、CopyOnWriteArrayList为什么并发安全性能比Vector好？" class="headerlink" title="2、CopyOnWriteArrayList为什么并发安全性能比Vector好？"></a>2、CopyOnWriteArrayList为什么并发安全性能比Vector好？</h6><ul>
<li>Vector对单独的add，remove等方法都是在方法上加了synchronized；</li>
<li>并且如果一个线程A调用size时，另一个线程B 执行了remove，然后size的值就不是最新的，然后线程A调用remove就会越界(这时就需要再加一个Synchronized)。这样就导致有了双重锁，效率大大降低，何必呢。</li>
<li>于是vector废弃了，要用就用CopyOnWriteArrayList 吧。</li>
</ul>
<h4 id="3、HashMap不安全"><a href="#3、HashMap不安全" class="headerlink" title="3、HashMap不安全"></a>3、HashMap不安全</h4><p>HashMap的底层没有用synchronized修饰，本身也没有使用CAS等轻量级锁。所以在多线程环境下，HashMap是不安全的。</p>
<p>示例：(在一边添加一遍读取的时候，可能会出现内容还没有添加进去就被读取的情况，而且会报：<code>java.util.ConcurrentModificationException</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演示HashMap</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//向集合添加内容</span></span><br><span class="line">                map.put(key,UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                <span class="comment">//从集合获取内容</span></span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;22=b7638976, 23=918c6021, 24=254a542e, 26=effdaef0, 27=b0fd0006, 16=f7d3b9d2, 11=00b17c4e, 12=25056443, 2=759da0ba, 3=d977b33e, 4=758b21a1, 5=3d8e4168, 17=78fd5054, 18=d7bb38f0, 8=a8951500, 19=d65b26d7, 9=604d74ec, 20=5397c946, 6=c9eab94c, 7=05d8fd82, 10=7400865e, 21=dc0083c7&#125;</span><br><span class="line">&#123;16=f7d3b9d2, 11=00b17c4e, 12=25056443, 2=759da0ba, 3=d977b33e, 4=758b21a1, 5=3d8e4168, 17=78fd5054, 8=a8951500, 9=604d74ec, 20=5397c946, 6=c9eab94c, 7=05d8fd82, 10=7400865e&#125;</span><br><span class="line">&#123;22=b7638976, 23=918c6021, 24=254a542e, 25=9f469278, 26=effdaef0, 27=b0fd0006, 16=f7d3b9d2, 11=00b17c4e, 12=25056443, 2=759da0ba, 3=d977b33e, 4=758b21a1, 5=3d8e4168, 17=78fd5054, 18=d7bb38f0, 8=a8951500, 19=d65b26d7, 9=604d74ec, 20=5397c946, 6=c9eab94c, 7=05d8fd82, 10=7400865e, 21=dc0083c7&#125;</span><br><span class="line">&#123;22=b7638976, 23=918c6021, 24=254a542e, 25=9f469278, 26=effdaef0, 27=b0fd0006, 28=85c91660, 29=930cd3b4, 16=f7d3b9d2, 11=00b17c4e, 12=25056443, 2=759da0ba, 3=d977b33e, 4=758b21a1, 5=3d8e4168, 17=78fd5054, 18=d7bb38f0, 8=a8951500, 19=d65b26d7, 9=604d74ec, 20=5397c946, 6=c9eab94c, 7=05d8fd82, 10=7400865e, 21=dc0083c7&#125;</span><br><span class="line">&#123;22=b7638976, 23=918c6021, 24=254a542e, 25=9f469278, 26=effdaef0, 27=b0fd0006, 28=85c91660, 16=f7d3b9d2, 11=00b17c4e, 12=25056443, 2=759da0ba, 3=d977b33e, 4=758b21a1, 5=3d8e4168, 17=78fd5054, 18=d7bb38f0, 8=a8951500, 19=d65b26d7, 9=604d74ec, 20=5397c946, 6=c9eab94c, 7=05d8fd82, 10=7400865e, 21=dc0083c7&#125;</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;0&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;5&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;17&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;1&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;7&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;14&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;19&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;26&quot;</span> Exception <span class="keyword">in</span> thread <span class="string">&quot;27&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.HashMap<span class="variable">$HashIterator</span>.nextNode(HashMap.java:1437)</span><br><span class="line">	at java.util.HashMap<span class="variable">$EntryIterator</span>.next(HashMap.java:1471)</span><br><span class="line">	at java.util.HashMap<span class="variable">$EntryIterator</span>.next(HashMap.java:1469)</span><br><span class="line">	at java.util.AbstractMap.toString(AbstractMap.java:554)</span><br><span class="line">	at java.lang.String.valueOf(String.java:2994)</span><br><span class="line">	at java.io.PrintStream.println(PrintStream.java:821)</span><br><span class="line">	at test.ThreadDemo4.lambda<span class="variable">$main</span><span class="variable">$0</span>(ThreadDemo4.java:20)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>解决HashMap在多线程环境下不安全的问题：</p>
<ol>
<li>方案1：用<code>HashTable</code>代替HashMap</li>
<li>方案2：JUC的<code>ConcurrentHashMap</code></li>
</ol>
<h5 id="方案1：用HashTable代替HashMap"><a href="#方案1：用HashTable代替HashMap" class="headerlink" title="方案1：用HashTable代替HashMap"></a>方案1：用<code>HashTable</code>代替HashMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用HashTable代替HashMap</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashTable&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在HashTable底层的几乎所有方法都有Synchronized进行修饰，所以在多线程下HashTable是安全的。</p>
<p>但是这种方法会导致程序的效率变得很低，所以一般不会使用这种方法。</p>
<p>那么有没有好的方法，既解决了HashMap不安全的问题，又不会对程序的效率造成很大的影响？</p>
<p>答：方案2：所以JUC的<code>ConcurrentHashMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap解决</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h4 id="4、JUC的ConcurrentHashMap"><a href="#4、JUC的ConcurrentHashMap" class="headerlink" title="4、JUC的ConcurrentHashMap"></a>4、JUC的<code>ConcurrentHashMap</code></h4><h5 id="1、BAT大厂的面试问题-12"><a href="#1、BAT大厂的面试问题-12" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>为什么HashTable慢？它的并发度是什么？那么ConcurrentHashMap并发度是什么？</li>
<li>ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别？JDK1.8解決了JDK1.7中什么问题？</li>
<li>ConcurrentHashMap JDK1.7实现的原理是什么？<ul>
<li>分段锁机制</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.8实现的原理是什么？<ul>
<li>数组+链表+红黑树，CAS</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少？为何一旦初始化就不可再扩容？</li>
<li>ConcurrentHashMap JDK1.7说说其put的机制？</li>
<li>ConcurrentHashMap JDK1.7是如何扩容的？<ul>
<li>rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容)</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.8是如何扩容的？<ul>
<li>tryPresize</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.8链表转红黑树的时机是什么？临界值为什么是8？</li>
<li>ConcurrentHashMap JDK1.8是如何进行数据迁移的？<ul>
<li>transfer</li>
</ul>
</li>
<li>JDK 7 HashMap 并发死链问题</li>
</ul>
<h5 id="2、为什么HashTable慢"><a href="#2、为什么HashTable慢" class="headerlink" title="2、为什么HashTable慢"></a>2、为什么HashTable慢</h5><p>Hashtable之所以效率低下主要是因为其<strong>实现使用了synchronized关键字对put等操作进行加锁</strong>，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p>
<h5 id="3、ConcurrentHashMap-JDK1-7"><a href="#3、ConcurrentHashMap-JDK1-7" class="headerlink" title="3、ConcurrentHashMap - JDK1.7"></a>3、ConcurrentHashMap - JDK1.7</h5><p>在JDK1.5~1.7版本，Java使用了<code>分段锁机制</code>实现ConcurrentHashMap.</p>
<p>简而言之，<strong>ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可</strong>。因此，ConcurrentHashMap在多线程并发编程中可实现多线程put操作。</p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li>
</ul>
<p>接下来分析JDK1.7版本中ConcurrentHashMap的实现原理。</p>
<h6 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h6><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表“<strong>部分</strong>”或“<strong>一段</strong>”的意思，所以很多地方都会将其描述为<code>分段锁</code>。一般使用“槽”来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 Segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-concurrent-hashmap-1.png" alt="img"></p>
<p><code>concurrencyLevel</code>：并行级别、并发数、Segment 数，怎么翻译不重要，重要的是理解它。<strong>默认是 16</strong>，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。<strong>这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</strong></p>
<p>再具体到每个 Segment 内部，其实<strong>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全</strong>，所以处理起来要麻烦些。</p>
<h6 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h6><ul>
<li><code>initialCapacity</code>：<strong>初始容量。这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment</strong>。</li>
<li><code>loadFactor</code>：<strong>负载因子。之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，即 0000 0000 0000 1111后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;<span class="comment">// 掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成，我们得到了一个 Segment 数组。如下图所示：</p>
<p><img src="/2021/07/19/JUC/image-20210814031243376.png" alt="image-20210814031243376"></p>
<p>我们就当是用 new ConcurrentHashMap() <strong>无参构造函数</strong>进行初始化的，那么初始化完成后:</p>
<ul>
<li><strong>Segment 数组长度为 16，不可以扩容</strong></li>
<li><strong>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</strong></li>
<li>这里<strong>初始化了 segment[0]，其他位置还是 null</strong>，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li><strong>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15</strong>，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，这两个值马上就会用到</li>
</ul>
<p>可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好</p>
<p><strong>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment</strong></p>
<p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p>
<p><img src="/2021/07/19/JUC/image-20210814031359616.png" alt="image-20210814031359616"></p>
<p>结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment</p>
<p><img src="/2021/07/19/JUC/image-20210814031416319.png" alt="image-20210814031416319"></p>
<h6 id="3、put过程分析"><a href="#3、put过程分析" class="headerlink" title="3、put过程分析"></a>3、put过程分析</h6><p>先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null, </span></span><br><span class="line">        <span class="comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="comment">// 进入 segment 的put 流程</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由 <code>数组+链表</code> 组成的。segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span><br><span class="line">    <span class="comment">//    先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    <span class="comment">// 如果不成功, 进入 scanAndLockForPut 流程</span></span><br><span class="line">    <span class="comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span></span><br><span class="line">    <span class="comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span></span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    <span class="comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新增</span></span><br><span class="line">                <span class="comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span></span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 2) 创建新 node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3) 扩容</span></span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h6 id="4、初始化槽：ensureSegment"><a href="#4、初始化槽：ensureSegment" class="headerlink" title="4、初始化槽：ensureSegment"></a>4、初始化槽：ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line"></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作<strong>使用 CAS 进行控制</strong>。</p>
<h6 id="5、获取写入锁：scanAndLockForPut"><a href="#5、获取写入锁：scanAndLockForPut" class="headerlink" title="5、获取写入锁：scanAndLockForPut"></a>5、获取写入锁：scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value)</span><br></pre></td></tr></table></figure>

<p>也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">// 所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node</strong>。</p>
<h6 id="6、扩容：rehash"><a href="#6、扩容：rehash" class="headerlink" title="6、扩容：rehash"></a>6、扩容：rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，<strong>扩容后，容量为原来的 2 倍</strong>。</p>
<p>由于扩容发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br></pre></td></tr></table></figure>

<p><strong>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用（直接搬移，没有进行头插法）</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，剩余节点需要新建</span></span><br><span class="line">                <span class="comment">// 这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容完成, 才加入新的节点</span></span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    <span class="comment">// 替换为新的 HashEntry table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p>
<h6 id="7、get过程分析"><a href="#7、get过程分析" class="headerlink" title="7、get过程分析"></a>7、get过程分析</h6><p>相对于 put 来说，get 就很简单了。</p>
<ul>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1. hash 值</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="comment">// u 为 segment 对象在数组中的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2. 根据 hash 找到对应的 segment </span></span><br><span class="line">    <span class="comment">// s 即为 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8、size计算流程"><a href="#8、size计算流程" class="headerlink" title="8、size计算流程"></a>8、size计算流程</h6><ul>
<li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</li>
<li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to     </span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.     </span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="comment">// 超过重试次数, 需要创建所有 segment 并加锁</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里处理的很巧妙</span></span><br><span class="line">            <span class="comment">// 计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</span></span><br><span class="line">            <span class="comment">// 先判断最后得出来的结果是不是与上次得到的结果一致：</span></span><br><span class="line">            <span class="comment">// 一致，跳出循环</span></span><br><span class="line">            <span class="comment">// 不一致，将本次得到的结果设置为最后的结果，方面下一次的对比</span></span><br><span class="line">            <span class="comment">// 重试次数超过 3，将所有 segment 锁住，重新计算个数返回</span></span><br><span class="line">            <span class="comment">// 在上面if (retries++ == RETRIES_BEFORE_LOCK)块内上锁，在下面finally的if块中解锁</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="9、并发问题分析"><a href="#9、并发问题分析" class="headerlink" title="9、并发问题分析"></a>9、并发问题分析</h6><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p>
<ul>
<li>put 操作的线程安全性：<ul>
<li><strong>初始化槽</strong>，这个我们之前就说过了，<strong>使用了 CAS 来初始化 Segment 中的数组</strong>。</li>
<li><strong>添加节点到链表的操作是插入到表头的</strong>，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 **get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 <code>setEntryAt</code> 方法中使用的 <code>UNSAFE.putOrderedObject</code>**。</li>
<li><strong>扩容</strong>。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，<strong>如果 get 先行，那么就是在旧的 table 上做查询操作</strong>；而 <strong>put 先行，那么 put 操作的可见性保证就是 ==table 使用了 volatile 关键字==。</strong></li>
</ul>
</li>
<li>remove 操作的线程安全性：<ul>
<li>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</li>
<li><strong>get 操作需要遍历链表，但是 remove 操作会”破坏”链表</strong>。</li>
<li><strong>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题</strong>。</li>
<li>如果 remove 先破坏了一个节点，分两种情况考虑。 <ol>
<li>如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以<strong>源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</strong></li>
<li>如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 <strong>next 属性是 volatile 的</strong>。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="4、ConcurrentHashMap-JDK1-8"><a href="#4、ConcurrentHashMap-JDK1-8" class="headerlink" title="4、ConcurrentHashMap - JDK1.8"></a>4、ConcurrentHashMap - JDK1.8</h5><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的<strong>数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现</strong>。</p>
<h6 id="1、数据结构-1"><a href="#1、数据结构-1" class="headerlink" title="1、数据结构"></a>1、数据结构</h6><p><img src="/2021/07/19/JUC/java-thread-x-concurrent-hashmap-2.png" alt="img"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p>
<p>重要属性和内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小，也就是容量的3/4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="comment">// Node里面的属性：键。值、hash码、next</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通</span></span><br><span class="line">Node <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>相关的重要方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure>

<h6 id="2、初始化-1"><a href="#2、初始化-1" class="headerlink" title="2、初始化"></a>2、初始化</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl：sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... </span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p>
<h6 id="3、put过程分析-1"><a href="#3、put过程分析-1" class="headerlink" title="3、put过程分析"></a>3、put过程分析</h6><p>仔细地一行一行代码看下去：（以下数组简称（table），链表简称（bin））</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="comment">// 其中 spread 方法会综合高位低位, 具有更好的 hash 性</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f 是链表头节点</span></span><br><span class="line">        <span class="comment">// fh 是链表头结点的 hash</span></span><br><span class="line">        <span class="comment">// i 是链表在 table 中的下标</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 要创建 table</span></span><br><span class="line">        <span class="comment">// 如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            <span class="comment">// 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="comment">// 要创建链表头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="comment">// 帮忙扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了、</span></span><br><span class="line">            <span class="comment">// 帮忙之后, 进入下一轮循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addCount()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check 是之前 binCount 的个数(也就是链表的长度)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 已经有了 counterCells, 向 cell 累加</span></span><br><span class="line">        (as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        <span class="comment">// 还没有, 向 baseCount 累加</span></span><br><span class="line">        U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)</span><br><span class="line">    ) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 还没有 counterCells</span></span><br><span class="line">            as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// cell cas 增加计数失败</span></span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 创建累加单元数组和cell, 累加重试</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 获取元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; </span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// newtable 已经创建了，帮忙扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要扩容，这时 newtable 未创建</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个增加size计数的方法与LongAdder的原理有点像：都是采用的分段累加的思想</p>
<p>它还有一个功能就是：扩容</p>
<h6 id="4、初始化数组：initTable"><a href="#4、初始化数组：initTable" class="headerlink" title="4、初始化数组：initTable"></a>4、初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁（表示初始化 table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5、链表转红黑树：treeifyBin"><a href="#5、链表转红黑树：treeifyBin" class="headerlink" title="5、链表转红黑树：treeifyBin"></a>5、链表转红黑树：treeifyBin</h6><p>前面我们在 put 源码分析也说过，<strong>treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容</strong>。</p>
<p>我们还是进行源码分析吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="6、扩容：tryPresize"><a href="#6、扩容：tryPresize" class="headerlink" title="6、扩容：tryPresize"></a>6、扩容：tryPresize</h6><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，<strong>扩容后数组容量为原来的 2 倍</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了(n &lt;&lt; 1)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个方法的核心在于 <code>sizeCtl</code> 值的操作</strong>，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p>
<h6 id="7、数据迁移：transfer"><a href="#7、数据迁移：transfer" class="headerlink" title="7、数据迁移：transfer"></a>7、数据迁移：transfer</h6><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 <code>stride</code>，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 <code>transferIndex</code> 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">//       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局: i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl: n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到底，<strong>transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制</strong>。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h6 id="8、get过程分析"><a href="#8、get过程分析" class="headerlink" title="8、get过程分析"></a>8、get过程分析</h6><p>get 方法从来都是最简单的，这里也不例外：</p>
<ul>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置：(n - 1) &amp; h</li>
<li>根据该位置处结点性质进行相应查找<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h6 id="9、size-计算流程"><a href="#9、size-计算流程" class="headerlink" title="9、size 计算流程"></a>9、size 计算流程</h6><p>size 计算实际发生在 put，remove 改变集合元素的操作之中</p>
<ul>
<li>没有竞争发生，向 baseCount 累加计数</li>
<li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数<ul>
<li>counterCells 初始有两个 cell</li>
<li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells;</span><br><span class="line">    CounterCell a；</span><br><span class="line">        <span class="comment">// 将 baseCount 计数与所有 cell 计数累加</span></span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="10、总结"><a href="#10、总结" class="headerlink" title="10、总结"></a>10、总结</h6><p>Java 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p>
<ul>
<li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li>
<li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li>
<li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li>
<li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li>
<li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li>
<li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li>
</ul>
<h5 id="5、对比总结"><a href="#5、对比总结" class="headerlink" title="5、对比总结"></a>5、对比总结</h5><ul>
<li><code>HashTable</code>：使用了<code>synchronized</code>关键字对put等操作进行加锁；</li>
<li><code>ConcurrentHashMap JDK1.7</code>：使用<code>分段锁机制</code>实现；</li>
<li><code>ConcurrentHashMap JDK1.8</code>：则使用<code>数组+链表+红黑树数据结构和CAS原子操作</code>实现；</li>
</ul>
<h5 id="6、正确使用ConcurrentHashMap——computeIfAbsent-方法"><a href="#6、正确使用ConcurrentHashMap——computeIfAbsent-方法" class="headerlink" title="6、正确使用ConcurrentHashMap——computeIfAbsent()方法"></a>6、正确使用ConcurrentHashMap——computeIfAbsent()方法</h5><p>示例：单词计数</p>
<p>生成测试数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ALPHA = <span class="string">&quot;abcedfghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = ALPHA.length();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">200</span>;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(length * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = ALPHA.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(ch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">            <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tmp/&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;.txt&quot;</span>)))) &#123;</span><br><span class="line">            String collect = list.subList(i * count, (i + <span class="number">1</span>) * count).stream()</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">            out.print(collect);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模版代码，模版代码中封装了多线程读取文件的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String,V&gt;,List&lt;String&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, V&gt; counterMap = supplier.get();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; words = readFromFile(idx);</span><br><span class="line">            consumer.accept(counterMap, words);</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t-&gt;t.start());</span><br><span class="line">    ts.forEach(t-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(counterMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">readFromFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;tmp/&quot;</span> + i +<span class="string">&quot;.txt&quot;</span>)))) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String word = in.readLine(); <span class="keyword">if</span>(word == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            words.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你要做的是实现两个参数</p>
<ul>
<li>一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数</li>
<li>二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List</li>
</ul>
<p>正确结果输出应该是每个单词出现 200 次</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=200, b=200, c=200, d=200, e=200, f=200, g=200, h=200, i=200, j=200, k=200, l=200, m=200, n=200, o=200, p=200, q=200, r=200, s=200, t=200, u=200, v=200, w=200, x=200, y=200, z=200&#125; </span><br></pre></td></tr></table></figure>

<p>下面的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    <span class="comment">// 创建 map 集合</span></span><br><span class="line">    <span class="comment">// 创建 ConcurrentHashMap 对不对？</span></span><br><span class="line">    () -&gt; <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(),</span><br><span class="line">    <span class="comment">// 进行计数</span></span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            Integer counter = map.get(word);</span><br><span class="line">            <span class="keyword">int</span> newValue = counter == <span class="keyword">null</span> ? <span class="number">1</span> : counter + <span class="number">1</span>; </span><br><span class="line">            map.put(word, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>有没有问题？请改进</p>
<p>问题：使用HashMap，线程不安全</p>
<p>改进：使用ConcurrentHashMap替换HashMap</p>
<p>运行发现问题：就算加上了ConcurrentHashMap也不能保证线程安全</p>
<p>原因：原因不难发现，ConcurrentHashMap只是保证了单一操作的线程安全，但是单一线程的组合并不保证线程安全。我们可以发现：</p>
<ul>
<li><code>Integer counter = map.get(word);</code>：根据Key（word单词）获取Value（计数）——读操作</li>
<li><code>int newValue = counter == null ? 1 : counter + 1; map.put(word, newValue);</code><ul>
<li>如果Key（单词）存在，则计数加1</li>
<li>如果Key（单词）不存在，则计数为1</li>
<li>在将结果的Key与Value放入Map容器当中——写操作</li>
</ul>
</li>
</ul>
<p>虽然ConcurrentHashMap能保证单一的读操作或单一读操作的线程安全，但是读操作与写操作的组合并不能保证线程安全</p>
<ul>
<li><p>解决方法1：将读操作与写操作一起加入Synchronized(map)同步代码块当中</p>
<ul>
<li>缺点：锁的粒度太大，线程的效率降低</li>
</ul>
</li>
<li><p>解决方法2：使用ConcurrentHashMap的<code>computeIfAbsent()</code>方法</p>
<ul>
<li><p>注意：</p>
<ul>
<li>累加操作也是需要保证线程安全性，所以使用的是LongAdder累加器来完成累加操作</li>
<li> 注意不能使用 <code>putIfAbsent</code>，此方法返回的是上一次的 value，首次调用返回 null</li>
</ul>
</li>
<li><pre><code class="java">demo(
    // 创建 map 集合
    // 创建 ConcurrentHashMap 对不对？
    () -&gt; new ConcurrentHashMap&lt;String, LongAdder&gt;(8,0.75f,8),

    (map, words) -&gt; &#123;
        for (String word : words) &#123;

            // 如果缺少一个 key，则计算生成一个 value , 然后将  key value 放入 map
            //                  a      0
            LongAdder value = map.computeIfAbsent(word, (key) -&gt; new LongAdder());
            // 执行累加
            value.increment(); // 2

            /*// 检查 key 有没有
                        Integer counter = map.get(word);
                        int newValue = counter == null ? 1 : counter + 1;
                        // 没有 则 put
                        map.put(word, newValue);*/
        &#125;
    &#125;
);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解决方法3：使用函数式编程，无需原子变量——使用ConcurrentHashMap的merge方法</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    demo(</span><br><span class="line">        () -&gt; new ConcurrentHashMap&lt;String, Integer&gt;(),</span><br><span class="line">        (map, words) -&gt; &#123;</span><br><span class="line">            for (String word : words) &#123;</span><br><span class="line">                &#x2F;&#x2F; 函数式编程，无需原子变量</span><br><span class="line">                map.merge(word, 1, Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="7、JDK-7-HashMap-并发死链问题原理"><a href="#7、JDK-7-HashMap-并发死链问题原理" class="headerlink" title="7、JDK 7 HashMap 并发死链问题原理"></a>7、JDK 7 HashMap 并发死链问题原理</h5><h6 id="1、JDK-7-HashMap-并发死链问题"><a href="#1、JDK-7-HashMap-并发死链问题" class="headerlink" title="1、JDK 7 HashMap 并发死链问题"></a>1、JDK 7 HashMap 并发死链问题</h6><p>JDK 7 HashMap会出现死链问题的原因：JDK 7 HashMap的扩容数组的方法</p>
<ul>
<li>JDK 7 HashMap使用的是头插法进行扩容数组的（JDK 8 HashMap使用的是尾插法——“七上八下”）</li>
<li>在多线程下，就有可能出现死链问题<ul>
<li>实际上就是一个线程在扩容时把链表节点倒过来了，而另一个线程在扩容时正好也在前一个节点，就死循环了</li>
</ul>
</li>
</ul>
<p>下面使用一些测试代码和用debug的模式来验证JDK 7 HashMap 并发死链问题</p>
<p>注意：</p>
<ul>
<li>要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了</li>
<li>以下测试代码是精心准备的，不要随便改动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试 java 7 中哪些数字的 hash 结果相等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;长度为16时，桶下标为1的key&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">16</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;长度为32时，桶下标为1的key&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">32</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span></span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">// 放 12 个元素</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">16</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;扩容前大小[main]:&quot;</span>+map.size());</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、死链复现"><a href="#2、死链复现" class="headerlink" title="2、死链复现"></a>2、死链复现</h6><p>调试工具使用 idea</p>
<p>在 HashMap 源码 590 行加断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = newTable.length;</span><br></pre></td></tr></table></figure>

<p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newTable.length==<span class="number">32</span> &amp;&amp; </span><br><span class="line">    (</span><br><span class="line">    Thread.currentThread().getName().equals(<span class="string">&quot;Thread-0&quot;</span>)||     </span><br><span class="line">    Thread.currentThread().getName().equals(<span class="string">&quot;Thread-1&quot;</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行运行代码，程序在预料的断点位置停了下来，输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长度为16时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">16 </span><br><span class="line">35 </span><br><span class="line">50 </span><br><span class="line">长度为32时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">35 </span><br><span class="line">扩容前大小[main]:12 </span><br></pre></td></tr></table></figure>

<p>接下来进入扩容流程调试</p>
<p>在 HashMap 源码 594 行加断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next; <span class="comment">// 593 </span></span><br><span class="line"><span class="keyword">if</span> (rehash)              <span class="comment">// 594 </span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点，条件为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName().equals(<span class="string">&quot;Thread-0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这时可以在 Variables 面板观察到 e 和 next 变量，使用 <code>view as -&gt; Object</code> 查看节点状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e		(<span class="number">1</span>)-&gt;(<span class="number">35</span>)-&gt;(<span class="number">16</span>)-&gt;<span class="keyword">null</span></span><br><span class="line">next	(<span class="number">35</span>)-&gt;(<span class="number">16</span>)-&gt;<span class="keyword">null</span> </span><br></pre></td></tr></table></figure>

<p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>]  (<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="keyword">null</span> </span><br><span class="line">扩容后大小:<span class="number">13</span> </span><br></pre></td></tr></table></figure>

<p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e		(<span class="number">1</span>)-&gt;<span class="keyword">null</span></span><br><span class="line">next	(<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="keyword">null</span>  </span><br></pre></td></tr></table></figure>

<p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结果正确，但它结束后 Thread-0 还要继续运行</p>
<p>接下来就可以单步调试（F8）观察死链的产生了</p>
<p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>]		(<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="keyword">null</span> </span><br><span class="line">e			    (<span class="number">1</span>)-&gt;<span class="keyword">null</span></span><br><span class="line">next			(<span class="number">1</span>)-&gt;<span class="keyword">null</span> </span><br></pre></td></tr></table></figure>

<p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>]		(<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="keyword">null</span> </span><br><span class="line">e			    (<span class="number">1</span>)-&gt;<span class="keyword">null</span></span><br><span class="line">next			<span class="keyword">null</span> </span><br></pre></td></tr></table></figure>

<p>再看看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这时 e  (1,35)</span></span><br><span class="line"><span class="comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span></span><br><span class="line">newTable[<span class="number">1</span>] = e;  </span><br><span class="line"><span class="comment">// 再尝试将 e 作为链表头, 死链已成</span></span><br><span class="line">e = next;</span><br><span class="line"><span class="comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span></span><br></pre></td></tr></table></figure>

<h6 id="3、通过JDK-7-HashMap源码分析死链问题"><a href="#3、通过JDK-7-HashMap源码分析死链问题" class="headerlink" title="3、通过JDK 7 HashMap源码分析死链问题"></a>3、通过JDK 7 HashMap源码分析死链问题</h6><p>HashMap 的并发死链发生在扩容时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 table 迁移至 newTable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">            <span class="comment">// 1 处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 2 处</span></span><br><span class="line">            <span class="comment">// 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 </span></span><br><span class="line">            next e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 map 中初始元素是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原始链表，格式：[下标] (key,next)</span><br><span class="line">[1] (1,35)-&gt;(35,16)-&gt;(16,null)</span><br><span class="line">线程 a 执行到 1 处 ，此时局部变量 e 为 (1,35)，而局部变量 next 为 (35,16) 线程 a 挂起</span><br><span class="line">线程 b 开始执行</span><br><span class="line">第一次循环</span><br><span class="line">[1] (1,null)</span><br><span class="line">第二次循环</span><br><span class="line">[1] (35,1)-&gt;(1,null)</span><br><span class="line">第三次循环</span><br><span class="line">[1] (35,1)-&gt;(1,null)</span><br><span class="line">[17] (16,null)</span><br><span class="line">切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (1,null)，而 next 的内容被改为 (35,1) 并链向 (1,null)</span><br><span class="line">第一次循环</span><br><span class="line">[1] (1,null)</span><br><span class="line">第二次循环，注意这时 e 是  (35,1) 并链向 (1,null) 所以 next 又是 (1,null)</span><br><span class="line">[1] (35,1)-&gt;(1,null)</span><br><span class="line">第三次循环，e 是 (1,null)，而 next 是 null，但 e 被放入链表头，这样 e.next 变成了 35 （2 处）</span><br><span class="line">[1] (1,35)-&gt;(35,1)-&gt;(1,35)</span><br><span class="line">已经是死链了</span><br></pre></td></tr></table></figure>

<h6 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h6><ul>
<li>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合</li>
<li>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序）（尾插法），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</li>
</ul>
<h4 id="5、HashSet不安全"><a href="#5、HashSet不安全" class="headerlink" title="5、HashSet不安全"></a>5、HashSet不安全</h4><p>同理，HashSet在多线程的环境下也是不安全的。解决方法：JUC的<code>CopyOnWriteArraySet</code></p>
<p>CopyOnWriteArraySet：对其所有操作使用<strong>内部CopyOnWriteArrayList的Set</strong>。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。<strong>在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList</strong>。</p>
<h3 id="10、JUC并发集合：BlockingQueue接口（阻塞队列）"><a href="#10、JUC并发集合：BlockingQueue接口（阻塞队列）" class="headerlink" title="10、JUC并发集合：BlockingQueue接口（阻塞队列）"></a>10、JUC并发集合：BlockingQueue接口（阻塞队列）</h3><p>JUC里的 <code>BlockingQueue</code> 接口表示<strong>一个线程安全放入和提取实例的队列</strong>。下面将给你演示如何使用这个 BlockingQueue，不会讨论如何在 Java 中实现一个你自己的 BlockingQueue。</p>
<h4 id="1、BAT大厂的面试问题-13"><a href="#1、BAT大厂的面试问题-13" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>什么是BlockingDeque？</li>
<li>BlockingQueue大家族有哪些？<ul>
<li>ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue…</li>
</ul>
</li>
<li>BlockingQueue适合用在什么样的场景？</li>
<li>BlockingQueue常用的方法？</li>
<li>BlockingQueue插入方法有哪些？这些方法(<code>add(o)</code>,<code>offer(o)</code>,<code>put(o)</code>,<code>offer(o, timeout, timeunit)</code>)的区别是什么？</li>
<li>BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法？</li>
<li>BlockingDeque适合用在什么样的场景？</li>
<li>BlockingDeque大家族有哪些？</li>
<li>BlockingDeque 与BlockingQueue实现例子？</li>
</ul>
<h4 id="2、BlockingQueue和BlockingDeque"><a href="#2、BlockingQueue和BlockingDeque" class="headerlink" title="2、BlockingQueue和BlockingDeque"></a>2、BlockingQueue和BlockingDeque</h4><h5 id="1、BlockingQueue"><a href="#1、BlockingQueue" class="headerlink" title="1、BlockingQueue"></a>1、BlockingQueue</h5><h6 id="1、什么是BlockQueue？"><a href="#1、什么是BlockQueue？" class="headerlink" title="1、什么是BlockQueue？"></a>1、什么是BlockQueue？</h6><p><strong>BlockingQueue 通常用于==一个线程生产对象，而另外一个线程消费这些对象==的场景</strong>。下图是对这个原理的阐述：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-blocking-queue-1.png" alt="img"></p>
<p><strong>线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素。</strong></p>
<ul>
<li>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是<strong>有限的</strong>。</li>
<li>如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 </li>
<li>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</li>
</ul>
<h6 id="2、为什么需要BlockQueue？"><a href="#2、为什么需要BlockQueue？" class="headerlink" title="2、为什么需要BlockQueue？"></a>2、为什么需要BlockQueue？</h6><ul>
<li>好处是<strong>我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了</strong>；</li>
<li>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</li>
</ul>
<h6 id="3、适用场景——经典的“生产者”和-“消费者”模型"><a href="#3、适用场景——经典的“生产者”和-“消费者”模型" class="headerlink" title="3、适用场景——经典的“生产者”和 “消费者”模型"></a>3、适用场景——经典的“生产者”和 “消费者”模型</h6><p>在多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和 “消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。</p>
<p>假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。</p>
<p>但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。 </p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</li>
<li>队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</li>
</ul>
<h5 id="2、BlockingQueue的方法"><a href="#2、BlockingQueue的方法" class="headerlink" title="2、BlockingQueue的方法"></a>2、BlockingQueue的方法</h5><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>四组不同的行为方式解释：</p>
<ul>
<li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<p>BlockingQueue 的核心方法：</p>
<ul>
<li>放入数据<ol>
<li>offer(anObject)：表示如果可能的话，将 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。（<strong>本方法不阻塞当前执行方法的线程</strong>）</li>
<li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。</li>
<li>put(anObject)：把 anObject 加到 BlockingQueue 里，如果 BlockQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续。</li>
<li>add(anObject)：把 anObject 加到 BlockingQueue 里，如果 BlockQueue 没有空间，则调用此方法的线程抛出一个异常：Queue full。</li>
</ol>
</li>
<li>获取数据<ol>
<li>poll(time)：取走 BlockingQueue 里排在首位的对象，若不能立即取出，<strong>则可以等time 参数规定的时间，取不到时返回 null</strong>。</li>
<li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回null。</li>
<li>take()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>；</li>
<li>remove()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，抛出一个异常：<code>NoSuchElementException</code></li>
<li>drainTo()：一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定<br>获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ul>
<li><strong>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。</strong> </li>
<li>可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。</li>
<li>但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</li>
</ul>
<h5 id="3、BlockingDeque"><a href="#3、BlockingDeque" class="headerlink" title="3、BlockingDeque"></a>3、BlockingDeque</h5><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安全放入和提取实例的双端队列。</p>
<p>BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。 deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<p>使用情景：</p>
<ul>
<li><strong>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque</strong>。</li>
<li><strong>如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。</strong></li>
</ul>
<p>BlockingDeque 图解：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-blocking-deque-1.png" alt="img"></p>
<h5 id="4、BlockingDeque的方法"><a href="#4、BlockingDeque的方法" class="headerlink" title="4、BlockingDeque的方法"></a>4、BlockingDeque的方法</h5><p>一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。</p>
<p>BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>addLast(o)</td>
<td>offerLast(o)</td>
<td>putLast(o)</td>
<td>offerLast(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeLast(o)</td>
<td>pollLast(o)</td>
<td>takeLast(o)</td>
<td>pollLast(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getLast(o)</td>
<td>peekLast(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>四组不同的行为方式解释：</p>
<ul>
<li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<h5 id="5、BlockingQueue和BlockingDeque的关系"><a href="#5、BlockingQueue和BlockingDeque的关系" class="headerlink" title="5、BlockingQueue和BlockingDeque的关系"></a>5、BlockingQueue和BlockingDeque的关系</h5><p><strong>BlockingDeque 接口继承自 BlockingQueue 接口。</strong>这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。</p>
<p>以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现：</p>
<table>
<thead>
<tr>
<th>BlockingQueue</th>
<th>BlockingDeque</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>addLast()</td>
</tr>
<tr>
<td>offer() x 2</td>
<td>offerLast() x 2</td>
</tr>
<tr>
<td>put()</td>
<td>putLast()</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll() x 2</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>take()</td>
<td>takeFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<h4 id="3、BlockingQueue的例子"><a href="#3、BlockingQueue的例子" class="headerlink" title="3、BlockingQueue的例子"></a>3、BlockingQueue的例子</h4><p>这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 <code>ArrayBlockingQueue</code> 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 Producer 类。注意它在每次 put() 调用时是为何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、数组阻塞队列——ArrayBlockingQueue-（常用）"><a href="#1、数组阻塞队列——ArrayBlockingQueue-（常用）" class="headerlink" title="**1、数组阻塞队列——ArrayBlockingQueue**（常用）"></a>**1、数组阻塞队列——<code>ArrayBlockingQueue</code>**（常用）</h5><p>ArrayBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p><strong>ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里</strong>。</p>
<ul>
<li>有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。</li>
<li><strong>你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了</strong>(译者注: 因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 </li>
<li>ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</li>
<li><strong>除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置</strong>。</li>
</ul>
<p>ArrayBlockingQueue 与 LinkedBlockingQueue 的区别：</p>
<ul>
<li><p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，<strong>都是共用同一个锁对象</strong>，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；</p>
<ul>
<li>按照实现原理来分析，ArrayBlockingQueue 完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 ArrayBlockingQueue 的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 </li>
</ul>
</li>
<li><p>ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则<strong>会生成一个额外的Node 对象</strong>。</p>
<ul>
<li>这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC 的影响还是存在一定的区别。</li>
</ul>
</li>
<li><p>在创建 ArrayBlockingQueue 时，我们还可以控制对象的内部锁是否采用公平锁，<strong>默认采用非公平锁</strong>。 </p>
<p>以下是在使用  ArrayBlockingQueue 的时候对其初始化的一个示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Object object = queue.take();</span><br></pre></td></tr></table></figure>

<p>以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String string = queue.take();</span><br></pre></td></tr></table></figure>

<p>==一句话总结：ArrayBlockingQueue 是由数组结构组成的有界阻塞队列。== </p>
<h5 id="2、延迟队列——DelayQueue"><a href="#2、延迟队列——DelayQueue" class="headerlink" title="2、延迟队列——DelayQueue"></a>2、延迟队列——<code>DelayQueue</code></h5><p>DelayQueue 实现了 BlockingQueue 接口。</p>
<p><strong>DelayQueue 是一个没有大小限制的队列</strong>，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 </p>
<p>DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。<strong>如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take  被调用的时候被释放掉</strong>。</p>
<p>传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值：</p>
<ul>
<li>DAYS——天</li>
<li>HOURS——时</li>
<li>INUTES——分钟</li>
<li>SECONDS——秒</li>
<li>MILLISECONDS——毫秒</li>
<li>MICROSECONDS——微秒</li>
<li>NANOSECONDS——纳秒</li>
</ul>
<p>正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。 以下是使用 DelayQueue 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DelayQueue queue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">        Delayed element1 = <span class="keyword">new</span> DelayedElement();</span><br><span class="line">        queue.put(element1);</span><br><span class="line">        Delayed element2 = queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。</p>
<p>==一句话总结：使用优先级队列实现的延迟无界阻塞队列。==</p>
<h5 id="3、链阻塞队列——LinkedBlockingQueue-（常用）"><a href="#3、链阻塞队列——LinkedBlockingQueue-（常用）" class="headerlink" title="**3、链阻塞队列——LinkedBlockingQueue**（常用）"></a>**3、链阻塞队列——<code>LinkedBlockingQueue</code>**（常用）</h5><p>LinkedBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p><strong>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</strong></p>
<p><strong>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</strong> </p>
<p>LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 </p>
<p><strong>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</strong></p>
<p>以下是 LinkedBlockingQueue 的初始化和使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">bounded.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure>

<p>==一句话总结：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。== </p>
<h5 id="4、具有优先级的阻塞队列——PriorityBlockingQueue"><a href="#4、具有优先级的阻塞队列——PriorityBlockingQueue" class="headerlink" title="4、具有优先级的阻塞队列——PriorityBlockingQueue"></a>4、具有优先级的阻塞队列——<code>PriorityBlockingQueue</code></h5><p>PriorityBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p><strong>PriorityBlockingQueue 是一个基于优先级的无界的并发队列</strong>。（优先级的判断通过构造函数传入的 Compator 对象来决定）</p>
<p>它使用了和类 java.util.PriorityQueue 一样的排序规则。</p>
<ul>
<li>你无法向这个队列中插入 null 值。</li>
<li>所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。 </li>
</ul>
<p>注意：</p>
<ul>
<li><strong>PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。</strong></li>
<li><strong>如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。</strong> </li>
<li>由于PriorityBlockingQueue是无界的，所以<strong>PriorityBlockingQueue 并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。<ul>
<li>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong> </li>
</ul>
</li>
<li><strong>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是==公平锁==。</strong></li>
</ul>
<p>以下是使用 PriorityBlockingQueue 的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue queue   = <span class="keyword">new</span> PriorityBlockingQueue();</span><br><span class="line"><span class="comment">//String implements java.lang.Comparable</span></span><br><span class="line">queue.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line">String value = queue.take();</span><br></pre></td></tr></table></figure>

<p>==一句话总结：支持优先级排序的无界阻塞队列。==</p>
<h5 id="5、同步队列——SynchronousQueue"><a href="#5、同步队列——SynchronousQueue" class="headerlink" title="5、同步队列——SynchronousQueue"></a>5、同步队列——<code>SynchronousQueue</code></h5><p>SynchronousQueue 类实现了 BlockingQueue 接口。</p>
<p><strong>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素</strong>。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<p>声明一个 SynchronousQueue 有两种不同的方式——<strong>公平模式</strong>和<strong>非公平模式</strong>，它们之间有着不太一样的行为：</p>
<ul>
<li><strong>公平模式</strong>：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</li>
<li><strong>非公平模式（SynchronousQueue 默认）</strong>：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</li>
</ul>
<p>==一句话总结：不存储元素的阻塞队列，也即单个元素的队列。==</p>
<h5 id="6、链阻塞无界队列——LinkedTransferQueue"><a href="#6、链阻塞无界队列——LinkedTransferQueue" class="headerlink" title="6、链阻塞无界队列——LinkedTransferQueue"></a>6、链阻塞无界队列——<code>LinkedTransferQueue</code></h5><p><strong>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列</strong>。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和transfer 方法。</p>
<p>LinkedTransferQueue 采用一种<strong>预占模式</strong>。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。 </p>
<p>==一句话总结：由链表组成的无界阻塞队列。== </p>
<h4 id="4、BlockingDeque-的例子"><a href="#4、BlockingDeque-的例子" class="headerlink" title="4、BlockingDeque 的例子"></a>4、BlockingDeque 的例子</h4><p>既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类：<code>LinkedBlockingDeque</code>。</p>
<p>以下是如何使用 BlockingDeque 方法的一个简短代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>

<h5 id="链阻塞双端队列——LinkedBlockDeque"><a href="#链阻塞双端队列——LinkedBlockDeque" class="headerlink" title="链阻塞双端队列——LinkedBlockDeque"></a>链阻塞双端队列——<code>LinkedBlockDeque</code></h5><p>LinkedBlockingDeque 类实现了 BlockingDeque 接口。</p>
<p><strong>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。</strong> </p>
<p>deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<p>LinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。</p>
<p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住，该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况：</p>
<ul>
<li>插入元素时：如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常</li>
<li>读取元素时：如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</li>
</ul>
<p>以下是 LinkedBlockingDeque 实例化以及使用的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>

<p>==一句话总结：由链表组成的双向阻塞队列==</p>
<h3 id="11、JUC集合：LinkedBlockingQueue详解"><a href="#11、JUC集合：LinkedBlockingQueue详解" class="headerlink" title="11、JUC集合：LinkedBlockingQueue详解"></a>11、JUC集合：LinkedBlockingQueue详解</h3><h4 id="1、LinkedBlockingQueue-原理"><a href="#1、LinkedBlockingQueue-原理" class="headerlink" title="1、LinkedBlockingQueue 原理"></a>1、LinkedBlockingQueue 原理</h4><h5 id="1、基本的入队出队"><a href="#1、基本的入队出队" class="headerlink" title="1、基本的入队出队"></a>1、基本的入队出队</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *	下列三种情况之一</span></span><br><span class="line"><span class="comment">		*	- 真正的后继节点</span></span><br><span class="line"><span class="comment">		*	- 自己, 发生在出队时</span></span><br><span class="line"><span class="comment">		*	- null, 表示是没有后继节点, 是最后了*/</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化链表 <code>last = head = new Node&lt;E&gt;(null);</code> Dummy 节点用来占位，item 为 null</p>
<p><img src="/2021/07/19/JUC/image-20210814034851138.png" alt="image-20210814034851138"></p>
<p>当一个节点入队 <code>last = last.next = node;</code></p>
<p><img src="/2021/07/19/JUC/image-20210814034913187.png" alt="image-20210814034913187"></p>
<p>再来一个节点入队 <code>last = last.next = node;</code></p>
<p><img src="/2021/07/19/JUC/image-20210814034931731.png" alt="image-20210814034931731"></p>
<p>出队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h = head; </span><br><span class="line">Node&lt;E&gt; first = h.next; </span><br><span class="line">h.next = h; <span class="comment">// help GC head = first;</span></span><br><span class="line">E x = first.item; </span><br><span class="line">first.item = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>

<p><code>h = head</code></p>
<p><img src="/2021/07/19/JUC/image-20210814035037609.png" alt="image-20210814035037609"></p>
<p><code>first = h.next</code></p>
<p><img src="/2021/07/19/JUC/image-20210814035055942.png" alt="image-20210814035055942"></p>
<p><code>h.next = h</code></p>
<p><img src="/2021/07/19/JUC/image-20210814035113682.png" alt="image-20210814035113682"></p>
<p><code>head = first</code></p>
<p><img src="/2021/07/19/JUC/image-20210814035130035.png" alt="image-20210814035130035"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E x = first.item; </span><br><span class="line">first.item = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/image-20210814035147199.png" alt="image-20210814035147199"></p>
<h5 id="2、加锁分析"><a href="#2、加锁分析" class="headerlink" title="2、加锁分析"></a>2、加锁分析</h5><p>==高明之处==在于用了两把锁和 dummy 节点</p>
<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行（锁住的队列的头和尾）<ul>
<li>消费者与消费者线程仍然串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li>
<li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争<ul>
<li>这里就体现了dummy 占位节点的用处了：就算只剩下一个正常的结点，两把锁锁住的依旧是两个对象，没有竞争</li>
</ul>
</li>
<li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;     putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 满了等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 倒过来读就好: 等待 notFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位, 入队且计数加一</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();  </span><br><span class="line">        <span class="comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一个元素, 叫醒 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span></span><br><span class="line">    <span class="comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由 put 唤醒 put 是为了避免信号不足</p>
</blockquote>
<h4 id="2、性能比较"><a href="#2、性能比较" class="headerlink" title="2、性能比较"></a>2、性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p>
<ul>
<li>Linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Array 实现是数组</li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h3 id="12、JUC集合：ConcurrentLinkedQueue详解"><a href="#12、JUC集合：ConcurrentLinkedQueue详解" class="headerlink" title="12、JUC集合：ConcurrentLinkedQueue详解"></a>12、JUC集合：ConcurrentLinkedQueue详解</h3><ul>
<li><strong>一个基于链接节点的无界线程安全队列</strong>。此队列按照 ==FIFO(先进先出)原==则对元素进行排序。</li>
<li><strong>队列的头部是队列中时间最长的元素。队列的尾部是队列中时间最短的元素</strong>。</li>
<li><strong>新的元素插入到队列的尾部，队列获取操作从队列头部获得元素</strong>。</li>
<li>当<strong>多个线程共享访问一个公共 collection 时</strong>，ConcurrentLinkedQueue 是一个恰当的选择。</li>
<li><strong>此队列不允许使用 null 元素</strong>。</li>
</ul>
<p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p>
<ul>
<li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li>
<li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li>
<li>只是这【锁】使用了 cas 来实现</li>
</ul>
<p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的</p>
<p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p>
<p><img src="/2021/07/19/JUC/image-20210814043528344.png" alt="image-20210814043528344"></p>
<h4 id="1、BAT大厂的面试问题-14"><a href="#1、BAT大厂的面试问题-14" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>要想用线程安全的队列有哪些选择？<ul>
<li>Vector，<code>Collections.synchronizedList(List&lt;T&gt; list)</code>, ConcurrentLinkedQueue等</li>
</ul>
</li>
<li>ConcurrentLinkedQueue实现的数据结构？</li>
<li>ConcurrentLinkedQueue底层原理？<ul>
<li>全程无锁(CAS)</li>
</ul>
</li>
<li>ConcurrentLinkedQueue的核心方法有哪些？<ul>
<li>offer()，poll()，peek()，isEmpty()等队列常用方法</li>
</ul>
</li>
<li>说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计？</li>
<li>ConcurrentLinkedQueue适合什么样的使用场景？</li>
</ul>
<h4 id="2、ConcurrentLinkedQueue数据结构"><a href="#2、ConcurrentLinkedQueue数据结构" class="headerlink" title="2、ConcurrentLinkedQueue数据结构"></a>2、ConcurrentLinkedQueue数据结构</h4><p>通过源码分析可知，ConcurrentLinkedQueue的数据结构与LinkedBlockingQueue的数据结构相同，都是使用的链表结构。</p>
<p>ConcurrentLinkedQueue的数据结构如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-1.png" alt="img"></p>
<p>说明：ConcurrentLinkedQueue采用的链表结构，并且包含有一个头结点和一个尾结点。</p>
<h4 id="3、ConcurrentLinkedQueue源码分析"><a href="#3、ConcurrentLinkedQueue源码分析" class="headerlink" title="3、ConcurrentLinkedQueue源码分析"></a>3、ConcurrentLinkedQueue源码分析</h4><h5 id="1、类的继承关系-4"><a href="#1、类的继承关系-4" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：ConcurrentLinkedQueue继承了抽象类AbstractQueue，AbstractQueue定义了对队列的基本操作；同时实现了Queue接口，Queue定义了对队列的基本操作，同时，还实现了Serializable接口，表示可以被序列化。</p>
<h5 id="2、类的内部类-3"><a href="#2、类的内部类-3" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="comment">// next域</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class="line"><span class="comment">        * only be seen after publication via casNext.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        <span class="comment">// 设置item的值</span></span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并替换item值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置next域的值，并不会保证修改对其他线程立即可见</span></span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并替换next域的值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// item域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="comment">// next域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Node类表示链表结点，用于存放元素，包含item域和next域，item域表示元素，next域表示下一个结点，**其利用反射机制和CAS机制来更新item域和next域，==保证原子性==**。</p>
<h5 id="3、类的属性-1"><a href="#3、类的属性-1" class="headerlink" title="3、类的属性"></a>3、类的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">196745693267521676L</span>;</span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// head域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="comment">// tail域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentLinkedQueue.class;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：属性中包含了head域和tail域，表示链表的头结点和尾结点，同时，<strong>ConcurrentLinkedQueue也使用了反射机制和CAS机制来更新头结点和尾结点，==保证原子==性</strong>。</p>
<h5 id="4、-类的构造函数"><a href="#4、-类的构造函数" class="headerlink" title="4、 类的构造函数"></a>4、 类的构造函数</h5><ul>
<li><p><code>ConcurrentLinkedQueue()</code>型构造函数</p>
<ul>
<li><pre><code class="java">public ConcurrentLinkedQueue() &#123;
    // 初始化头结点与尾结点
    head = tail = new Node&lt;E&gt;(null);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：**该构造函数用于创建一个最初为空的 ConcurrentLinkedQueue，头结点与尾结点指向同一个结点，该结点的item域为null，next域也为null**。</span><br><span class="line"></span><br><span class="line">- &#96;ConcurrentLinkedQueue(Collection&lt;? extends E&gt;)&#96;型构造函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Node&lt;E&gt; h &#x3D; null, t &#x3D; null;</span><br><span class="line">        for (E e : c) &#123; &#x2F;&#x2F; 遍历c集合</span><br><span class="line">            &#x2F;&#x2F; 保证元素不为空</span><br><span class="line">            checkNotNull(e);</span><br><span class="line">            &#x2F;&#x2F; 新生一个结点</span><br><span class="line">            Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">            if (h &#x3D;&#x3D; null) &#x2F;&#x2F; 头结点为null</span><br><span class="line">                &#x2F;&#x2F; 赋值头结点与尾结点</span><br><span class="line">                h &#x3D; t &#x3D; newNode;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 直接头结点的next域</span><br><span class="line">                t.lazySetNext(newNode);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值头结点</span><br><span class="line">                t &#x3D; newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; null) &#x2F;&#x2F; 头结点为null</span><br><span class="line">            &#x2F;&#x2F; 新生头结点与尾结点</span><br><span class="line">            h &#x3D; t &#x3D; new Node&lt;E&gt;(null);</span><br><span class="line">        &#x2F;&#x2F; 赋值头结点</span><br><span class="line">        head &#x3D; h;</span><br><span class="line">        &#x2F;&#x2F; 赋值尾结点</span><br><span class="line">        tail &#x3D; t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：<strong>该构造函数用于创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素</strong>。</p>
</li>
</ul>
</li>
</ul>
<h5 id="5、核心函数分析"><a href="#5、核心函数分析" class="headerlink" title="5、核心函数分析"></a>5、核心函数分析</h5><h6 id="1、offer函数"><a href="#1、offer函数" class="headerlink" title="1、offer函数"></a>1、offer函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不为null</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 新生一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// q为p结点的下一个结点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123; <span class="comment">// q结点为null</span></span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123; <span class="comment">// 比较并进行替换p结点的next域</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// p不等于t结点，不一致    // hop two nodes at a time</span></span><br><span class="line">                    <span class="comment">// 比较并替换尾结点</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="comment">// 返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p结点等于q结点</span></span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            <span class="comment">// 原来的尾结点与现在的尾结点是否相等，若相等，则p赋值为head，否则，赋值为现在的尾结点</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            <span class="comment">// 重新赋值p结点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>offer函数用于将指定元素插入此队列的尾部</strong>。下面模拟offer函数的操作，队列状态的变化(假设单线程添加元素，连续添加10、20两个元素)。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-2.png" alt="img"></p>
<ul>
<li>若ConcurrentLinkedQueue的初始状态如上图所示，即队列为空。单线程添加元素，此时，添加元素10，则状态如下所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-3.png" alt="img"></li>
</ul>
</li>
<li>如上图所示，添加元素10后，tail没有变化，还是指向之前的结点，继续添加元素20，则状态如下所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png" alt="img"></li>
</ul>
</li>
<li>如上图所示，添加元素20后，tail指向了最新添加的结点。</li>
</ul>
<h6 id="2、poll函数"><a href="#2、poll函数" class="headerlink" title="2、poll函数"></a>2、poll函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123; <span class="comment">// 保存头结点</span></span><br><span class="line">            <span class="comment">// item项</span></span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123; <span class="comment">// item不为null并且比较并替换item成功</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// p不等于h    // hop two nodes at a time</span></span><br><span class="line">                    <span class="comment">// 更新头结点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p); </span><br><span class="line">                <span class="comment">// 返回item</span></span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// q结点为null</span></span><br><span class="line">                <span class="comment">// 更新头结点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p等于q</span></span><br><span class="line">                <span class="comment">// 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// p赋值为q</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>此函数用于获取并移除此队列的头</strong>，如果此队列为空，则返回null。下面模拟poll函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，poll两次)。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png" alt="img"></p>
<ul>
<li>队列初始状态如上图所示，在poll操作后，队列的状态如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-6.png" alt="img"></li>
</ul>
</li>
<li>如上图可知，poll操作后，head改变了，并且head所指向的结点的item变为了null。再进行一次poll操作，队列的状态如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-7.png" alt="img"></li>
</ul>
</li>
<li>如上图可知，poll操作后，head结点没有变化，只是指示的结点的item域变成了null。</li>
</ul>
<h6 id="3、remove函数"><a href="#3、remove函数" class="headerlink" title="3、remove函数"></a>3、remove函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素为null，返回</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123; <span class="comment">// 获取第一个存活的结点</span></span><br><span class="line">        <span class="comment">// 第一个存活结点的item值</span></span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>)) &#123; <span class="comment">// 找到item相等的结点，并且将该结点的item设置为null</span></span><br><span class="line">            <span class="comment">// p的后继结点</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) <span class="comment">// pred不为null并且next不为null</span></span><br><span class="line">                <span class="comment">// 比较并替换next域</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pred赋值为p</span></span><br><span class="line">        pred = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：**此函数用于从队列中移除指定元素的单个实例(如果存在)**。其中，会调用到first函数和succ函数，first函数的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保成功</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="comment">// p结点的item域是否为null</span></span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// item不为null或者next域为null</span></span><br><span class="line">                <span class="comment">// 更新头结点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="comment">// 返回结点</span></span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p等于q</span></span><br><span class="line">                <span class="comment">// 继续从头结点开始</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// p赋值为q</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>first函数用于找到链表中第一个存活的结点</strong>。succ函数源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p结点的next域</span></span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    <span class="comment">// 如果next域为自身，则返回头结点，否则，返回next</span></span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>succ用于获取结点的下一个结点。如果结点的next域指向自身，则返回head头结点，否则，返回next结点。</strong></p>
<p>下面模拟remove函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，执行remove(10)、remove(20)操作)。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-4.png" alt="img"></p>
<ul>
<li>如上图所示，为ConcurrentLinkedQueue的初始状态，remove(10)后的状态如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-9.png" alt="img"></li>
</ul>
</li>
<li>如上图所示，当执行remove(10)后，head指向了head结点之前指向的结点的下一个结点，并且head结点的item域置为null。继续执行remove(20)，状态如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-juc-concurrentlinkedqueue-10.png" alt="img"></li>
</ul>
</li>
<li>如上图所示，执行remove(20)后，head与tail指向同一个结点，item域为null。</li>
</ul>
<h6 id="4、size函数"><a href="#4、size函数" class="headerlink" title="4、size函数"></a>4、size函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) <span class="comment">// 从第一个存活的结点开始往后遍历</span></span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>) <span class="comment">// 结点的item域不为null</span></span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE) <span class="comment">// 增加计数，若达到最大值，则跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 返回大小</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>此函数用于返回ConcurrenLinkedQueue的大小，从第一个存活的结点(first)开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小</strong>。</p>
<h4 id="4、ConcurrentLinkedQueue示例"><a href="#4、ConcurrentLinkedQueue示例" class="headerlink" title="4、ConcurrentLinkedQueue示例"></a>4、ConcurrentLinkedQueue示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Integer&gt; clq;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(ConcurrentLinkedQueue&lt;Integer&gt; clq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clq = clq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;add &quot;</span> + i);</span><br><span class="line">                clq.add(i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Integer&gt; clq;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(ConcurrentLinkedQueue&lt;Integer&gt; clq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clq = clq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;poll &quot;</span> + clq.poll());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentLinkedQueue&lt;Integer&gt; clq = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Integer&gt;();</span><br><span class="line">        PutThread p1 = <span class="keyword">new</span> PutThread(clq);</span><br><span class="line">        GetThread g1 = <span class="keyword">new</span> GetThread(clq);</span><br><span class="line">        </span><br><span class="line">        p1.start();</span><br><span class="line">        g1.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">add 0</span><br><span class="line">poll null</span><br><span class="line">add 1</span><br><span class="line">poll 0</span><br><span class="line">add 2</span><br><span class="line">poll 1</span><br><span class="line">add 3</span><br><span class="line">poll 2</span><br><span class="line">add 4</span><br><span class="line">poll 3</span><br><span class="line">add 5</span><br><span class="line">poll 4</span><br><span class="line">poll 5</span><br><span class="line">add 6</span><br><span class="line">add 7</span><br><span class="line">poll 6</span><br><span class="line">poll 7</span><br><span class="line">add 8</span><br><span class="line">add 9</span><br><span class="line">poll 8</span><br></pre></td></tr></table></figure>

<p>说明：<strong>GetThread线程不会因为ConcurrentLinkedQueue队列为空而等待，而是直接返回null，所以当实现队列不空时，等待时，则需要用户自己实现等待逻辑</strong>。</p>
<h4 id="5、再深入理解"><a href="#5、再深入理解" class="headerlink" title="5、再深入理解"></a>5、再深入理解</h4><h5 id="1、HOPS（延迟更新的策略）的设计"><a href="#1、HOPS（延迟更新的策略）的设计" class="headerlink" title="1、HOPS（延迟更新的策略）的设计"></a>1、HOPS（延迟更新的策略）的设计</h5><p>通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p>
<ul>
<li><code>tail更新触发时机</code>：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。</li>
<li><code>head更新触发时机</code>：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</li>
</ul>
<p>并且在更新操作时，源码中会有注释为：<code>hop two nodes at a time</code>。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个(猜的 😃)，从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢?</p>
<p>如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，<strong>如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率</strong>，所以doug lea大师<strong>每间隔1次(tail和队尾节点的距离为1)进行才利用CAS更新tail</strong>。对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。</p>
<h5 id="2、ConcurrentLinkedQueue适合的场景"><a href="#2、ConcurrentLinkedQueue适合的场景" class="headerlink" title="2、ConcurrentLinkedQueue适合的场景"></a>2、ConcurrentLinkedQueue适合的场景</h5><p>ConcurrentLinkedQueue通过无锁来做到了更高的并发量，是个高性能的队列，但是使用场景相对不如阻塞队列常见，毕竟取数据也要不停的去循环，不如阻塞的逻辑好设计，但是<strong>在并发量特别大的情况下，是个不错的选择，性能上好很多</strong>，而且这个队列的设计也是特别费力，尤其的使用的改良算法和对哨兵的处理。整体的思路都是比较严谨的，<strong>这个也是使用了无锁造成的，我们自己使用无锁的条件的话，这个队列是个不错的参考</strong>。</p>
<h3 id="13、多线程锁"><a href="#13、多线程锁" class="headerlink" title="13、多线程锁"></a>13、多线程锁</h3><h4 id="1、公平锁与非公平锁"><a href="#1、公平锁与非公平锁" class="headerlink" title="1、公平锁与非公平锁"></a>1、公平锁与非公平锁</h4><h5 id="1、公平锁"><a href="#1、公平锁" class="headerlink" title="1、公平锁"></a>1、公平锁</h5><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<ul>
<li>优点：所有的线程都能得到资源，不会饿死在队列中。</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
<h5 id="2、非公平锁"><a href="#2、非公平锁" class="headerlink" title="2、非公平锁"></a>2、非公平锁</h5><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
<h5 id="3、公平锁与非公平锁"><a href="#3、公平锁与非公平锁" class="headerlink" title="3、公平锁与非公平锁"></a>3、公平锁与非公平锁</h5><p>公平和非公平都是排序队列的，但是公平的新创建的线程会排到所有的就绪队列之后，非公平的线程会和就绪队列直接竞争资源，也就是插队。</p>
<p>举个去KFC吃饭的例子（来自敖丙dalao的例子）</p>
<ul>
<li>现在是早餐时间，敖丙想去kfc搞个早餐，发现有很多人了，一过去没多想，就乖乖到队尾排队，这样大家都觉得很公平，先到先得，所以这是公平锁咯。<ul>
<li><img src="/2021/07/19/JUC/v2-ede1b517df68a503291c48f7405bdc0b_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>那非公平锁就是，敖丙过去买早餐，发现大家都在排队，但是敖丙这个人有点渣的，就是喜欢插队，那他就直接怼到第一位那去，后面的鸡蛋，米豆都不行，我插队也不敢说什么，只能默默忍受了。<ul>
<li><img src="/2021/07/19/JUC/v2-76e9a9a9dfb5b14660b6b96367fa5f3f_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>但是偶尔，鸡蛋也会崛起，叫我滚到后面排队，我也是欺软怕硬，默默到后面排队，就插队失败了。<ul>
<li><img src="/2021/07/19/JUC/v2-3377fd02f2c0b65304c7449b33a3c112_1440w.jpg" alt="img"></li>
</ul>
</li>
</ul>
<h5 id="4、公平锁与非公平锁的实现——ReentrantLock（具体看一看上文的ReentrantLock）"><a href="#4、公平锁与非公平锁的实现——ReentrantLock（具体看一看上文的ReentrantLock）" class="headerlink" title="4、公平锁与非公平锁的实现——ReentrantLock（具体看一看上文的ReentrantLock）"></a>4、公平锁与非公平锁的实现——ReentrantLock（具体看一看上文的ReentrantLock）</h5><p>在上文中介绍了ReentrantLock类，以及ReentrantLock类的三个内部类——<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code>。</p>
<p>其中NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。</p>
<p>而NonfairSync实现的就是非公平锁（ReentrantLock的默认实现），FairSync实现的就是公平锁。</p>
<p>公平锁：（FairSync源码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 尝试公平获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 状态为0</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 不存在已经等待更久的线程并且比较并且设置状态成功</span></span><br><span class="line">                <span class="comment">// 设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 状态不为0，即资源已经被线程占据</span></span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 超过了int的表示范围</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>仔细看FairSync的源码就能发现，它加了一个<code>hasQueuedPredecessors</code>的判断，那他判断里面有些什么玩意呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span>  <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initia Lized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="comment">//其实这个赋值顺序也是很有讲究的，倒过来有可能会导致空指针</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initia Lization orde r</span></span><br><span class="line">    Nodeh = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">        <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> | s. thread != Thread. currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的大概意思也是<strong>判断当前的线程是不是位于同步队列的首位</strong>，是就是返回true，否就返回false。</p>
<p>非公平锁：（NonfairSync源码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得锁</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 比较并设置状态成功，状态0表示锁没有被占用</span></span><br><span class="line">           <span class="comment">// 把当前线程设置独占了锁</span></span><br><span class="line">           setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">// 锁已经被占用，或者set失败</span></span><br><span class="line">           <span class="comment">// 以独占模式获取对象，忽略中断</span></span><br><span class="line">           acquire(<span class="number">1</span>); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。</p>
<h5 id="5、公平锁与非公平锁的实现过程"><a href="#5、公平锁与非公平锁的实现过程" class="headerlink" title="5、公平锁与非公平锁的实现过程"></a>5、公平锁与非公平锁的实现过程</h5><p>非公平锁：</p>
<ul>
<li>A线程准备进去获取锁，首先判断了一下state状态，发现是0，所以可以CAS成功，并且修改了当前持有锁的线程为自己。<ul>
<li><img src="/2021/07/19/JUC/v2-e95055fb06912adbd0f13e2d9b3e128a_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>这个时候B线程也过来了，也是一上来先去判断了一下state状态，发现是1，那就CAS失败了，真晦气，只能乖乖去等待队列，等着唤醒了，先去睡一觉吧。<ul>
<li><img src="/2021/07/19/JUC/v2-a55d05b65f58984e5632b4ab18c7fcb8_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>A持有久了，也有点腻了，准备释放掉锁，给别的仔一个机会，所以改了state状态，抹掉了持有锁线程的痕迹，准备去叫醒B。<ul>
<li><img src="/2021/07/19/JUC/v2-9b55c499d1d012e56bb124d52ad6b469_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>这个时候有个带绿帽子的仔C过来了，发现state怎么是0啊，果断CAS修改为1，还修改了当前持有锁的线程为自己。</li>
<li>B线程被A叫醒准备去获取锁，发现state居然是1，CAS就失败了，只能失落的继续回去等待队列，路线还不忘骂A渣男，怎么骗自己，欺骗我的感情。<ul>
<li><img src="/2021/07/19/JUC/v2-c2109ccde8193517f686d1aeda955eca_1440w.jpg" alt="img"></li>
</ul>
</li>
</ul>
<p>以上就是一个非公平锁的线程，这样的情况就有可能像B这样的线程长时间无法得到资源，优点就是可能有的线程减少了等待时间，提高了利用率。</p>
<p>公平锁：</p>
<ul>
<li>线A现在想要获得锁，先去判断下state，发现也是0，去看了看队列，自己居然是第一位，果断修改了持有线程为自己。<ul>
<li><img src="/2021/07/19/JUC/v2-dcdc7a00cf64cdb961063b19a2fd12dc_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>线程B过来了，去判断一下state，嗯哼？居然是state=1，那cas就失败了呀，所以只能乖乖去排队了。<ul>
<li><img src="/2021/07/19/JUC/v2-89e7b1f27f62fd035173ed87c4046f7e_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>线程A暖男来了，持有没多久就释放了，改掉了所有的状态就去唤醒线程B了，这个时候线程C进来了，但是他先判断了下state发现是0，以为有戏，然后去看了看队列，发现前面有人了，作为新时代的良好市民，果断排队去了。<ul>
<li><img src="/2021/07/19/JUC/v2-7a280921de91d6d5d89f027ec4faa3b3_1440w.jpg" alt="img"></li>
</ul>
</li>
<li>线程B得到A的召唤，去判断state了，发现值为0，自己也是队列的第一位，那很香呀，可以得到了。<ul>
<li><img src="/2021/07/19/JUC/v2-84816ac8172eeb9519bd783334a99815_1440w.jpg" alt="img"></li>
</ul>
</li>
</ul>
<p>以上就是一个公平锁的线程，这样的情况就不会出现线程长时间无法得到资源，缺点就是要判断当前的等待队列是否有线程在等待，花费的开销较大，效率不行。</p>
<h5 id="6、深入：公平锁真的公平吗？"><a href="#6、深入：公平锁真的公平吗？" class="headerlink" title="6、深入：公平锁真的公平吗？"></a>6、深入：公平锁真的公平吗？</h5><p>公平锁相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">     <span class="keyword">int</span> c = getState();</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">             compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">     	<span class="comment">//重入锁的代码</span></span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//其实这个赋值顺序也是很有讲究的，倒过来有可能会导致空指针</span></span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Node t = tail;</span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">         	<span class="comment">//初始化</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))......①</span><br><span class="line">                 tail = head;........................②</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             node.prev = t;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                 t.next = node;</span><br><span class="line">                 <span class="keyword">return</span> t;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情景：假设当前有三个线程<code>A、B、C</code>，分别取调用公平锁的lock.lock()</p>
<ul>
<li>假设线程<code>A</code>一马当先，先获取到锁，此时<code>state == 1</code>。然后线程<code>B</code>，也来到了<code>tryAcquire</code>方法<ul>
<li>公平锁与非公平锁的区别就是在<code>tryAcquire</code>中会判断是否有先驱节点，也就是方法<code>hasQueuedPredecessors</code></li>
</ul>
</li>
<li>此时<code>tail</code>和<code>head</code>都<code>null</code>，所以肯定方法<code>hasQueuedPredecessors</code>返回<code>false</code></li>
<li>线程<code>B</code>回到<code>tryAcquire</code>中执行<code>cas_state</code>方法，由于<code>A</code>还没有释放锁，所以肯定获取不到，最终返回<code>false</code>，需要加入同步队列。在<code>addWaiter</code>中，由于<code>tail == null</code> 直接进入<code>enq</code>方法。</li>
<li>①和②便是重点。</li>
</ul>
<h6 id="情景1："><a href="#情景1：" class="headerlink" title="情景1："></a>情景1：</h6><ul>
<li><p>当线程<code>B</code>执行到①，此时<code>head</code>有值，但是<code>tail</code>还是为<code>null</code></p>
</li>
<li><p>此时线程<code>C</code>也执行到<code>hasQueuedPredecessors</code></p>
</li>
<li><pre><code class="java">Node t = null;
Node h = new Node();
此时 h != t &amp;&amp; ((s = h.next) == null)  为true
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因此线程&#96;C&#96;不能插队，也要加入等待队列。</span><br><span class="line"></span><br><span class="line">###### 情景2：</span><br><span class="line"></span><br><span class="line">- 当线程&#96;B&#96;执行到②，此时&#96;head&#96;有值，且&#96;head &#x3D;&#x3D; tail&#96;</span><br><span class="line"></span><br><span class="line">- 此时线程&#96;C&#96;也执行到&#96;hasQueuedPredecessors&#96;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  Node t &#x3D; h</span><br><span class="line">  此时 h !&#x3D; t 为false 短路直接返回</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>因此线程<code>C</code>可以插队，去执行<code>cas_state</code>方法<br>假设在执行<code>cas</code>方法之前，线程<code>A</code>已经释放了锁，那么线程<code>C</code>就可以插队，先于<code>B</code>抢到锁。</p>
<h6 id="关于公平锁源码中hasQueuedPredecessors-方法中tail和head赋值顺序问题"><a href="#关于公平锁源码中hasQueuedPredecessors-方法中tail和head赋值顺序问题" class="headerlink" title="关于公平锁源码中hasQueuedPredecessors()方法中tail和head赋值顺序问题"></a>关于公平锁源码中hasQueuedPredecessors()方法中tail和head赋值顺序问题</h6><p>如果<code>head</code>先于<code>tail</code>赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">//如果此时head还没有初始化，获得的是null，赋值完后失去时间片</span></span><br><span class="line">    Node t = tail; <span class="comment">//此时head完成初始化，且tail != null</span></span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// h != t 成立 没有短路</span></span><br><span class="line">    	<span class="comment">//h == null 因此h.next会产生NPE</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><strong>ReentrantLock中的公平锁只有在等待队列中存在等待节点（不包括虚节点）的时候，才是真正意义上的公平锁。</strong></p>
<h4 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h4><h5 id="1、什么是重入锁"><a href="#1、什么是重入锁" class="headerlink" title="1、什么是重入锁"></a>1、什么是重入锁</h5><p>通常情况下，锁可以用来控制多线程的访问行为。那对于同一个线程，如果连续两次对同一把锁进行lock，会怎么样了？</p>
<p>对于一般的锁来说，这个线程就会被永远卡死在那边，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    lock();  <span class="comment">//和上一个lock()操作同一个锁对象，那么这里就永远等待了</span></span><br><span class="line">    unlock();</span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个特性相当不好用，因为在实际的开发过程中，函数之间的调用关系可能错综复杂，一个不小心就可能在多个不同的函数中，反复调用lock()，这样的话，线程就自己和自己卡死了。</p>
<p>所以，对于希望傻瓜式编程的我们来说，重入锁就是用来解决这个问题的。<strong>重入锁使得同一个线程可以对同一把锁，在不释放的前提下，反复加锁，而不会导致线程卡死</strong>。因此，如果我们使用的是重入锁，那么上述代码就可以正常工作。<strong>你唯一需要保证的，就是unlock()的次数和lock()一样多</strong>（否则会造成死锁）。</p>
<p><img src="/2021/07/19/JUC/image-20210723031848803.png" alt="image-20210723031848803"></p>
<h5 id="2、重入锁的实现原理"><a href="#2、重入锁的实现原理" class="headerlink" title="2、重入锁的实现原理"></a>2、重入锁的实现原理</h5><p>java当中的重入锁——Lock接口的实现类ReentrantLock。其中最重要的方法——lock()</p>
<p>重入锁内部实现的主要类如下图：</p>
<p><img src="/2021/07/19/JUC/image-2.jpg" alt="图片"></p>
<p><strong>重入锁的核心功能委托给内部类Sync实现</strong>，并且根据是否是公平锁有FairSync和NonfairSync两种实现。这是一种典型的策略模式。</p>
<p><strong>实现重入锁的方法很简单，就是基于一个状态变量state。这个变量保存在<code>AbstractQueuedSynchronizer</code>（AQS）对象中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>当这个<code>state==0</code>时，表示锁是空闲的，大于零表示锁已经被占用， <strong>它的数值表示当前线程重复占用这个锁的次数</strong>。因此，lock()的最简单的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// compareAndSetState就是对state进行CAS操作，如果修改成功就占用锁</span></span><br><span class="line"> <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">     setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="comment">//如果修改不成功，说明别的线程已经使用了这个锁，那么就可能需要等待</span></span><br><span class="line">     acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是acquire()  的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//tryAcquire() 再次尝试获取锁，</span></span><br><span class="line"> <span class="comment">//如果发现锁就是当前线程占用的，则更新state，表示重复占用的次数，</span></span><br><span class="line"> <span class="comment">//同时宣布获得锁成功,这正是重入的关键所在</span></span><br><span class="line"> <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">     <span class="comment">// 如果获取失败，那么就在这里入队等待</span></span><br><span class="line">     acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">     <span class="comment">//如果在等待过程中 被中断了，那么重新把中断标志位设置上</span></span><br><span class="line">     selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、公平的重入锁与非公平的重入锁"><a href="#3、公平的重入锁与非公平的重入锁" class="headerlink" title="3、公平的重入锁与非公平的重入锁"></a>3、公平的重入锁与非公平的重入锁</h5><p><strong>默认情况下，重入锁是不公平的。</strong></p>
<p>那公平锁和非公平锁实现的核心区别在哪里呢？</p>
<ul>
<li><p>对于lock()方法代码：</p>
<ul>
<li><pre><code class="java">//非公平锁 
 final void lock() &#123;
     //上来不管三七二十一，直接抢了再说
     if (compareAndSetState(0, 1))
         setExclusiveOwnerThread(Thread.currentThread());
     else
         //抢不到，就进队列慢慢等着
         acquire(1);
 &#125;

 //公平锁
 final void lock() &#123;
     //直接进队列等着
     acquire(1);
 &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 从上面的代码中也不难看到，非公平锁如果第一次争抢失败，后面的处理和公平锁是一样的，都是进入等待队列慢慢等。</span><br><span class="line"></span><br><span class="line">- 对于tryLock()方法代码：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;非公平锁 </span><br><span class="line">     final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">          final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">          int c &#x3D; getState();</span><br><span class="line">          if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">              &#x2F;&#x2F;上来不管三七二十一，直接抢了再说</span><br><span class="line">              if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;如果就是当前线程占用了锁，那么就更新一下state，表示重复占用锁的次数</span><br><span class="line">          &#x2F;&#x2F;这是“重入”的关键所在</span><br><span class="line">          else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">              &#x2F;&#x2F;我又来了哦~~~（重入）</span><br><span class="line">              int nextc &#x3D; c + acquires;</span><br><span class="line">              if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">                  throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;公平锁</span><br><span class="line">     protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">         final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">         int c &#x3D; getState();</span><br><span class="line">         if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F;先看看有没有别人在等，没有人等我才会去抢，有人在我前面 ，我就不抢啦</span><br><span class="line">             if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                 compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                 setExclusiveOwnerThread(current);</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">             int nextc &#x3D; c + acquires;</span><br><span class="line">             if (nextc &lt; 0)</span><br><span class="line">                 throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">             setState(nextc);</span><br><span class="line">             return true;</span><br><span class="line">         &#125;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="4、Condition"><a href="#4、Condition" class="headerlink" title="4、Condition"></a>4、Condition</h5><p><code>Condition</code>可以理解为重入锁的伴生对象。<strong>它提供了在重入锁的基础上，进行等待和通知的机制</strong>。可以使用 newCondition()方法生成一个Condition对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>那Condition对象怎么用呢？在JDK内部就有一个很好的例子。让我们来看一下<code>ArrayBlockingQueue</code>吧。</p>
<p>ArrayBlockingQueue是一个队列，你可以把元素塞入队列(enqueue)，也可以拿出来take()。但是有一个小小的条件，就是如果队列是空的，那么take()就需要等待，一直等到有元素了，再返回。</p>
<p>那这个功能，怎么实现呢？这就可以使用Condition对象了。</p>
<p>实际在ArrayBlockingQueue中，就维护一个Condition对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">notEmpty = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>这个notEmpty 就是一个Condition对象。<strong>它用来通知其他线程，ArrayBlockingQueue是不是空着的</strong>。当我们需要拿出一个元素时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果队列长度为0，那么就在notEmpty condition上等待了，一直等到有元素进来为止</span></span><br><span class="line">            <span class="comment">// 注意，await()方法，一定是要先获得condition伴生的那个lock，才可以使用。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">//一旦有人通知我队列里有东西了，我就弹出一个返回</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有元素入队时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     <span class="comment">//先拿到锁，拿到锁才能操作对应的Condition对象</span></span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (count == items.length)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//入队了， 在这个函数里，就会进行notEmpty的通知，通知相关线程，有数据准备好了</span></span><br><span class="line">             enqueue(e);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//释放锁了，等着的那个线程，现在可以去弹出一个元素试试了</span></span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="comment">//元素已经放好了，通知那个等着拿东西的人吧</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>因此，整个流程如图所示：</p>
<p><img src="/2021/07/19/JUC/image-3.jpg" alt="图片"></p>
<h5 id="5、显示重入锁（lock）与隐式重入锁（Synchronized）"><a href="#5、显示重入锁（lock）与隐式重入锁（Synchronized）" class="headerlink" title="5、显示重入锁（lock）与隐式重入锁（Synchronized）"></a>5、显示重入锁（<code>lock</code>）与隐式重入锁（<code>Synchronized</code>）</h5><ul>
<li>显示重入锁（<code>lock</code>）：需要手动的上锁与释放锁的重入锁<ul>
<li>如上文所说，lock的ReentrantLock就是显示重入锁</li>
</ul>
</li>
<li>隐式重入锁（<code>Synchronized</code>）：自动的上锁与释放锁的重入锁<ul>
<li>Synchronized的上锁与释放锁是由JVM自动控制的</li>
</ul>
</li>
</ul>
<h5 id="6、重入锁的使用示例"><a href="#6、重入锁的使用示例" class="headerlink" title="6、重入锁的使用示例"></a>6、重入锁的使用示例</h5><p>使用重入锁，实现一个简单的计数器。这个计数器可以保证在多线程环境中，统计数据的精确性，请看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问count时，需要加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取数据也需要加锁，才能保证数据的可见性</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、可重入锁总结"><a href="#7、可重入锁总结" class="headerlink" title="7、可重入锁总结"></a>7、可重入锁总结</h5><ul>
<li>显示重入锁（<code>lock</code>）与隐式重入锁（<code>Synchronized</code>）</li>
<li>对于同一个线程，重入锁允许你反复获得通一把锁，但是，申请和释放锁的次数必须一致。</li>
<li>默认情况下，重入锁是非公平的，公平的重入锁性能差于非公平锁</li>
<li>重入锁的内部实现是基于CAS操作的</li>
<li>重入锁的伴生对象Condition提供了await()和singal()的功能，可以用于线程间消息通信</li>
<li>如果是不可重入锁的话，第一个锁没有解锁就不能操作第二个锁的内容</li>
</ul>
<h4 id="3、死锁"><a href="#3、死锁" class="headerlink" title="3、死锁"></a>3、死锁</h4><h5 id="1、什么是死锁"><a href="#1、什么是死锁" class="headerlink" title="1、什么是死锁"></a>1、什么是死锁</h5><p>两个或多个进程在运行过程中，因争夺资源而造成的一种相互等待的现象，当进程处于这种相互等待的状态时，若无外力作用，它们都将无法再向前推进。</p>
<p><img src="/2021/07/19/JUC/image-20210723034133100.png" alt="image-20210723034133100"></p>
<h5 id="2、产生死锁的三大原因"><a href="#2、产生死锁的三大原因" class="headerlink" title="2、产生死锁的三大原因"></a>2、产生死锁的三大原因</h5><ol>
<li>竞争可消耗资源</li>
<li>竞争不可抢占资源<ul>
<li>系统中的资源可以分为两类：<ul>
<li>可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
<li>还有一种资源：临时资源。<ul>
<li>包括硬件中断、信号、消息、缓冲区内的消息等</li>
<li>它可以是可剥夺资源，也可以是不可剥夺资源</li>
</ul>
</li>
</ul>
</li>
<li>产生死锁中的竞争资源指的是竞争<strong>不可剥夺资源的临时资源</strong></li>
</ul>
</li>
<li>进程运行推进顺序不当<ul>
<li>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</li>
<li>当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li>
</ul>
</li>
</ol>
<h5 id="3、产生死锁的四大条件"><a href="#3、产生死锁的四大条件" class="headerlink" title="3、产生死锁的四大条件"></a>3、产生死锁的四大条件</h5><p>产生死锁的必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li><strong>循环等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。</li>
</ol>
<h5 id="4、验证是否发生死锁的方法"><a href="#4、验证是否发生死锁的方法" class="headerlink" title="4、验证是否发生死锁的方法"></a>4、验证是否发生死锁的方法</h5><ul>
<li>jps<ul>
<li>类似linux的ps -ef</li>
</ul>
</li>
<li>jstack<ul>
<li>jvm自带的堆栈跟踪工具</li>
</ul>
</li>
<li>JConsole等工具</li>
</ul>
<h5 id="5、解决死锁的方法"><a href="#5、解决死锁的方法" class="headerlink" title="5、解决死锁的方法"></a>5、解决死锁的方法</h5><p>处理死锁的方法可归结为四种：</p>
<ul>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ul>
<h6 id="1、预防死锁"><a href="#1、预防死锁" class="headerlink" title="1、预防死锁"></a>1、预防死锁</h6><p>预防死锁：通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁的方法</p>
<ul>
<li>破坏“请求和条件”：<ul>
<li>必须一次性申请其在整个运行过程中所需的全部资源<ul>
<li>优点：简单、易行且安全</li>
<li>缺点：<ul>
<li>资源被严重浪费，严重地恶化资源的利用率</li>
<li>使进程经常会发生饥饿现象</li>
</ul>
</li>
</ul>
</li>
<li>对上面方法的改进：允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用完毕的全部资源，然后再请求新的所需资源。</li>
</ul>
</li>
<li>破坏“不可抢占条件”：<ul>
<li>当一个已经保存了某些不可抢占资源的进程，提出新的资源请求而不能满足时，它必须释放已经保持的所有资源，待以后需要时在重新申请。（这个方法代价太大，一般不使用这个方法）</li>
</ul>
</li>
<li>破坏“循环等待条件”：<ul>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反</li>
</ul>
</li>
</ul>
<p>对于java来说：</p>
<ol>
<li>以确定的顺序获得锁<ul>
<li>如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：<ul>
<li><img src="/2021/07/19/JUC/70.jpg" alt="img"></li>
</ul>
</li>
<li>如果此时把获得锁的时序改成：<ul>
<li><img src="/2021/07/19/JUC/71.jpg" alt="img"></li>
</ul>
</li>
<li>那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。</li>
<li>问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“循环等待”），可能就无法满足要求了，这个时候开发者可以使用<code>银行家算法</code>，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生。</li>
</ul>
</li>
<li>超时放弃（Lock接口中的tryLock(long time, TimeUnit unit)使用的就是这个方法）<ul>
<li>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，</li>
<li>然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 还是按照之前的例子，时序图如下：<ul>
<li><img src="/2021/07/19/JUC/73.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h6 id="2、避免死锁"><a href="#2、避免死锁" class="headerlink" title="2、避免死锁"></a>2、避免死锁</h6><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。</p>
<p><strong>由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。</strong></p>
<p>其中最具有代表性的避免死锁算法是<code>银行家算法</code>。</p>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。</p>
<p>安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
<p><strong>处在安全状态的进程==一定==不会发生死锁问题，不处在安全状态的进程==可能==发生死锁问题</strong>。</p>
<h6 id="3、检测死锁"><a href="#3、检测死锁" class="headerlink" title="3、检测死锁"></a>3、检测死锁</h6><ol>
<li>首先为每个进程和每个资源指定一个唯一的号码；</li>
<li>然后建立资源分配表和进程等待表。</li>
<li>资源分配图 + 死锁定理</li>
</ol>
<h6 id="4、解除死锁"><a href="#4、解除死锁" class="headerlink" title="4、解除死锁"></a>4、解除死锁</h6><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ul>
<li>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</li>
<li>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；<ul>
<li>所谓代价是指优先级、运行代价、进程的重要性和价值等。</li>
</ul>
</li>
</ul>
<h5 id="6、死锁代码"><a href="#6、死锁代码" class="headerlink" title="6、死锁代码"></a>6、死锁代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个对象</span></span><br><span class="line">    <span class="keyword">static</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁a，试图获取锁b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁b，试图获取锁a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、活锁"><a href="#4、活锁" class="headerlink" title="4、活锁"></a>4、活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> cn.itcast.n2.util.Sleeper.sleep;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：<strong>使两个线程互相错开运行</strong></p>
<h4 id="5、饥饿"><a href="#5、饥饿" class="headerlink" title="5、饥饿"></a>5、饥饿</h4><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。</p>
<p>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题：</p>
<p><img src="/2021/07/19/JUC/image-20210806020827445.png" alt="image-20210806020827445"></p>
<p>顺序加锁的解决方案：</p>
<p><img src="/2021/07/19/JUC/image-20210806020910048.png" alt="image-20210806020910048"></p>
<h4 id="6、乐观锁-Optimistic-Locking-和悲观锁-Pessimistic-Lock"><a href="#6、乐观锁-Optimistic-Locking-和悲观锁-Pessimistic-Lock" class="headerlink" title="6、乐观锁(Optimistic Locking)和悲观锁(Pessimistic Lock)"></a>6、乐观锁(Optimistic Locking)和悲观锁(Pessimistic Lock)</h4><h5 id="1、悲观锁-Pessimistic-Lock"><a href="#1、悲观锁-Pessimistic-Lock" class="headerlink" title="1、悲观锁(Pessimistic Lock)"></a>1、悲观锁(Pessimistic Lock)</h5><ul>
<li>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</li>
<li>悲观锁，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。<strong>悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)</strong></li>
<li>之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，<strong>因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起</strong>。悲观锁的实现：<ul>
<li>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</li>
<li>Java 里面的同步 <code>synchronized</code> 关键字的实现。</li>
</ul>
</li>
<li>悲观锁主要分为<strong>共享锁</strong>和<strong>排他锁</strong>：<ul>
<li><strong>共享锁</strong>【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li><strong>排他锁</strong>【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。</li>
</ul>
</li>
<li>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</li>
<li>说明：<ul>
<li> 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210726192457057.png" alt="image-20210726192457057"></p>
<h5 id="2、乐观锁-Optimistic-Locking"><a href="#2、乐观锁-Optimistic-Locking" class="headerlink" title="2、乐观锁(Optimistic Locking)"></a>2、乐观锁(Optimistic Locking)</h5><ul>
<li>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。<strong>乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量</strong>。</li>
<li>乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：<ul>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li>
</ul>
</li>
<li>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</li>
<li>说明：<ul>
<li>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210726202536158.png" alt="image-20210726202536158"></p>
<h6 id="乐观锁场景：在线文档"><a href="#乐观锁场景：在线文档" class="headerlink" title="乐观锁场景：在线文档"></a>乐观锁场景：在线文档</h6><p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>
<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>
<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>
<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>
<ul>
<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>
<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li>
</ul>
<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>
<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>
<h4 id="7、表锁和行锁"><a href="#7、表锁和行锁" class="headerlink" title="7、表锁和行锁"></a>7、表锁和行锁</h4><p><strong>表锁</strong>和<strong>行锁</strong>主要是mysql数据库的悬挂知识，这里简单提一下，知道概念就行。</p>
<ul>
<li>表锁：当一个线程在给一张表进行数据操作的时候，会将整一张表都锁起来。在它操作完成之前，其他线程不能对这张表的所有数据进行操作。<ul>
<li><img src="/2021/07/19/JUC/image-20210726205202616.png" alt="image-20210726205202616"></li>
</ul>
</li>
<li>行锁：一个线程在对一张表的某一行数据进行操作的时候，会将那一行数据锁起来，在它操作完成之前，其他线程不能对这一行数据进行操作，但是对原这张表的其他行数据进行操作是允许的。<ul>
<li><img src="/2021/07/19/JUC/image-20210726205505114.png" alt="image-20210726205505114"></li>
</ul>
</li>
</ul>
<h4 id="8、读锁与写锁"><a href="#8、读锁与写锁" class="headerlink" title="8、读锁与写锁"></a>8、读锁与写锁</h4><p>读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享。</p>
<ul>
<li>读锁：共享锁。即允许多个线程一起读取某一个资源——“共享读”<ul>
<li>读锁存在”死锁”问题：线程1和线程2一起读取一张表，这时候线程1如果想要修改（写）这张表的数据，就需要线程2完成读操作后退出；同理，这个时候如果线程2也想修改（写）这张表的数据，那么也要等待线程1读取完后退出。这个时候就会出现线程1和线程2互相等待的情况——“死锁”</li>
<li>注意：如果读锁只读不写的话，就不存在”死锁”问题。</li>
<li><img src="/2021/07/19/JUC/image-20210726210610999.png" alt="image-20210726210610999"></li>
</ul>
</li>
<li>写锁：独占锁。即一次只允许一个线程对某一个资源进行写操作（这个时候不存在读线程，也不存在写线程（除非是它自己））——“单独写”<ul>
<li>写锁存在也”死锁”问题：线程1和线程2对一张表的不同行进行写操作。这个时候线程1想要写线程2操作的行，就需要等待线程2写完毕退出；同理，线程2想要写线程1操作的行，就需要等待线程1写完毕退出。这个时候就会出现线程1和线程2互相等待的情况——“死锁”</li>
<li><img src="/2021/07/19/JUC/image-20210726210629126.png" alt="image-20210726210629126"></li>
</ul>
</li>
</ul>
<h4 id="9、自旋锁与自适应自旋锁、偏向锁"><a href="#9、自旋锁与自适应自旋锁、偏向锁" class="headerlink" title="9、自旋锁与自适应自旋锁、偏向锁"></a>9、自旋锁与自适应自旋锁、偏向锁</h4><p>在<code>4、关键字：synchronized篇</code>里有详细说明。这里不在赘述。</p>
<h3 id="14、JUC线程池——FutureTask（未来任务）"><a href="#14、JUC线程池——FutureTask（未来任务）" class="headerlink" title="14、JUC线程池——FutureTask（未来任务）"></a>14、JUC线程池——FutureTask（未来任务）</h3><h4 id="1、BAT大厂的面试问题-15"><a href="#1、BAT大厂的面试问题-15" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>FutureTask用来解决什么问题的？为什么会出现？</li>
<li>FutureTask类结构关系怎么样的？</li>
<li>FutureTask的线程安全是由什么保证的？</li>
<li>FutureTask结果返回机制？</li>
<li>FutureTask内部运行状态的转变？</li>
<li>FutureTask通常会怎么用？举例说明。</li>
</ul>
<h4 id="2、FutureTask简介"><a href="#2、FutureTask简介" class="headerlink" title="2、FutureTask简介"></a>2、FutureTask简介</h4><ul>
<li>FutureTask 为 Future 提供了基础实现，如<strong>获取任务执行结果(get)**和</strong>取消任务(cancel)**等。</li>
<li><strong>如果任务尚未完成，获取任务执行结果时将会阻塞</strong>。</li>
<li>**一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)**。</li>
<li><strong>FutureTask 常用来封装 <code>Callable</code> 和 <code>Runnable</code>，也可以作为一个任务提交到线程池中执行</strong>。</li>
<li>除了作为一个独立的类之外，此类也<strong>提供了一些功能性函数供我们创建自定义 task 类使用</strong>。</li>
<li><strong>FutureTask 的线程安全由<code>CAS</code>来保证</strong>。</li>
</ul>
<h4 id="3、FutureTask类关系"><a href="#3、FutureTask类关系" class="headerlink" title="3、FutureTask类关系"></a>3、FutureTask类关系</h4><p><img src="/2021/07/19/JUC/java-thread-x-juc-futuretask-1.png" alt="img"></p>
<p>可以看到，FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以<strong>FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果</strong>。</p>
<h4 id="4、FutureTask源码分析"><a href="#4、FutureTask源码分析" class="headerlink" title="4、FutureTask源码分析"></a>4、FutureTask源码分析</h4><h5 id="1、Callable接口"><a href="#1、Callable接口" class="headerlink" title="1、Callable接口"></a>1、Callable接口</h5><p><strong>Callable是个泛型接口，泛型V就是要call()方法返回的类型</strong>。若是不能返回成功，则抛异常。</p>
<p>对比Runnable接口，Runnable不会返回数据也不能抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、Future接口"><a href="#2、Future接口" class="headerlink" title="2、Future接口"></a>2、Future接口</h5><p>Future接口代表<strong>异步计算的结果</strong>，<strong>通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行</strong>。</p>
<p>Future接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：<strong>cancel()方法用来取消异步任务的执行。</strong><ul>
<li>如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。</li>
<li>如果任务还没有被执行，则会返回true并且异步任务不会被执行。</li>
<li>如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</li>
</ul>
</li>
<li><code>isCanceled()</code>：<strong>判断任务是否被取消</strong>，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</li>
<li><code>isDone()</code>：<strong>判断任务是否已经完成</strong>，如果完成则返回true，否则返回false。<ul>
<li>需要注意的是：<strong>任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true</strong>。</li>
</ul>
</li>
<li><code>get()</code>：<strong>获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成</strong>。<ul>
<li>如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li>
</ul>
</li>
<li><code>get(long timeout,Timeunit unit)</code>：<strong>带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常</strong>。</li>
</ul>
<h5 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部持有的callable任务，运行完毕后置空</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从get()中返回的结果或抛出的异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行callable的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Treiber栈保存等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>其中需要注意的是**<code>state</code>是volatile类型的**，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。</p>
<p>7种状态具体表示：</p>
<ul>
<li><code>NEW</code>：表示是个<strong>新的任务或者还没被执行完的任务。这是初始状态</strong>。</li>
<li><code>COMPLETING</code>：<strong>任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</strong></li>
<li><code>NORMAL</code>：<strong>任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</strong></li>
<li><code>EXCEPTIONAL</code>：<strong>任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</strong></li>
<li><code>CANCELLED</code>：<strong>任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</strong></li>
<li><code>INTERRUPTING</code>：<strong>任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</strong></li>
<li><code>INTERRUPTED</code>：**调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。 **<ul>
<li><strong>有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。</strong></li>
</ul>
</li>
</ul>
<p>各个状态之间的可能转换关系如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-futuretask-2.png" alt="img"></p>
<h5 id="4、构造函数"><a href="#4、构造函数" class="headerlink" title="4、构造函数"></a>4、构造函数</h5><ul>
<li><p>FutureTask(Callable<V> callable)</V></p>
<ul>
<li><pre><code class="java">public FutureTask(Callable&lt;V&gt; callable) &#123;
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 这个构造函数会把传入的Callable变量保存在this.callable字段中，该字段定义为&#96;private Callable&lt;V&gt; callable&#96;；**用来保存底层的调用，在被执行完成以后会指向null，接着会初始化state字段为NEW**。</span><br><span class="line"></span><br><span class="line">- FutureTask(Runnable runnable, V result)</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">        this.callable &#x3D; Executors.callable(runnable, result);</span><br><span class="line">        this.state &#x3D; NEW;       &#x2F;&#x2F; ensure visibility of callable</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><strong>这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。</strong></p>
</li>
<li><p>顺带看下Executors.callable()这个方法，这个方法的功能是把Runnable转换成Callable，代码如下：</p>
<ul>
<li><pre><code class="java">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;
    if (task == null)
       throw new NullPointerException();
    return new RunnableAdapter&lt;T&gt;(task, result);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可以看到这里采用的是**适配器模式**，调用&#96;RunnableAdapter&lt;T&gt;(task, result)&#96;方法来适配，实现如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">        final Runnable task;</span><br><span class="line">        final T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.result &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        public T call() &#123;</span><br><span class="line">            task.run();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>这个适配器很简单，就是简单的实现了Callable接口，在call()实现中调用Runnable.run()方法，然后把传入的result作为任务的结果返回。</p>
</li>
</ul>
</li>
</ul>
<p>在new了一个FutureTask对象之后，接下来就是在另一个线程中执行这个Task，无论是通过直接new一个Thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。</p>
<h5 id="5、核心方法——run"><a href="#5、核心方法——run" class="headerlink" title="5、核心方法——run()"></a>5、核心方法——run()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建任务，CAS替换runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);<span class="comment">//设置执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);<span class="comment">//处理中断逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程。执行完毕调用set(result)方法设置执行结果。set(result)源码如下：（使用的也是CAS修改state状态为COMPLETING）</p>
<ul>
<li><pre><code class="java">protected void set(V v) &#123;
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();//执行完毕，唤醒等待线程
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 首先利用cas修改state状态为COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt)的方式设置state状态为NORMAL。结果设置完毕后，调用finishCompletion()方法唤醒等待线程，源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    private void finishCompletion() &#123;</span><br><span class="line">        &#x2F;&#x2F; assert state &gt; COMPLETING;</span><br><span class="line">        for (WaitNode q; (q &#x3D; waiters) !&#x3D; null;) &#123;</span><br><span class="line">            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;&#x2F;&#x2F;移除等待线程</span><br><span class="line">                for (;;) &#123;&#x2F;&#x2F;自旋遍历等待线程</span><br><span class="line">                    Thread t &#x3D; q.thread;</span><br><span class="line">                    if (t !&#x3D; null) &#123;</span><br><span class="line">                        q.thread &#x3D; null;</span><br><span class="line">                        LockSupport.unpark(t);&#x2F;&#x2F;唤醒等待线程</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode next &#x3D; q.next;</span><br><span class="line">                    if (next &#x3D;&#x3D; null)</span><br><span class="line">                        break;</span><br><span class="line">                    q.next &#x3D; null; &#x2F;&#x2F; unlink to help gc</span><br><span class="line">                    q &#x3D; next;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;任务完成后调用函数，自定义扩展</span><br><span class="line">        done();</span><br><span class="line">    </span><br><span class="line">        callable &#x3D; null;        &#x2F;&#x2F; to reduce footprint</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>回到run方法，如果在 run 期间被中断，此时需要调用<code>handlePossibleCancellationInterrupt</code>方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中，源码如下：</p>
<ul>
<li><pre><code class="java">private void handlePossibleCancellationInterrupt(int s) &#123;
    //在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待
    if (s == INTERRUPTING)
        while (state == INTERRUPTING)
            Thread.yield(); // wait out pending interrupt
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 6、核心方法——get()</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;获取执行结果</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s &#x3D; state;</span><br><span class="line">    if (s &lt;&#x3D; COMPLETING)</span><br><span class="line">        s &#x3D; awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>说明：FutureTask 通过get()方法获取任务执行结果。如果任务处于未完成的状态(<code>state &lt;= COMPLETING</code>)，就调用awaitDone方法(后面单独讲解)等待任务完成。任务完成后，通过report方法获取执行结果或抛出执行期间的异常。</p>
<p>report源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回执行结果或抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、核心方法——awaitDone-boolean-timed-long-nanos"><a href="#7、核心方法——awaitDone-boolean-timed-long-nanos" class="headerlink" title="7、核心方法——awaitDone(boolean timed, long nanos)"></a>7、核心方法——awaitDone(boolean timed, long nanos)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">//获取并清除中断状态</span></span><br><span class="line">            removeWaiter(q);<span class="comment">//移除等待WaitNode</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;<span class="comment">//置空等待节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//CAS修改waiter</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);<span class="comment">//超时，移除等待节点</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);<span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>awaitDone用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。</strong>函数执行逻辑如下：</p>
<p><strong>如果线程被中断，首先清除中断状态，调用removeWaiter移除等待节点，然后抛出InterruptedException。</strong></p>
<p>removeWaiter源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;<span class="comment">//首先置空线程</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">//依次遍历查找</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q, s)) <span class="comment">//cas替换</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前状态为结束状态(state&gt;COMPLETING)，则根据需要置空等待节点的线程，并返回 Future 状态；</li>
<li>如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出CPU执行时间片；</li>
<li>如果state为NEW，先新建一个WaitNode，然后CAS修改当前waiters；</li>
<li>如果等待超时，则调用removeWaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；</li>
<li>其他情况直接阻塞当前线程。</li>
</ul>
<h5 id="8、核心方法——cancel-boolean-mayInterruptIfRunning"><a href="#8、核心方法——cancel-boolean-mayInterruptIfRunning" class="headerlink" title="8、核心方法——cancel(boolean mayInterruptIfRunning)"></a>8、核心方法——cancel(boolean mayInterruptIfRunning)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;<span class="comment">//可以在运行时中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();<span class="comment">//移除并唤醒所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。</p>
<ul>
<li>如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED。</li>
<li>如果当前状态不为NEW，则根据参数mayInterruptIfRunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishCompletion移除并唤醒所有等待线程。</li>
</ul>
<h4 id="5、FutureTask示例"><a href="#5、FutureTask示例" class="headerlink" title="5、FutureTask示例"></a>5、FutureTask示例</h4><p><strong>常用使用方式：</strong></p>
<ul>
<li>第一种方式：<code>Future</code> + <code>ExecutorService</code></li>
<li>第二种方式：<code>FutureTask</code> + <code>ExecutorService</code></li>
<li>第三种方式：<code>FutureTask</code> + <code>Thread</code></li>
</ul>
<h5 id="1、Future使用示例"><a href="#1、Future使用示例" class="headerlink" title="1、Future使用示例"></a>1、Future使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          Future future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  Long start = System.currentTimeMillis();</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                      Long current = System.currentTimeMillis();</span><br><span class="line">                     <span class="keyword">if</span> ((current - start) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Integer result = (Integer)future.get();</span><br><span class="line">             System.out.println(result);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、FutureTask-Thread例子"><a href="#2、FutureTask-Thread例子" class="headerlink" title="2、FutureTask + Thread例子"></a>2、FutureTask + Thread例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方式:Future + ExecutorService</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Future&lt;Integer&gt; future = service.submit(task);</span></span><br><span class="line"><span class="comment">         * service.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方式: FutureTask + ExecutorService</span></span><br><span class="line"><span class="comment">         * ExecutorService executor = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">         * executor.submit(futureTask);</span></span><br><span class="line"><span class="comment">         * executor.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种方式:FutureTask + Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">&quot;Task thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task is not done&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;result is &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15、JUC强大的辅助类"><a href="#15、JUC强大的辅助类" class="headerlink" title="15、JUC强大的辅助类"></a>15、JUC强大的辅助类</h3><h4 id="1、CountDownLatch（减少计数）"><a href="#1、CountDownLatch（减少计数）" class="headerlink" title="1、CountDownLatch（减少计数）"></a>1、CountDownLatch（减少计数）</h4><p><code>CountDownLatch</code>底层也是由<code>AQS</code>，用来同步一个或多个任务的常用并发工具类，强制它们等待由其他任务执行的一组操作完成。</p>
<h5 id="1、BAT大厂的面试问题-16"><a href="#1、BAT大厂的面试问题-16" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>什么是CountDownLatch？</li>
<li>CountDownLatch底层实现原理？</li>
<li>CountDownLatch一次可以唤醒几个任务？<ul>
<li>多个</li>
</ul>
</li>
<li>CountDownLatch有哪些主要方法？<ul>
<li>await()、countDown()</li>
</ul>
</li>
<li>CountDownLatch适用于什么场景？</li>
<li>写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? <ul>
<li>使用CountDownLatch 代替wait notify 好处。</li>
</ul>
</li>
</ul>
<h5 id="2、CountDownLatch介绍"><a href="#2、CountDownLatch介绍" class="headerlink" title="2、CountDownLatch介绍"></a>2、CountDownLatch介绍</h5><p>从源码可知，<strong>其底层是由<code>AQS</code>提供支持</strong>，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列：<strong>同步队列sync queue</strong> 和<strong>条件队列condition queue</strong>，不同的条件会有不同的条件队列。</p>
<p>CountDownLatch主要用来进行线程同步协作，等待所有线程完成倒计时。其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<p>CountDownLatch典型的用法是：<strong>将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。</strong></p>
<h5 id="3、CountDownLatch源码分析"><a href="#3、CountDownLatch源码分析" class="headerlink" title="3、CountDownLatch源码分析"></a>3、CountDownLatch源码分析</h5><h6 id="1、类的继承关系-5"><a href="#1、类的继承关系-5" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><p>CountDownLatch没有显示继承哪个父类或者实现哪个父接口，<strong>它底层是AQS是通过内部类Sync来实现的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、类的内部类-4"><a href="#2、类的内部类-4" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h6><p>CountDownLatch类存在一个<strong>内部类Sync，继承自AbstractQueuedSynchronizer</strong>，（AQS）其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图设置状态来反映共享模式下的一个释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 没有被线程占有</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并且设置成功</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>对CountDownLatch方法的调用会转发到对Sync或AQS的方法的调用，所以，AQS对CountDownLatch提供支持。</strong></p>
<h6 id="3、类的属性-2"><a href="#3、类的属性-2" class="headerlink" title="3、类的属性"></a>3、类的属性</h6><p>CountDownLatch类的内部只有一个Sync类型的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4、类的构造函数-1"><a href="#4、类的构造函数-1" class="headerlink" title="4、类的构造函数"></a>4、类的构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化状态数</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该构造函数可以<strong>构造一个用给定计数初始化的CountDownLatch，并且构造函数内完成了sync的初始化，并设置了状态数</strong>。</p>
<h6 id="5、核心函数——await函数"><a href="#5、核心函数——await函数" class="headerlink" title="5、核心函数——await函数"></a>5、核心函数——await函数</h6><p>此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 转发到sync对象上</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：由源码可知，对CountDownLatch对象的await的调用会转发为<strong>对Sync的acquireSharedInterruptibly(从AQS继承的方法)方法的调用</strong>。</p>
<ul>
<li><p>acquireSharedInterruptibly源码如下：</p>
<ul>
<li><pre><code class="java">public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException &#123;
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：从源码中可知，acquireSharedInterruptibly又调用了CountDownLatch的内部类Sync的tryAcquireShared和AQS的doAcquireSharedInterruptibly函数。</span><br><span class="line"></span><br><span class="line">- tryAcquireShared函数的源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。</p>
</li>
</ul>
</li>
<li><p>doAcquireSharedInterruptibly函数的源码如下：</p>
<ul>
<li><pre><code class="java">private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123;
    // 添加节点至等待队列
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try &#123;
        for (;;) &#123; // 无限循环
            // 获取node的前驱节点
            final Node p = node.predecessor();
            if (p == head) &#123; // 前驱节点为头结点
                // 试图在共享模式下获取对象状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) &#123; // 获取成功
                    // 设置头结点并进行繁殖
                    setHeadAndPropagate(node, r);
                    // 设置节点next域
                    p.next = null; // help GC
                    failed = false;
                    return;
                &#125;
            &#125;
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查
                // 抛出异常
                throw new InterruptedException();
        &#125;
    &#125; finally &#123;
        if (failed)
            cancelAcquire(node);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：在AQS的doAcquireSharedInterruptibly中可能会再次调用CountDownLatch的内部类Sync的tryAcquireShared方法和AQS的setHeadAndPropagate方法。</span><br><span class="line"></span><br><span class="line">- setHeadAndPropagate方法源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取头结点</span><br><span class="line">        Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">        &#x2F;&#x2F; 设置头结点</span><br><span class="line">        &#x2F;&#x2F; 设置自己为 head</span><br><span class="line">        setHead(node);</span><br><span class="line">        &#x2F;*</span><br><span class="line">            * Try to signal next queued node if:</span><br><span class="line">            *   Propagation was indicated by caller,</span><br><span class="line">            *     or was recorded (as h.waitStatus either before</span><br><span class="line">            *     or after setHead) by a previous operation</span><br><span class="line">            *     (note: this uses sign-check of waitStatus because</span><br><span class="line">            *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">            * and</span><br><span class="line">            *   The next node is waiting in shared mode,</span><br><span class="line">            *     or we don&#39;t know, because it appears null</span><br><span class="line">            *</span><br><span class="line">            * The conservatism in both of these checks may cause</span><br><span class="line">            * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">            * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">            * anyway.</span><br><span class="line">            *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; propagate 表示有共享资源（例如共享读锁或信号量）</span><br><span class="line">        &#x2F;&#x2F; 原 head waitStatus &#x3D;&#x3D; Node.SIGNAL 或 Node.PROPAGATE</span><br><span class="line">        &#x2F;&#x2F; 现在 head waitStatus &#x3D;&#x3D; Node.SIGNAL 或 Node.PROPAGATE</span><br><span class="line">        if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">            (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取节点的后继</span><br><span class="line">            Node s &#x3D; node.next;</span><br><span class="line">            &#x2F;&#x2F; 如果是最后一个节点或者是等待共享读锁的节点</span><br><span class="line">            if (s &#x3D;&#x3D; null || s.isShared()) &#x2F;&#x2F; 后继为空或者为共享模式</span><br><span class="line">                &#x2F;&#x2F; 以共享模式进行释放</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：<strong>该方法设置头结点并且释放头结点后面的满足条件的结点</strong>，该方法中可能会调用到AQS的doReleaseShared方法。</p>
</li>
</ul>
</li>
<li><p>AQS的doReleaseShared方法其源码如下：</p>
<ul>
<li><pre><code class="java">private void doReleaseShared() &#123;
    /*
        * Ensure that a release propagates, even if there are other
        * in-progress acquires/releases.  This proceeds in the usual
        * way of trying to unparkSuccessor of head if it needs
        * signal. But if it does not, status is set to PROPAGATE to
        * ensure that upon release, propagation continues.
        * Additionally, we must loop in case a new node is added
        * while we are doing this. Also, unlike other uses of
        * unparkSuccessor, we need to know if CAS to reset status
        * fails, if so rechecking.
        */
    // 无限循环
    // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark
    // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析
    for (;;) &#123;
        // 保存头结点
        Node h = head;
        // 队列还有节点
        if (h != null &amp;&amp; h != tail) &#123; // 头结点不为空并且头结点不为尾结点
            // 获取头结点的等待状态
            int ws = h.waitStatus; 
            if (ws == Node.SIGNAL) &#123; // 状态为SIGNAL
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续
                    continue;            // loop to recheck cases
                // 下一个节点 unpark 如果成功获取读锁
                // 并且下下个节点还是 shared, 继续 doReleaseShared
                // 释放后继结点
                unparkSuccessor(h);
            &#125;
            else if (
                // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析
                ws == 0 &amp;&amp;
                !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续
                continue;                // loop on failed CAS
        &#125;
        if (h == head) // 若头结点改变，继续循环  
            break;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - 说明：**该方法在共享模式下释放**，具体的流程再之后会通过一个示例给出。</span><br><span class="line"></span><br><span class="line">所以，对CountDownLatch的await调用大致会有如下的调用链：</span><br><span class="line"></span><br><span class="line">![img](JUC&#x2F;java-thread-x-countdownlatch-1.png)</span><br><span class="line"></span><br><span class="line">说明：上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。</span><br><span class="line"></span><br><span class="line">###### 6、核心函数——countDown函数</span><br><span class="line"></span><br><span class="line">此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>说明：对countDown的调用转换为<strong>对Sync对象的releaseShared(从AQS继承而来)方法的调用</strong>。</p>
<ul>
<li><p>releaseShared源码如下：</p>
<ul>
<li><pre><code class="java">public final boolean releaseShared(int arg) &#123;
    if (tryReleaseShared(arg)) &#123;
        doReleaseShared();
        return true;
    &#125;
    return false;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：**此函数会以共享模式释放对象，并且在函数中会调用到CountDownLatch的tryReleaseShared函数，并且可能会调用AQS的doReleaseShared函数**。</span><br><span class="line"></span><br><span class="line">- tryReleaseShared源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">        &#x2F;&#x2F; 无限循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取状态</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#x2F;&#x2F; 没有被线程占有</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 下一个状态</span><br><span class="line">            int nextc &#x3D; c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc)) &#x2F;&#x2F; 比较并且设置成功</span><br><span class="line">                return nextc &#x3D;&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：<strong>此函数会试图设置状态来反映共享模式下的一个释放</strong>。具体的流程在下面的示例中会进行分析。</p>
</li>
</ul>
</li>
<li><p>AQS的doReleaseShared的源码如下：</p>
<ul>
<li><pre><code class="java">private void doReleaseShared() &#123;
    /*
        * Ensure that a release propagates, even if there are other
        * in-progress acquires/releases.  This proceeds in the usual
        * way of trying to unparkSuccessor of head if it needs
        * signal. But if it does not, status is set to PROPAGATE to
        * ensure that upon release, propagation continues.
        * Additionally, we must loop in case a new node is added
        * while we are doing this. Also, unlike other uses of
        * unparkSuccessor, we need to know if CAS to reset status
        * fails, if so rechecking.
        */
    // 无限循环
    for (;;) &#123;
        // 保存头结点
        Node h = head;
        if (h != null &amp;&amp; h != tail) &#123; // 头结点不为空并且头结点不为尾结点
            // 获取头结点的等待状态
            int ws = h.waitStatus; 
            if (ws == Node.SIGNAL) &#123; // 状态为SIGNAL
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续
                    continue;            // loop to recheck cases
                // 释放后继结点
                unparkSuccessor(h);
            &#125;
            else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续
                continue;                // loop on failed CAS
        &#125;
        if (h == head) // 若头结点改变，继续循环  
            break;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：此函数在共享模式下释放资源。</span><br><span class="line"></span><br><span class="line">所以，对CountDownLatch的countDown调用大致会有如下的调用链：</span><br><span class="line"></span><br><span class="line">![img](JUC&#x2F;java-thread-x-countdownlatch-2.png)</span><br><span class="line"></span><br><span class="line">说明：上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。</span><br><span class="line"></span><br><span class="line">##### 4、CountDownLatch示例</span><br><span class="line"></span><br><span class="line">下面给出了一个使用CountDownLatch的示例：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private CountDownLatch countDownLatch;</span><br><span class="line">    </span><br><span class="line">    public MyThread(String name, CountDownLatch countDownLatch) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; doing something&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; finish&quot;);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(2);</span><br><span class="line">        MyThread t1 &#x3D; new MyThread(&quot;t1&quot;, countDownLatch);</span><br><span class="line">        MyThread t2 &#x3D; new MyThread(&quot;t2&quot;, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(&quot;Waiting for t1 thread and t2 thread to finish&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;            </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> t1 thread and t2 thread to finish</span><br><span class="line">t1 doing something</span><br><span class="line">t2 doing something</span><br><span class="line">t1 finish</span><br><span class="line">t2 finish</span><br><span class="line">main <span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>说明：本程序首先计数器初始化为2。根据结果，可能会存在如下的一种时序图：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-countdownlatch-3.png" alt="img"></p>
<p>说明：首先main线程会调用await操作，此时main线程会被阻塞，等待被唤醒，之后t1线程执行了countDown操作，最后，t2线程执行了countDown操作，此时main线程就被唤醒了，可以继续运行。下面，进行详细分析：</p>
<ul>
<li>main线程执行countDownLatch.await操作，主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-countdownlatch-4.png" alt="img"></li>
<li>说明：在最后，main线程就被park了，即禁止运行了。此时Sync queue(同步队列)中有两个节点，AQS的state为2，包含main线程的结点的nextWaiter指向SHARED结点。</li>
</ul>
</li>
<li>t1线程执行countDownLatch.countDown操作，主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-countdownlatch-5.png" alt="img"></li>
<li>说明：此时，Sync queue队列里的结点个数未发生变化，但是此时，AQS的state已经变为1了。</li>
</ul>
</li>
<li>t2线程执行countDownLatch.countDown操作，主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-countdownlatch-6.png" alt="img"></li>
<li>说明：经过调用后，AQS的state为0，并且此时，main线程会被unpark，可以继续运行。当main线程获取cpu资源后，继续运行。</li>
</ul>
</li>
<li>main线程获取cpu资源，继续运行，由于main线程是在<code>parkAndCheckInterrupt</code>函数中被禁止的，所以此时，继续在parkAndCheckInterrupt函数运行。<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-countdownlatch-7.png" alt="img"></li>
<li>说明：main线程恢复，继续在parkAndCheckInterrupt函数中运行，之后又会回到最终达到的状态为：AQS的state为0，并且head与tail指向同一个结点，该节点的nextWaiter域还是指向SHARED结点。</li>
</ul>
</li>
</ul>
<h5 id="5、更深入理解-2"><a href="#5、更深入理解-2" class="headerlink" title="5、更深入理解"></a>5、更深入理解</h5><h6 id="1、面试题"><a href="#1、面试题" class="headerlink" title="1、面试题"></a>1、面试题</h6><blockquote>
<p>实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束。</p>
</blockquote>
<h6 id="2、使用wait和notify实现："><a href="#2、使用wait和notify实现：" class="headerlink" title="2、使用wait和notify实现："></a>2、使用wait和notify实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 启动&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(t2.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**会释放锁*/</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**唤醒T1进程*/</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 启动&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                   t2.add(i);</span><br><span class="line">                   System.out.println(<span class="string">&quot;add&quot;</span>+i);</span><br><span class="line">                   <span class="keyword">if</span>(t2.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                       <span class="comment">/**不会释放锁*/</span></span><br><span class="line">                       lock.notify();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">/**进程挂起，释放锁等待唤醒*/</span></span><br><span class="line">                           lock.wait();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t2 启动</span><br><span class="line">t1 启动</span><br><span class="line">add0</span><br><span class="line">add1</span><br><span class="line">add2</span><br><span class="line">add3</span><br><span class="line">add4</span><br><span class="line">t2 结束</span><br><span class="line">add5</span><br><span class="line">add6</span><br><span class="line">add7</span><br><span class="line">add8</span><br></pre></td></tr></table></figure>

<h6 id="3、CountDownLatch实现"><a href="#3、CountDownLatch实现" class="headerlink" title="3、CountDownLatch实现"></a>3、CountDownLatch实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3 t = <span class="keyword">new</span> T3();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(t.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   countDownLatch.await();</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               t.add(i);</span><br><span class="line">               System.out.println(<span class="string">&quot;add&quot;</span>+ i);</span><br><span class="line">               <span class="keyword">if</span>(t.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;countdown is open&quot;</span>);</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、CyclicBarrier（循环栅栏）"><a href="#2、CyclicBarrier（循环栅栏）" class="headerlink" title="2、CyclicBarrier（循环栅栏）"></a>2、CyclicBarrier（循环栅栏）</h4><p>CyclicBarrier底层是基于<code>ReentrantLock</code>和<code>AbstractQueuedSynchronizer</code>来实现的，在理解的时候最好和<code>CountDownLatch</code>放在一起理解。</p>
<h5 id="1、BAT大厂的面试问题-17"><a href="#1、BAT大厂的面试问题-17" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>什么是CyclicBarrier？</li>
<li>CyclicBarrier底层实现原理？</li>
<li>CountDownLatch和CyclicBarrier对比？</li>
<li>CyclicBarrier的核心函数有哪些？</li>
<li>CyclicBarrier适用于什么场景？</li>
</ul>
<h5 id="2、CyclicBarrier简介"><a href="#2、CyclicBarrier简介" class="headerlink" title="2、CyclicBarrier简介"></a>2、CyclicBarrier简介</h5><ul>
<li>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。</li>
<li>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</li>
<li>注意：CyclicBarrier的计数与线程数最好是一一对应才能达到我们的要求<ul>
<li>例子：一开始两个任务task1(执行1s)与task2(执行2s)，需要循环执行3次，即两对三次总共六次任务，每一对任务执行完毕会执行CyclicBarrier当中的任务task3，所以设置CyclicBarrier的计数为2，对应每一组两个任务</li>
<li>如果我们设置线程池的线程个数为2，那么会如我们所想执行——task1 task2 task3  task1 task2 task3 task1 task2 task3</li>
<li>如果我们设置线程池的线程个数为3，那么就不会如我们所想执行了，因为一开始会有三个线程线执行任务：task1 task2 task1，而CyclicBarrier的task3会被两个task1执行（因为1 + 1 = 2）结束后执行，执行流程就变成——task1 task1 task3 task2 task1 task3 task2 task2 task3</li>
</ul>
</li>
</ul>
<h5 id="3、CyclicBarrier源码分析"><a href="#3、CyclicBarrier源码分析" class="headerlink" title="3、CyclicBarrier源码分析"></a>3、CyclicBarrier源码分析</h5><h6 id="1、类的继承关系-6"><a href="#1、类的继承关系-6" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><p>CyclicBarrier没有显示继承哪个父类或者实现哪个父接口，所有AQS和重入锁不是通过继承实现的，而是通过<strong>组合</strong>实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、类的内部类-5"><a href="#2、类的内部类-5" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h6><p>CyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Generation类有一个属性broken，用来表示<strong>当前屏障是否被损坏</strong>。</p>
<h6 id="3、类的属性-3"><a href="#3、类的属性-3" class="headerlink" title="3、类的属性"></a>3、类的属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="comment">// 条件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="comment">// 参与的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="comment">// 由最后一个进入 barrier 的线程执行的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="comment">// 当前代</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">// 正在等待进入屏障的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该属性有一个为<code>ReentrantLock</code>对象，有一个为<code>Condition</code>对象，而Condition对象又是基于AQS的，所以，归根到底，<strong>底层还是由AQS提供支持</strong>。</p>
<h6 id="4、类的构造函数-2"><a href="#4、类的构造函数-2" class="headerlink" title="4、类的构造函数"></a>4、类的构造函数</h6><ul>
<li><p>CyclicBarrier(int, Runnable)型构造函数：</p>
<ul>
<li><pre><code class="java">public CyclicBarrier(int parties, Runnable barrierAction) &#123;
    // 参与的线程数量小于等于0，抛出异常
    if (parties &lt;= 0) throw new IllegalArgumentException();
    // 设置parties
    this.parties = parties;
    // 设置count
    this.count = parties;
    // 设置barrierCommand
    this.barrierCommand = barrierAction;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。</span><br><span class="line"></span><br><span class="line">- CyclicBarrier(int)型构造函数：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public CyclicBarrier(int parties) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用含有两个参数的构造函数</span><br><span class="line">        this(parties, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。</p>
</li>
</ul>
</li>
</ul>
<h6 id="5、核心函数——dowait函数"><a href="#5、核心函数——dowait函数" class="headerlink" title="5、核心函数——dowait函数"></a>5、核心函数——dowait函数</h6><p>此函数为CyclicBarrier类的核心函数，<strong>CyclicBarrier类对外提供的await函数在底层都是调用该类的doawait函数</strong>，</p>
<p>await函数源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doawait函数源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被破坏，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// 线程被中断</span></span><br><span class="line">            <span class="comment">// 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少正在等待进入屏障的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 正在等待进入屏障的线程数量为0，所有线程都已经进入</span></span><br><span class="line">            <span class="comment">// 运行的动作标识</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 保存运行动作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 动作不为空</span></span><br><span class="line">                    <span class="comment">// 运行</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置ranAction状态</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 进入下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 没有运行的动作</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 没有设置等待时间</span></span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    trip.await(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 设置了等待时间，并且等待时间大于0</span></span><br><span class="line">                    <span class="comment">// 等待指定时长</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; </span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123; <span class="comment">// 等于当前代并且屏障没有被损坏</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不等于当前带后者是屏障被损坏</span></span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    <span class="comment">// 中断当前线程</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被损坏，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">// 不等于当前代</span></span><br><span class="line">                <span class="comment">// 返回索引</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 设置了等待时间，并且等待时间小于0</span></span><br><span class="line">                <span class="comment">// 损坏屏障</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：dowait方法的逻辑会进行一系列的判断，大致流程如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-1.png" alt="img"></p>
<h6 id="6、核心函数——nextGenneration函数"><a href="#6、核心函数——nextGenneration函数" class="headerlink" title="6、核心函数——nextGenneration函数"></a>6、核心函数——nextGenneration函数</h6><p>此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 新生一代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此函数中会调用AQS的<code>signalAll</code>方法，即<strong>唤醒所有等待线程</strong>。</p>
<p>如果所有的线程都在等待此条件，则唤醒所有线程。其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头结点不为空</span></span><br><span class="line">        <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此函数判断头结点是否为空，即条件队列是否为空，然后会调用<code>doSignalAll</code>函数，doSignalAll函数源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition队列的头结点尾结点都设置为空</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取first结点的nextWaiter域结点</span></span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        <span class="comment">// 设置first结点的nextWaiter域为空</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将first结点从condition队列转移到sync队列</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        <span class="comment">// 重新设置first</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferForSignal函数，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">        * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">        * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">        * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 上一个节点被取消</span></span><br><span class="line">        ws &gt; <span class="number">0</span> || </span><br><span class="line">        <span class="comment">// 上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">        !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此函数的作用就是<strong>将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息</strong>。</p>
<p>其中会调用到<code>enq</code>函数，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头结点为空，并设置头结点为新生成的结点</span></span><br><span class="line">                tail = head; <span class="comment">// 头结点与尾结点都指向同一个新生结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">            <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">            node.prev = t; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                t.next = node; </span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>此函数完成了结点插入同步队列的过程</strong>，也很好理解。</p>
<p>综合上面的分析可知，newGeneration函数的主要方法的调用如下，之后会通过一个例子详细讲解：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-2.png" alt="img"></p>
<h6 id="7、breakBarrier函数"><a href="#7、breakBarrier函数" class="headerlink" title="7、breakBarrier函数"></a>7、breakBarrier函数</h6><p>此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：可以看到，此函数也调用了AQS的signalAll函数，由signal函数提供支持。</p>
<h5 id="4、CyclicBarrier示例"><a href="#4、CyclicBarrier示例" class="headerlink" title="4、CyclicBarrier示例"></a>4、CyclicBarrier示例</h5><p>下面通过一个例子来详解CyclicBarrier的使用和内部工作机制，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, CyclicBarrier cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Thread(<span class="string">&quot;barrierAction&quot;</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; barrier action&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, cb);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, cb);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1 going to await</span><br><span class="line">main going to await</span><br><span class="line">t2 going to await</span><br><span class="line">t2 barrier action</span><br><span class="line">t2 <span class="built_in">continue</span></span><br><span class="line">t1 <span class="built_in">continue</span></span><br><span class="line">main <span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>说明：根据结果可知，可能会存在如下的调用时序：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-3.png" alt="java-thread-x-cyclicbarrier-3"></p>
<p>说明：由上图可知，假设t1线程的cb.await是在main线程的cb.await之前，cb.barrierAction动作是由最后一个进入屏障的线程t2执行的。根据时序图，进一步分析出其内部工作流程。</p>
<ul>
<li>main(主)线程执行cb.await操作，主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-4.png" alt="img"></li>
<li>说明：由于ReentrantLock的默认采用非公平策略，所以在dowait函数中调用的是ReentrantLock.NonfairSync的lock函数，由于此时AQS的状态是0，表示还没有被任何线程占用，故main线程可以占用，之后在dowait中会调用trip.await函数，最终的结果是条件队列中存放了一个包含main线程的结点，并且被禁止运行了，同时，main线程所拥有的资源也被释放了，可以供其他线程获取。</li>
</ul>
</li>
<li>t1线程执行cb.await操作，其中假设t1线程的lock.lock操作在main线程释放了资源之后，则其主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-5.png" alt="img"></li>
<li>说明：可以看到，之后condition queue(条件队列)里面有两个节点，包含t1线程的结点插入在队列的尾部，并且t1线程也被禁止了，因为执行了park操作，此时两个线程都被禁止了。</li>
</ul>
</li>
<li>t2线程执行cb.await操作，其中假设t2线程的lock.lock操作在t1线程释放了资源之后，则其主要调用的函数如下：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-6.png" alt="img"></li>
<li>说明：由上图可知，在t2线程执行await操作后，会直接执行command.run方法，不是重新开启一个线程，而是最后进入屏障的线程执行。同时，会将Condition queue中的所有节点都转移到Sync queue中，并且最后main线程会被unpark，可以继续运行。main线程获取cpu资源，继续运行。</li>
</ul>
</li>
<li>main线程获取cpu资源，继续运行，下图给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-7.png" alt="img"></li>
<li>说明：其中，由于main线程是在AQS.CO的wait中被park的，所以恢复时，会继续在该方法中运行。运行过后，t1线程被unpark，它获得cpu资源可以继续运行。</li>
</ul>
</li>
<li>t1线程获取cpu资源，继续运行，下图给出了主要的方法调用：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-cyclicbarrier-8.png" alt="img"></li>
<li>说明：其中，由于t1线程是在AQS.CO的wait方法中被park，所以恢复时，会继续在该方法中运行。运行过后，Sync queue中保持着一个空节点。头结点与尾节点均指向它。</li>
</ul>
</li>
</ul>
<p>注意：<strong>在线程await过程中中断线程会抛出异常，所有进入屏障的线程都将被释放</strong>。至于CyclicBarrier的其他用法，读者可以自行查阅API。</p>
<h5 id="5、新增一个容易理解的例子"><a href="#5、新增一个容易理解的例子" class="headerlink" title="5、新增一个容易理解的例子"></a>5、新增一个容易理解的例子</h5><p>场景：收集七龙珠召唤神龙</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier =</span><br><span class="line">                <span class="keyword">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;集齐7颗龙珠就可以召唤神龙&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 星龙珠被收集到了&quot;</span>);</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某一次执行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 星龙珠被收集到了</span><br><span class="line">4 星龙珠被收集到了</span><br><span class="line">3 星龙珠被收集到了</span><br><span class="line">1 星龙珠被收集到了</span><br><span class="line">7 星龙珠被收集到了</span><br><span class="line">6 星龙珠被收集到了</span><br><span class="line">5 星龙珠被收集到了</span><br><span class="line">集齐7颗龙珠就可以召唤神龙</span><br></pre></td></tr></table></figure>

<p>若将主线程的循环从<code>7</code>改成<code>6</code>的话，由于只能收集到6颗龙珠，所以不能召唤神龙（其实就是没能达到破坏屏障的条件，所有的线程都在等待）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 星龙珠被收集到了</span><br><span class="line">5 星龙珠被收集到了</span><br><span class="line">4 星龙珠被收集到了</span><br><span class="line">3 星龙珠被收集到了</span><br><span class="line">1 星龙珠被收集到了</span><br><span class="line">6 星龙珠被收集到了</span><br></pre></td></tr></table></figure>

<h5 id="6、和CountDownLatch再对比"><a href="#6、和CountDownLatch再对比" class="headerlink" title="6、和CountDownLatch再对比"></a>6、和CountDownLatch再对比</h5><ul>
<li><strong>CountDownLatch减计数，CyclicBarrier加计数。</strong></li>
<li><strong>CountDownLatch是一次性的，CyclicBarrier可以重用。</strong></li>
<li><strong>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。</strong></li>
</ul>
<h4 id="3、Semaphore（信号量）"><a href="#3、Semaphore（信号量）" class="headerlink" title="3、Semaphore（信号量）"></a>3、Semaphore（信号量）</h4><p>Semaphore底层是基于<code>AbstractQueuedSynchronizer</code>（AQS）来实现的。Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源，用来限制能同时访问共享资源的线程上限。</p>
<h5 id="1、BAT大厂的面试问题-18"><a href="#1、BAT大厂的面试问题-18" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>什么是Semaphore？</li>
<li>Semaphore内部原理？</li>
<li>Semaphore常用方法有哪些？如何实现线程同步和互斥的？</li>
<li>Semaphore适合用在什么场景？</li>
<li>单独使用Semaphore是不会使用到AQS的条件队列？</li>
<li>Semaphore中申请令牌(acquire)、释放令牌(release)的实现？</li>
<li>Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？</li>
<li>Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？</li>
<li>Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗？</li>
<li>Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗？</li>
</ul>
<h5 id="2、Semaphore源码分析"><a href="#2、Semaphore源码分析" class="headerlink" title="2、Semaphore源码分析"></a>2、Semaphore源码分析</h5><h6 id="1、类的继承关系-7"><a href="#1、类的继承关系-7" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Semaphore实现了Serializable接口，即<strong>可以进行序列化</strong>。</p>
<h6 id="2、类的内部类-6"><a href="#2、类的内部类-6" class="headerlink" title="2、类的内部类"></a>2、类的内部类</h6><p>Semaphore总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-juc-reentrantlock-1.png" alt="image"></p>
<p>说明：Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p>
<h6 id="3、类的内部类——Sync类"><a href="#3、类的内部类——Sync类" class="headerlink" title="3、类的内部类——Sync类"></a>3、类的内部类——Sync类</h6><p>Sync类的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        <span class="comment">// permits 即 state</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span></span><br><span class="line">                remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Sync类的属性相对简单，只有一个版本号，Sync类存在如下方法和作用如下：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-semaphore-2.png" alt="img"></p>
<h6 id="4、类的内部类——NonfairSync类"><a href="#4、类的内部类——NonfairSync类" class="headerlink" title="4、类的内部类——NonfairSync类"></a>4、类的内部类——NonfairSync类</h6><p>NonfairSync类继承了Sync类，表示采用非公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：从tryAcquireShared方法的源码可知，其会调用父类Sync的nonfairTryAcquireShared方法，表示按照非公平策略进行资源的获取。</p>
<h6 id="5、类的内部类——FairSync类"><a href="#5、类的内部类——FairSync类" class="headerlink" title="5、类的内部类——FairSync类"></a>5、类的内部类——FairSync类</h6><p>FairSync类继承了Sync类，表示采用公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 同步队列中存在其他节点</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 剩余的许可</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余的许可小于0或者比较设置成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：从tryAcquireShared方法的源码可知，它使用公平策略来获取资源，<strong>它会判断同步队列中是否存在其他的等待节点</strong>。</p>
<h6 id="6、类的属性"><a href="#6、类的属性" class="headerlink" title="6、类的属性"></a>6、类的属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Semaphore自身只有两个属性，最重要的是sync属性，<strong>基于Semaphore对象的操作绝大多数都转移到了对sync的操作</strong>。</p>
<h6 id="7、类的构造函数"><a href="#7、类的构造函数" class="headerlink" title="7、类的构造函数"></a>7、类的构造函数</h6><ul>
<li><p>Semaphore(int)型构造函数</p>
<ul>
<li><pre><code class="java">public Semaphore(int permits) &#123;
    sync = new NonfairSync(permits);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 说明：该构造函数会创建具有给定的许可数和**非公平的设置的Semaphore**。</span><br><span class="line"></span><br><span class="line">- Semaphore(int, boolean)型构造函数</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>说明：该构造函数会创建具有给定的许可数和<strong>给定的公平设置的Semaphore</strong>。</p>
</li>
</ul>
</li>
</ul>
<h6 id="8、核心函数——acquire函数"><a href="#8、核心函数——acquire函数" class="headerlink" title="8、核心函数——acquire函数"></a>8、核心函数——acquire函数</h6><p>此方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该方法中将会调用Sync对象的<code>acquireSharedInterruptibly</code>(从AQS继承而来的方法)方法，而acquireSharedInterruptibly方法在上面CountDownLatch中已经进行了分析，在此不再累赘。</p>
<p>最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-semaphore-3.png" alt="img"></p>
<p>说明：上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。</p>
<h6 id="9、核心函数——release函数"><a href="#9、核心函数——release函数" class="headerlink" title="9、核心函数——release函数"></a>9、核心函数——release函数</h6><p>此方法释放一个(多个)许可，将其返回给信号量，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该方法中将会调用Sync对象的<code>releaseShared</code>(从AQS继承而来的方法)方法，而releaseShared方法在上面CountDownLatch中已经进行了分析，在此不再累赘。</p>
<p>最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-semaphore-4.png" alt="img"></p>
<p>说明：上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。</p>
<h6 id="10、图解Semaphore的执行流程"><a href="#10、图解Semaphore的执行流程" class="headerlink" title="10、图解Semaphore的执行流程"></a>10、图解Semaphore的执行流程</h6><p><strong>加锁解锁流程</strong>：</p>
<ol>
<li><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一</p>
</li>
<li><p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p>
<p><img src="/2021/07/19/JUC/image-20210813191406684.png" alt="image-20210813191406684"></p>
</li>
<li><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>
<p><img src="/2021/07/19/JUC/image-20210813192404706.png" alt="image-20210813192404706"></p>
</li>
<li><p>这时 Thread-4 释放了 permits，状态如下</p>
<p><img src="/2021/07/19/JUC/image-20210813192655068.png" alt="image-20210813192655068"></p>
</li>
<li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
<p><img src="/2021/07/19/JUC/image-20210813193133463.png" alt="image-20210813193133463"></p>
</li>
</ol>
<h5 id="3、Semaphore示例"><a href="#3、Semaphore示例" class="headerlink" title="3、Semaphore示例"></a>3、Semaphore示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SEM_SIZE = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(SEM_SIZE);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, semaphore);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, semaphore);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">int</span> permits = <span class="number">5</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(permits);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main trying to acquire</span><br><span class="line">main acquire successfully</span><br><span class="line">t1 trying to acquire</span><br><span class="line">t1 acquire successfully</span><br><span class="line">t2 trying to acquire</span><br><span class="line">t1 release successfully</span><br><span class="line">main release successfully</span><br><span class="line">t2 acquire successfully</span><br><span class="line">t2 release successfully</span><br></pre></td></tr></table></figure>

<p>说明：首先，生成一个信号量，信号量有10个许可，然后，main，t1，t2三个线程获取许可运行，根据结果，可能存在如下的一种时序：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-semaphore-5.png" alt="img"></p>
<p>说明：如上图所示，首先，main线程执行acquire操作，并且成功获得许可，之后t1线程执行acquire操作，成功获得许可，之后t2执行acquire操作，由于此时许可数量不够，t2线程将会阻塞，直到许可可用。之后t1线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时t2线程会成功获得许可运行，t2运行完成后释放许可。下面进行详细分析：</p>
<ul>
<li>main线程执行semaphore.acquire操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-6.png" alt="img"></li>
<li>说明：此时，可以看到只是AQS的state变为了5，main线程并没有被阻塞，可以继续运行。</li>
</ul>
</li>
<li>t1线程执行semaphore.acquire操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-7.png" alt="img"></li>
<li>说明：此时，可以看到只是AQS的state变为了2，t1线程并没有被阻塞，可以继续运行。</li>
</ul>
</li>
<li>t2线程执行semaphore.acquire操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-8.png" alt="img"></li>
<li>说明：此时，t2线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，AQS的state还是为2。</li>
</ul>
</li>
<li>t1执行semaphore.release操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-9.png" alt="img"></li>
<li>说明：此时，t2线程将会被unpark，并且AQS的state为5，t2获取cpu资源后可以继续运行。</li>
</ul>
</li>
<li>main线程执行semaphore.release操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-10.png" alt="img"></li>
<li>说明：此时，t2线程还会被unpark，但是不会产生影响，此时，只要t2线程获得CPU资源就可以运行了。此时，AQS的state为10。</li>
</ul>
</li>
<li>t2获取CPU资源，继续运行，此时t2需要恢复现场，回到parkAndCheckInterrupt函数中，也是在should继续运行。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-11.png" alt="img"></li>
<li>说明：此时，可以看到，Sync queue中只有一个结点，头结点与尾节点都指向该结点，在setHeadAndPropagate的函数中会设置头结点并且会unpark队列中的其他结点。</li>
</ul>
</li>
<li>t2线程执行semaphore.release操作。主要的函数调用如下图所示：<ul>
<li><img src="/2021/07/19/JUC/java-thread-x-semaphore-12.png" alt="img"></li>
<li>说明：t2线程经过release后，此时信号量的许可又变为10个了，此时Sync queue中的结点还是没有变化。</li>
</ul>
</li>
</ul>
<h5 id="4、新增一个容易理解的例子"><a href="#4、新增一个容易理解的例子" class="headerlink" title="4、新增一个容易理解的例子"></a>4、新增一个容易理解的例子</h5><p>场景：6辆汽车，停3个车位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6辆汽车，停3个车位</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore，设置许可数量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟6辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 抢到了车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ------离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某一次执行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 抢到了车位</span><br><span class="line">2 抢到了车位</span><br><span class="line">3 抢到了车位</span><br><span class="line">2 ------离开了车位</span><br><span class="line">4 抢到了车位</span><br><span class="line">1 ------离开了车位</span><br><span class="line">3 ------离开了车位</span><br><span class="line">5 抢到了车位</span><br><span class="line">6 抢到了车位</span><br><span class="line">4 ------离开了车位</span><br><span class="line">5 ------离开了车位</span><br><span class="line">6 ------离开了车位</span><br></pre></td></tr></table></figure>

<h5 id="5、Semaphore应用"><a href="#5、Semaphore应用" class="headerlink" title="5、Semaphore应用"></a>5、Semaphore应用</h5><ul>
<li>使用Semaphore限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它<strong>只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数</strong>(例如连接数，请对比<code>Tomcat LimitLatch</code>的实现)</li>
<li>Semaphore比较适用于<strong>资源数与线程数相等的场景</strong></li>
<li>用 Semaphore <strong>实现简单连接池</strong>（一个线程对应一个数据库连接），对比享元模式下的实现(用wait notify)，性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoolSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Connection conn = pool.borrow();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(conn);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(poolSize);</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取空闲连接</span></span><br><span class="line">            <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                    <span class="keyword">return</span> connections[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockConnection</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MockConnection&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些重写的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6、更深入理解"><a href="#6、更深入理解" class="headerlink" title="6、更深入理解"></a>6、更深入理解</h5><h6 id="1、单独使用Semaphore是不会使用到AQS的条件队列的"><a href="#1、单独使用Semaphore是不会使用到AQS的条件队列的" class="headerlink" title="1、单独使用Semaphore是不会使用到AQS的条件队列的"></a>1、单独使用Semaphore是不会使用到AQS的条件队列的</h6><p><strong>不同于CyclicBarrier和ReentrantLock，单独使用Semaphore是不会使用到AQS的条件队列的，其实，只有进行await操作才会进入条件队列，其他的都是在同步队列中，只是当前线程会被park。</strong></p>
<h6 id="2、场景问题——semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？"><a href="#2、场景问题——semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？" class="headerlink" title="2、场景问题——semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？"></a>2、场景问题——semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？</h6><p>答案：拿不到令牌的线程阻塞，不会继续往下运行。</p>
<h6 id="3、场景问题——semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？"><a href="#3、场景问题——semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？" class="headerlink" title="3、场景问题——semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？"></a>3、场景问题——semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？</h6><p>答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，<strong>令牌没有重入的概念</strong>。你<strong>只要调用一次acquire方法，就需要有一个令牌才能继续运行</strong>。（这和你一次性申请11个令牌是一样的）</p>
<h6 id="4、场景问题——semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗？"><a href="#4、场景问题——semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗？" class="headerlink" title="4、场景问题——semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗？"></a>4、场景问题——semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗？</h6><p>答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p>
<h6 id="5、场景问题——semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#5、场景问题——semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="5、场景问题——semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a>5、场景问题——semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h6><p>答案：能，原因是release会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。</p>
<p>具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。。（或许是开发者考虑不周到）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> permitsNum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(permitsNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、Phaser-移相器"><a href="#4、Phaser-移相器" class="headerlink" title="4、Phaser(移相器)"></a>4、Phaser(移相器)</h4><p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p>
<h5 id="1、BAT大厂的面试问题-19"><a href="#1、BAT大厂的面试问题-19" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>Phaser主要用来解决什么问题？</li>
<li>Phaser与CyclicBarrier和CountDownLatch的区别是什么？</li>
<li>如果用CountDownLatch来实现Phaser的功能应该怎么实现？</li>
<li>Phaser运行机制是什么样的？</li>
<li>给一个Phaser使用的示例？</li>
</ul>
<h5 id="2、Phaser运行机制"><a href="#2、Phaser运行机制" class="headerlink" title="2、Phaser运行机制"></a>2、Phaser运行机制</h5><p><img src="/2021/07/19/JUC/java-thread-x-juc-phaser-1.png" alt="java-thread-x-juc-phaser-1"></p>
<h6 id="1、Registration-注册"><a href="#1、Registration-注册" class="headerlink" title="1、Registration(注册)"></a>1、<strong>Registration(注册)</strong></h6><p><strong>跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化</strong>。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，<strong>注册和撤销只影响内部count；不会创建更深的内部记录</strong>，所以<strong>任务不能查询他们是否已经注册</strong>。(不过，<strong>可以通过继承来实现类似的记录</strong>)</p>
<h6 id="2、Synchronization-同步机制"><a href="#2、Synchronization-同步机制" class="headerlink" title="2、Synchronization(同步机制)"></a>2、<strong>Synchronization(同步机制)</strong></h6><p>和CyclicBarrier一样，Phaser也可以重复await。方法arriveAndAwaitAdvance的效果类似CyclicBarrier.await。<strong>phaser的每一代都有一个相关的phase number，初始值为0，当所有注册的任务都到达phaser时phase+1，到达最大值(Integer.MAX_VALUE)之后清零</strong>。使用phase number可以独立控制 ==到达phaser== 和 ==等待其他线程== 的动作，通过下面两种类型的方法：</p>
<blockquote>
<ul>
<li><strong>Arrival(到达机制)</strong> arrive和arriveAndDeregister方法记录到达状态。这些方法不会阻塞，但是会返回一个相关的arrival phase number；也就是说，phase number用来确定到达状态。当所有任务都到达给定phase时，可以执行一个可选的函数，这个函数通过重写<code>onAdvance</code>方法实现，<strong>通常可以用来控制终止状态</strong>。重写此方法类似于为CyclicBarrier提供一个barrierAction，但比它更灵活。</li>
<li><strong>Waiting(等待机制)</strong> awaitAdvance方法需要一个表示arrival phase number的参数，并且在phaser前进到与给定phase不同的phase时返回。和CyclicBarrier不同，即使等待线程已经被中断，awaitAdvance方法也会一直等待。中断状态和超时时间同样可用，但是<strong>当任务等待中断或超时后未改变phaser的状态时会遭遇异常</strong>。如果有必要，<strong>在方法forceTermination之后可以执行这些异常的相关的handler进行恢复操作，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务</strong>。</li>
</ul>
</blockquote>
<h6 id="3、Termination-终止机制"><a href="#3、Termination-终止机制" class="headerlink" title="3、Termination(终止机制)"></a>3、<strong>Termination(终止机制)</strong></h6><p>可以用isTerminated方法检查phaser的终止状态。<strong>在终止时，所有同步方法立刻返回一个负值</strong>。在终止时尝试注册也没有效果。当调用onAdvance返回true时Termination被触发。当deregistration操作使已注册的parties变为0时，onAdvance的默认实现就会返回true。也可以重写onAdvance方法来定义终止动作。forceTermination方法也可以释放等待线程并且允许它们终止。</p>
<h6 id="4、Tiering-分层结构"><a href="#4、Tiering-分层结构" class="headerlink" title="4、Tiering(分层结构)"></a>4、<strong>Tiering(分层结构)</strong></h6><p><strong>Phaser支持分层结构(树状构造)来减少竞争</strong>。注册了大量parties的Phaser可能会因为同步竞争消耗很高的成本， 因此可以设置一些子Phaser来共享一个通用的parent。这样的话即使每个操作消耗了更多的开销，但是会提高整体吞吐量。 在一个分层结构的phaser里，子节点phaser的注册和取消注册都通过父节点管理。子节点phaser通过构造或方法register、bulkRegister进行首次注册时，在其父节点上注册。子节点phaser通过调用arriveAndDeregister进行最后一次取消注册时，也在其父节点上取消注册。</p>
<h6 id="5、Monitoring-状态监控"><a href="#5、Monitoring-状态监控" class="headerlink" title="5、Monitoring(状态监控)"></a>5、<strong>Monitoring(状态监控)</strong></h6><p>由于同步方法可能只被已注册的parties调用，所以phaser的当前状态也可能被任何调用者监控。在任何时候，可以通过getRegisteredParties获取parties数，其中getArrivedParties方法返回已经到达当前phase的parties数。当剩余的parties(通过方法getUnarrivedParties获取)到达时，phase进入下一代。这些方法返回的值可能只表示短暂的状态，所以一般来说在同步结构里并没有啥卵用。</p>
<h5 id="3、Phaser源码详解"><a href="#3、Phaser源码详解" class="headerlink" title="3、Phaser源码详解"></a>3、Phaser源码详解</h5><h6 id="1、核心参数"><a href="#1、核心参数" class="headerlink" title="1、核心参数"></a>1、核心参数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The parent of this phaser, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser parent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root of phaser tree. Equals this if not in a tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser root;</span><br><span class="line"><span class="comment">//等待线程的栈顶元素，根据phase取模定义为一个奇数header和一个偶数header</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;</span><br></pre></td></tr></table></figure>

<p>state状态说明：Phaser使用一个long型state值来标识内部状态：</p>
<ul>
<li><strong>低0-15位表示未到达parties数</strong>；</li>
<li><strong>中16-31位表示等待的parties数</strong>；</li>
<li><strong>中32-62位表示phase当前代</strong>；</li>
<li><strong>高63位表示当前phaser的终止状态</strong>。</li>
</ul>
<p>注意：子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。这里在后面源码分析的reconcileState方法里会讲解。 Qnode是Phaser定义的内部等待队列，用于在阻塞时记录等待线程及相关信息。实现了ForkJoinPool的一个内部接口ManagedBlocker，上面已经说过，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务(通过内部实现方法isReleasable和block)。</p>
<h6 id="2、函数列表"><a href="#2、函数列表" class="headerlink" title="2、函数列表"></a>2、函数列表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parent, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注册一个新的party</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//批量注册</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulkRegister</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程到达phaser并撤销注册，返回arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndDeregister</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//等待给定phase数，返回下一个 arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function"><span class="comment">//阻塞等待，直到phase前进到下一代，返回下一代的phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//响应中断版awaitAdvance</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//使当前phaser进入终止状态，已注册的parties不受影响，如果是分层结构，则终止所有phaser</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceTermination</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h6 id="3、方法——register"><a href="#3、方法——register" class="headerlink" title="3、方法——register()"></a>3、方法——register()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个新的party</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRegister</span><span class="params">(<span class="keyword">int</span> registrations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// adjustment to state</span></span><br><span class="line">    <span class="keyword">long</span> adjust = ((<span class="keyword">long</span>)registrations &lt;&lt; PARTIES_SHIFT) | registrations;</span><br><span class="line">    <span class="keyword">final</span> Phaser parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (parent == <span class="keyword">null</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> parties = counts &gt;&gt;&gt; PARTIES_SHIFT;<span class="comment">//获取已注册parties数</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = counts &amp; UNARRIVED_MASK;<span class="comment">//未到达数</span></span><br><span class="line">        <span class="keyword">if</span> (registrations &gt; MAX_PARTIES - parties)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badRegister(s));</span><br><span class="line">        phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);<span class="comment">//获取当前代</span></span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (counts != EMPTY) &#123;                  <span class="comment">// not 1st registration</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span> || reconcileState() == s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unarrived == <span class="number">0</span>)             <span class="comment">// wait out advance</span></span><br><span class="line">                    root.internalAwaitAdvance(phase, <span class="keyword">null</span>);<span class="comment">//等待其他任务到达</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                                   s, s + adjust))<span class="comment">//更新注册的parties数</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;              <span class="comment">// 1st root registration</span></span><br><span class="line">            <span class="keyword">long</span> next = ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, next))<span class="comment">//更新phase</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分层结构，子phaser首次注册用父节点管理</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;               <span class="comment">// 1st sub registration</span></span><br><span class="line">                <span class="keyword">if</span> (state == s) &#123;               <span class="comment">// recheck under lock</span></span><br><span class="line">                    phase = parent.doRegister(<span class="number">1</span>);<span class="comment">//分层结构，使用父节点注册</span></span><br><span class="line">                    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// finish registration whenever parent registration</span></span><br><span class="line">                    <span class="comment">// succeeded, even when racing with termination,</span></span><br><span class="line">                    <span class="comment">// since these are part of the same &quot;transaction&quot;.</span></span><br><span class="line">                    <span class="comment">//由于在同一个事务里，即使phaser已终止，也会完成注册</span></span><br><span class="line">                    <span class="keyword">while</span> (!UNSAFE.compareAndSwapLong</span><br><span class="line">                           (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                            ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust)) &#123;<span class="comment">//更新phase</span></span><br><span class="line">                        s = state;</span><br><span class="line">                        phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">                        <span class="comment">// assert (int)s == EMPTY;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：register方法为phaser添加一个新的party，如果onAdvance正在运行，那么这个方法会等待它运行结束再返回结果。如果当前phaser有父节点，并且当前phaser上没有已注册的party，那么就会交给父节点注册。</p>
<p>register和bulkRegister都由doRegister实现，大概流程如下：</p>
<ul>
<li><p>如果当前操作不是首次注册，那么直接在当前phaser上更新注册parties数</p>
</li>
<li><p>如果是首次注册，并且当前phaser没有父节点，说明是root节点注册，直接更新phase</p>
</li>
<li><p>如果当前操作是首次注册，并且当前phaser由父节点，则注册操作交由父节点，并更新当前phaser的phase</p>
</li>
<li><p>上面说过，子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。非首次注册时，如果Phaser有父节点，则调用reconcileState()方法解决root节点的phase延迟传递问题， 源码如下：</p>
<ul>
<li><pre><code class="java">private long reconcileState() &#123;
    final Phaser root = this.root;
    long s = state;
    if (root != this) &#123;
        int phase, p;
        // CAS to root phase with current parties, tripping unarrived
        while ((phase = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT)) !=
               (int)(s &gt;&gt;&gt; PHASE_SHIFT) &amp;&amp;
               !UNSAFE.compareAndSwapLong
               (this, stateOffset, s,
                s = (((long)phase &lt;&lt; PHASE_SHIFT) |
                     ((phase &lt; 0) ? (s &amp; COUNTS_MASK) :
                      (((p = (int)s &gt;&gt;&gt; PARTIES_SHIFT) == 0) ? EMPTY :
                       ((s &amp; PARTIES_MASK) | p))))))
            s = state;
    &#125;
    return s;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当root节点的phase已经advance到下一代，但是子节点phaser还没有，这种情况下它们必须通过更新未到达parties数完成它们自己的advance操作(如果parties为0，重置为EMPTY状态)。</span><br><span class="line"></span><br><span class="line">- 回到register方法的第一步，如果当前未到达数为0，说明上一代phase正在进行到达操作，此时调用internalAwaitAdvance()方法等待其他任务完成到达操作，源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;阻塞等待phase到下一代</span><br><span class="line">    private int internalAwaitAdvance(int phase, QNode node) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert root &#x3D;&#x3D; this;</span><br><span class="line">        releaseWaiters(phase-1);          &#x2F;&#x2F; ensure old queue clean</span><br><span class="line">        boolean queued &#x3D; false;           &#x2F;&#x2F; true when node is enqueued</span><br><span class="line">        int lastUnarrived &#x3D; 0;            &#x2F;&#x2F; to increase spins upon change</span><br><span class="line">        int spins &#x3D; SPINS_PER_ARRIVAL;</span><br><span class="line">        long s;</span><br><span class="line">        int p;</span><br><span class="line">        while ((p &#x3D; (int)((s &#x3D; state) &gt;&gt;&gt; PHASE_SHIFT)) &#x3D;&#x3D; phase) &#123;</span><br><span class="line">            if (node &#x3D;&#x3D; null) &#123;           &#x2F;&#x2F; spinning in noninterruptible mode</span><br><span class="line">                int unarrived &#x3D; (int)s &amp; UNARRIVED_MASK;&#x2F;&#x2F;未到达数</span><br><span class="line">                if (unarrived !&#x3D; lastUnarrived &amp;&amp;</span><br><span class="line">                    (lastUnarrived &#x3D; unarrived) &lt; NCPU)</span><br><span class="line">                    spins +&#x3D; SPINS_PER_ARRIVAL;</span><br><span class="line">                boolean interrupted &#x3D; Thread.interrupted();</span><br><span class="line">                if (interrupted || --spins &lt; 0) &#123; &#x2F;&#x2F; need node to record intr</span><br><span class="line">                    &#x2F;&#x2F;使用node记录中断状态</span><br><span class="line">                    node &#x3D; new QNode(this, phase, false, false, 0L);</span><br><span class="line">                    node.wasInterrupted &#x3D; interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (node.isReleasable()) &#x2F;&#x2F; done or aborted</span><br><span class="line">                break;</span><br><span class="line">            else if (!queued) &#123;           &#x2F;&#x2F; push onto queue</span><br><span class="line">                AtomicReference&lt;QNode&gt; head &#x3D; (phase &amp; 1) &#x3D;&#x3D; 0 ? evenQ : oddQ;</span><br><span class="line">                QNode q &#x3D; node.next &#x3D; head.get();</span><br><span class="line">                if ((q &#x3D;&#x3D; null || q.phase &#x3D;&#x3D; phase) &amp;&amp;</span><br><span class="line">                    (int)(state &gt;&gt;&gt; PHASE_SHIFT) &#x3D;&#x3D; phase) &#x2F;&#x2F; avoid stale enq</span><br><span class="line">                    queued &#x3D; head.compareAndSet(q, node);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ForkJoinPool.managedBlock(node);&#x2F;&#x2F;阻塞给定node</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    node.wasInterrupted &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            if (node.thread !&#x3D; null)</span><br><span class="line">                node.thread &#x3D; null;       &#x2F;&#x2F; avoid need for unpark()</span><br><span class="line">            if (node.wasInterrupted &amp;&amp; !node.interruptible)</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            if (p &#x3D;&#x3D; phase &amp;&amp; (p &#x3D; (int)(state &gt;&gt;&gt; PHASE_SHIFT)) &#x3D;&#x3D; phase)</span><br><span class="line">                return abortWait(phase); &#x2F;&#x2F; possibly clean up on abort</span><br><span class="line">        &#125;</span><br><span class="line">        releaseWaiters(phase);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>简单介绍下<strong>第二个参数node，如果不为空，则说明等待线程需要追踪中断状态或超时状态</strong>。以doRegister中的调用为例，不考虑线程争用，internalAwaitAdvance大概流程如下：</p>
<ul>
<li>首先调用releaseWaiters唤醒上一代所有等待线程，确保旧队列中没有遗留的等待线程。</li>
<li>循环SPINS_PER_ARRIVAL指定的次数或者当前线程被中断，创建node记录等待线程及相关信息。</li>
<li>继续循环调用ForkJoinPool.managedBlock运行被阻塞的任务</li>
<li>继续循环，阻塞任务运行成功被释放，跳出循环</li>
<li>最后唤醒当前phase的线程</li>
</ul>
</li>
</ul>
<h6 id="4、方法——arrive"><a href="#4、方法——arrive" class="headerlink" title="4、方法——arrive()"></a>4、方法——arrive()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doArrive(ONE_ARRIVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doArrive</span><span class="params">(<span class="keyword">int</span> adjust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="comment">//获取未到达数</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);</span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, s-=adjust)) &#123;<span class="comment">//更新state</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived == <span class="number">1</span>) &#123;<span class="comment">//当前为最后一个未到达的任务</span></span><br><span class="line">                <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">                <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))<span class="comment">//检查是否需要终止phaser</span></span><br><span class="line">                        n |= TERMINATION_BIT;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                        n |= EMPTY;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        n |= nextUnarrived;</span><br><span class="line">                    <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;</span><br><span class="line">                    n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n);</span><br><span class="line">                    releaseWaiters(phase);<span class="comment">//释放等待phase的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//分层结构，使用父节点管理arrive</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>) &#123; <span class="comment">//propagate deregistration</span></span><br><span class="line">                    phase = parent.doArrive(ONE_DEREGISTER);</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                              s, s | EMPTY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    phase = parent.doArrive(ONE_ARRIVAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>arrive方法手动调整到达数，使当前线程到达phaser</strong>。arrive和arriveAndDeregister都调用了doArrive实现，大概流程如下：</p>
<ul>
<li>首先更新state(state - adjust)；</li>
<li>如果当前不是最后一个未到达的任务，直接返回phase</li>
<li>如果当前是最后一个未到达的任务：<ul>
<li>如果当前是root节点，判断是否需要终止phaser，CAS更新phase，最后释放等待的线程；</li>
<li>如果是分层结构，并且已经没有下一代未到达的parties，则交由父节点处理doArrive逻辑，然后更新state为EMPTY。</li>
</ul>
</li>
</ul>
<h6 id="5、方法——arriveAndAwaitAdvance"><a href="#5、方法——arriveAndAwaitAdvance" class="headerlink" title="5、方法——arriveAndAwaitAdvance()"></a>5、方法——arriveAndAwaitAdvance()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Specialization of doArrive+awaitAdvance eliminating some reads/paths</span></span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);<span class="comment">//获取未到达数</span></span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                                      s -= ONE_ARRIVAL)) &#123;<span class="comment">//更新state</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);<span class="comment">//阻塞等待其他任务</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> parent.arriveAndAwaitAdvance();<span class="comment">//子Phaser交给父节点处理</span></span><br><span class="line">            <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">            <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))<span class="comment">//全部到达，检查是否可销毁</span></span><br><span class="line">                n |= TERMINATION_BIT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                n |= EMPTY;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n |= nextUnarrived;</span><br><span class="line">            <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;<span class="comment">//计算下一代phase</span></span><br><span class="line">            n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (!UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n))<span class="comment">//更新state</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT); <span class="comment">// terminated</span></span><br><span class="line">            releaseWaiters(phase);<span class="comment">//释放等待phase的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextPhase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。效果类似于CyclicBarrier.await</strong>。大概流程如下：</p>
<ul>
<li>更新state(state - 1)；</li>
<li>如果未到达数大于1，调用internalAwaitAdvance阻塞等待其他任务到达，返回当前phase</li>
<li>如果为分层结构，则交由父节点处理arriveAndAwaitAdvance逻辑</li>
<li>如果未到达数&lt;=1，判断phaser终止状态，CAS更新phase到下一代，最后释放等待当前phase的线程，并返回下一代phase。</li>
</ul>
<h6 id="6、方法——awaitAdvance-int-phase"><a href="#6、方法——awaitAdvance-int-phase" class="headerlink" title="6、方法——awaitAdvance(int phase)"></a>6、方法——awaitAdvance(int phase)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase)</span><br><span class="line">        <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应中断版awaitAdvance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase) &#123;</span><br><span class="line">        QNode node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        p = root.internalAwaitAdvance(phase, node);</span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>awaitAdvance用于阻塞等待线程到达，直到phase前进到下一代，返回下一代的phase number</strong>。方法很简单，不多赘述。awaitAdvanceInterruptibly方法是响应中断版的awaitAdvance，不同之处在于，调用阻塞时会记录线程的中断状态。</p>
<h4 id="5、Exchanger-交换器"><a href="#5、Exchanger-交换器" class="headerlink" title="5、Exchanger(交换器)"></a>5、Exchanger(交换器)</h4><p>Exchanger是用于线程协作的工具类，<strong>主要用于两个线程之间的数据交换</strong>。</p>
<h5 id="1、BAT大厂的面试问题-20"><a href="#1、BAT大厂的面试问题-20" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h5><ul>
<li>Exchanger主要解决什么问题？</li>
<li>对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式？</li>
<li>Exchanger在不同的JDK版本中实现有什么差别？</li>
<li>Exchanger实现机制？</li>
<li>Exchanger已经有了slot单节点，为什么会加入arena node数组？什么时候会用到数组？</li>
<li>arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？</li>
<li>什么是伪共享，Exchanger中如何体现的？</li>
<li>Exchanger实现举例</li>
</ul>
<h5 id="2、Exchanger简介"><a href="#2、Exchanger简介" class="headerlink" title="2、Exchanger简介"></a>2、Exchanger简介</h5><p><strong>Exchanger用于进行两个线程之间的数据交换</strong>。它提供一个==同步点==，在这个同步点，两个线程可以交换彼此的数据。<strong>这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</strong></p>
<h5 id="3、Exchanger实现机制"><a href="#3、Exchanger实现机制" class="headerlink" title="3、Exchanger实现机制"></a>3、Exchanger实现机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slot is empty) &#123; <span class="comment">// offer</span></span><br><span class="line">        <span class="comment">// slot为空时，将item 设置到Node 中        </span></span><br><span class="line">        place item in a Node;</span><br><span class="line">        <span class="keyword">if</span> (can CAS slot from empty to node) &#123;</span><br><span class="line">            <span class="comment">// 当将node通过CAS交换到slot中时，挂起线程等待被唤醒</span></span><br><span class="line">            wait <span class="keyword">for</span> release;</span><br><span class="line">            <span class="comment">// 被唤醒后返回node中匹配到的item</span></span><br><span class="line">            <span class="keyword">return</span> matching item in node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (can CAS slot from node to empty) &#123; <span class="comment">// release</span></span><br><span class="line">         <span class="comment">// 将slot设置为空</span></span><br><span class="line">        <span class="comment">// 获取node中的item，将需要交换的数据设置到匹配的item</span></span><br><span class="line">        get the item in node;</span><br><span class="line">        set matching item in node;</span><br><span class="line">        <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        release waiting thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else retry on CAS failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如有2条线程A和B，A线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程B进来，读取A设置的数据，然后设置线程B需要交换的数据，然后唤醒A线程，原理就是这么简单。但是<strong>当多个线程之间进行交换数据时就会出现问题，所以Exchanger加入了arena数组</strong>。</p>
<h5 id="4、Exchanger源码解析"><a href="#4、Exchanger源码解析" class="headerlink" title="4、Exchanger源码解析"></a>4、Exchanger源码解析</h5><h6 id="1、内部类——Participant"><a href="#1、内部类——Participant" class="headerlink" title="1、内部类——Participant"></a>1、内部类——Participant</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Participant的作用是<strong>为每个线程保留唯一的一个Node节点，它继承ThreadLocal，说明每个线程具有不同的状态。</strong></p>
<h6 id="2、内部类——Node"><a href="#2、内部类——Node" class="headerlink" title="2、内部类——Node"></a>2、内部类——Node</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="comment">// arena的下标，多个槽位的时候利用</span></span><br><span class="line">    <span class="keyword">int</span> index; </span><br><span class="line">    <span class="comment">// 上一次记录的Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> bound; </span><br><span class="line">    <span class="comment">// 在当前bound下CAS失败的次数；</span></span><br><span class="line">    <span class="keyword">int</span> collides;</span><br><span class="line">    <span class="comment">// 用于自旋；</span></span><br><span class="line">    <span class="keyword">int</span> hash; </span><br><span class="line">    <span class="comment">// 这个线程的当前项，也就是需要交换的数据；</span></span><br><span class="line">    Object item; </span><br><span class="line">    <span class="comment">//做releasing操作的线程传递的项；</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match; </span><br><span class="line">    <span class="comment">//挂起时设置线程值，其他情况下为null；</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Node定义中有两个变量值得思考：<code>bound</code>以及<code>collides</code>。前面提到了<strong>数组area是为了避免竞争而产生的，如果系统不存在竞争问题，那么完全没有必要开辟一个高效的arena来徒增系统的复杂性</strong>。</p>
<ol>
<li>首先通过单个slot的exchanger来交换数据，当探测到竞争时将安排不同的位置的slot来保存线程Node，并且可以确保没有slot会在同一个缓存行上。</li>
<li>如何来判断会有竞争呢？<ul>
<li>CAS替换slot失败，如果失败，则通过记录冲突次数来扩展arena的尺寸，我们在记录冲突的过程中会跟踪“bound”的值，以及会重新计算在bound的值被改变时的冲突次数。</li>
</ul>
</li>
</ol>
<h6 id="3、核心属性-1"><a href="#3、核心属性-1" class="headerlink" title="3、核心属性"></a>3、核心属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Participant participant;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node slot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>**为什么会有 <code>arena数组槽</code>**？</p>
<ul>
<li>slot为单个槽，arena为数组槽，他们都是Node类型。</li>
<li>在这里可能会感觉到疑惑，slot作为Exchanger交换数据的场景，应该只需要一个就可以了啊？为何还多了一个Participant和数组类型的arena呢？</li>
<li>一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重==伸缩性问题==。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。</li>
<li><strong>通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。</strong>但是**Exchanger不是一来就会生成arena数组来降低竞争，==只有当产生竞争是才会生成arena数组==**。</li>
</ul>
</li>
<li><p><strong>那么怎么将Node与当前线程绑定呢？</strong></p>
<ul>
<li>Participant，<strong>Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中记录在arena中的下标index。</strong></li>
</ul>
</li>
</ul>
<h6 id="4、构造函数-1"><a href="#4、构造函数-1" class="headerlink" title="4、构造函数"></a>4、构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a new Exchanger.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化participant对象。</p>
<h6 id="5、核心方法——exchange-V-x"><a href="#5、核心方法——exchange-V-x" class="headerlink" title="5、核心方法——exchange(V x)"></a>5、核心方法——exchange(V x)</h6><p><strong>等待另一个线程到达此交换点(除非当前线程被中断)，然后将给定的对象传送给该线程，并接收该线程的对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 当参数为null时需要将item设置为空的对象</span></span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="comment">// 注意到这里的这个表达式是整个方法的核心</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">            (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0</span> L)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// disambiguates null return</span></span><br><span class="line">            (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0</span> L)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V) v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较好理解：</p>
<ul>
<li>arena为数组槽，如果为null，则执行slotExchange()方法，</li>
<li>否则判断线程是否中断，如果中断值抛出InterruptedException异常，</li>
<li>没有中断则执行arenaExchange()方法。</li>
</ul>
<p>整套逻辑就是：如果slotExchange(Object item, boolean timed, long ns)方法执行失败了就执行arenaExchange(Object item, boolean timed, long ns)方法，最后返回结果V。</p>
<p><strong><code>NULL_ITEM</code> 为一个空节点，其实就是一个Object对象而已，slotExchange()为单个slot交换</strong>。</p>
<h6 id="6、slotExchange-Object-item-boolean-timed-long-ns"><a href="#6、slotExchange-Object-item-boolean-timed-long-ns" class="headerlink" title="6、slotExchange(Object item, boolean timed, long ns)"></a>6、slotExchange(Object item, boolean timed, long ns)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程node对象</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 若果线程被中断，就直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="comment">// 将slot值赋给q</span></span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line">			<span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// CAS操作成功后，将slot中的item赋值给对象v，以便返回。</span></span><br><span class="line">                <span class="comment">// 这里也是就读取之前线程要交换的数据</span></span><br><span class="line">                Object v = q.item;</span><br><span class="line">                <span class="comment">// 将当前线程需要交给的数据设置在q中的match</span></span><br><span class="line">                q.match = item;</span><br><span class="line">                 <span class="comment">// 获取被挂起的线程</span></span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果线程不为null，唤醒它</span></span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="comment">// 返回其他线程给的V</span></span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="comment">// CAS 操作失败，表示有其它线程竞争，在此线程之前将数据已取走</span></span><br><span class="line">            <span class="comment">// NCPU:CPU的核数</span></span><br><span class="line">            <span class="comment">// bound == 0 表示arena数组未初始化过，CAS操作bound将其增加SEQ</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                <span class="comment">// 初始化arena数组</span></span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面分析过，只有当arena不为空才会执行slotExchange方法的</span></span><br><span class="line">		<span class="comment">// 所以表示刚好已有其它线程加入进来将arena初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 这里就需要去执行arenaExchange</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里表示当前线程是以第一个线程进来交换数据</span></span><br><span class="line">            <span class="comment">// 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程</span></span><br><span class="line">            <span class="comment">// 将需要交换的数据先存放在当前线程变量p中</span></span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="comment">// 将需要交换的数据通过CAS设置到交换区slot</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="comment">// 交换成功后跳出自旋</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot</span></span><br><span class="line">            <span class="comment">// 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="comment">// 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，</span></span><br><span class="line">    <span class="comment">// 等待其它线程交换数据然后唤醒当前线程</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0</span> L;</span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot</span></span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 下面的逻辑主要是自旋等待，直到spins递减到0为止</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            h ^= h &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>) t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="comment">// 此处表示未设置超时或者时间未超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0</span> L)) &#123;</span><br><span class="line">            <span class="comment">// 设置线程t被当前对象阻塞</span></span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 给p挂机线程的值赋值</span></span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                <span class="comment">// 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            <span class="comment">// 线程被唤醒，将被挂起的线程设置为null</span></span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 设置线程t未被任何对象阻塞</span></span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 不是以上条件时(可能是arena已不为null或者超时)    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">             <span class="comment">// arena不为null则v为null,其它为超时则v为超市对象TIMED_OUT，并且跳出循环</span></span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0</span> L &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取走match值，并将p中的match置为null</span></span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置item为null</span></span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="comment">// 返回交换值</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先通过participant获取当前线程节点Node。检测是否中断，如果中断return null，等待后续抛出InterruptedException异常。</p>
<ul>
<li>如果slot不为null，则进行slot消除，成功直接返回数据V，否则失败，则创建arena消除数组。</li>
<li>如果slot为null，但arena不为null，则返回null，进入arenaExchange逻辑。</li>
<li>如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入<code>spin+block</code>(自旋+阻塞)模式。</li>
</ul>
<p>在自旋+阻塞模式中，<strong>首先取得结束时间和自旋次数</strong>。</p>
<ul>
<li>如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋(改自旋使用当前节点中的hash，并改变之)和退让。</li>
<li>当自旋数为0后，假如slot发生了改变(slot != p)则重置自旋数并重试。</li>
<li>否则<ul>
<li>假如：当前未中断&amp;arena为null&amp;(当前不是限时版本或者限时版本+当前时间未结束)：阻塞或者限时阻塞。</li>
<li>假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：<ul>
<li>不限时版本：置v为null；</li>
<li>限时版本：如果时间结束以及未中断则TIMED_OUT；</li>
</ul>
</li>
</ul>
</li>
<li>否则给出null(原因是探测到arena非空或者当前线程中断)。</li>
<li>match不为空时跳出循环。</li>
</ul>
<h6 id="7、arenaExchange-Object-item-boolean-timed-long-ns"><a href="#7、arenaExchange-Object-item-boolean-timed-long-ns" class="headerlink" title="7、arenaExchange(Object item, boolean timed, long ns)"></a>7、arenaExchange(Object item, boolean timed, long ns)</h6><p><strong>此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timed 为true表示设置了超时时间，ns为&gt;0的值，反之没有设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">arenaExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node[] a = arena;</span><br><span class="line">    <span class="comment">// 获取当前线程中的存放的node</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">//index初始值0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.index;;) &#123; <span class="comment">// access slot at i</span></span><br><span class="line">        <span class="comment">// 遍历，如果在数组中找到数据则直接交换并唤醒线程，如未找到则将需要交换给其它线程的数据放置于数组中</span></span><br><span class="line">        <span class="keyword">int</span> b, m, c;</span><br><span class="line">        <span class="keyword">long</span> j; <span class="comment">// j is raw array offset</span></span><br><span class="line">        <span class="comment">// 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量</span></span><br><span class="line">        <span class="comment">// q实际为arena数组偏移(i + 1) *  128个地址位上的node</span></span><br><span class="line">        Node q = (Node) U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">        <span class="comment">// 如果q不为null，并且CAS操作成功，将下标j的元素置为null</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; U.compareAndSwapObject(a, j, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程</span></span><br><span class="line">            Object v = q.item; <span class="comment">// release</span></span><br><span class="line">            q.match = item;</span><br><span class="line">            Thread w = q.parked;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(w);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        <span class="comment">// q 为null 并且 i 未超过数组边界    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 将需要给其它线程的item赋予给p中的item</span></span><br><span class="line">            p.item = item; <span class="comment">// offer</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, <span class="keyword">null</span>, p)) &#123;</span><br><span class="line">                <span class="comment">// 交换成功</span></span><br><span class="line">                <span class="keyword">long</span> end = (timed &amp;&amp; m == <span class="number">0</span>) ? System.nanoTime() + ns : <span class="number">0</span> L;</span><br><span class="line">                Thread t = Thread.currentThread(); <span class="comment">// wait</span></span><br><span class="line">                <span class="comment">// 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = p.hash, spins = SPINS;;) &#123;</span><br><span class="line">                    Object v = p.match;</span><br><span class="line">                    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 其它线程设置的需要交换的数据match不为null</span></span><br><span class="line">                        <span class="comment">// 将match设置null,item设置为null</span></span><br><span class="line">                        U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>; <span class="comment">// clear for next use</span></span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        h ^= h &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        h ^= h &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">                        h ^= h &lt;&lt; <span class="number">10</span>; <span class="comment">// xorshift</span></span><br><span class="line">                        <span class="keyword">if</span> (h == <span class="number">0</span>) <span class="comment">// initialize hash</span></span><br><span class="line">                            h = SPINS | (<span class="keyword">int</span>) t.getId();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// approx 50% true</span></span><br><span class="line">                            (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                            Thread.yield(); <span class="comment">// two yields per wait</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) != p)</span><br><span class="line">                        <span class="comment">// 和slotExchange方法中的类似，arena数组中的数据已被CAS设置</span></span><br><span class="line">                       <span class="comment">// match值还未设置，让其再自旋等待match被设置</span></span><br><span class="line">                        spins = SPINS; <span class="comment">// releaser hasn&#x27;t set match yet</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; m == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (!timed ||</span><br><span class="line">                            (ns = end - System.nanoTime()) &gt; <span class="number">0</span> L)) &#123;</span><br><span class="line">                        <span class="comment">// 设置线程t被当前对象阻塞</span></span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">this</span>); <span class="comment">// emulate LockSupport</span></span><br><span class="line">                         <span class="comment">// 线程t赋值</span></span><br><span class="line">                        p.parked = t; <span class="comment">// minimize window</span></span><br><span class="line">                        <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                            <span class="comment">// 数组中对象还相等，表示线程还未被唤醒，唤醒线程</span></span><br><span class="line">                            U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">                        p.parked = <span class="keyword">null</span>;</span><br><span class="line">                         <span class="comment">// 设置线程t未被任何对象阻塞</span></span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                        U.compareAndSwapObject(a, j, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 这里给bound增加加一个SEQ</span></span><br><span class="line">                        <span class="keyword">if</span> (m != <span class="number">0</span>) <span class="comment">// try to shrink</span></span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ - <span class="number">1</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>;</span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        i = p.index &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// descend</span></span><br><span class="line">                        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (timed &amp;&amp; m == <span class="number">0</span> &amp;&amp; ns &lt;= <span class="number">0</span> L)</span><br><span class="line">                            <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// expired; restart</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 交换失败，表示有其它线程更改了arena数组中下标i的元素</span></span><br><span class="line">                p.item = <span class="keyword">null</span>; <span class="comment">// clear offer</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时表示下标不在bound &amp; MMASK或q不为null但CAS操作失败</span></span><br><span class="line">           <span class="comment">// 需要更新bound变化后的值</span></span><br><span class="line">            <span class="keyword">if</span> (p.bound != b) &#123; <span class="comment">// stale; reset</span></span><br><span class="line">                p.bound = b;</span><br><span class="line">                p.collides = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 反向遍历</span></span><br><span class="line">                i = (i != m || m == <span class="number">0</span>) ? m : m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                !U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ + <span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">// 记录CAS失败的次数</span></span><br><span class="line">                p.collides = c + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 循环遍历</span></span><br><span class="line">                i = (i == <span class="number">0</span>) ? m : i - <span class="number">1</span>; <span class="comment">// cyclically traverse</span></span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 此时表示bound值增加了SEQ+1</span></span><br><span class="line">                i = m + <span class="number">1</span>; <span class="comment">// grow</span></span><br><span class="line">            <span class="comment">// 设置下标</span></span><br><span class="line">            p.index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过participant取得当前节点Node，然后根据当前节点Node的index去取arena中相对应的节点node。</p>
<h5 id="5、前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？"><a href="#5、前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？" class="headerlink" title="5、前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？"></a>5、<strong>前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line"><span class="comment">// 这个arena到底有多大呢? 我们先看FULL 和ASHIFT的定义：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL = (NCPU &gt;= (MMASK &lt;&lt; <span class="number">1</span>)) ? MMASK : NCPU &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MMASK = <span class="number">0xff</span>;        <span class="comment">// 255</span></span><br><span class="line"><span class="comment">// 假如我的机器NCPU = 8 ，则得到的是768大小的arena数组。然后通过以下代码取得在arena中的节点：</span></span><br><span class="line"></span><br><span class="line">Node q = (Node)U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line"><span class="comment">// 它仍然是通过右移ASHIFT位来取得Node的，ABASE定义如下：</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">ABASE = U.arrayBaseOffset(ak) + (<span class="number">1</span> &lt;&lt; ASHIFT);</span><br><span class="line"><span class="comment">// U.arrayBaseOffset获取对象头长度，数组元素的大小可以通过unsafe.arrayIndexScale(T[].class) 方法获取到。这也就是说要访问类型为T的第N个元素的话，你的偏移量offset应该是arrayOffset+N*arrayScale。也就是说BASE = arrayOffset+ 128 。</span></span><br></pre></td></tr></table></figure>

<h5 id="6、用-sun-misc-Contended来规避伪共享？"><a href="#6、用-sun-misc-Contended来规避伪共享？" class="headerlink" title="6、用@sun.misc.Contended来规避伪共享？"></a>6、<strong>用@sun.misc.Contended来规避伪共享？</strong></h5><p><strong>伪共享说明</strong>：<strong>假设一个类的两个相互独立的属性a和b在内存地址上是连续的(比如FIFO队列的头尾指针)，那么它们通常会被加载到相同的cpu cache line里面。并发情况下，如果一个线程修改了a，会导致整个cache line失效(包括b)，这时另一个线程来读b，就需要从内存里再次加载了，这种多线程频繁修改ab的情况下，虽然a和b看似独立，但它们会互相干扰，非常影响性能。</strong>（在原子累加器篇也有伪共享问题的阐述）</p>
<p>我们再看Node节点的定义，在Java 8 中我们是可以利用sun.misc.Contended来规避伪共享的。所以说通过 &lt;&lt; ASHIFT方式加上sun.misc.Contended，所以使得任意两个可用Node不会再同一个缓存行中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再次回到arenaExchange()。取得arena中的node节点后，如果定位的节点q 不为空，且CAS操作成功，则交换数据，返回交换的数据，唤醒等待的线程。</p>
<ul>
<li>如果q等于null且下标在bound &amp; MMASK范围之内，则尝试占领该位置，如果成功，则采用自旋 + 阻塞的方式进行等待交换数据。</li>
<li>如果下标不在bound &amp; MMASK范围之内获取由于q不为null但是竞争失败的时候：消除p。加入bound 不等于当前节点的bond(b != p.bound)，则更新p.bound = b，collides = 0 ，i = m或者m - 1。如果冲突的次数不到m 获取m 已经为最大值或者修改当前bound的值失败，则通过增加一次collides以及循环递减下标i的值；否则更新当前bound的值成功：我们令i为m+1即为此时最大的下标。最后更新当前index的值。</li>
</ul>
<h5 id="7、更深入理解"><a href="#7、更深入理解" class="headerlink" title="7、更深入理解"></a>7、更深入理解</h5><h6 id="1、SynchronousQueue对比？"><a href="#1、SynchronousQueue对比？" class="headerlink" title="1、SynchronousQueue对比？"></a>1、<strong>SynchronousQueue对比？</strong></h6><p>Exchanger是一种线程间安全交换数据的机制。可以和之前分析过的SynchronousQueue对比一下：</p>
<ul>
<li>线程A通过SynchronousQueue将数据a交给线程B；</li>
<li>线程A通过Exchanger和线程B交换数据，线程A把数据a交给线程B，同时线程B把数据b交给线程A。</li>
</ul>
<p>可见，SynchronousQueue是交给一个数据，Exchanger是交换两个数据。</p>
<h6 id="2、不同JDK实现有何差别？"><a href="#2、不同JDK实现有何差别？" class="headerlink" title="2、不同JDK实现有何差别？"></a>2、<strong>不同JDK实现有何差别？</strong></h6><ul>
<li><strong>在JDK5中Exchanger被设计成一个容量为1的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程。</strong></li>
<li><strong>从JDK6开始，Exchanger用了类似ConcurrentMap的分段思想，提供了多个slot，增加了并发执行时的吞吐量</strong>。</li>
</ul>
<h5 id="8、Exchanger示例"><a href="#8、Exchanger示例" class="headerlink" title="8、Exchanger示例"></a>8、Exchanger示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">        Producer(String name, Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">&quot;Producer-&quot;</span> + name);</span><br><span class="line">            <span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    data = i;</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot; 交换前:&quot;</span> + data);</span><br><span class="line">                    data = exchanger.exchange(data);</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot; 交换后:&quot;</span> + data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">        Consumer(String name, Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">&quot;Consumer-&quot;</span> + name);</span><br><span class="line">            <span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                data = <span class="number">0</span>;</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot; 交换前:&quot;</span> + data);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    data = exchanger.exchange(data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot; 交换后:&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">&quot;&quot;</span>, exchanger).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(<span class="string">&quot;&quot;</span>, exchanger).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其结果可能如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:1</span><br><span class="line">Consumer- 交换后:1</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Producer- 交换前:2</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:2</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:3</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:3</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:4</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:4</span><br><span class="line">Consumer- 交换前:0</span><br></pre></td></tr></table></figure>



<h3 id="16、ThreadPool线程池"><a href="#16、ThreadPool线程池" class="headerlink" title="16、ThreadPool线程池"></a>16、ThreadPool线程池</h3><h4 id="1、线程池简介"><a href="#1、线程池简介" class="headerlink" title="1、线程池简介"></a>1、线程池简介</h4><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销， 进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。 </p>
<h4 id="2、线程池的优势"><a href="#2、线程池的优势" class="headerlink" title="2、线程池的优势"></a>2、线程池的优势</h4><p>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量， 超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<h4 id="3、线程池的主要特点"><a href="#3、线程池的主要特点" class="headerlink" title="3、线程池的主要特点"></a>3、线程池的主要特点</h4><ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>:线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java 中的线程池是通过 <strong>Executor 框架</strong>实现的，该框架中用到了 <code>Executor</code>，<code>Executors</code>， <code>ExecutorService</code>，<code>ThreadPoolExecutor</code> 这几个类：</p>
<p><img src="/2021/07/19/JUC/image-20210728133227349.png" alt="image-20210728133227349"></p>
<h4 id="4、线程池参数说明"><a href="#4、线程池参数说明" class="headerlink" title="4、线程池参数说明"></a>4、线程池参数说明</h4><ul>
<li><code>corePoolSize</code>：线程池的核心线程数</li>
<li><code>maximumPoolSize</code>：能容纳的最大线程数</li>
<li><code>keepAliveTime</code>：空闲线程存活时间</li>
<li><code>unit</code>：存活的时间单位</li>
<li><code>workQueue</code>：存放提交但未执行任务的队列</li>
<li><code>threadFactory</code>：创建线程的工厂类</li>
<li><code>handler</code>：等待队列满后的拒绝策略</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210728134755032.png" alt="image-20210728134755032"></p>
<h4 id="5、拒绝策略-重点"><a href="#5、拒绝策略-重点" class="headerlink" title="5、拒绝策略(重点)"></a>5、拒绝策略(重点)</h4><p>线程池中，有三个重要的参数，决定影响了拒绝策略：<code>corePoolSize</code> - 核心线程数，也即最小的线程数。<code>workQueue</code> - 阻塞队列 。 <code>maximumPoolSize</code> -最大线程数。</p>
<p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>
<p>总结起来，也就是一句话，当提交的任务数大于（workQueue.size() + maximumPoolSize ），就会触发线程池的拒绝策略。</p>
<p>四种拒绝策略：</p>
<ul>
<li><code>CallerRunsPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大；</li>
<li><code>AbortPolicy</code>：丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。<strong>线程池默认的拒绝策略</strong>。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</li>
<li><code>DiscardPolicy</code>：直接丢弃，其他啥都没有；</li>
<li><code>DiscardOldestPolicy</code>：当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入 </li>
</ul>
<p>除了线程池给的四种拒绝策略的实现，其他著名框架也提供了拒绝策略实现：</p>
<ul>
<li><code>Dubbo</code> 的实现：在抛出 <code>RejectedExecutionException</code> 异常之前<strong>会记录日志</strong>，并 <strong>dump 线程栈信息</strong>，<strong>方便定位问题</strong></li>
<li><code>Netty</code> 的实现：<strong>创建一个新线程来执行任务</strong></li>
<li><code>ActiveMQ</code> 的实现：<strong>带超时等待（60s）尝试放入队列</strong>，类似我们之前自定义的拒绝策略</li>
<li><code>PinPoint</code> 的实现：它使用了一个<strong>拒绝策略链</strong>，会<strong>逐一尝试策略链中每种拒绝策略</strong></li>
</ul>
<h4 id="6、线程池的种类与创建"><a href="#6、线程池的种类与创建" class="headerlink" title="6、线程池的种类与创建"></a>6、线程池的种类与创建</h4><ul>
<li><p>newCachedThreadPool——线程池根据需求创建线程，可扩容，遇强则强</p>
<ul>
<li><p>作用：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p>特点：</p>
<ul>
<li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li>
<li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li>
<li>当线程池中，没有可用线程，会重新创建一个线程</li>
</ul>
</li>
<li><p>创建方式：</p>
<ul>
<li><pre><code class="java">/**
  *    可缓存线程池
  * @return
  */
public static ExecutorService newCachedThreadPool()&#123;
    /**
    *    corePoolSize 线程池的核心线程数
    *    maximumPoolSize 能容纳的最大线程数
    *    keepAliveTime 空闲线程存活时间
    *    unit 存活的时间单位
    *    workQueue 存放提交但未执行任务的队列
    *    threadFactory 创建线程的工厂类:可以省略
    *    handler 等待队列满后的拒绝策略:可以省略
    */ 
    return new ThreadPoolExecutor(0, 
           Integer.MAX_VALUE, 
           60L,                        
           TimeUnit.SECONDS,                        
           new SynchronousQueue&lt;&gt;(),                        
           Executors.defaultThreadFactory(),                       
           new ThreadPoolExecutor.AbortPolicy());
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 场景：适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景 </span><br><span class="line"></span><br><span class="line">- newFixedThreadPool——一池N线程</span><br><span class="line"></span><br><span class="line">  - 作用：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</span><br><span class="line"></span><br><span class="line">  - 特点：</span><br><span class="line"></span><br><span class="line">    - 线程池中的线程处于一定的量，可以很好的控制线程的并发量</span><br><span class="line">    - 线程可以重复被使用，在显示关闭之前，都将一直存在</span><br><span class="line">    - 超出一定量的线程被提交时候需在队列中等待</span><br><span class="line"></span><br><span class="line">  - 创建方式：</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      &#x2F;**</span><br><span class="line">        *	固定长度线程池</span><br><span class="line">        * @return</span><br><span class="line">        *&#x2F;</span><br><span class="line">      public static ExecutorService newCachedThreadPool()&#123;</span><br><span class="line">          &#x2F;**</span><br><span class="line">          *	corePoolSize 线程池的核心线程数</span><br><span class="line">          *	maximumPoolSize 能容纳的最大线程数</span><br><span class="line">          *	keepAliveTime 空闲线程存活时间</span><br><span class="line">          *	unit 存活的时间单位</span><br><span class="line">          *	workQueue 存放提交但未执行任务的队列</span><br><span class="line">          *	threadFactory 创建线程的工厂类:可以省略</span><br><span class="line">          *	handler 等待队列满后的拒绝策略:可以省略</span><br><span class="line">          *&#x2F; </span><br><span class="line">          return new ThreadPoolExecutor(10, </span><br><span class="line">                 Integer.MAX_VALUE, </span><br><span class="line">                 0L,                        </span><br><span class="line">                 TimeUnit.SECONDS,                        </span><br><span class="line">                 new SynchronousQueue&lt;&gt;(),                        </span><br><span class="line">                 Executors.defaultThreadFactory(),                       </span><br><span class="line">                 new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>场景：适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p>
</li>
</ul>
</li>
<li><p>newSingleThreadExecutor——一个任务一个任务执行，一池一线程</p>
<ul>
<li><p>作用：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程， 那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。 </p>
</li>
<li><p>特点：线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行 </p>
</li>
<li><p>创建方式：</p>
<ul>
<li><pre><code class="java">/**
  *    单一线程池
  * @return
  */
public static ExecutorService newCachedThreadPool()&#123;
    /**
    *    corePoolSize 线程池的核心线程数
    *    maximumPoolSize 能容纳的最大线程数
    *    keepAliveTime 空闲线程存活时间
    *    unit 存活的时间单位
    *    workQueue 存放提交但未执行任务的队列
    *    threadFactory 创建线程的工厂类:可以省略
    *    handler 等待队列满后的拒绝策略:可以省略
    */ 
    return new ThreadPoolExecutor(1, 
           1, 
           0L,                        
           TimeUnit.SECONDS,                        
           new SynchronousQueue&lt;&gt;(),                        
           Executors.defaultThreadFactory(),                       
           new ThreadPoolExecutor.AbortPolicy());
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 场景：适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景 </span><br><span class="line"></span><br><span class="line">- newScheduleThreadPool(了解)——定时以及周期性执行任务线程池</span><br><span class="line"></span><br><span class="line">  - 作用：线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</span><br><span class="line"></span><br><span class="line">  - 特点：</span><br><span class="line"></span><br><span class="line">    - 线程池中具有指定数量的线程，即便是空线程也将保留</span><br><span class="line">    - 可定时或者延迟执行线程活动</span><br><span class="line"></span><br><span class="line">  - 创建方式：</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      public static ScheduledExecutorService newScheduledThreadPool</span><br><span class="line">          (int corePoolSize, ThreadFactory threadFactory) &#123; </span><br><span class="line">          return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); </span><br><span class="line">      &#125; </span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>场景：适用于需要多个后台线程执行周期任务的场景</p>
</li>
</ul>
</li>
<li><p>newWorkStealingPool——多个任务队列的线程池</p>
<ul>
<li><p>dk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个<strong>拥有多个任务队列的线程池</strong>，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p>
</li>
<li><p>创建方式：</p>
<ul>
<li><pre><code class="java">public static ExecutorService newWorkStealingPool(int parallelism) &#123;
    /**
    *    parallelism：并行级别，通常默认为 JVM 可用的处理器个数
    *    factory：用于创建 ForkJoinPool 中使用的线程。
    *    handler：用于处理工作线程未处理的异常，默认为 null
    *    asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列
    */ 
    return new ForkJoinPool(parallelism, 
                            ForkJoinPool.defaultForkJoinWorkerThreadFactory, 
                            null, 
                            true);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 场景：适用于大耗时，可并行执行的场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7、线程池底层的工作原理</span><br><span class="line"></span><br><span class="line">![10-线程池底层工作流程](JUC&#x2F;10-线程池底层工作流程.png)</span><br><span class="line"></span><br><span class="line">1. 在创建了线程池后，线程池中的线程数为零，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</span><br><span class="line">2. 当调用 execute()方法添加一个请求任务时，线程池会做出如下判断：</span><br><span class="line">   1.  如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</span><br><span class="line">   2. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入workQueue 队列； </span><br><span class="line">   3. 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务（救急）； </span><br><span class="line">   4. 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span><br><span class="line">3. 当一个线程完成任务时，它会从队列中取下一个任务来执行</span><br><span class="line">4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</span><br><span class="line">   1.  如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</span><br><span class="line">   2. 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</span><br><span class="line"></span><br><span class="line">![image-20210728141353731](JUC&#x2F;image-20210728141353731.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8、线程池的注意事项</span><br><span class="line"></span><br><span class="line">1. **线程的创建不是在创建线程池的时候创建，而是在执行execute()方法的时候，线程才真正地开始创建**；</span><br><span class="line">2. 项目中创建多线程时，使用常见的三种线程池创建方式，&#96;单一&#96;、&#96;可变&#96;、&#96;定长&#96;。但是它们都有一定问题，原因是 &#96;FixedThreadPool&#96; 和 &#96;SingleThreadExecutor&#96; 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，**容易导致 OOM**。**所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池**。</span><br><span class="line">3. 创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建：</span><br><span class="line">   - corePoolSize 线程池的核心线程数</span><br><span class="line">   - maximumPoolSize 能容纳的最大线程数</span><br><span class="line">   - keepAliveTime 空闲线程存活时间</span><br><span class="line">   - unit 存活的时间单位</span><br><span class="line">   - workQueue 存放提交但未执行任务的队列</span><br><span class="line">   - threadFactory 创建线程的工厂类</span><br><span class="line">   - handler 等待队列满后的拒绝策略</span><br><span class="line">4. 为什么不允许适用不允许 Executors.的方式手动创建线程池，如下图：</span><br><span class="line">   - ![image-20210728141417446](JUC&#x2F;image-20210728141417446.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 9、自定义线程池</span><br><span class="line"></span><br><span class="line">![image-20210810234602627](JUC&#x2F;image-20210810234602627.png)</span><br><span class="line"></span><br><span class="line">注意：以下的&#x3D;&#x3D;任务队列&#x3D;&#x3D;和&#x3D;&#x3D;拒绝策略的接口&#x3D;&#x3D;其实不用我们编写，可以使用JUC为我们提供的BlockingQueue，而拒绝策略的话，直接使用lambda表达式实现JUC提供好的拒绝策略接口中的reject方法即可。</span><br><span class="line"></span><br><span class="line">##### 1、步骤1：自定义任务队列</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">class BlockingQueue&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 任务队列</span><br><span class="line">    private Deque&lt;T&gt; queue &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 锁</span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3. 生产者条件变量</span><br><span class="line">    private Condition fullWaitSet &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 消费者条件变量</span><br><span class="line">    private Condition emptyWaitSet &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5. 容量</span><br><span class="line">    private int capcity;</span><br><span class="line"></span><br><span class="line">    public BlockingQueue(int capcity) &#123;</span><br><span class="line">        this.capcity &#x3D; capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带超时阻塞获取</span><br><span class="line">    public T poll(long timeout, TimeUnit unit) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将 timeout 统一转换为 纳秒 （时间统一管理）</span><br><span class="line">            long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">            while (queue.isEmpty()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 返回值是剩余时间</span><br><span class="line">                    if (nanos &lt;&#x3D; 0) &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 返回值是 等待时间-执行时间</span><br><span class="line">                    nanos &#x3D; emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t &#x3D; queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            return t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞获取</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.isEmpty()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t &#x3D; queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            return t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞添加</span><br><span class="line">    public void put(T task) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.size() &#x3D;&#x3D; capcity) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log.debug(&quot;等待加入任务队列 &#123;&#125; ...&quot;, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带超时时间阻塞添加</span><br><span class="line">    public boolean offer(T task, long timeout, TimeUnit timeUnit) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long nanos &#x3D; timeUnit.toNanos(timeout);</span><br><span class="line">            while (queue.size() &#x3D;&#x3D; capcity) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(nanos &lt;&#x3D; 0) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(&quot;等待加入任务队列 &#123;&#125; ...&quot;, task);</span><br><span class="line">                    nanos &#x3D; fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回等待队列的长度</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return queue.size();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 尝试放入阻塞队列，若不能放进阻塞队列，执行拒绝策略</span><br><span class="line">    public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断队列是否满</span><br><span class="line">            if(queue.size() &#x3D;&#x3D; capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(this, task);</span><br><span class="line">            &#125; else &#123;  &#x2F;&#x2F; 有空闲</span><br><span class="line">                log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2、步骤2：自定义拒绝策略接口"><a href="#2、步骤2：自定义拒绝策略接口" class="headerlink" title="2、步骤2：自定义拒绝策略接口"></a>2、步骤2：自定义拒绝策略接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拒绝策略 由于只有一个方法，可以使用函数式接口（lambda表达式）</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、步骤3：自定义线程池"><a href="#3、步骤3：自定义线程池" class="headerlink" title="3、步骤3：自定义线程池"></a>3、步骤3：自定义线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="comment">// 这里将线程进行进一步的封装，封装成Worker对象,有更多的操作空间</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间的单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，执行拒绝策略</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 将拒绝策略封装成一个接口交由调用者自己选择执行什么拒绝策略</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Worker的实现</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="comment">// 任务</span></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、步骤4：测试编写好的自定义线程池"><a href="#4、步骤4：测试编写好的自定义线程池" class="headerlink" title="4、步骤4：测试编写好的自定义线程池"></a>4、步骤4：测试编写好的自定义线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17、ThreadPool线程池——ThreadPoolExecutor"><a href="#17、ThreadPool线程池——ThreadPoolExecutor" class="headerlink" title="17、ThreadPool线程池——ThreadPoolExecutor"></a>17、ThreadPool线程池——<code>ThreadPoolExecutor</code></h3><h4 id="1、BAT大厂的面试问题-21"><a href="#1、BAT大厂的面试问题-21" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>为什么要有线程池？</li>
<li>Java是实现和管理线程池有哪些方式？请简单举例如何使用。</li>
<li>为什么很多公司不允许使用Executors去创建线程池？那么推荐怎么使用呢？</li>
<li>ThreadPoolExecutor有哪些核心的配置参数？请简要说明</li>
<li>ThreadPoolExecutor可以创建哪是哪三种线程池呢？</li>
<li>当队列满了并且worker的数量达到maxSize的时候，会怎么样？</li>
<li>说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略？默认是什么策略？</li>
<li>简要说下线程池的任务执行机制？<ul>
<li>execute –&gt; addWorker –&gt;runworker (getTask)</li>
</ul>
</li>
<li>线程池中任务是如何提交的？</li>
<li>线程池中任务是如何关闭的？</li>
<li>在配置线程池的时候需要考虑哪些配置因素？</li>
<li>如何监控线程池的状态？</li>
</ul>
<h4 id="2、为什么需要线程池"><a href="#2、为什么需要线程池" class="headerlink" title="2、为什么需要线程池"></a>2、为什么需要线程池</h4><p>线程池能够对线程进行统一分配，调优和监控：</p>
<ul>
<li>降低资源消耗(线程无限制地创建，然后使用完毕后销毁)</li>
<li>提高响应速度(无须创建线程)</li>
<li>提高线程的可管理性</li>
</ul>
<h4 id="3、ThreadPoolExecutor例子"><a href="#3、ThreadPoolExecutor例子" class="headerlink" title="3、ThreadPoolExecutor例子"></a>3、ThreadPoolExecutor例子</h4><p>Java是如何实现和管理线程池的?</p>
<p>从JDK 5开始，<strong>把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供</strong>。</p>
<p>WorkerThread：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Command = &quot;</span>+command);</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleThreadPool：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> WorkerThread(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">          &#125;</span><br><span class="line">        executor.shutdown(); <span class="comment">// This will make the executor accept no new threads and finish all existing threads in the queue</span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123; <span class="comment">// Wait until all threads are finish,and also you can use &quot;executor.awaitTermination();&quot; to wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中我们创建了固定大小为五个工作线程的线程池。然后分配给线程池十个工作，因为线程池大小为五，它将启动五个工作线程先处理五个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。</p>
<p>这里是以上程序的输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 Start. Command = 1</span><br><span class="line">pool-1-thread-4 Start. Command = 3</span><br><span class="line">pool-1-thread-1 Start. Command = 0</span><br><span class="line">pool-1-thread-3 Start. Command = 2</span><br><span class="line">pool-1-thread-5 Start. Command = 4</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-3 Start. Command = 8</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-2 Start. Command = 9</span><br><span class="line">pool-1-thread-1 Start. Command = 7</span><br><span class="line">pool-1-thread-5 Start. Command = 6</span><br><span class="line">pool-1-thread-4 Start. Command = 5</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure>

<p>输出表明线程池中至始至终只有五个名为 “pool-1-thread-1” 到 “pool-1-thread-5” 的五个线程，这五个线程不随着工作的完成而消亡，会一直存在，并负责执行分配给线程池的任务，直到线程池消亡。</p>
<p>Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，但是 ThreadPoolExecutor 提供的功能远不止于此。我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。</p>
<p>这里是我们自定义的 RejectedExecutionHandler 接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionHandlerImpl</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">&quot; is rejected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor 提供了一些方法，我们可以使用这些方法来查询 executor 的当前状态，线程池大小，活动线程数量以及任务数量。因此我是用来一个监控线程在特定的时间间隔内打印 executor 信息。</p>
<p>MyMonitorThread.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMonitorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMonitorThread</span><span class="params">(ThreadPoolExecutor executor, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.seconds=delay;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    String.format(<span class="string">&quot;[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>.executor.getPoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCorePoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getActiveCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCompletedTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isShutdown(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isTerminated()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(seconds*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是使用 ThreadPoolExecutor 的线程池实现例子。</p>
<p>WorkerPool.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//RejectedExecutionHandler implementation</span></span><br><span class="line">        RejectedExecutionHandlerImpl rejectionHandler = <span class="keyword">new</span> RejectedExecutionHandlerImpl();</span><br><span class="line">        <span class="comment">//Get the ThreadFactory implementation to use</span></span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">//creating the ThreadPoolExecutor</span></span><br><span class="line">        ThreadPoolExecutor executorPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>), threadFactory, rejectionHandler);</span><br><span class="line">        <span class="comment">//start the monitoring thread</span></span><br><span class="line">        MyMonitorThread monitor = <span class="keyword">new</span> MyMonitorThread(executorPool, <span class="number">3</span>);</span><br><span class="line">        Thread monitorThread = <span class="keyword">new</span> Thread(monitor);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">        <span class="comment">//submit work to the thread pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            executorPool.execute(<span class="keyword">new</span> WorkerThread(<span class="string">&quot;cmd&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//shut down the pool</span></span><br><span class="line">        executorPool.shutdown();</span><br><span class="line">        <span class="comment">//shut down the monitor thread</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        monitor.shutdown();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在初始化 ThreadPoolExecutor 时，我们保持初始池大小为 2，最大池大小为 4 而工作队列大小为 2。因此如果已经有四个正在执行的任务而此时分配来更多任务的话，工作队列将仅仅保留他们(新任务)中的两个，其他的将会被 RejectedExecutionHandlerImpl 处理。</p>
<p>上面程序的输出可以证实以上观点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 Start. Command = cmd0</span><br><span class="line">pool-1-thread-4 Start. Command = cmd5</span><br><span class="line">cmd6 is rejected</span><br><span class="line">pool-1-thread-3 Start. Command = cmd4</span><br><span class="line">pool-1-thread-2 Start. Command = cmd1</span><br><span class="line">cmd7 is rejected</span><br><span class="line">cmd8 is rejected</span><br><span class="line">cmd9 is rejected</span><br><span class="line">[monitor] [0/2] Active: 4, Completed: 0, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [4/2] Active: 4, Completed: 0, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-1 Start. Command = cmd3</span><br><span class="line">pool-1-thread-4 Start. Command = cmd2</span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">[monitor] [4/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">true</span>, isTerminated: <span class="literal">true</span></span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">true</span>, isTerminated: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>注意 executor 的活动任务、完成任务以及所有完成任务，这些数量上的变化。我们可以调用 shutdown() 方法来结束所有提交的任务并终止线程池。</p>
<h4 id="4、ThreadPoolExecutor使用详解"><a href="#4、ThreadPoolExecutor使用详解" class="headerlink" title="4、ThreadPoolExecutor使用详解"></a>4、ThreadPoolExecutor使用详解</h4><p>其实java线程池的实现原理很简单，说白了就是<strong>一个线程集合workerSet和一个阻塞队列workQueue</strong>。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<p><img src="/2021/07/19/JUC/java-thread-x-executors-1.png" alt="java-thread-x-executors-1"></p>
<h5 id="1、Execute原理"><a href="#1、Execute原理" class="headerlink" title="1、Execute原理"></a>1、Execute原理</h5><p>当一个任务提交至线程池之后：</p>
<ol>
<li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li>
<li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li>
<li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li>
</ol>
<p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl。</p>
<h5 id="2、参数"><a href="#2、参数" class="headerlink" title="2、参数"></a>2、参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize，即使有其他空闲线程能够执行新来的任务，也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有核心线程。</li>
<li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列。在JDK中提供了如下阻塞队列：<ul>
<li><code>ArrayBlockingQueue</code>：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</li>
<li><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</li>
<li><code>PriorityBlockingQuene</code>：具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>。</p>
<ul>
<li><code>maximumPoolSize</code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列，则maximumPoolSize则不起作用，因为无法提交至核心线程池的线程会一直持续地放入workQueue。</li>
<li><code>keepAliveTime</code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用，超过这个时间的空闲线程将被终止； ——针对救急线程</li>
<li><code>unit</code> keepAliveTime的单位 —— 针对救急线程</li>
<li><code>threadFactory</code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为<code>DefaultThreadFactory</code></li>
<li><code>handler</code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<ul>
<li><code>AbortPolicy</code>：直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>：直接丢弃任务；</li>
</ul>
</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义拒绝策略，<strong>如记录日志或持久化存储不能处理的任务</strong>。</p>
<p><img src="/2021/07/19/JUC/image-20210811040044445.png" alt="image-20210811040044445"></p>
<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p>
<h5 id="3、三种类型"><a href="#3、三种类型" class="headerlink" title="3、三种类型"></a>3、三种类型</h5><h6 id="1、newFixedThreadPool"><a href="#1、newFixedThreadPool" class="headerlink" title="1、newFixedThreadPool"></a>1、newFixedThreadPool</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。</li>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<p>FixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE)，这会导致以下问题：</p>
<ul>
<li>线程池里的线程数量不超过corePoolSize，这导致了maximumPoolSize和keepAliveTime将会是个无用参数</li>
<li>由于使用了无界队列，所以FixedThreadPool永远不会拒绝，即饱和策略失效</li>
</ul>
<blockquote>
<p>评价：适用于任务量已知，相对耗时的任务</p>
</blockquote>
<h6 id="2、newSingleThreadPool"><a href="#2、newSingleThreadPool" class="headerlink" title="2、newSingleThreadPool"></a>2、newSingleThreadPool</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行。</li>
</ul>
<p>由于使用了无界队列，所以SingleThreadPool永远不会拒绝，即饱和策略失效。</p>
<p>使用场景：</p>
<ul>
<li>希望多个任务排队执行。</li>
<li>线程数固定为 1，任务数多于 1 时，会放入无界队列排队。</li>
<li>任务执行完毕，这唯一的线程也不会被释放。</li>
</ul>
<h6 id="3、newCachedThreadPool"><a href="#3、newCachedThreadPool" class="headerlink" title="3、newCachedThreadPool"></a>3、newCachedThreadPool</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数是 0， 最大线程数是 <code>Integer.MAX_VALUE</code>，救急线程的空闲生存时间是 60s，意味着<ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li>队列采用了 <code>SynchronousQueue</code> 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>
</ul>
<p>线程池的线程数可达到<code>Integer.MAX_VALUE</code>，即<code>2147483647</code>，内部使用<code>SynchronousQueue</code>作为阻塞队列； 和<code>newFixedThreadPool</code>创建的线程池不同，<code>newCachedThreadPool</code>在没有任务执行时，当线程的空闲时间超过<code>keepAliveTime</code>，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同：</p>
<ol>
<li>主线程调用SynchronousQueue的offer()方法放入task，倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task，即调用了SynchronousQueue的poll()，那么主线程将该task交给空闲线程。否则执行(2)</li>
<li>当线程池为空或者没有空闲的线程，则创建新的线程执行任务。</li>
<li>执行完任务的线程倘若在60s内仍空闲，则会被终止。因此长时间空闲的CachedThreadPool不会持有任何线程资源。</li>
</ol>
<blockquote>
<p>评价：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
</blockquote>
<h6 id="4、区别"><a href="#4、区别" class="headerlink" title="4、区别"></a>4、区别</h6><ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li>
<li><code>Executors.newSingleThreadExecutor()</code> 线程个数始终为1，不能修改<ul>
<li><code>FinalizableDelegatedExecutorService</code> 应用的是==装饰器模式==，只对外暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中特有的方法</li>
</ul>
</li>
<li><code>Executors.newFixedThreadPool(1)</code> 初始时为1，以后还可以修改<ul>
<li>对外暴露的是 <code>ThreadPoolExecutor</code> 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h5 id="4、关闭线程池"><a href="#4、关闭线程池" class="headerlink" title="4、关闭线程池"></a>4、关闭线程池</h5><p>遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<h6 id="1、关闭方式——shutdown"><a href="#1、关闭方式——shutdown" class="headerlink" title="1、关闭方式——shutdown"></a>1、关闭方式——shutdown</h6><p>将线程池里的线程状态设置成<code>SHUTDOWN</code>状态，然后中断所有没有正在执行任务的线程。</p>
<h6 id="2、关闭方式——shutdownNow"><a href="#2、关闭方式——shutdownNow" class="headerlink" title="2、关闭方式——shutdownNow"></a>2、关闭方式——shutdownNow</h6><p>将线程池里的线程状态设置成<code>STOP</code>状态，然后停止所有正在执行或暂停任务的线程。只要调用这两个关闭方法中的任意一个，isShutDown() 返回true。当所有任务都成功关闭了，isTerminated()返回true。</p>
<h4 id="5、ThreadPoolExecutor源码详解"><a href="#5、ThreadPoolExecutor源码详解" class="headerlink" title="5、ThreadPoolExecutor源码详解"></a>5、ThreadPoolExecutor源码详解</h4><h5 id="1、几个关键属性"><a href="#1、几个关键属性" class="headerlink" title="1、几个关键属性"></a>1、几个关键属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个属性是用来存放 当前运行的worker数量以及线程池状态的</span></span><br><span class="line"><span class="comment">//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//worker的集合,用set来存放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//超出coreSize的worker的生存时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//常驻worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure>

<h5 id="2、内部状态"><a href="#2、内部状态" class="headerlink" title="2、内部状态"></a>2、内部状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>其中AtomicInteger变量<code>ctl</code>的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：</p>
<ul>
<li><code>RUNNING</code>：-1 &lt;&lt; COUNT_BITS，即高3位为<code>111</code>，<strong>该状态的线程池会接收新任务，并处理阻塞队列中的任务</strong>；</li>
<li><code>SHUTDOWN</code>：0 &lt;&lt; COUNT_BITS，即高3位为<code>000</code>，<strong>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务</strong>；</li>
<li><code>STOP</code>：1 &lt;&lt; COUNT_BITS，即高3位为<code>001</code>，<strong>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务</strong>；</li>
<li><code>TIDYING</code>：2 &lt;&lt; COUNT_BITS，即高3位为<code>010</code>，<strong>所有任务全执行完毕，活动线程为 0 即将进入终结</strong>；</li>
<li><code>TERMINATED</code>：3 &lt;&lt; COUNT_BITS，即高3位为<code>011</code>，<strong>terminated()方法已经执行完成</strong></li>
</ul>
<p><img src="/2021/07/19/JUC/java-thread-x-executors-2.png" alt="img"></p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高3位</th>
<th>接收新任务</th>
<th>处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p>
<blockquote>
<p>注意：为什么RUNNING为<code>111</code>确是最小的？</p>
<p>因为计算机都是补码来记录，所以<code>111</code>其实是<code>-1</code></p>
</blockquote>
<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、任务的执行"><a href="#3、任务的执行" class="headerlink" title="3、任务的执行"></a>3、任务的执行</h5><blockquote>
<p>execute –&gt; addWorker –&gt;runworker (getTask)</p>
</blockquote>
<p>线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。 从Woker类的构造方法实现可以发现：线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。 firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p>
<h6 id="1、execute-方法"><a href="#1、execute-方法" class="headerlink" title="1、execute()方法"></a>1、execute()方法</h6><p>ThreadPoolExecutor.execute(task)实现了Executor.execute(task)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">    <span class="comment">//workerCountOf获取线程池的当前线程数；小于corePoolSize，执行addWorker创建新线程执行command任务</span></span><br><span class="line">       <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double check: c, recheck</span></span><br><span class="line">    <span class="comment">// 线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)</span></span><br><span class="line">        <span class="comment">//如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往线程池中创建新的线程失败，则reject任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要double check线程池的状态?</p>
<p>在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。</p>
<h6 id="2、addWorker方法"><a href="#2、addWorker方法" class="headerlink" title="2、addWorker方法"></a>2、addWorker方法</h6><p>从方法execute的实现可以看出：addWorker主要负责创建新的线程并执行任务线程池创建新线程执行任务时，需要 获取全局锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS更新线程池数量</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();  <span class="comment">// 线程启动，执行任务(Worker.thread(firstTask).start());</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、Worker类的runworker方法"><a href="#3、Worker类的runworker方法" class="headerlink" title="3、Worker类的runworker方法"></a>3、Worker类的runworker方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">// 创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承了AQS类，可以方便的实现工作线程的中止操作；</li>
<li>实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；</li>
<li>当前提交的任务firstTask作为参数传入Worker的构造方法；</li>
</ul>
<p>一些属性还有构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个worker</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">//当一个worker刚创建的时候,就先尝试执行这个任务</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">//记录完成任务的数量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="comment">//创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>runWorker方法是线程池的核心：</p>
<ul>
<li>线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行可中断；</li>
<li>Worker执行firstTask或从workQueue中获取任务：<ul>
<li>进行加锁操作，保证thread不被其他线程中断(除非线程池被中断)</li>
<li>检查线程池状态，倘若线程池处于中断状态，当前线程将中断。</li>
<li>执行beforeExecute</li>
<li>执行任务的run方法</li>
<li>执行afterExecute方法</li>
<li>解锁操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行firstTask，再从workerQueue中取task(getTask())</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4、getTask方法"><a href="#4、getTask方法" class="headerlink" title="4、getTask方法"></a>4、getTask方法</h6><p>下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出线程池是怎么让超过corePoolSize的那部分worker销毁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里一段代码是keepAliveTime起作用的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br></pre></td></tr></table></figure>

<p>allowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。</p>
<p>如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</p>
<p>如果线程不允许无休止空闲timed == true，workQueue.poll任务：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</p>
<h5 id="4、任务的提交"><a href="#4、任务的提交" class="headerlink" title="4、任务的提交"></a>4、任务的提交</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/JUC/java-thread-x-executors-3.png" alt="img"></p>
<ol>
<li>submit任务，等待线程池execute</li>
<li>执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；</li>
<li>FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;future result&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。</p>
<ol>
<li>Callable接口类似于Runnable，只是Runnable没有返回值。</li>
<li>Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；</li>
<li>Future.get方法会导致主线程阻塞，直到Callable任务执行完成；</li>
</ol>
<h6 id="1、submit方法"><a href="#1、submit方法" class="headerlink" title="1、submit方法"></a>1、submit方法</h6><p>AbstractExecutorService.submit()实现了ExecutorService.submit() 可以获取执行完的返回值，而ThreadPoolExecutor 是AbstractExecutorService.submit()的子类，所以submit方法也是ThreadPoolExecutor的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit()在ExecutorService中的定义</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit方法在AbstractExecutorService中的实现</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；</p>
<h6 id="2、FutureTask对象"><a href="#2、FutureTask对象" class="headerlink" title="2、FutureTask对象"></a>2、FutureTask对象</h6><p><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code> 可以将FutureTask提交至线程池中等待被执行(通过FutureTask的run方法来执行)</p>
<ul>
<li><p>内部状态</p>
<ul>
<li><pre><code class="java">/* The run state of this task, initially NEW. 
    * ...
    * Possible state transitions:
    * NEW -&gt; COMPLETING -&gt; NORMAL
    * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
    * NEW -&gt; CANCELLED
    * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
    */
private volatile int state;
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 内部状态的修改通过sun.misc.Unsafe修改</span><br><span class="line"></span><br><span class="line">- get方法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  </span><br><span class="line">  public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">      int s &#x3D; state;</span><br><span class="line">      if (s &lt;&#x3D; COMPLETING)</span><br><span class="line">          s &#x3D; awaitDone(false, 0L);</span><br><span class="line">      return report(s);</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>内部通过awaitDone方法对主线程进行阻塞，具体实现如下：</p>
</li>
<li><pre><code class="java">private int awaitDone(boolean timed, long nanos)
    throws InterruptedException &#123;
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) &#123;
        if (Thread.interrupted()) &#123;
            removeWaiter(q);
            throw new InterruptedException();
        &#125;

        int s = state;
        if (s &gt; COMPLETING) &#123;
            if (q != null)
                q.thread = null;
            return s;
        &#125;
        else if (s == COMPLETING) // cannot time out yet
            Thread.yield();
        else if (q == null)
            q = new WaitNode();
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q);
        else if (timed) &#123;
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) &#123;
                removeWaiter(q);
                return state;
            &#125;
            LockSupport.parkNanos(this, nanos);
        &#125;
        else
            LockSupport.park(this);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 如果主线程被中断，则抛出中断异常；</span><br><span class="line"></span><br><span class="line">  - 判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回；</span><br><span class="line"></span><br><span class="line">  - 如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL；</span><br><span class="line"></span><br><span class="line">  - 通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表；</span><br><span class="line"></span><br><span class="line">  - 最终通过LockSupport的park或parkNanos挂起线程；</span><br><span class="line"></span><br><span class="line">- run方法</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (state !&#x3D; NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">            Callable&lt;V&gt; c &#x3D; callable;</span><br><span class="line">            if (c !&#x3D; null &amp;&amp; state &#x3D;&#x3D; NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                boolean ran;</span><br><span class="line">                try &#123;</span><br><span class="line">                    result &#x3D; c.call();</span><br><span class="line">                    ran &#x3D; true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result &#x3D; null;</span><br><span class="line">                    ran &#x3D; false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; runner must be non-null until state is settled to</span><br><span class="line">            &#x2F;&#x2F; prevent concurrent calls to run()</span><br><span class="line">            runner &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; state must be re-read after nulling runner to prevent</span><br><span class="line">            &#x2F;&#x2F; leaked interrupts</span><br><span class="line">            int s &#x3D; state;</span><br><span class="line">            if (s &gt;&#x3D; INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>FutureTask.run方法是在线程池中被执行的，而非主线程：</p>
<ol>
<li>通过执行Callable任务的call方法；</li>
<li>如果call执行成功，则通过set方法保存结果；</li>
<li>如果call执行有异常，则通过setException保存异常；</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="5、任务的关闭"><a href="#5、任务的关闭" class="headerlink" title="5、任务的关闭"></a>5、任务的关闭</h5><p>shutdown方法会将线程池的状态设置为SHUTDOWN，线程池进入这个状态后，就拒绝再接受任务，然后会将剩余的任务全部执行完：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">-	不会接收新任务</span></span><br><span class="line"><span class="comment">-	但已提交任务会执行完</span></span><br><span class="line"><span class="comment">-	此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否可以关闭线程</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//尝试中断worker,仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">//预留方法,留给子类实现</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor——扩展点</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有的worker</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它</span></span><br><span class="line">            <span class="comment">//注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能</span></span><br><span class="line">            <span class="comment">//它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow做的比较绝，它先将线程池状态设置为STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的worker，然后清空任务队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">-	不会接收新任务</span></span><br><span class="line"><span class="comment">-	会将队列中的任务返回</span></span><br><span class="line"><span class="comment">-	并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//检测权限，修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//中断所有的worker，打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//获取队列中剩余任务，清空任务队列</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有worker，然后调用中断方法</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、其他方法"><a href="#6、其他方法" class="headerlink" title="6、其他方法"></a>6、其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>



<h4 id="6、异常的处理"><a href="#6、异常的处理" class="headerlink" title="6、异常的处理"></a>6、异常的处理</h4><p>使用线程池创建线程时，如果线程内部发生异常的话，是不会抛出或者在控制台打印异常信息的，所以需要我们对可能出现异常进行异常处理，对于异常的处理有以下几种方法：</p>
<ul>
<li><p>线程自己捕捉：线程在代码里对可能出现的异常进行try catch捕捉</p>
<ul>
<li><pre><code class="java">ExecutorService pool = Executors.newFixedThreadPool(1);
pool.submit(() -&gt; &#123;
    try &#123;
        log.debug(&quot;task1&quot;);
        int i = 1 / 0;
    &#125; catch (Exception e) &#123;
        log.error(&quot;error:&quot;, e);
    &#125;
&#125;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过Future进行结果的返回来判断是否发生异常：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    ExecutorService pool &#x3D; Executors.newFixedThreadPool(1);</span><br><span class="line">    Future&lt;Boolean&gt; f &#x3D; pool.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(&quot;task1&quot;);</span><br><span class="line">        inti &#x3D; 1&#x2F;0;</span><br><span class="line">        return true ;</span><br><span class="line">    &#125;);</span><br><span class="line">    Log. debug(&quot;result:&#123;&#125;&quot;, f.get();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="7、更深入理解-1"><a href="#7、更深入理解-1" class="headerlink" title="7、更深入理解"></a>7、更深入理解</h4><h5 id="1、为什么线程池不允许使用Executors去创建？"><a href="#1、为什么线程池不允许使用Executors去创建？" class="headerlink" title="1、为什么线程池不允许使用Executors去创建？"></a>1、为什么线程池不允许使用Executors去创建？</h5><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor:  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool和newScheduledThreadPool:  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li>
</ul>
<h6 id="1、推荐方式1"><a href="#1、推荐方式1" class="headerlink" title="1、推荐方式1"></a>1、推荐方式1</h6><p>首先引入：commons-lang3包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br></pre></td></tr></table></figure>

<h6 id="2、推荐方式2"><a href="#2、推荐方式2" class="headerlink" title="2、推荐方式2"></a>2、推荐方式2</h6><p>首先引入：com.google.guava包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// excute</span></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//gracefully shutdown</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h6 id="3、推荐方式3"><a href="#3、推荐方式3" class="headerlink" title="3、推荐方式3"></a>3、推荐方式3</h6><p>spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean调用execute(Runnable task)方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userThreadPool&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;corePoolSize&quot;</span> value=<span class="string">&quot;10&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxPoolSize&quot;</span> value=<span class="string">&quot;100&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;queueCapacity&quot;</span> value=<span class="string">&quot;2000&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name=<span class="string">&quot;threadFactory&quot;</span> value= threadFactory /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span><br><span class="line">        &lt;ref local=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in code</span></span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure>

<h5 id="2、配置线程池需要考虑的因素"><a href="#2、配置线程池需要考虑的因素" class="headerlink" title="2、配置线程池需要考虑的因素"></a>2、配置线程池需要考虑的因素</h5><p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。</p>
<p>性质不同的任务可用使用不同规模的线程池分开处理：</p>
<ul>
<li>CPU密集型：尽可能少的线程，Ncpu+1</li>
<li>IO密集型：尽可能多的线程，Ncpu*2，比如数据库连接池</li>
<li>混合型：CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li>
</ul>
<p>具体也可以参考<code>8、并发的多线程设计模式的7、工作线程模式查看</code></p>
<h5 id="3、监控线程池的状态"><a href="#3、监控线程池的状态" class="headerlink" title="3、监控线程池的状态"></a>3、监控线程池的状态</h5><p>可以使用ThreadPoolExecutor以下方法：</p>
<ul>
<li><code>getTaskCount()</code> Returns the approximate total number of tasks that have ever been scheduled for execution.<ul>
<li>返回计划执行的任务的大致总数。</li>
</ul>
</li>
<li><code>getCompletedTaskCount()</code> Returns the approximate total number of tasks that have completed execution. <ul>
<li>返回已完成执行的任务的大致总数</li>
<li>返回结果少于getTaskCount()。</li>
</ul>
</li>
<li><code>getLargestPoolSize()</code> Returns the largest number of threads that have ever simultaneously been in the pool. <ul>
<li>返回池中同时存在的最大线程数。</li>
<li>返回结果小于等于maximumPoolSize</li>
</ul>
</li>
<li><code>getPoolSize()</code> Returns the current number of threads in the pool.<ul>
<li>返回池中当前的线程数。</li>
</ul>
</li>
<li><code>getActiveCount()</code> Returns the approximate number of threads that are actively executing tasks.<ul>
<li>返回当前正在执行任务的线程的大致数目。</li>
</ul>
</li>
</ul>
<h3 id="18、ThreadPool线程池——ScheduledThreadPoolExecutor"><a href="#18、ThreadPool线程池——ScheduledThreadPoolExecutor" class="headerlink" title="18、ThreadPool线程池——ScheduledThreadPoolExecutor"></a>18、ThreadPool线程池——<code>ScheduledThreadPoolExecutor</code></h3><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此<strong>所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</strong>。</p>
<p>如果使用的是<code>ScheduledThreadPoolExecutor</code>，<strong>前一个任务的延迟或异常都不会影响到之后的任务，但是异常信息不会被打印出来。需要我们对异常信息进行处理</strong></p>
<p>在很多业务场景中，我们可能需要<strong>周期性的运行某项任务来获取结果</strong>，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。</p>
<h4 id="1、BAT大厂的面试问题-22"><a href="#1、BAT大厂的面试问题-22" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>ScheduledThreadPoolExecutor要解决什么样的问题？</li>
<li>ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性？</li>
<li>ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类？</li>
<li>ScheduledThreadPoolExecutor有哪两个关闭策略？区别是什么？</li>
<li>ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么？</li>
<li>为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</li>
<li>Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor？</li>
</ul>
<h4 id="2、ScheduledThreadPoolExecutor简介"><a href="#2、ScheduledThreadPoolExecutor简介" class="headerlink" title="2、ScheduledThreadPoolExecutor简介"></a>2、ScheduledThreadPoolExecutor简介</h4><p><strong>ScheduledThreadPoolExecutor继承自 ThreadPoolExecutor，为任务提供延迟或周期执行，属于线程池的一种</strong>。和 ThreadPoolExecutor 相比，它还具有以下几种特性：</p>
<ul>
<li><strong>使用专门的任务类型——ScheduledFutureTask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 ExecutorService 来执行)。</strong></li>
<li><strong>使用专门的存储队列——DelayedWorkQueue 来存储任务，DelayedWorkQueue 是无界延迟队列DelayQueue 的一种。相比ThreadPoolExecutor也简化了执行机制</strong>(delayedExecute方法，后面单独分析)。</li>
<li><strong>支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。</strong></li>
</ul>
<h4 id="3、ScheduledThreadPoolExecutor数据结构"><a href="#3、ScheduledThreadPoolExecutor数据结构" class="headerlink" title="3、ScheduledThreadPoolExecutor数据结构"></a>3、ScheduledThreadPoolExecutor数据结构</h4><p><img src="/2021/07/19/JUC/java-thread-x-stpe-1.png" alt="img"></p>
<p>ScheduledThreadPoolExecutor继承自 <code>ThreadPoolExecutor</code>，ScheduledThreadPoolExecutor 内部构造了两个内部类 <code>ScheduledFutureTask</code> 和 <code>DelayedWorkQueue</code>:</p>
<ul>
<li><code>ScheduledFutureTask</code>：继承了FutureTask，说明是一个异步运算任务；最上层分别实现了Runnable、Future、Delayed接口，说明它是一个<strong>可以延迟执行的异步运算任务</strong>。</li>
<li><code>DelayedWorkQueue</code>：这是 ScheduledThreadPoolExecutor <strong>为存储周期或延迟任务专门定义的一个延迟队列，继承了 AbstractQueue，为了契合 ThreadPoolExecutor 也实现了 BlockingQueue 接口</strong>。它内部只允许存储 RunnableScheduledFuture 类型的任务。<strong>与 DelayQueue 的不同之处就是它只允许存放 RunnableScheduledFuture 对象，并且自己实现了二叉堆(DelayQueue 是利用了 PriorityQueue 的二叉堆结构)。</strong></li>
</ul>
<h4 id="4、ScheduledThreadPoolExecutor源码解析"><a href="#4、ScheduledThreadPoolExecutor源码解析" class="headerlink" title="4、ScheduledThreadPoolExecutor源码解析"></a>4、ScheduledThreadPoolExecutor源码解析</h4><h5 id="1、内部类ScheduledFutureTask"><a href="#1、内部类ScheduledFutureTask" class="headerlink" title="1、内部类ScheduledFutureTask"></a>1、内部类ScheduledFutureTask</h5><h6 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为相同延时任务提供的顺序编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务可以执行的时间，纳秒级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复任务的执行周期时间，纳秒级。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新入队的任务</span></span><br><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟队列的索引，以支持更快的取消操作</span></span><br><span class="line"><span class="keyword">int</span> heapIndex;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sequenceNumber</code>：当两个任务有相同的延迟时间时，按照 <code>FIFO</code> 的顺序入队。<strong>sequenceNumber 就是为相同延时任务提供的顺序编号</strong>。</li>
<li><code>time</code>：<strong>任务可以执行时的时间，==纳秒级==，通过<code>triggerTime</code>方法计算得出。</strong></li>
<li><code>period</code>：任<strong>务的执行周期时间，==纳秒级==。</strong><ul>
<li><strong>正数表示固定速率执行(为scheduleAtFixedRate提供服务)，</strong></li>
<li><strong>负数表示固定延迟执行(为scheduleWithFixedDelay提供服务)，</strong></li>
<li><strong>0表示不重复任务。</strong></li>
</ul>
</li>
<li><code>outerTask</code>：<strong>重新入队的任务，通过<code>reExecutePeriodic</code>方法入队重新排序。</strong></li>
</ul>
<h6 id="2、核心方法run"><a href="#2、核心方法run" class="headerlink" title="2、核心方法run()"></a>2、核心方法run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();<span class="comment">//是否为周期任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))<span class="comment">//当前状态是否可以执行</span></span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        <span class="comment">//不是周期任务，直接执行</span></span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();<span class="comment">//设置下一次运行时间</span></span><br><span class="line">        reExecutePeriodic(outerTask);<span class="comment">//重排序一个周期任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>ScheduledFutureTask 的run方法重写了 FutureTask 的版本，以便执行周期任务时重置/重排序任务。任务的执行通过父类 FutureTask 的run实现。</strong></p>
<p>内部有两个针对周期任务的方法：</p>
<ul>
<li><p><code>setNextRunTime()</code>：<strong>用来设置下一次运行的时间</strong>，源码如下：</p>
<ul>
<li><pre><code class="java">//设置下一次执行任务的时间
private void setNextRunTime() &#123;
    long p = period;
    if (p &gt; 0)  //固定速率执行，scheduleAtFixedRate
        time += p;
    else
        time = triggerTime(-p);  //固定延迟执行，scheduleWithFixedDelay
&#125;
//计算固定延迟任务的执行时间
long triggerTime(long delay) &#123;
    return now() +
        ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay));
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;reExecutePeriodic()&#96;：**周期任务重新入队等待下一次执行**，源码如下：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;重排序一个周期任务</span><br><span class="line">    void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) &#123;</span><br><span class="line">        if (canRunInCurrentRunState(true)) &#123;&#x2F;&#x2F;池关闭后可继续执行</span><br><span class="line">            super.getQueue().add(task);&#x2F;&#x2F;任务入列</span><br><span class="line">            &#x2F;&#x2F;重新检查run-after-shutdown参数，如果不能继续运行就移除队列任务，并取消任务的执行</span><br><span class="line">            if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))</span><br><span class="line">                task.cancel(false);</span><br><span class="line">            else</span><br><span class="line">                ensurePrestart();&#x2F;&#x2F;启动一个新的线程等待任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>reExecutePeriodic与delayedExecute的执行策略一致，只不过reExecutePeriodic不会执行拒绝策略而是直接丢掉任务</strong>。</p>
<h6 id="3、cancel方法"><a href="#3、cancel方法" class="headerlink" title="3、cancel方法"></a>3、cancel方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        remove(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledFutureTask.cancel本质上由其父类 FutureTask.cancel 实现</strong>。<strong>取消任务成功后会根据removeOnCancel参数决定是否从队列中移除此任务。</strong></p>
<h5 id="2、核心属性"><a href="#2、核心属性" class="headerlink" title="2、核心属性"></a>2、核心属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭后继续执行已经存在的周期任务 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭后继续执行已经存在的延时任务 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消任务后移除 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为相同延时的任务提供的顺序编号，保证任务之间的FIFO顺序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>continueExistingPeriodicTasksAfterShutdown</code>和<code>executeExistingDelayedTasksAfterShutdown</code>是 <strong>ScheduledThreadPoolExecutor 定义的 <code>run-after-shutdown</code> 参数，</strong>用来控制池关闭之后的任务执行逻辑。</li>
<li><code>removeOnCancel</code><strong>用来控制任务取消后是否从队列中移除</strong>。当一个已经提交的周期或延迟任务在运行之前被取消，那么它之后将不会运行。默认配置下，这种已经取消的任务在届期之前不会被移除。 通过这种机制，可以方便检查和监控线程池状态，但也可能导致已经取消的任务无限滞留。为了避免这种情况的发生，我们可以通过<code>setRemoveOnCancelPolicy</code>方法设置移除策略，把参数<code>removeOnCancel</code>设为true可以在任务取消后立即从队列中移除。</li>
<li><code>sequencer</code>是为相同延时的任务提供的顺序编号，保证任务之间的 <code>FIFO</code> 顺序。与 ScheduledFutureTask 内部的sequenceNumber参数作用一致。</li>
</ul>
<h5 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h5><p>首先看下构造函数，ScheduledThreadPoolExecutor 内部有四个构造函数，这里我们只看这个最大构造灵活度的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数都是通过super调用了ThreadPoolExecutor的构造，并且<strong>使用特定等待队列DelayedWorkQueue</strong>。</p>
<h5 id="4、核心方法——Schedule"><a href="#4、核心方法——Schedule" class="headerlink" title="4、核心方法——Schedule"></a>4、核心方法——Schedule</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)));<span class="comment">//构造ScheduledFutureTask任务</span></span><br><span class="line">    delayedExecute(t);<span class="comment">//任务执行主方法</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<strong>schedule主要用于执行一次性(延迟)任务</strong>。函数执行逻辑分两步：</p>
<ul>
<li><p><code>封装 Callable/Runnable</code>: 首先通过<code>triggerTime</code>计算任务的延迟执行时间，然后通过 <code>ScheduledFutureTask</code> 的构造函数把 Runnable/Callable 任务构造为<code>ScheduledThreadPoolExecutor</code>可以执行的任务类型，最后调用<code>decorateTask</code>方法执行用户自定义的逻辑；<strong>decorateTask是一个用户可自定义扩展的方法，默认实现下直接返回封装的RunnableScheduledFuture任务</strong>，源码如下：</p>
<ul>
<li><pre><code class="java">protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
    Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) &#123;
    return task;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;执行任务&#96;：**通过delayedExecute实现**。下面我们来详细分析：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123;</span><br><span class="line">        if (isShutdown())</span><br><span class="line">            reject(task);&#x2F;&#x2F;池已关闭，执行拒绝策略</span><br><span class="line">        else &#123;</span><br><span class="line">            super.getQueue().add(task);&#x2F;&#x2F;任务入队</span><br><span class="line">            if (isShutdown() &amp;&amp;</span><br><span class="line">                !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;&#x2F;&#x2F;判断run-after-shutdown参数</span><br><span class="line">                remove(task))&#x2F;&#x2F;移除任务</span><br><span class="line">                task.cancel(false);</span><br><span class="line">            else</span><br><span class="line">                ensurePrestart();&#x2F;&#x2F;启动一个新的线程等待任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>说明：delayedExecute是执行任务的主方法，方法执行逻辑如下：</p>
<ul>
<li><p><strong>如果池已关闭(ctl &gt;= SHUTDOWN)，执行任务拒绝策略</strong>；</p>
</li>
<li><p><strong>池正在运行，首先把任务入队排序；然后重新检查池的关闭状态</strong>，执行如下逻辑：</p>
<ol>
<li><p><code>A</code>：<strong>如果池正在运行，或者 run-after-shutdown 参数值为true，则调用父类方法ensurePrestart启动一个新的线程等待执行任务</strong>。ensurePrestart源码如下：</p>
<ul>
<li><pre><code class="java">void ensurePrestart() &#123;
    int wc = workerCountOf(ctl.get());
    if (wc &lt; corePoolSize)
        addWorker(null, true);
    else if (wc == 0)
        addWorker(null, false);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - ensurePrestart是父类 ThreadPoolExecutor 的方法，用于启动一个新的工作线程等待执行任务，即使corePoolSize为0也会安排一个新线程。</span><br><span class="line"></span><br><span class="line">  2. &#96;B&#96;：**如果池已经关闭，并且 run-after-shutdown 参数值为false，则执行父类(ThreadPoolExecutor)方法remove移除队列中的指定任务，成功移除后调用ScheduledFutureTask.cancel取消任务**</span><br><span class="line"></span><br><span class="line">##### 5、核心方法——scheduleAtFixedRate 和 scheduleWithFixedDelay</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，</span><br><span class="line"> * 之后每隔period执行一次，不等待第一次执行完成就开始计时</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              long initialDelay,</span><br><span class="line">                                              long period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    if (period &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#x2F;&#x2F;构建RunnableScheduledFuture任务类型</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft &#x3D;</span><br><span class="line">        new ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      null,</span><br><span class="line">                                      triggerTime(initialDelay, unit),&#x2F;&#x2F;计算任务的延迟时间</span><br><span class="line">                                      unit.toNanos(period));&#x2F;&#x2F;计算任务的执行周期</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t &#x3D; decorateTask(command, sft);&#x2F;&#x2F;执行用户自定义逻辑</span><br><span class="line">    sft.outerTask &#x3D; t;&#x2F;&#x2F;赋值给outerTask，准备重新入队等待下一次执行</span><br><span class="line">    delayedExecute(t);&#x2F;&#x2F;执行任务</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，</span><br><span class="line"> * 在第一次执行完之后延迟delay后开始下一次执行</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 long initialDelay,</span><br><span class="line">                                                 long delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    if (delay &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#x2F;&#x2F;构建RunnableScheduledFuture任务类型</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft &#x3D;</span><br><span class="line">        new ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      null,</span><br><span class="line">                                      triggerTime(initialDelay, unit),&#x2F;&#x2F;计算任务的延迟时间</span><br><span class="line">                                      unit.toNanos(-delay));&#x2F;&#x2F;计算任务的执行周期</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t &#x3D; decorateTask(command, sft);&#x2F;&#x2F;执行用户自定义逻辑</span><br><span class="line">    sft.outerTask &#x3D; t;&#x2F;&#x2F;赋值给outerTask，准备重新入队等待下一次执行</span><br><span class="line">    delayedExecute(t);&#x2F;&#x2F;执行任务</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>说明：scheduleAtFixedRate和scheduleWithFixedDelay方法的逻辑与schedule类似。</p>
<p><strong>注意scheduleAtFixedRate和scheduleWithFixedDelay的区别</strong>: 乍一看两个方法一模一样，其实，<strong>在unit.toNanos这一行代码中还是有区别的：</strong></p>
<ul>
<li><strong>没错，scheduleAtFixedRate传的是正值，而scheduleWithFixedDelay传的则是负值，这个值就是 ScheduledFutureTask 的period属性。</strong></li>
<li>执行效果上也有区别：<ul>
<li>对于scheduleAtFixedRate来说：如果间隔时间小于线程执行任务的时间（例如：间隔时间为1s，然而线程要执行2s），那么将会影响到间隔的时间——<strong>间隔时间无效，会等到任务执行完毕在执行下一个任务</strong>。</li>
<li>而对于scheduleWithFixedDelay来说：如果间隔时间小于线程执行任务的时间（例如：间隔时间为1s，然而线程要执行2s），那么间隔的时间会增加——间隔的时间(3s) = 设置的延迟时间(1s) + 代码的执行时间(2s)，即：scheduleWithFixedDelay的时间间隔是从上一个任务结束时间来计算的</li>
</ul>
</li>
</ul>
<h5 id="6、核心方法——shutdown"><a href="#6、核心方法——shutdown" class="headerlink" title="6、核心方法——shutdown()"></a>6、核心方法——shutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消并清除由于关闭策略不应该运行的所有任务</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="comment">//获取run-after-shutdown参数</span></span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;<span class="comment">//池关闭后不保留任务</span></span><br><span class="line">        <span class="comment">//依次取消任务</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();<span class="comment">//清除等待队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//池关闭后保留任务</span></span><br><span class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">        <span class="comment">//遍历快照以避免迭代器异常</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="comment">//如果任务已经取消，移除队列中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">//终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：池关闭方法调用了父类ThreadPoolExecutor的shutdown，具体分析见 ThreadPoolExecutor 篇。这里主要介绍以下在shutdown方法中调用的==关闭钩子onShutdown方法==，它的主要作用是<strong>在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown)来决定线程池关闭后是否关闭已经存在的任务</strong>。</p>
<h4 id="5、再深入理解-1"><a href="#5、再深入理解-1" class="headerlink" title="5、再深入理解"></a>5、再深入理解</h4><h5 id="1、为什么ThreadPoolExecutor-的调整策略却不适用于-ScheduledThreadPoolExecutor？"><a href="#1、为什么ThreadPoolExecutor-的调整策略却不适用于-ScheduledThreadPoolExecutor？" class="headerlink" title="1、为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？"></a>1、<strong>为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</strong></h5><p>例如：</p>
<ol>
<li>由于 ScheduledThreadPoolExecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整maximumPoolSize对其没有任何影响(所以 ScheduledThreadPoolExecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为Integer.MAX_VALUE)。</li>
<li>此外，设置corePoolSize为0或者设置核心线程空闲后清除(allowCoreThreadTimeOut)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。</li>
</ol>
<h5 id="2、Executors-提供了哪几种方法来构造-ScheduledThreadPoolExecutor？"><a href="#2、Executors-提供了哪几种方法来构造-ScheduledThreadPoolExecutor？" class="headerlink" title="2、Executors 提供了哪几种方法来构造 ScheduledThreadPoolExecutor？"></a>2、Executors 提供了哪几种方法来构造 ScheduledThreadPoolExecutor？</h5><ul>
<li><code>newScheduledThreadPool</code>：可指定核心线程数的线程池。</li>
<li><code>newSingleThreadScheduledExecutor</code>：只有一个工作线程的线程池。如果内部工作线程由于执行周期任务异常而被终止，则会新建一个线程替代它的位置。</li>
</ul>
<p><strong>注意：newScheduledThreadPool(1, threadFactory) 不等价于newSingleThreadScheduledExecutor。</strong></p>
<ul>
<li>newSingleThreadScheduledExecutor创建的线程池保证<strong>内部只有一个线程执行任务，并且线程数不可扩展</strong>；</li>
<li>而通过newScheduledThreadPool(1, threadFactory)创建的线程池<strong>可以通过setCorePoolSize方法来修改核心线程数</strong>。</li>
</ul>
<h4 id="6、ScheduledThreadPoolExecutor应用"><a href="#6、ScheduledThreadPoolExecutor应用" class="headerlink" title="6、ScheduledThreadPoolExecutor应用"></a>6、ScheduledThreadPoolExecutor应用</h4><p>需求：让每周四 18:00:00 定时执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何让每周四 18:00:00 定时执行任务？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 获取周四时间</span></span><br><span class="line">        LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">        <span class="comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span></span><br><span class="line">        <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        <span class="comment">// initailDelay 代表当前时间和周四的时间差</span></span><br><span class="line">        <span class="comment">// period 一周的间隔时间</span></span><br><span class="line">        <span class="keyword">long</span> initailDelay = Duration.between(now, time).toMillis();</span><br><span class="line">        <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19、Tomcat-线程池"><a href="#19、Tomcat-线程池" class="headerlink" title="19、Tomcat 线程池"></a>19、Tomcat 线程池</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>Tomcat 在哪里用到了线程池呢？——tomcat的连接器部分(Connector)（tomcat还有容器部分——负责servlet规范的）</p>
<p><img src="/2021/07/19/JUC/image-20210812012018371.png" alt="image-20210812012018371"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore </li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li>如果总线程数达到 maximumPoolSize<ul>
<li>这时不会立刻抛 RejectedExecutionException 异常</li>
<li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul>
</li>
</ul>
<h4 id="2、源码-tomcat-7-0-42"><a href="#2、源码-tomcat-7-0-42" class="headerlink" title="2、源码 tomcat-7.0.42"></a>2、源码 tomcat-7.0.42</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的execute方法</span></span><br><span class="line">        <span class="keyword">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123; <span class="comment">// 出现异常，进行进一步的处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="comment">// 得到任务队列</span></span><br><span class="line">            <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次尝试将任务放入队列</span></span><br><span class="line">                <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    <span class="comment">// 失败，抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            submittedCount.decrementAndGet(); </span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskQueue.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">force</span><span class="params">(Runnable  o, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( parent.isShutdown() ) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">        <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、Connector-配置"><a href="#3、Connector-配置" class="headerlink" title="3、Connector 配置"></a>3、Connector 配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>acceptorThreadCount</td>
<td>1</td>
<td>acceptor 线程数量</td>
</tr>
<tr>
<td>pollerThreadCount</td>
<td>1</td>
<td>poller 线程数量</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>10</td>
<td>核心线程数，即 corePoolSize</td>
</tr>
<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td>executor</td>
<td>-</td>
<td>Executor 名称，用来引用下面的 Executor</td>
</tr>
</tbody></table>
<h4 id="4、Executor-线程配置"><a href="#4、Executor-线程配置" class="headerlink" title="4、Executor 线程配置"></a>4、Executor 线程配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>threadPriority</td>
<td>5</td>
<td>线程优先级</td>
</tr>
<tr>
<td>daemon</td>
<td>true</td>
<td>是否守护线程</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>25</td>
<td>核心线程数，即 corePoolSize</td>
</tr>
<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>60000</td>
<td>线程生存时间，单位是毫秒，默认值即 1 分钟</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>Integer.MAX_VALUE</td>
<td>队列长度</td>
</tr>
<tr>
<td>prestartminSpareThreads</td>
<td>false</td>
<td>核心线程是否在服务器启动时启动</td>
</tr>
</tbody></table>
<h3 id="20、Fork-Join分支合并框架"><a href="#20、Fork-Join分支合并框架" class="headerlink" title="20、Fork/Join分支合并框架"></a>20、Fork/Join分支合并框架</h3><p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p>
<h4 id="1、BAT大厂的面试问题-23"><a href="#1、BAT大厂的面试问题-23" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>Fork/Join主要用来解决什么样的问题？</li>
<li>Fork/Join框架是在哪个JDK版本中引入的？</li>
<li>Fork/Join框架主要包含哪三个模块？模块之间的关系是怎么样的？</li>
<li>ForkJoinPool类继承关系？</li>
<li>ForkJoinTask抽象类继承关系？<ul>
<li>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> 、<code>RecursiveAction</code> 或 <code>CountedCompleter</code> 来实现我们的业务需求，而<strong>不会直接继承 ForkJoinTask 类</strong>。</li>
</ul>
</li>
<li>整个Fork/Join 框架的执行流程/运行机制是怎么样的？</li>
<li>具体阐述Fork/Join的分治思想和work-stealing 实现方式？</li>
<li>有哪些JDK源码中使用了Fork/Join思想？</li>
<li>如何使用Executors工具类创建ForkJoinPool？</li>
<li>写一个例子：用ForkJoin方式实现1+2+3+…+100000？</li>
<li>Fork/Join在使用时有哪些注意事项？结合JDK中的斐波那契数列实例具体说明</li>
</ul>
<h4 id="2、Fork-Join框架简介"><a href="#2、Fork-Join框架简介" class="headerlink" title="2、Fork/Join框架简介"></a>2、Fork/Join框架简介</h4><p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p>
<h5 id="1、三个模块及关系"><a href="#1、三个模块及关系" class="headerlink" title="1、三个模块及关系"></a>1、三个模块及关系</h5><p>Fork/Join框架主要包含三个模块：</p>
<ul>
<li>任务对象：<code>ForkJoinTask</code> (包括<code>RecursiveTask</code>、<code>RecursiveAction</code> 和 <code>CountedCompleter</code>)</li>
<li>执行Fork/Join任务的线程：<code>ForkJoinWorkerThread</code></li>
<li>线程池：<code>ForkJoinPool</code></li>
</ul>
<p>这三者的关系是：ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 《A Java Fork/Join Framework》Dong Lea</span></span><br><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (problem is small)</span><br><span class="line"> 		directly solve problem</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		split problem into independent parts</span><br><span class="line"> 		fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> 		join all subtasks</span><br><span class="line"> 		compose result from subresults</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable/Callable 任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask 的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的 RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From JDK 7 doc. Class RecursiveTask&lt;V&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">   Fibonacci(<span class="keyword">int</span> n) &#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">   <span class="function">Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">     Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">     f1.fork();</span><br><span class="line">     Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">     <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> 、<code>RecursiveAction</code> 或 <code>CountedCompleter</code> 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</p>
<h5 id="2、核心思想：分治算法（Divide-and-Conquer）"><a href="#2、核心思想：分治算法（Divide-and-Conquer）" class="headerlink" title="2、核心思想：分治算法（Divide-and-Conquer）"></a>2、核心思想：分治算法（Divide-and-Conquer）</h5><p>分治算法(Divide-and-Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork/Join 框架的任务运行机制：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-forkjoin-2.png" alt="img"></p>
<p>Fork/Join 框架要完成两件事情： </p>
<ul>
<li>Fork：把一个复杂任务进行分拆，大事化小</li>
<li>Join：把分拆任务的结果进行合并</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210729225650517.png" alt="image-20210729225650517"></p>
<ol>
<li><strong>任务分割</strong>：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li>
<li><strong>执行任务并合并结果</strong>：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li>
</ol>
<h5 id="3、核心思想：work-stealing（工作窃取）算法"><a href="#3、核心思想：work-stealing（工作窃取）算法" class="headerlink" title="3、核心思想：work-stealing（工作窃取）算法"></a>3、核心思想：work-stealing（工作窃取）算法</h5><p>work-stealing(工作窃取)算法：线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并(join)的事件类型任务也非常适用。</p>
<p><strong>在 ForkJoinPool 中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。</strong></p>
<p>具体思路如下：</p>
<ul>
<li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。</li>
<li>队列支持三个功能push、pop、poll</li>
<li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。</li>
<li>划分的子任务调用fork时，都会被push到自己的队列中。</li>
<li>默认情况下，工作线程从自己的双端队列获出任务并执行。</li>
<li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。</li>
</ul>
<p><img src="/2021/07/19/JUC/java-thread-x-forkjoin-3.png" alt="img"></p>
<h5 id="4、Fork-Join-框架的执行流程"><a href="#4、Fork-Join-框架的执行流程" class="headerlink" title="4、Fork/Join 框架的执行流程"></a>4、Fork/Join 框架的执行流程</h5><p>上图可以看出ForkJoinPool 中的任务执行分两种：</p>
<ul>
<li>直接通过 FJP 提交的外部任务(external/submissions task)，存放在 workQueues 的偶数槽位；</li>
<li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li>
</ul>
<p>那Fork/Join 框架的执行流程是什么样的？</p>
<p><img src="/2021/07/19/JUC/java-thread-x-forkjoin-5.png" alt="img"></p>
<h4 id="3、Fork-Join类关系"><a href="#3、Fork-Join类关系" class="headerlink" title="3、Fork/Join类关系"></a>3、Fork/Join类关系</h4><h5 id="1、ForkJoinPool继承关系"><a href="#1、ForkJoinPool继承关系" class="headerlink" title="1、ForkJoinPool继承关系"></a>1、ForkJoinPool继承关系</h5><p><img src="/2021/07/19/JUC/blog\XGH-blog\source_posts\JUC\java-thread-x-forkjoin-1.png" alt="img"></p>
<p>内部类介绍：</p>
<ul>
<li><code>ForkJoinWorkerThreadFactory</code>：内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread</li>
<li><code>DefaultForkJoinWorkerThreadFactory</code>：ForkJoinWorkerThreadFactory 的默认实现类</li>
<li><code>InnocuousForkJoinWorkerThreadFactory</code>：实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。</li>
<li><code>EmptyTask</code>：内部占位类，用于替换队列中 join 的任务。</li>
<li><code>ManagedBlocker</code>：为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。</li>
<li><code>WorkQueue</code>：ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，<strong>使用 <code>@Contented</code> 注解修饰防止伪共享</strong>。<ul>
<li>工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。</li>
<li>工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。</li>
</ul>
</li>
<li><code>伪共享状态</code>：缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</li>
</ul>
<h5 id="2、ForkJoinTask继承关系"><a href="#2、ForkJoinTask继承关系" class="headerlink" title="2、ForkJoinTask继承关系"></a>2、ForkJoinTask继承关系</h5><p><img src="/2021/07/19/JUC/java-thread-x-forkjoin-4.png" alt="img"></p>
<p>ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把 Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。</p>
<h4 id="4、Fork-Join框架源码解析"><a href="#4、Fork-Join框架源码解析" class="headerlink" title="4、Fork/Join框架源码解析"></a>4、Fork/Join框架源码解析</h4><p>分析思路：在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分：</p>
<ul>
<li>首先介绍任务的提交流程 - 外部任务(external/submissions task)提交；</li>
<li>然后介绍任务的提交流程 - 子任务(Worker task)提交；</li>
<li>再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；</li>
<li>最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())</li>
</ul>
<h5 id="1、ForkJoinPool"><a href="#1、ForkJoinPool" class="headerlink" title="1、ForkJoinPool"></a>1、ForkJoinPool</h5><h6 id="1、核心参数-1"><a href="#1、核心参数-1" class="headerlink" title="1、核心参数"></a>1、核心参数</h6><p>在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。</p>
<p>例如，如果要更新活跃线程数，使用公式(UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; c)；c 代表当前 ctl，UC_MASK 和 SP_MASK 分别是高位和低位掩码，AC_UNIT 为活跃线程的增量数，使用(UC_MASK &amp; (c + AC_UNIT))就可以计算出高32位，然后再加上低32位(SP_MASK &amp; c)，就拼接成了一个新的ctl。</p>
<p>这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。</p>
<p>ForkJoinPool 与 内部类 WorkQueue 共享的一些常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants shared across ForkJoinPool and WorkQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK = <span class="number">0xffff</span>;        <span class="comment">//  低位掩码，也是最大索引位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP = <span class="number">0x7fff</span>;        <span class="comment">//  工作线程最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK = <span class="number">0xfffe</span>;        <span class="comment">//  偶数低位掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK = <span class="number">0x007e</span>;        <span class="comment">//  workQueues 数组最多64个槽位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl 子域和 WorkQueue.scanState 的掩码和标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING = <span class="number">1</span>;             <span class="comment">// 标记是否正在运行任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 失活状态  负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本戳，防止ABA问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 模式掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE = <span class="number">0</span>; <span class="comment">//LIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//FIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享模式队列，负数</span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 中的相关常量和实例字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  低位和高位掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AC_SHIFT = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TC_SHIFT = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT; <span class="comment">//工作线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT; <span class="comment">//掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>);  <span class="comment">// 创建工作线程标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RSLOCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RSIGNAL = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// 主控制参数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// 运行状态锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> config;                    <span class="comment">// 并行度|模式</span></span><br><span class="line"><span class="keyword">int</span> indexSeed;                       <span class="comment">// 用于生成工作线程索引</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// 主对象注册信息，workQueue</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;<span class="comment">// 线程工厂</span></span><br><span class="line"><span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// 每个工作线程的异常信息</span></span><br><span class="line"><span class="keyword">final</span> String workerNamePrefix;       <span class="comment">// 用于创建工作线程的名称</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicLong stealCounter;    <span class="comment">// 偷取任务总数，也可作为同步监视器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 静态初始化字段 */</span></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;</span><br><span class="line"><span class="comment">//启动或杀死线程的方法调用者的权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission modifyThreadPermission;</span><br><span class="line"><span class="comment">// 公共静态pool</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"><span class="comment">//并行度，对应内部common池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> commonParallelism;</span><br><span class="line"><span class="comment">//备用线程数，在tryCompensate中使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> commonMaxSpares;</span><br><span class="line"><span class="comment">//创建workerNamePrefix(工作线程名称前缀)时的序号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> poolNumberSequence;</span><br><span class="line"><span class="comment">//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> IDLE_TIMEOUT = <span class="number">2000L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>; <span class="comment">// 2sec</span></span><br><span class="line"><span class="comment">//空闲超时时间，防止timer未命中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_SLOP = <span class="number">20L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  <span class="comment">// 20ms</span></span><br><span class="line"><span class="comment">//默认备用线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_COMMON_MAX_SPARES = <span class="number">256</span>;</span><br><span class="line"><span class="comment">//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS  = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//indexSeed的增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEED_INCREMENT = <span class="number">0x9e3779b9</span>;</span><br></pre></td></tr></table></figure>

<p>说明：ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成：</p>
<ul>
<li><code>AC</code>：正在运行工作线程数减去目标并行度，高16位</li>
<li><code>TC</code>：总工作线程数减去目标并行度，中高16位</li>
<li><code>SS</code>：栈顶等待线程的版本计数和状态，中低16位</li>
<li><code>ID</code>：栈顶 WorkQueue 在池中的索引(poolIndex)，低16位</li>
</ul>
<p>在后面的源码解析中，某些地方也提取了ctl的低32位(sp=(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。</p>
<h6 id="2、ForkJoinPool-WoekQueue-中的相关属性"><a href="#2、ForkJoinPool-WoekQueue-中的相关属性" class="headerlink" title="2、ForkJoinPool.WoekQueue 中的相关属性"></a>2、ForkJoinPool.WoekQueue 中的相关属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始队列容量，2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="comment">//最大队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// Woker状态, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// 记录前一个栈顶的ctl</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// 偷取任务数</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// 记录偷取者索引，初始为随机索引</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// 池索引和模式</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// 下一个poll操作的索引(栈底/队列头)</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// 下一个push操作的索引(栈顶/队列尾)</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务数组</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 当前工作队列的工作线程，共享模式下为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// 调用park阻塞期间为owner，其他情况为null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// 记录被join过来的任务</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// 记录从其他工作队列偷取过来的任务</span></span><br></pre></td></tr></table></figure>

<h5 id="2、ForkJoinTask"><a href="#2、ForkJoinTask" class="headerlink" title="2、ForkJoinTask"></a>2、ForkJoinTask</h5><h6 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 任务运行状态 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// 任务运行状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// 任务完成状态标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16 等待信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// 低位掩码</span></span><br></pre></td></tr></table></figure>

<h4 id="5、Fork-Join框架源码解析"><a href="#5、Fork-Join框架源码解析" class="headerlink" title="5、Fork/Join框架源码解析"></a>5、Fork/Join框架源码解析</h4><h5 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">            checkFactory(factory),</span><br><span class="line">            handler,</span><br><span class="line">            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool-&quot;</span> + nextPoolId() + <span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：在 ForkJoinPool 中我们可以自定义四个参数：</p>
<ul>
<li><code>parallelism</code>：并行度，默认为CPU数，最小为1</li>
<li><code>factory</code>：工作线程工厂；</li>
<li><code>handler</code>：处理工作线程运行任务时的异常情况类，默认为null；</li>
<li><code>asyncMode</code>：是否为异步模式，默认为 false。<strong>如果为true，表示子任务的执行遵循 FIFO 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务</strong>。</li>
</ul>
<p>在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 ForkJoinPool 中的common池，在JDK1.8之后提供了ForkJoinPool.commonPool()方法可以直接使用common池，来看一下它的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>);<span class="comment">//并行度</span></span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;</span>);<span class="comment">//线程工厂</span></span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;</span>);<span class="comment">//异常处理类</span></span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">            (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;<span class="comment">//默认并行度为1</span></span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool.commonPool-worker-&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用common pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。</p>
<h5 id="2、执行流程——外部任务（external-submissions-task）提交"><a href="#2、执行流程——外部任务（external-submissions-task）提交" class="headerlink" title="2、执行流程——外部任务（external/submissions task）提交"></a>2、执行流程——外部任务（external/submissions task）提交</h5><p>向 ForkJoinPool 提交任务有三种方式：</p>
<ul>
<li>invoke()会等待任务计算完毕并返回计算结果；</li>
<li>execute()是直接向池提交一个任务来异步执行，无返回结果；</li>
<li>submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。</li>
</ul>
<p>这三种提交方式都都是调用externalPush()方法来完成，所以接下来我们将从externalPush()方法开始逐步分析外部任务的执行过程。</p>
<h6 id="1、externalPush-ForkJoinTask-lt-gt-task"><a href="#1、externalPush-ForkJoinTask-lt-gt-task" class="headerlink" title="1、externalPush(ForkJoinTask&lt;?&gt; task)"></a>1、externalPush(ForkJoinTask&lt;?&gt; task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加给定任务到submission队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue q;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();<span class="comment">//探针值，用于计算WorkQueue槽位索引</span></span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp; <span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定workQueue</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">        <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引位置</span></span><br><span class="line">            U.putOrderedObject(a, j, task);<span class="comment">//任务入列</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//更新push slot</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);<span class="comment">//任务数小于1时尝试创建或激活一个工作线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);<span class="comment">//初始化workQueues及相关属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说明一下externalPush和externalSubmit两个方法的联系：它们的作用都是把任务放到队列中等待执行。不同的是，externalSubmit可以说是完整版的externalPush，在任务首次提交时，需要初始化workQueues及其他相关属性，这个初始化操作就是externalSubmit来完成的；而后再向池中提交的任务都是通过简化版的externalSubmit-externalPush来完成。</p>
<p>externalPush的执行流程很简单：</p>
<ol>
<li>首先找到一个随机偶数槽位的 workQueue，</li>
<li>然后把任务放入这个 workQueue 的任务数组中，并更新top位。</li>
<li>如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalSubmit初始化时发生异常导致工作线程创建失败)。</li>
</ol>
<h6 id="2、externalSubmit-ForkJoinTask-lt-gt-task"><a href="#2、externalSubmit-ForkJoinTask-lt-gt-task" class="headerlink" title="2、externalSubmit(ForkJoinTask&lt;?&gt; task)"></a>2、externalSubmit(ForkJoinTask&lt;?&gt; task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务提交</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化调用线程的探针值，用于计算WorkQueue索引</span></span><br><span class="line">    <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        WorkQueue q;</span><br><span class="line">        <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;<span class="comment">// 池已关闭</span></span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化workQueues</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            rs = lockRunState();<span class="comment">//锁定runState</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化stealCounter</span></span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">//创建workQueues，容量为2的幂次方</span></span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);<span class="comment">//解锁并更新runState</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;<span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定 workQueue</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;<span class="comment">//当前workQueue的全部任务</span></span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="keyword">null</span>) &#123;<span class="comment">//扩容</span></span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);<span class="comment">//放入给定任务</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//修改push slot</span></span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;<span class="comment">//任务提交成功，创建或激活工作线程</span></span><br><span class="line">                    signalWork(ws, q);<span class="comment">//创建或激活一个工作线程来运行任务</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure 操作失败，重新获取探针值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// 更新索引k位值的workQueue</span></span><br><span class="line">            <span class="comment">//else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);<span class="comment">//重新获取线程探针值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：externalSubmit是externalPush的完整版本，主要用于<strong>第一次提交任务时初始化workQueues及相关属性</strong>，并且<strong>提交给定任务到队列中</strong>。具体执行步骤如下：</p>
<ul>
<li>如果池为终止状态(runState&lt;0)，调用tryTerminate来终止线程池，并抛出任务拒绝异常；</li>
<li>如果尚未初始化，就为 FJP 执行初始化操作：初始化stealCounter、创建workerQueues，然后继续自旋；</li>
<li>初始化完成后，执行在externalPush中相同的操作：获取 workQueue，放入指定任务。任务提交成功后调用signalWork方法创建或激活线程；</li>
<li>如果在步骤3中获取到的 workQueue 为null，会在这一步中创建一个 workQueue，创建成功继续自旋执行第三步操作；</li>
<li>如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。</li>
</ul>
<h6 id="3、signalWork-WorkQueue-ws-WorkQueue-q"><a href="#3、signalWork-WorkQueue-ws-WorkQueue-q" class="headerlink" title="3、signalWork(WorkQueue[] ws, WorkQueue q)"></a>3、signalWork(WorkQueue[] ws, WorkQueue q)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> sp, i;</span><br><span class="line">    WorkQueue v;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>) c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);<span class="comment">//工作线程太少，添加新的工作线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//计算ctl，加上版本戳SS_SEQ避免ABA问题</span></span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒阻塞线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：新建或唤醒一个工作线程，在<code>externalPush</code>、<code>externalSubmit</code>、<code>workQueue.push</code>、<code>scan</code>中调用。如果还有空闲线程，则尝试唤醒索引到的 WorkQueue 的parker线程；如果工作线程过少((ctl &amp; ADD_WORKER) != 0L)，则调用tryAddWorker添加一个新的工作线程。</p>
<h6 id="4、tryAddWorker-long-c"><a href="#4、tryAddWorker-long-c" class="headerlink" title="4、tryAddWorker(long c)"></a>4、tryAddWorker(long c)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();<span class="comment">//创建工作线程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createWorker()创建工作线程。</p>
<h6 id="5、createWorker"><a href="#5、createWorker" class="headerlink" title="5、createWorker()"></a>5、createWorker()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);<span class="comment">//线程创建失败处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：createWorker首先通过线程工厂创一个新的ForkJoinWorkerThread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterWorker处理线程创建失败的逻辑(deregisterWorker在后面再详细说明)。</p>
<p>ForkJoinWorkerThread 的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;aForkJoinWorkerThread&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ForkJoinWorkerThread 在构造时首先调用父类 Thread 的方法，然后为工作线程注册pool和workQueue，而workQueue的注册任务由ForkJoinPool.registerWorker来完成。</p>
<h6 id="6、registerWorker"><a href="#6、registerWorker" class="headerlink" title="6、registerWorker()"></a>6、registerWorker()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);<span class="comment">//构造新的WorkQueue</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成新建WorkQueue的索引</span></span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// Worker任务放在奇数索引位 odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision 已存在，重新计算索引位</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//查找可用的索引位</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;<span class="comment">//所有索引位都被占用，对workQueues进行扩容</span></span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);<span class="comment">//workQueues 扩容</span></span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：registerWorker是 ForkJoinWorkerThread 构造器的回调函数，用于创建和记录工作线程的 WorkQueue。比较简单，就不多赘述了。<strong>注意在此为工作线程创建的 WorkQueue 是放在奇数索引的(代码行: i = ((s &lt;&lt; 1) | 1) &amp; m;)</strong></p>
<h6 id="7、小结"><a href="#7、小结" class="headerlink" title="7、小结"></a>7、小结</h6><p>OK，外部任务的提交流程就先讲到这里。在createWorker()中启动工作线程后(wt.start())，当为线程分配到CPU执行时间片之后会运行 ForkJoinWorkerThread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。</p>
<h5 id="3、执行流程：子任务（Worker-task）提交"><a href="#3、执行流程：子任务（Worker-task）提交" class="headerlink" title="3、执行流程：子任务（Worker task）提交"></a>3、执行流程：子任务（Worker task）提交</h5><p>子任务的提交相对比较简单，<strong>由任务的fork()方法完成</strong>。通过上面的流程图可以看到任务被分割(fork)之后调用了ForkJoinPool.WorkQueue.push()方法直接把任务放到队列中等待被执行。</p>
<h6 id="1、ForkJoinTask-fork"><a href="#1、ForkJoinTask-fork" class="headerlink" title="1、ForkJoinTask.fork()"></a>1、ForkJoinTask.fork()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果当前线程是 Worker 线程，说明当前任务是fork分割的子任务，通过ForkJoinPool.workQueue.push()方法直接把任务放到自己的等待队列中；否则调用ForkJoinPool.externalPush()提交到一个随机的等待队列中(外部任务)。</p>
<h6 id="2、ForkJoiPool-WorkQueue-push"><a href="#2、ForkJoiPool-WorkQueue-push" class="headerlink" title="2、ForkJoiPool.WorkQueue.push()"></a>2、ForkJoiPool.WorkQueue.push()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;<span class="comment">//首次提交，创建或唤醒一个工作线程</span></span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：首先把任务放入等待队列并更新top位；如果当前 WorkQueue 为新建的等待队列(top-base&lt;=1)，则调用signalWork方法为当前 WorkQueue 新建或唤醒一个工作线程；如果 WorkQueue 中的任务数组容量过小，则调用growArray()方法对其进行==两倍==扩容，growArray()方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;<span class="comment">//获取内部任务列表</span></span><br><span class="line">    <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Queue capacity exceeded&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">    <span class="comment">//新建一个两倍容量的任务数组</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mask = size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从老数组中拿出数据，放到新的数组中</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// emulate poll from old array, push to new array</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="keyword">int</span> j = ((b &amp; mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;) U.getObjectVolatile(oldA, oldj);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))</span><br><span class="line">                U.putObjectVolatile(a, j, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h6><p>到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。</p>
<h5 id="4、执行流程：任务执行"><a href="#4、执行流程：任务执行" class="headerlink" title="4、执行流程：任务执行"></a>4、执行流程：任务执行</h5><p>回到我们开始时的流程图，在ForkJoinPool .createWorker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到CPU执行时间片之后会执行 ForkJoinWorkerThread 的run()方法正式开始执行任务。</p>
<h6 id="1、ForkJoinWorkerThread-run"><a href="#1、ForkJoinWorkerThread-run" class="headerlink" title="1、ForkJoinWorkerThread.run()"></a>1、ForkJoinWorkerThread.run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);<span class="comment">//处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：方法很简单，在工作线程运行前后会调用自定义钩子函数(<code>onStart</code>和<code>onTermination</code>)，<strong>任务的运行则是调用了ForkJoinPool.runWorker()。如果全部任务执行完毕或者期间遭遇异常，则通过ForkJoinPool.deregisterWorker关闭工作线程并处理异常信息</strong>(deregisterWorker方法我们后面会详细讲解)。</p>
<h6 id="2、ForkJoinPool-runWorker-WorkerQueue-w"><a href="#2、ForkJoinPool-runWorker-WorkerQueue-w" class="headerlink" title="2、ForkJoinPool.runWorker(WorkerQueue w)"></a>2、ForkJoinPool.runWorker(WorkerQueue w)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)<span class="comment">//扫描任务执行</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：runWorker是 ForkJoinWorkerThread 的主运行方法，用来依次执行当前工作线程中的任务。</p>
<p>函数流程很简单：调用scan方法依次获取任务，然后调用WorkQueue .runTask运行任务；如果未扫描到任务，则调用awaitWork等待，直到工作线程/线程池终止或等待超时。</p>
<h6 id="3、ForkJoinPool-scan-WorkQueue-w-int-r"><a href="#3、ForkJoinPool-scan-WorkQueue-w-int-r" class="headerlink" title="3、ForkJoinPool.scan(WorkQueue w, int r)"></a>3、ForkJoinPool.scan(WorkQueue w, int r)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="comment">//初始扫描起点，自旋扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">            WorkQueue q;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n;</span><br><span class="line">            <span class="keyword">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;<span class="comment">//获取workQueue</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="comment">//计算偏移量</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//取base位置任务</span></span><br><span class="line">                            q.base == b) &#123;<span class="comment">//stable</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;  <span class="comment">//scanning</span></span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;<span class="comment">//</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;<span class="comment">//更新base位</span></span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);<span class="comment">//创建或唤醒工作线程来运行任务</span></span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate 尝试激活工作线程</span></span><br><span class="line">                                w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>) c], AC_UNIT);<span class="comment">//唤醒栈顶工作线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//base位置任务为空或base位置偏移，随机移位重新扫描</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    r ^= r &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;<span class="comment">//队列任务为空，记录base位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新索引k 继续向后查找</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="comment">//运行到这里说明已经扫描了全部的 workQueues，但并未扫描到任务</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">// 已经被灭活或终止,跳出循环</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对当前WorkQueue进行灭活操作</span></span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                            (UC_MASK &amp; ((c = ctl) - AC_UNIT)));<span class="comment">//计算ctl为INACTIVE状态并减少活跃线程数</span></span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>) c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);<span class="comment">//修改scanState为inactive状态</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))<span class="comment">//更新scanState为灭活状态</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;<span class="comment">//重置checkSum，继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：扫描并尝试偷取一个任务。使用w.hint进行随机索引 WorkQueue，也就是说并不一定会执行当前 WorkQueue 中的任务，而是偷取别的Worker的任务来执行。</p>
<p>函数的大概执行流程如下：</p>
<ul>
<li>取随机位置的一个 WorkQueue；</li>
<li>获取base位的 ForkJoinTask，成功取到后更新base位并返回任务；如果取到的 WorkQueue 中任务数大于1，则调用signalWork创建或唤醒其他工作线程；</li>
<li>如果当前工作线程处于不活跃状态(INACTIVE)，则调用tryRelease尝试唤醒栈顶工作线程来执行。</li>
</ul>
<p>tryRelease源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> c, WorkQueue v, <span class="keyword">long</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sp = (<span class="keyword">int</span>) c, vs = (sp + SS_SEQ) &amp; ~INACTIVE;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="comment">//ctl低32位等于scanState，说明可以唤醒parker线程</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.scanState == sp) &#123;          <span class="comment">// v is at top of stack</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;</span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；</li>
<li>如果扫描整个workQueues之后没有获取到任务，则设置当前工作线程为INACTIVE状态；然后重置checkSum，再次扫描一圈之后如果还没有任务则跳出循环返回null。</li>
</ul>
<h6 id="4、ForkJoinPool-awaitWork-WorkQueue-w-int-r"><a href="#4、ForkJoinPool-awaitWork-WorkQueue-w-int-r" class="headerlink" title="4、ForkJoinPool.awaitWork(WorkQueue w, int r)"></a>4、ForkJoinPool.awaitWork(WorkQueue w, int r)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">21</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v;</span><br><span class="line">                WorkQueue[] ws;</span><br><span class="line">                <span class="keyword">int</span> s, j;</span><br><span class="line">                AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                        (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                        (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// 当前workQueue已经终止，返回false recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;<span class="comment">//判断线程是否被中断，并清除中断状态</span></span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>) ((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);<span class="comment">//活跃线程数</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) || <span class="comment">//无active线程，尝试终止</span></span><br><span class="line">                    (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>) c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>) (c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))<span class="comment">//总线程过量</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                <span class="comment">//计算空闲超时时间</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;<span class="comment">//设置parker，准备阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);<span class="comment">//阻塞指定的时间</span></span><br><span class="line"></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，说明等到任务，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                    deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))<span class="comment">//未等到任务，更新ctl，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：回到runWorker方法，如果scan方法未扫描到任务，会调用awaitWork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下：</p>
<ul>
<li>在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。</li>
<li>如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 Worker，就阻塞指定的时间(IDLE_TIMEOUT)；</li>
<li>等到届期或被唤醒后如果发现自己是scanning(scanState &gt;= 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。</li>
</ul>
<h6 id="5、WorkQueue-runTask"><a href="#5、WorkQueue-runTask" class="headerlink" title="5、WorkQueue.runTask()"></a>5、WorkQueue.runTask()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec();<span class="comment">//更新currentSteal并执行任务</span></span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();<span class="comment">//依次执行本地任务</span></span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);<span class="comment">//增加偷取任务数</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();<span class="comment">//执行钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：在scan方法扫描到任务之后，调用WorkQueue.runTask()来执行获取到的任务，大概流程如下：</p>
<ul>
<li>标记scanState为正在执行状态；</li>
<li>更新currentSteal为当前获取到的任务并执行它，任务的执行调用了ForkJoinTask.doExec()方法，</li>
</ul>
<p>ForkJoinTask.doExec()方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinTask.doExec()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();<span class="comment">//执行我们定义的任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用execLocalTasks依次执行当前WorkerQueue中的任务，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行并移除所有本地任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;<span class="comment">//FIFO模式</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getAndSetObject</span><br><span class="line">                        (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)<span class="comment">//FIFO执行，取top任务</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();<span class="comment">//执行</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();<span class="comment">//LIFO模式执行，取base任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新偷取任务数；</li>
<li>还原scanState并执行钩子函数。</li>
</ul>
<h6 id="6、ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex"><a href="#6、ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex" class="headerlink" title="6、ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)"></a>6、ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">    WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1.移除workQueue</span></span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;<span class="comment">//获取ForkJoinWorkerThread的等待队列</span></span><br><span class="line">        WorkQueue[] ws;                           <span class="comment">// remove index from array</span></span><br><span class="line">        <span class="keyword">int</span> idx = w.config &amp; SMASK;<span class="comment">//计算workQueue索引</span></span><br><span class="line">        <span class="keyword">int</span> rs = lockRunState();<span class="comment">//获取runState锁和当前池运行状态</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            ws[idx] = <span class="keyword">null</span>;<span class="comment">//移除workQueue</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//解除runState锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.减少CTL数</span></span><br><span class="line">    <span class="keyword">long</span> c;                                       <span class="comment">// decrement counts</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                 (<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                       (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                       (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">//3.处理被移除workQueue内部相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.qlock = -<span class="number">1</span>;                             <span class="comment">// ensure set</span></span><br><span class="line">        w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">        w.cancelAll();                            <span class="comment">// cancel remaining tasks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果线程未终止，替换被移除的workQueue并唤醒内部线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                    <span class="comment">// possibly replace</span></span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">        <span class="comment">//尝试终止线程池</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              <span class="comment">// already terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//唤醒被替换的线程，依赖于下一步</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;         <span class="comment">// wake up replacement</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建工作线程替换</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            tryAddWorker(c);                      <span class="comment">// create replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                      <span class="comment">// don&#x27;t need replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>)                               <span class="comment">// help clean on way out</span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>                                          <span class="comment">// rethrow</span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：deregisterWorker方法用于<strong>工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给 ForkJoinTask 来处理</strong>。</p>
<h6 id="7、小结-1"><a href="#7、小结-1" class="headerlink" title="7、小结"></a>7、小结</h6><p>以上我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join/invoke)。</p>
<h5 id="5、获取任务结果——ForkJoinTask-join-ForkJoinTask-invoke"><a href="#5、获取任务结果——ForkJoinTask-join-ForkJoinTask-invoke" class="headerlink" title="5、获取任务结果——ForkJoinTask.join()/ForkJoinTask.invoke()"></a>5、获取任务结果——ForkJoinTask.join()/ForkJoinTask.invoke()</h5><ul>
<li><p>join()</p>
<ul>
<li><pre><code class="java">//合并任务结果
public final V join() &#123;
    int s;
    if ((s = doJoin() &amp; DONE_MASK) != NORMAL)
        reportException(s);
    return getRawResult();
&#125;

//join, get, quietlyJoin的主实现方法
private int doJoin() &#123;
    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
    return (s = status) &lt; 0 ? s :
    ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
        (w = (wt = (ForkJoinWorkerThread)t).workQueue).
        tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :
    wt.pool.awaitJoin(w, this, 0L) :
    externalAwaitDone();
&#125;

final int doExec() &#123;
    int s; boolean completed; 
    if ((s = status) &gt;= 0) &#123;
        try &#123;
            completed = exec(); 
        &#125; catch (Throwable rex) &#123;
            return setExceptionalCompletion(rex); 
        &#125;
        if (completed) 
            s = setCompletion(NORMAL); 
    &#125;
    return s; 
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - 它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种： &#x3D;&#x3D;已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）&#x3D;&#x3D; </span><br><span class="line"></span><br><span class="line">    - 如果任务状态是已完成，则直接返回任务结果。</span><br><span class="line">    - 如果任务状态是被取消，则直接抛出 CancellationException</span><br><span class="line">    - 如果任务状态是抛出异常，则直接抛出对应的异常</span><br><span class="line"></span><br><span class="line">  - 在 doJoin()方法流程如下：</span><br><span class="line"></span><br><span class="line">    1. 首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</span><br><span class="line">    2. 如果没有执行完，则从任务数组里取出任务并执行。</span><br><span class="line">    3. 如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</span><br><span class="line"></span><br><span class="line">- invoke()</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;执行任务，并等待任务完成并返回结果</span><br><span class="line">    public final V invoke() &#123;</span><br><span class="line">        int s;</span><br><span class="line">        if ((s &#x3D; doInvoke() &amp; DONE_MASK) !&#x3D; NORMAL)</span><br><span class="line">            reportException(s);</span><br><span class="line">        return getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;invoke, quietlyInvoke的主实现方法</span><br><span class="line">    private int doInvoke() &#123;</span><br><span class="line">        int s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">        return (s &#x3D; doExec()) &lt; 0 ? s :</span><br><span class="line">            ((t &#x3D; Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">            (wt &#x3D; (ForkJoinWorkerThread)t).pool.</span><br><span class="line">            awaitJoin(wt.workQueue, this, 0L) :</span><br><span class="line">            externalAwaitDone();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>说明：join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。</p>
<p>ForkJoinTask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了doJoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalAwaitDone方法等待执行结果。</p>
<p>不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列 top 位时(通过tryUnpush方法判断)才能执行，如果当前任务不在 top 位或者任务执行失败调用ForkJoinPool.awaitJoin方法帮助执行或阻塞当前 join 任务。(所以在官方文档中建议了我们对ForkJoinTask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用：<code>a.fork(); b.fork(); b.join(); a.join();</code>。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top 位)，在它fork()之后直接调用join()就可以直接执行而不会调用ForkJoinPool.awaitJoin方法去等待。)</p>
<p>在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程：</p>
<p><img src="/2021/07/19/JUC/java-thread-x-forkjoin-6.png" alt="img"></p>
<p>后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalAwaitDone)，然后再讲解内部 join 任务(从ForkJoinPool.awaitJoin()开始)。</p>
<h6 id="1、ForkJoinTask-externalAwaitDone"><a href="#1、ForkJoinTask-externalAwaitDone" class="headerlink" title="1、ForkJoinTask.externalAwaitDone()"></a>1、ForkJoinTask.externalAwaitDone()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(  <span class="comment">// CountedCompleter任务</span></span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);  <span class="comment">// ForkJoinTask任务</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;<span class="comment">//执行失败，进入等待</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;  <span class="comment">//更新state</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;<span class="comment">//SIGNAL 等待信号</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是<strong>对不同的任务类型分两种情况</strong>：</p>
<ul>
<li><strong>如果我们的任务为 CountedCompleter 类型的任务，则调用externalHelpComplete方法来执行任务。</strong></li>
<li><strong>其他类型的 ForkJoinTask 任务调用tryExternalUnpush来执行</strong></li>
</ul>
<p>tryExternalUnpush的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为外部提交者提供 tryUnpush 功能(给定任务在top位时弹出任务)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryExternalUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue w;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">int</span> m, s;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (w = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (a = w.array) != <span class="keyword">null</span> &amp;&amp; (s = w.top) != w.base) &#123;</span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;  <span class="comment">//取top位任务</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(w, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;  <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">if</span> (w.top == s &amp;&amp; w.array == a &amp;&amp;</span><br><span class="line">                    U.getObject(a, j) == task &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;  <span class="comment">//符合条件，弹出</span></span><br><span class="line">                U.putOrderedInt(w, QTOP, s - <span class="number">1</span>);  <span class="comment">//更新top</span></span><br><span class="line">                U.putOrderedInt(w, QLOCK, <span class="number">0</span>); <span class="comment">//解锁，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            U.compareAndSwapInt(w, QLOCK, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//当前任务不在top位，解锁返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryExternalUnpush的作用就是<strong>判断当前任务是否在top位，如果是则弹出任务，然后在externalAwaitDone中调用doExec()执行任务</strong>。</p>
<h6 id="2、ForkJoinPool-awaitJoin"><a href="#2、ForkJoinPool-awaitJoin" class="headerlink" title="2、ForkJoinPool.awaitJoin()"></a>2、ForkJoinPool.awaitJoin()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;  <span class="comment">//获取给定Worker的join任务</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);  <span class="comment">//把currentJoin替换为给定任务</span></span><br><span class="line">        <span class="comment">//判断是否为CountedCompleter类型的任务</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">                (CountedCompleter&lt;?&gt;) task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)  <span class="comment">//已经完成|取消|异常 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)<span class="comment">//CountedCompleter任务由helpComplete来完成join</span></span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))  <span class="comment">//尝试执行</span></span><br><span class="line">                helpStealer(w, task);  <span class="comment">//队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>) <span class="comment">//已经完成|取消|异常，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//计算任务等待时间</span></span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;<span class="comment">//执行补偿操作</span></span><br><span class="line">                task.internalWait(ms);<span class="comment">//补偿执行成功，任务等待指定时间</span></span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);<span class="comment">//更新活跃线程数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);<span class="comment">//循环结束，替换为原来的join任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果当前 join 任务不在Worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。</p>
<p>函数执行流程如下：</p>
<ul>
<li>由于每次调用awaitJoin都会优先执行当前join的任务，所以首先会更新currentJoin为当前join任务；</li>
<li>进入自旋：<ul>
<li>首先检查任务是否已经完成(通过task.status &lt; 0判断)，如果给定任务执行完毕|取消|异常，则跳出循环返回执行状态s；</li>
<li>如果是 CountedCompleter 任务类型，调用helpComplete方法来完成join操作(后面笔者会开新篇来专门讲解CountedCompleter，本篇暂时不做详细解析)；</li>
<li>非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务；</li>
<li>如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；</li>
<li>再次判断任务是否执行完毕(task.status &lt; 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；</li>
<li>调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。在执行补偿期间，如果发现资源争用|池处于unstable状态|当前Worker已终止，则调用ForkJoinTask.internalWait()方法等待指定的时间，任务唤醒之后继续自旋。</li>
</ul>
</li>
</ul>
<p>ForkJoinTask.internalWait()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">internalWait</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// force completer to issue notify</span></span><br><span class="line">        U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;<span class="comment">//更新任务状态为SIGNAL(等待唤醒)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123; wait(timeout); &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在awaitJoin中，我们总共调用了三个比较复杂的方法：<code>tryRemoveAndExec</code>、<code>helpStealer</code>和<code>tryCompensate</code>，下面我们依次讲解。</p>
<h6 id="3、WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task"><a href="#3、WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task" class="headerlink" title="3、WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)"></a>3、WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</h6><p>非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从top往下自旋查找</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引</span></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getObject(a, j)) == <span class="keyword">null</span>) <span class="comment">//获取索引到的任务</span></span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123; <span class="comment">//给定任务为索引任务</span></span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123; <span class="comment">//弹出任务</span></span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s); <span class="comment">//更新top</span></span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                                a, j, task, <span class="keyword">new</span> EmptyTask()); <span class="comment">//join任务已经被移除，替换为一个占位任务</span></span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec(); <span class="comment">//执行</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123; <span class="comment">//给定任务不是top任务</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) <span class="comment">//弹出任务</span></span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);<span class="comment">//更新top</span></span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="comment">//遍历结束</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>) <span class="comment">//任务执行完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：从top位开始自旋向下找到给定任务，如果找到把它从当前 Worker 的任务队列中移除并执行它。</p>
<p>注意返回的参数：如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。</p>
<h6 id="4、ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task"><a href="#4、ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task" class="headerlink" title="4、ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)"></a>4、ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</h6><p>如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helpStealer</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    <span class="keyword">int</span> oldSum = <span class="number">0</span>, checkSum, m;</span><br><span class="line">    <span class="keyword">if</span> (ws != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;                                       <span class="comment">// restart point</span></span><br><span class="line">            checkSum = <span class="number">0</span>;                          <span class="comment">// for stability check</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    <span class="comment">// v is subtask stealer</span></span><br><span class="line">            descent:</span><br><span class="line">            <span class="keyword">for</span> (subtask = task; subtask.status &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">                <span class="comment">//1. 找到给定WorkQueue的偷取者v</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = j.hint | <span class="number">1</span>, k = <span class="number">0</span>, i; ; k += <span class="number">2</span>) &#123;<span class="comment">//跳两个索引，因为Worker在奇数索引位</span></span><br><span class="line">                    <span class="keyword">if</span> (k &gt; m)                     <span class="comment">// can&#x27;t find stealer</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="keyword">if</span> ((v = ws[i = (h + k) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.currentSteal == subtask) &#123;<span class="comment">//定位到偷取者</span></span><br><span class="line">                            j.hint = i;<span class="comment">//更新stealer索引</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2. 帮助偷取者v执行任务</span></span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;                         <span class="comment">// help v or descend</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a;            <span class="comment">//偷取者内部的任务</span></span><br><span class="line">                    <span class="keyword">int</span> b;</span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;<span class="comment">//获取偷取者的join任务</span></span><br><span class="line">                    <span class="keyword">if</span> (subtask.status &lt; <span class="number">0</span> || j.currentJoin != subtask ||</span><br><span class="line">                            v.currentSteal != subtask) <span class="comment">// stale</span></span><br><span class="line">                        <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                    <span class="keyword">if</span> (b - v.top &gt;= <span class="number">0</span> || (a = v.array) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((subtask = next) == <span class="keyword">null</span>)   <span class="comment">//偷取者的join任务为null，跳出descent循环</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        j = v;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//获取base偏移地址</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i));<span class="comment">//获取偷取者的base任务</span></span><br><span class="line">                    <span class="keyword">if</span> (v.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="keyword">null</span>)             <span class="comment">// stale</span></span><br><span class="line">                            <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;<span class="comment">//弹出任务</span></span><br><span class="line">                            v.base = b + <span class="number">1</span>;         <span class="comment">//更新偷取者的base位</span></span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;<span class="comment">//获取调用者偷来的任务</span></span><br><span class="line">                            <span class="keyword">int</span> top = w.top;</span><br><span class="line">                            <span class="comment">//首先更新给定workQueue的currentSteal为偷取者的base任务，然后执行该任务</span></span><br><span class="line">                            <span class="comment">//然后通过检查top来判断给定workQueue是否有自己的任务，如果有，</span></span><br><span class="line">                            <span class="comment">// 则依次弹出任务(LIFO)-&gt;更新currentSteal-&gt;执行该任务(注意这里是自己偷自己的任务执行)</span></span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">                            &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    w.top != top &amp;&amp; <span class="comment">//内部有自己的任务，依次弹出执行</span></span><br><span class="line">                                    (t = w.pop()) != <span class="keyword">null</span>);</span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);<span class="comment">//还原给定workQueue的currentSteal</span></span><br><span class="line">                            <span class="keyword">if</span> (w.base != w.top)<span class="comment">//给定workQueue有自己的任务了，帮助结束，返回</span></span><br><span class="line">                                <span class="keyword">return</span>;            <span class="comment">// can&#x27;t further help</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。</p>
<p>基本思想是：偷取者帮助我执行任务，我去帮助偷取者执行它的任务。 函数执行流程如下：</p>
<ol>
<li>循环定位偷取者，由于Worker是在奇数索引位，所以每次会跳两个索引位。</li>
<li>定位到偷取者之后，更新调用者 WorkQueue 的hint为偷取者的索引，方便下次定位； </li>
<li>定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。</li>
<li>在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top != top)，则依次弹出自己的任务(LIFO顺序)并执行(也就是说自己偷自己的任务执行)。</li>
</ol>
<h6 id="5、ForkJoinPool-tryCompensate-WorkQueue-w"><a href="#5、ForkJoinPool-tryCompensate-WorkQueue-w" class="headerlink" title="5、ForkJoinPool.tryCompensate(WorkQueue w)"></a>5、ForkJoinPool.tryCompensate(WorkQueue w)</h6><p>调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">            (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">            (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>; <span class="comment">//调用者已终止</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>) (c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);<span class="comment">//唤醒等待的工作线程</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//没有空闲线程</span></span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>) (c &gt;&gt; AC_SHIFT) + pc; <span class="comment">//活跃线程数</span></span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>) (c &gt;&gt; TC_SHIFT) + pc;<span class="comment">//总线程数</span></span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;<span class="comment">//取奇数索引位</span></span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)<span class="comment">//没有正在运行任务，跳出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;<span class="comment">//正在运行任务，添加标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;<span class="comment">//总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空，不需要补偿</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                    (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);<span class="comment">//更新活跃线程数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))<span class="comment">//超出最大线程数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                    <span class="string">&quot;Thread limit exceeded replacing blocked worker&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                    (TC_MASK &amp; (c + TC_UNIT)));<span class="comment">//计算总线程数</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);<span class="comment">//更新总线程数</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿</span></span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况：</p>
<ul>
<li><strong>需要补偿</strong> ：<ul>
<li>调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryRelease方法)</li>
<li>池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createWorker方法)</li>
</ul>
</li>
<li><strong>不需要补偿</strong> ：<ul>
<li>调用者已终止或池处于不稳定状态</li>
<li>总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空</li>
</ul>
</li>
</ul>
<h4 id="6、Fork-Join的陷阱与注意事项"><a href="#6、Fork-Join的陷阱与注意事项" class="headerlink" title="6、Fork/Join的陷阱与注意事项"></a>6、Fork/Join的陷阱与注意事项</h4><p>使用Fork/Join框架时，需要注意一些陷阱, 在下面 <code>斐波那契数列</code>例子中你将看到示例。</p>
<h5 id="1、避免不必要的fork"><a href="#1、避免不必要的fork" class="headerlink" title="1、避免不必要的fork()"></a>1、避免不必要的fork()</h5><p>划分成两个子任务后，不要同时调用两个子任务的fork()方法。</p>
<p>表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，<strong>直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多</strong>。</p>
<blockquote>
<p>当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的<code>invokeAll</code>方法，因为使用它们能避免不必要的fork()。</p>
</blockquote>
<h5 id="2、注意fork-、compute-、join-的顺序"><a href="#2、注意fork-、compute-、join-的顺序" class="headerlink" title="2、注意fork()、compute()、join()的顺序"></a>2、注意fork()、compute()、join()的顺序</h5><p>为了两个任务并行，三个方法的调用顺序需要万分注意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">right.fork(); <span class="comment">// 计算右边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.compute(); <span class="comment">// 计算左边的任务(同时右边任务也在计算)</span></span><br><span class="line"><span class="keyword">long</span> rightAns = right.join(); <span class="comment">// 等待右边的结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<p>如果我们写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left.fork(); <span class="comment">// 计算完左边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="keyword">long</span> rightAns = right.compute(); <span class="comment">// 再计算右边的任务</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rightAns = right.compute(); <span class="comment">// 计算完右边的任务</span></span><br><span class="line">left.fork(); <span class="comment">// 再计算左边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<h5 id="3、选择合适的子任务粒度"><a href="#3、选择合适的子任务粒度" class="headerlink" title="3、选择合适的子任务粒度"></a>3、选择合适的子任务粒度</h5><p>选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用Fork/Join框架并不一定比顺序执行任务的效率高：如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。</p>
<p>官方文档给出的粗略经验是：任务应该执行<code>100~10000</code>个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。</p>
<blockquote>
<p>和其他Java代码一样，Fork/Join框架测试时需要“预热”或者说执行几遍才会被JIT(Just-in-time)编译器优化，所以测试性能之前跑几遍程序很重要。</p>
</blockquote>
<h5 id="4、避免重量级任务划分与结果合并"><a href="#4、避免重量级任务划分与结果合并" class="headerlink" title="4、避免重量级任务划分与结果合并"></a>4、避免重量级任务划分与结果合并</h5><p>Fork/Join的很多使用场景都用到数组或者List等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免<code>System.arraycopy</code>这样耗时耗空间的操作，从而最小化任务的处理开销。</p>
<h4 id="7、再深入理解"><a href="#7、再深入理解" class="headerlink" title="7、再深入理解"></a>7、再深入理解</h4><h5 id="1、有哪些JDK源码中使用了Fork-Join思想"><a href="#1、有哪些JDK源码中使用了Fork-Join思想" class="headerlink" title="1、有哪些JDK源码中使用了Fork/Join思想"></a>1、有哪些JDK源码中使用了Fork/Join思想</h5><p>我们常用的数组工具类 Arrays 在JDK 8之后新增的==并行排序方法(parallelSort)==就运用了 ForkJoinPool 的特性，还有 ConcurrentHashMap 在JDK 8之后添加的==函数式方法(如forEach等)==也有运用。</p>
<h5 id="2、使用Executors工具类创建ForkJoinPool"><a href="#2、使用Executors工具类创建ForkJoinPool" class="headerlink" title="2、使用Executors工具类创建ForkJoinPool"></a>2、使用Executors工具类创建ForkJoinPool</h5><p>Java8在Executors工具类中新增了两个工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parallelism定义并行级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span></span>;</span><br><span class="line"><span class="comment">// 默认并行级别为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">// Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="3、关于Fork-Join异常处理"><a href="#3、关于Fork-Join异常处理" class="headerlink" title="3、关于Fork/Join异常处理"></a>3、关于Fork/Join异常处理</h5><p>Java的受检异常机制一直饱受诟病，所以在ForkJoinTask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个ExecutionException的受检异常。</p>
<p>所以你可以<strong>在ForkJoinTask中看到内部把受检异常转换成了运行时异常</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rethrow</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">uncheckedThrow</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)t; <span class="comment">// rely on vacuous cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==关于Java你不知道的10件事==中已经指出，JVM实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给Java编译器用的：用于警告程序员这里有个异常没有处理。</p>
<p>但不可否认的是invoke、join()仍可能会抛出运行时异常，所以ForkJoinTask还提供了两个不提取结果和异常的方法quietlyInvoke()、quietlyJoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。</p>
<p><strong>使用<code>quitelyInvoke()</code>和<code>quietlyJoin()</code>时可以配合<code>isCompletedAbnormally()</code>和<code>isCompletedNormally()</code>方法使用。</strong></p>
<p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的getException 方法获取异常。 </p>
<p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。 </p>
<h4 id="8、一些Fork-Join例子"><a href="#8、一些Fork-Join例子" class="headerlink" title="8、一些Fork/Join例子"></a>8、一些Fork/Join例子</h4><h5 id="1、采用Fork-Join来异步计算1-2-3-……-10000的结果"><a href="#1、采用Fork-Join来异步计算1-2-3-……-10000的结果" class="headerlink" title="1、采用Fork/Join来异步计算1+2+3+……+10000的结果"></a>1、采用Fork/Join来异步计算1+2+3+……+10000的结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start; <span class="comment">//开始计算的数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> end; <span class="comment">//最后计算的数</span></span><br><span class="line"></span><br><span class="line">        SumTask(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果</span></span><br><span class="line">            <span class="keyword">if</span>(end - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行: &quot;</span> + start + <span class="string">&quot;-&quot;</span> + end);</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                    sum += i;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果计算量大于1000，那么拆分为两个任务</span></span><br><span class="line">            SumTask task1 = <span class="keyword">new</span> SumTask(start, (start + end) / <span class="number">2</span>);</span><br><span class="line">            SumTask task2 = <span class="keyword">new</span> SumTask((start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">//获取任务执行的结果</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> SumTask(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">1</span>-<span class="number">625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6251</span>-<span class="number">6875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">6</span> 开始执行: <span class="number">5626</span>-<span class="number">6250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">10</span> 开始执行: <span class="number">3751</span>-<span class="number">4375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">13</span> 开始执行: <span class="number">2501</span>-<span class="number">3125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">626</span>-<span class="number">1250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">11</span> 开始执行: <span class="number">5001</span>-<span class="number">5625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> 开始执行: <span class="number">7501</span>-<span class="number">8125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">14</span> 开始执行: <span class="number">1251</span>-<span class="number">1875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span> 开始执行: <span class="number">9376</span>-<span class="number">10000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">8126</span>-<span class="number">8750</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> 开始执行: <span class="number">1876</span>-<span class="number">2500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">12</span> 开始执行: <span class="number">4376</span>-<span class="number">5000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span> 开始执行: <span class="number">8751</span>-<span class="number">9375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6876</span>-<span class="number">7500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">3126</span>-<span class="number">3750</span></span><br><span class="line"><span class="number">50005000</span></span><br></pre></td></tr></table></figure>

<h5 id="2、实现斐波那契数列"><a href="#2、实现斐波那契数列" class="headerlink" title="2、实现斐波那契数列"></a>2、实现斐波那契数列</h5><blockquote>
<p>斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>); <span class="comment">// 最大并发数4</span></span><br><span class="line">    Fibonacci fibonacci = <span class="keyword">new</span> Fibonacci(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Integer result = forkJoinPool.invoke(fibonacci);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为官方API文档示例</span></span><br><span class="line"><span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">    Fibonacci(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">        f1.fork(); </span><br><span class="line">        Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> f2.compute() + f1.join(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照<code>f1.fork()，f2.fork()， f2.join()，f1.join()</code>这样的顺序，不然有性能问题，详见上面注意事项中的说明。</p>
<p>官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    invokeAll(f1,f2);</span><br><span class="line">    <span class="keyword">return</span> f2.join() + f1.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> </span>&#123;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)   <span class="comment">//除了第一个都fork</span></span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)  <span class="comment">//留一个自己执行</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="21、CompletableFuture异步回调"><a href="#21、CompletableFuture异步回调" class="headerlink" title="21、CompletableFuture异步回调"></a>21、CompletableFuture异步回调</h3><h4 id="1、CompletableFuture-简介"><a href="#1、CompletableFuture-简介" class="headerlink" title="1、CompletableFuture 简介"></a>1、CompletableFuture 简介</h4><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞， 可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。 </p>
<p>CompletableFuture 实现了 Future, CompletionStage 接口：</p>
<ul>
<li>实现了 Future 接口就可以兼容现在有线程池框架</li>
<li>而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法</li>
</ul>
<p>通过这两者集合，从而打造出了强大的CompletableFuture 类。 </p>
<h4 id="2、Future-与-CompletableFuture"><a href="#2、Future-与-CompletableFuture" class="headerlink" title="2、Future 与 CompletableFuture"></a>2、Future 与 CompletableFuture</h4><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。 </p>
<h4 id="3、Future-的主要缺点"><a href="#3、Future-的主要缺点" class="headerlink" title="3、Future 的主要缺点"></a>3、Future 的主要缺点</h4><ol>
<li>不支持手动完成<ul>
<li>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果， 现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</li>
</ul>
</li>
<li>不支持进一步的非阻塞调用<ul>
<li>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</li>
</ul>
</li>
<li>不支持链式调用<ul>
<li>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。</li>
</ul>
</li>
<li>不支持多个 Future 合并<ul>
<li>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后， 执行某些函数，是没法通过 Future 实现的。 </li>
</ul>
</li>
<li>不支持异常处理<ul>
<li>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</li>
</ul>
</li>
</ol>
<h4 id="4、CompletableFuture的使用"><a href="#4、CompletableFuture的使用" class="headerlink" title="4、CompletableFuture的使用"></a>4、CompletableFuture的使用</h4><h5 id="1、CompletableFuture-入门"><a href="#1、CompletableFuture-入门" class="headerlink" title="1、CompletableFuture 入门"></a>1、CompletableFuture 入门</h5><p>场景：主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);</span><br><span class="line">                <span class="comment">//子线程睡 5 秒</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="comment">//在子线程中完成主线程</span></span><br><span class="line">                future.complete(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="comment">//主线程调用 get 方法阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程调用 get 方法获取结果为: &quot;</span> + future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A子线程开始干活</span><br><span class="line">主线程调用 get 方法获取结果为: success</span><br><span class="line">主线程完成,阻塞结束!!!!!!</span><br></pre></td></tr></table></figure>

<h5 id="2、没有返回值的同步任务"><a href="#2、没有返回值的同步任务" class="headerlink" title="2、没有返回值的同步任务"></a>2、没有返回值的同步任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有返回值的同步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步调用</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : CompletableFuture1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步任务调用runAsync()方法，使用get()方法获取</p>
<h5 id="3、有返回值的异步任务"><a href="#3、有返回值的异步任务" class="headerlink" title="3、有返回值的异步任务"></a>3、有返回值的异步任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步调用和同步调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//异步调用</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : CompletableFuture2&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture2.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------t=&quot;</span>+t);</span><br><span class="line">            System.out.println(<span class="string">&quot;------u=&quot;</span>+u);</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步调用使用supplyAsync()方法，可以通过whenComplete()获取。</p>
<p>其中supplyAsync()方法的参数是一个Supplier类，而Supplier类是一个函数式接口，可以使用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中whenComplete()的两个参数：</p>
<ul>
<li>t：用来接收异步调用中正常返回的结果，此时的u返回null</li>
<li>u：用来接收异步调用过程中出现的异常，此时的t返回null</li>
</ul>
<p>关于一些函数式接口的接口类：</p>
<ul>
<li><code>supplier</code>：提供者，特点：无中生有 ：() -&gt; 结果</li>
<li><code>function</code>：函数，特点：一个参数一个结果 ：(参数) -&gt; 结果<ul>
<li><code>BiFunction</code>：两个参数一个结果 ：(参数1,参数2) -&gt; 结果</li>
</ul>
</li>
<li><code>consumer</code>：消费者，特点：一个参数没结果：(参数) -&gt; void<ul>
<li><code>BiConsumer</code>：两个参数，没有结果：(参数1,参数2) -&gt; void</li>
</ul>
</li>
</ul>
<h5 id="4、线程依赖"><a href="#4、线程依赖" class="headerlink" title="4、线程依赖"></a>4、线程依赖</h5><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">                num += <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;).thenApply(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> num * num;</span><br><span class="line">        &#125;);</span><br><span class="line">        Integer integer = future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束, 子线程的结果为:&quot;</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">加 10 任务开始</span><br><span class="line">主线程结束, 子线程的结果为:400</span><br></pre></td></tr></table></figure>

<h5 id="5、消费处理结果"><a href="#5、消费处理结果" class="headerlink" title="5、消费处理结果"></a>5、消费处理结果</h5><p>thenAccept 消费处理结果，接收任务的处理结果，并消费处理，无返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">                num += <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;).thenApply(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> num * num;</span><br><span class="line">        &#125;).thenAccept(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">加 10 任务开始</span><br><span class="line">子线程全部处理完成,最后调用了 accept,结果为:400</span><br></pre></td></tr></table></figure>

<h5 id="6、异常处理"><a href="#6、异常处理" class="headerlink" title="6、异常处理"></a>6、异常处理</h5><p>exceptionally 异常处理，出现异常时触发 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>handle 类似于 thenAccept/thenRun 方法，是最后一步的处理调用，但是同时可以处理异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;).handle((i, ex) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 handle 方法&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发生了异常,内容为:&quot;</span> + ex.getMessage());</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">进入 handle 方法</span><br><span class="line">发生了异常,内容为:java.lang.ArithmeticException: / by zero</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<h5 id="7、结果合并"><a href="#7、结果合并" class="headerlink" title="7、结果合并"></a>7、结果合并</h5><p>thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        <span class="comment">//第一步加 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = future.thenCompose(i -&gt;</span><br><span class="line">                <span class="comment">//再来一个CompletableFuture</span></span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">                &#125;));</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(future1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">加 10 任务开始</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>thenCombine 合并两个没有依赖关系的 CompletableFutures 任务 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        <span class="comment">//第一步加 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line">            num = num * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//合并两个结果</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; future = job1.thenCombine(job2, (BiFunction&lt;Integer, Integer, List&lt;Integer&gt;&gt;) (a, b) -&gt; &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(a);</span><br><span class="line">            list.add(b);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;合并结果为:&quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">加 10 任务开始</span><br><span class="line">乘以 10 任务开始</span><br><span class="line">合并结果为:[20, 200]</span><br></pre></td></tr></table></figure>

<h5 id="8、合并多个任务的结果allOf-与anyOf"><a href="#8、合并多个任务的结果allOf-与anyOf" class="headerlink" title="8、合并多个任务的结果allOf 与anyOf"></a>8、合并多个任务的结果allOf 与anyOf</h5><p>allOf：一系列独立的future 任务，等其所有的任务执行完后做一些事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//第一步加 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.add(job1);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.add(job2);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);</span><br><span class="line">            num -= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.add(job3);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.add(job4);</span><br><span class="line">        <span class="comment">//多任务合并</span></span><br><span class="line">        List&lt;Integer&gt; collect = list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">加 10 任务开始</span><br><span class="line">乘以 10 任务开始</span><br><span class="line">减以 10 任务开始</span><br><span class="line">除以 10 任务开始</span><br><span class="line">[20, 200, 190, 19]</span><br></pre></td></tr></table></figure>

<p>anyOf：只要在多个future 里面有一个返回，整个任务就可以结束，而不需要等到每一个 future 结束 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> CompletableFuture[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//第一步加 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">                num += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futures[<span class="number">0</span>] = job1;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line">                num *= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futures[<span class="number">1</span>] = job2;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);</span><br><span class="line">                num -= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futures[<span class="number">2</span>] = job3;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futures[<span class="number">3</span>] = job4;</span><br><span class="line">        CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始</span><br><span class="line">乘以 10 任务开始</span><br><span class="line">100</span><br></pre></td></tr></table></figure>



<h3 id="22、Java-并发-ThreadLocal详解"><a href="#22、Java-并发-ThreadLocal详解" class="headerlink" title="22、Java 并发 - ThreadLocal详解"></a>22、Java 并发 - ThreadLocal详解</h3><p><strong>ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。</strong></p>
<h4 id="1、BAT大厂的面试问题-24"><a href="#1、BAT大厂的面试问题-24" class="headerlink" title="1、BAT大厂的面试问题"></a>1、BAT大厂的面试问题</h4><ul>
<li>什么是ThreadLocal？用来解决什么问题的？</li>
<li>说说你对ThreadLocal的理解</li>
<li>ThreadLocal是如何实现线程隔离的？</li>
<li>为什么ThreadLocal会造成内存泄露？如何解决？</li>
<li>还有哪些使用ThreadLocal的应用场景？</li>
</ul>
<h4 id="2、ThreadLocal简介"><a href="#2、ThreadLocal简介" class="headerlink" title="2、ThreadLocal简介"></a>2、ThreadLocal简介</h4><p>我们在==Java 并发 - 并发理论基础==总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：</p>
<ul>
<li><strong>互斥同步</strong>：<code>synchronized</code> 和 <code>ReentrantLock</code></li>
<li><strong>非阻塞同步</strong>：<code>CAS</code>，<code>AtomicXXXX</code></li>
<li><strong>无同步方案</strong>：<code>栈封闭</code>，<code>本地存储(Thread Local)</code>，<code>可重入代码</code></li>
</ul>
<p>这个章节将详细的讲讲 本地存储(Thread Local)。官网的解释是这样的：</p>
<blockquote>
<p>his class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID) 该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。</p>
</blockquote>
<p>总结而言：<strong>ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类；当使用ThreadLocal来维护变量时，ThreadLocal会为每个线程创建单独的变量副本，避免因多线程操作共享变量而导致的数据不一致的情况</strong>。</p>
<h4 id="3、ThreadLocal理解"><a href="#3、ThreadLocal理解" class="headerlink" title="3、ThreadLocal理解"></a>3、ThreadLocal理解</h4><blockquote>
<p>提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例来理解ThreadLocal：</p>
</blockquote>
<p>如下数据库管理类在单线程使用是没有任何问题的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，在多线程中使用会存在线程安全问题：</p>
<ol>
<li>第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；</li>
<li>第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</li>
</ol>
<p>为了解决上述线程安全的问题，<strong>第一考虑：互斥同步</strong></p>
<p>你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用<code>Synchronized</code>或者<code>ReentrantLock互斥锁</code>。</p>
<p>这里再抛出一个问题：这地方到底需不需要将connect变量进行共享？</p>
<p>事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectionManager connectionManager = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">        Connection connection = connectionManager.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用connection进行操作</span></span><br><span class="line"></span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样处理确实也没有任何问题，由于<strong>每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题</strong>。</p>
<p>但是这样会有一个致命的影响：<strong>导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大</strong>。</p>
<p>这时候ThreadLocal登场了</p>
<p>那么这种情况下使用ThreadLocal是再适合不过的了，<strong>因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能</strong>。下面就是网上出现最多的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dbConnectionLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再注意下<strong>ThreadLocal的修饰符</strong></p>
<p>ThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。<strong>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</strong></p>
<blockquote>
<p>但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如<strong>内存的占用会比不使用ThreadLocal要大</strong>。</p>
</blockquote>
<h4 id="4、ThreadLocal原理"><a href="#4、ThreadLocal原理" class="headerlink" title="4、ThreadLocal原理"></a>4、ThreadLocal原理</h4><h5 id="1、如何实现线程隔离"><a href="#1、如何实现线程隔离" class="headerlink" title="1、如何实现线程隔离"></a>1、如何实现线程隔离</h5><p>主要是用到了Thread对象中的一个<code>ThreadLocalMap</code>类型的变量<code>threadLocals</code>，负责存储当前线程的关于Connection的对象，dbConnectionLocal(以上述例子中为例) 这个变量为Key，以新建的Connection对象为Value；这样的话，线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回。</p>
<p>具体关于为线程分配变量副本的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先获取当前线程对象t，然后从线程t中获取到ThreadLocalMap的成员属性threadLocals</li>
<li>如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值，则直接返回当前线程要获取的对象(本例中为Connection)；</li>
<li>如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象，那么重新创建一个Connection对象，并且添加到当前线程的threadLocals Map中，并返回；</li>
<li>如果当前线程的threadLocals属性还没有被初始化，则重新创建一个ThreadLocalMap对象，并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。</li>
</ul>
<p>如果存在则直接返回很好理解，那么对于如何初始化的代码又是怎样的呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先调用我们上面写的重载过后的initialValue方法，产生一个Connection对象</li>
<li>继续查看当前线程的threadLocals是不是空的，如果ThreadLocalMap已被初始化，那么直接将产生的对象添加到ThreadLocalMap中，如果没有初始化，则创建并添加对象到其中；</li>
</ul>
<p>同时，ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们也可以不实现initialValue，将初始化工作放到DBConnectionFactory的getConnection方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection connection = dbConnectionLocal.get();</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            dbConnectionLocal.set(connection);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了；其实就是<strong>用了Map的数据结构给当前线程缓存了，要使用的时候就从本线程的threadLocals对象中获取就可以了，key就是当前线程</strong>；</p>
<p>当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了，当然能做到变量的线程间隔离了；</p>
<p>现在我们知道了ThreadLocal到底是什么了，又知道了如何使用ThreadLocal以及其基本实现原理了，是不是就可以结束了呢？其实还有一个问题就是ThreadLocalMap是个什么对象，为什么要用这个对象呢？</p>
<h5 id="2、ThreadLocalMap对象是什么"><a href="#2、ThreadLocalMap对象是什么" class="headerlink" title="2、ThreadLocalMap对象是什么"></a>2、ThreadLocalMap对象是什么</h5><p>本质上来讲，它就是一个Map，但是这个ThreadLocalMap与我们平时见到的Map有点不一样：</p>
<ul>
<li><strong>它没有实现Map接口</strong>；</li>
<li><strong>它没有public的方法，最多有一个default的构造方法，因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用，属于静态内部类</strong>；</li>
<li><strong>ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</strong></li>
<li><strong>该方法仅仅用了一个Entry数组来存储Key、Value；Entry并不是链表形式，而是每个bucket里面仅仅放一个Entry</strong>；</li>
</ul>
<p>要了解ThreadLocalMap的实现，我们先从入口开始，就是往该Map中添加一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行简单的分析，对该代码表层意思进行解读：</p>
<ul>
<li>看下当前threadLocal的在数组中的索引位置 比如：<code>i = 2</code>，看 <code>i = 2</code> 位置上面的元素(Entry)的<code>Key</code>是否等于threadLocal 这个 Key，如果等于就很好说了，直接将该位置上面的Entry的Value替换成最新的就可以了；</li>
<li>如果当前位置上面的 Entry 的 Key为空，说明ThreadLocal对象已经被回收了，那么就调用<code>replaceStaleEntry</code></li>
<li>如果清理完无用条目(ThreadLocal被回收的条目)、并且数组中的数据大小 &gt; 阈值的时候对当前的Table进行重新哈希，所以，<strong>该HashMap是处理冲突检测的机制是向后移位，清除过期条目 最终找到合适的位置</strong>；</li>
</ul>
<p>了解完Set方法，后面就是Get方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先找到ThreadLocal的索引位置，如果索引位置处的entry不为空并且键与threadLocal是同一个对象，则直接返回；否则去后面的索引位置继续查找。</p>
<h4 id="5、ThreadLocal造成内存泄漏的问题"><a href="#5、ThreadLocal造成内存泄漏的问题" class="headerlink" title="5、ThreadLocal造成内存泄漏的问题"></a>5、ThreadLocal造成内存泄漏的问题</h4><p>网上有这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long[] a = <span class="keyword">new</span> Long[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;LocalVariable&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// (3)</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span> * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// (4)</span></span><br><span class="line">                    localVariable.set(<span class="keyword">new</span> LocalVariable());</span><br><span class="line">                    <span class="comment">// (5)</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;use local varaible&quot;</span> + localVariable.get());</span><br><span class="line">                    localVariable.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (6)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pool execute over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果用线程池来操作ThreadLocal 对象确实会造成内存泄露，因为对于线程池里面不会销毁的线程，里面总会存在着<code>&lt;ThreadLocal, LocalVariable&gt;</code>的强引用，因为final static 修饰的 ThreadLocal 并不会释放，而ThreadLocalMap 对于 Key 虽然是弱引用，但是强引用不会释放，弱引用当然也会一直有值，同时创建的LocalVariable对象也不会释放，就造成了内存泄露</strong>；</p>
<p>如果LocalVariable对象不是一个大对象的话，其实泄露的并不严重，<code>泄露的内存 = 核心线程数 * LocalVariable</code>对象的大小；</p>
<p>所以，为了避免出现内存泄露的情况，ThreadLocal提供了一个清除线程中对象的方法，即 <code>remove</code>，其实内部实现就是调用 ThreadLocalMap 的remove方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>找到Key对应的Entry，并且清除Entry的Key(ThreadLocal)置空，随后清除过期的Entry即可避免内存泄露</strong>。</p>
<h4 id="6、再看ThreadLocal应用场景"><a href="#6、再看ThreadLocal应用场景" class="headerlink" title="6、再看ThreadLocal应用场景"></a>6、再看ThreadLocal应用场景</h4><h5 id="1、每个线程维护了一个“序列号”"><a href="#1、每个线程维护了一个“序列号”" class="headerlink" title="1、每个线程维护了一个“序列号”"></a>1、每个线程维护了一个“序列号”</h5><blockquote>
<p>再回想上文说的，如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</p>
</blockquote>
<p>每个线程维护了一个“序列号”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The next serial number to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextSerialNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal serialNum = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(nextSerialNum++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) (serialNum.get())).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Session的管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="3、在线程内部创建ThreadLocal"><a href="#3、在线程内部创建ThreadLocal" class="headerlink" title="3、在线程内部创建ThreadLocal"></a>3、在线程内部创建ThreadLocal</h5><p>还有一种用法是在线程类内部创建ThreadLocal，基本步骤如下：</p>
<ul>
<li>在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。</li>
<li>在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。</li>
<li>在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ThreadLocal&lt;Student&gt; StudentThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String currentThreadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> age = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is set age: &quot;</span>  + age);</span><br><span class="line">        Student Student = getStudentt(); <span class="comment">//通过这个方法，为每个线程都独立的new一个Studentt对象，每个线程的的Studentt对象都可以设置不同的值</span></span><br><span class="line">        Student.setAge(age);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is first get age: &quot;</span> + Student.getAge());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( currentThreadName + <span class="string">&quot; is second get age: &quot;</span> + Student.getAge());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Student <span class="title">getStudentt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student Student = StudentThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == Student) &#123;</span><br><span class="line">            Student = <span class="keyword">new</span> Student();</span><br><span class="line">            StudentThreadLocal.set(Student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocalTest t = <span class="keyword">new</span> ThreadLocalTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、java开发手册中推荐的ThreadLocal"><a href="#4、java开发手册中推荐的ThreadLocal" class="headerlink" title="4、java开发手册中推荐的ThreadLocal"></a>4、java开发手册中推荐的ThreadLocal</h5><p>看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再要用到 DateFormat 对象的地方，这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateUtils.df.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>



<h3 id="23、补充：阿姆达尔定律"><a href="#23、补充：阿姆达尔定律" class="headerlink" title="23、补充：阿姆达尔定律"></a>23、补充：阿姆达尔定律</h3><p>阿姆达尔定律可以用来计算处理器平行运算之后效率提升的能力。阿姆达尔定律因Gene Amdal 在1967年提出这个定律而得名。绝大多数使用并行或并发系统的开发者有一种并发或并行可能会带来提速的感觉，甚至不知道阿姆达尔定律。不管怎样，了解阿姆达尔定律还是有用的。</p>
<p>我会首先以算术的方式介绍阿姆达尔定律定律，然后再用图表演示一下。</p>
<h4 id="1、阿姆达尔定律定义"><a href="#1、阿姆达尔定律定义" class="headerlink" title="1、阿姆达尔定律定义"></a>1、阿姆达尔定律定义</h4><p>一个程序（或者一个算法）可以按照是否可以被并行化分为下面两个部分：</p>
<ul>
<li><strong>可以被并行化的部分</strong></li>
<li><strong>不可以被并行化的部分</strong></li>
</ul>
<p>假设一个程序处理磁盘上的文件。这个程序的一小部分用来扫描路径和在内存中创建文件目录。做完这些后，每个文件交个一个单独的线程去处理。扫描路径和创建文件目录的部分不可以被并行化，不过处理文件的过程可以。</p>
<p>程序串行（非并行）执行的总时间我们记为T。<strong>时间T包括不可以被并行和可以被并行部分的时间</strong>。<strong>不可以被并行的部分我们记为B</strong>。那么<strong>可以被并行的部分就是T-B</strong>。下面的列表总结了这些定义：</p>
<ul>
<li><strong>T = 串行执行的总时间</strong></li>
<li><strong>B = 不可以并行的总时间</strong></li>
<li><strong>T-B = 并行部分的总时间</strong></li>
</ul>
<p>从上面可以得出：<code>T = B + (T – B)</code></p>
<p>首先，这个看起来可能有一点奇怪，程序的可并行部分在上面这个公式中并没有自己的标识。然而，由于这个公式中可并行可以用总时间T 和 B（不可并行部分）表示出来，这个公式实际上已经从概念上得到了简化，也即是指以这种方式减少了变量的个数。</p>
<p><strong>T-B 是可并行化的部分</strong>，以并行的方式执行可以提高程序的运行速度。<strong>可以提速多少取决于有多少线程或者多少个CPU来执行。线程或者CPU的个数我们记为N</strong>。可并行化部分被执行的最快时间可以通过下面的公式计算出来：<code>(T – B ) / N</code> 或者通过这种方式 <code>(1 / N) * (T – B)</code>。维基中使用的是第二种方式。</p>
<p>根据阿姆达尔定律，当一个程序的可并行部分使用N个线程或CPU执行时，执行的总时间为：<code>T(N) = B + ( T – B ) / N</code></p>
<p><strong>T(N)指的是在并行因子为N时的总执行时间</strong>。因此，<strong>T(1)就执行在并行因子为1时程序的总执行时间</strong>。使用T(1)代替T，阿姆达尔定律定律看起来像这样：<code>T(N) = B + (T(1) – B) / N</code> 表达的意思都是是一样的。</p>
<h4 id="2、一个计算例子"><a href="#2、一个计算例子" class="headerlink" title="2、一个计算例子"></a>2、一个计算例子</h4><p>为了更好的理解阿姆达尔定律，让我们来看一个计算的例子。执行一个程序的总时间设为1，程序的不可并行化占40%，按总时间1计算，就是0.4，可并行部分就是1 – 0.4 = 0.6。</p>
<p>在并行因子为2的情况下，程序的执行时间将会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T(2) &#x3D; 0.4 + ( 1 - 0.4 ) &#x2F; 2</span><br><span class="line"> &#x3D; 0.4 + 0.6 &#x2F; 2</span><br><span class="line"> &#x3D; 0.4 + 0.3</span><br><span class="line"> &#x3D; 0.7</span><br></pre></td></tr></table></figure>

<p>在并行因子为5的情况下，程序的执行时间将会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T(5) &#x3D; 0.4 + ( 1 - 0.4 ) &#x2F; 5</span><br><span class="line"> &#x3D; 0.4 + 0.6 &#x2F; 6</span><br><span class="line"> &#x3D; 0.4 + 0.12</span><br><span class="line"> &#x3D; 0.52</span><br></pre></td></tr></table></figure>



<h4 id="3、阿姆达尔定律图示"><a href="#3、阿姆达尔定律图示" class="headerlink" title="3、阿姆达尔定律图示"></a>3、阿姆达尔定律图示</h4><p>为了更好地理解阿姆达尔定律，我会尝试演示这个定律是如何诞生的。</p>
<p>首先，一个程序可以被分割为两部分，一部分为不可并行部分B，一部分为可并行部分1 – B。如下图：</p>
<p><img src="/2021/07/19/JUC/image-20210814195444348.png" alt="image-20210814195444348"></p>
<p>在顶部被带有分割线的那条直线代表总时间 T(1)。</p>
<p>下面你可以看到在并行因子为2的情况下的执行时间：</p>
<p><img src="/2021/07/19/JUC/image-20210814195510264.png" alt="image-20210814195510264"></p>
<p>并行因子为3的情况：</p>
<p><img src="/2021/07/19/JUC/image-20210814195531931.png" alt="image-20210814195531931"></p>
<h4 id="4、优化算法"><a href="#4、优化算法" class="headerlink" title="4、优化算法"></a>4、优化算法</h4><p>从阿姆达尔定律可以看出，程序的可并行化部分可以通过使用更多的硬件（更多的线程或CPU）运行更快。<strong>对于不可并行化的部分，只能通过优化代码来达到提速的目的</strong>。因此，你可以通过优化不可并行化部分来提高你的程序的运行速度和并行能力。你可以对不可并行化在算法上做一点改动，如果有可能，你也可以把一些移到可并行化放的部分。</p>
<h5 id="优化串行分量"><a href="#优化串行分量" class="headerlink" title="优化串行分量"></a>优化串行分量</h5><p>如果你优化一个程序的串行化部分，你也可以使用阿姆达尔定律来计算程序优化后的执行时间。如果不可并行部分通过一个因子O来优化，那么阿姆达尔定律看起来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(O, N) &#x3D; B &#x2F; O + (1 - B &#x2F; O) &#x2F; N</span><br></pre></td></tr></table></figure>

<p>记住，现在程序的不可并行化部分占了<code>B / O</code>的时间，所以，可并行化部分就占了<code>1 - B / O</code>的时间。</p>
<p>如果B为0.1，O为2，N为5，计算看起来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T(2,5) &#x3D; 0.4 &#x2F; 2 + (1 - 0.4 &#x2F; 2) &#x2F; 5</span><br><span class="line">   &#x3D; 0.2 + (1 - 0.4 &#x2F; 2) &#x2F; 5</span><br><span class="line">   &#x3D; 0.2 + (1 - 0.2) &#x2F; 5</span><br><span class="line">   &#x3D; 0.2 + 0.8 &#x2F; 5</span><br><span class="line">   &#x3D; 0.2 + 0.16</span><br><span class="line">   &#x3D; 0.36</span><br></pre></td></tr></table></figure>



<h4 id="5、运行时间-vs-加速"><a href="#5、运行时间-vs-加速" class="headerlink" title="5、运行时间 vs. 加速"></a>5、运行时间 vs. 加速</h4><p>到目前为止，我们只用阿姆达尔定律计算了一个程序或算法在优化后或者并行化后的执行时间。我们也可以使用阿姆达尔定律计算加速比（speedup），也就是经过优化后或者串行化后的程序或算法比原来快了多少。</p>
<p>如果旧版本的程序或算法的执行时间为T，那么增速比就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup &#x3D; T &#x2F; T(O , N);</span><br></pre></td></tr></table></figure>

<p>为了计算执行时间，我们常常把T设为1，加速比为原来时间的一个分数。公式大致像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup &#x3D; 1 &#x2F; T（O,N)</span><br></pre></td></tr></table></figure>

<p>如果我们使用阿姆达尔定律来代替T(O,N)，我们可以得到下面的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup &#x3D; 1 &#x2F; ( B &#x2F; O + (1 - B &#x2F; O) &#x2F; N)</span><br></pre></td></tr></table></figure>

<p>如果B = 0.4， O = 2， N = 5， 计算变成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Speedup &#x3D; 1 &#x2F; ( 0.4 &#x2F; 2 + (1 - 0.4 &#x2F; 2) &#x2F; 5)</span><br><span class="line">    &#x3D; 1 &#x2F; ( 0.2 + (1 - 0.4 &#x2F; 2) &#x2F; 5)</span><br><span class="line">    &#x3D; 1 &#x2F; ( 0.2 + (1 - 0.2) &#x2F; 5 )</span><br><span class="line">    &#x3D; 1 &#x2F; ( 0.2 + 0.8 &#x2F; 5 )</span><br><span class="line">    &#x3D; 1 &#x2F; ( 0.2 + 0.16 )</span><br><span class="line">    &#x3D; 1 &#x2F; 0.36</span><br><span class="line">    &#x3D; 2.77777 ...</span><br></pre></td></tr></table></figure>

<p>上面的计算结果可以看出，如果你通过一个因子2来优化不可并行化部分，一个因子5来并行化可并行化部分，这个程序或算法的最新优化版本最多可以比原来的版本快2.77777倍。</p>
<h4 id="6、测量，不要仅是计算"><a href="#6、测量，不要仅是计算" class="headerlink" title="6、测量，不要仅是计算"></a>6、测量，不要仅是计算</h4><p>虽然阿姆达尔定律允许你并行化一个算法的理论加速比，但是不要过度依赖这样的计算。在实际场景中，当你优化或并行化一个算法时，可以有很多的因子可以被考虑进来。</p>
<p>内存的速度，CPU缓存，磁盘，网卡等可能都是一个限制因子。如果一个算法的最新版本是并行化的，但是导致了大量的CPU缓存浪费，你可能不会再使用x N个CPU来获得x N的期望加速。如果你的内存总线（memory bus），磁盘，网卡或者网络连接都处于高负载状态，也是一样的情况。</p>
<p>我们的建议是，<strong>使用阿姆达尔定律定律来指导我们优化程序，而不是用来测量优化带来的实际加速比</strong>。记住，有时候一个高度串行化的算法胜过一个并行化的算法，因为串行化版本不需要进行协调管理（上下文切换），而且一个单个的CPU在底层硬件工作（CPU管道、CPU缓存等）上的一致性可能更好。</p>
<hr>
<h2 id="8、并发的相关多线程设计模式"><a href="#8、并发的相关多线程设计模式" class="headerlink" title="8、并发的相关多线程设计模式"></a>8、并发的相关多线程设计模式</h2><h3 id="1、两阶段终止-Two-Phase-Termination"><a href="#1、两阶段终止-Two-Phase-Termination" class="headerlink" title="1、两阶段终止(Two Phase Termination)"></a>1、两阶段终止(Two Phase Termination)</h3><p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p>
<h4 id="1、错误思路"><a href="#1、错误思路" class="headerlink" title="1、错误思路"></a>1、错误思路</h4><ul>
<li>使用线程对象的 stop() 方法停止线程<ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁，可能会造成死锁问题</li>
</ul>
</li>
<li>使用 System.exit(int) 方法停止线程<ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
</ul>
<h4 id="2、正常做法——两阶段终止模式（interrupt实现）"><a href="#2、正常做法——两阶段终止模式（interrupt实现）" class="headerlink" title="2、正常做法——两阶段终止模式（interrupt实现）"></a>2、正常做法——两阶段终止模式（interrupt实现）</h4><h5 id="1、实现流程图"><a href="#1、实现流程图" class="headerlink" title="1、实现流程图"></a>1、实现流程图</h5><p><img src="/2021/07/19/JUC/image-5.jpg" alt="img"></p>
<h5 id="2、实现方法"><a href="#2、实现方法" class="headerlink" title="2、实现方法"></a>2、实现方法</h5><p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p>
<ul>
<li>如果打断的是阻塞的线程，会清空打断状态，打断状态为false</li>
<li>如果打断的是正常运行的线程，不会清空打断状态，打断状态为true</li>
</ul>
<h5 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTPT</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 情况1：sleep被打断</span></span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>); <span class="comment">// 情况2：正常执行被打断</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 因为sleep出现异常后，会清除打断标记</span></span><br><span class="line">                    <span class="comment">// 需要重置打断标记</span></span><br><span class="line">                    current.interrupt(); </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;监控线程&quot;</span> );</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11:49:42.915 c.TwoPhaseTermination [监控线程] - 执行监控记录 </span><br><span class="line">11:49:43.919 c.TwoPhaseTermination [监控线程] - 执行监控记录</span><br><span class="line">11:49:44.919 c.TwoPhaseTermination [监控线程] - 执行监控记录</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at cn.itcast.test.TwoPhaseTermination.lambda<span class="variable">$start</span><span class="variable">$0</span>(Iest3. java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java: 748)</span><br><span class="line">11:49:45.413 c.TestTwoPhaseTermination [main] - stop </span><br><span class="line">11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure>

<p>两个细节：</p>
<ol>
<li>线程被打断时分为两种情况<ol>
<li>情况1：线程在sleep时被打断，此时线程会抛出InterruptedException: sleep interrupted异常进入catch模块，不会清除打断标记，也就是说isInterrupted()返回false，所以需要在catch模块当中重置打断标记</li>
<li>情况2：线程在正常执行被打断，此时线程的打断标记不会被清除，即isInterrupted()返回true，在下一次的判断中进入if块执行break;语句退出死循环</li>
</ol>
</li>
<li>线程使用的是isInterrupted()用来判断打断标记是否为true，即有没有被打断过。其实还有一个方法可以用来判断有没有被打断过，那就是interrupted()<ol>
<li>isInterrupted()：判断当前线程是否被打断，不会清除==打断标记==</li>
<li>interrupted()：判断当前线程是否被打断，是一个静态方法，会清除==打断标记==</li>
</ol>
</li>
</ol>
<h4 id="3、正常做法——两阶段终止模式（volatile实现）"><a href="#3、正常做法——两阶段终止模式（volatile实现）" class="headerlink" title="3、正常做法——两阶段终止模式（volatile实现）"></a>3、正常做法——两阶段终止模式（volatile实现）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTPT</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    <span class="comment">// 打断标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 情况1：sleep被打断</span></span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>); <span class="comment">// 情况2：正常执行被打断</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;监控线程&quot;</span> );</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这里依旧使用打断interrupt是为了即使监控线程在sleep当中也能马上结束，而不是等到sleep结束在停止</span></span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:08:21.970 c.TwoPhaseTermination [监控线程] - 执行监控记录 </span><br><span class="line">17:08:22.973 c.TwoPhaseTermination [监控线程] - 执行监控记录</span><br><span class="line">17:08:23.974 c.TwoPhaseTermination [监控线程] - 执行监控记录</span><br><span class="line">17:08:24.467 c.TwoPhaseTermination [mian] - 停止监控</span><br><span class="line">17:08:24.467 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure>



<h3 id="2、犹豫模式（Balking）——同步模式"><a href="#2、犹豫模式（Balking）——同步模式" class="headerlink" title="2、犹豫模式（Balking）——同步模式"></a>2、犹豫模式（Balking）——同步模式</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p>
<h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><p>以上面两阶段终止模式的例子，当调用了多次tpt.start;就会创建多个监控线程，其实这是错误的，监控线程只需要一个就够了，在第二次创建监控线程的时候应该直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Thread.sleep(3500);</span></span><br><span class="line"><span class="comment">        log.debug(&quot;停止监控&quot;);</span></span><br><span class="line"><span class="comment">        tpt.stop();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 判断是否执行过 start 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123; <span class="comment">// false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    starting = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、犹豫Balking模式还经常用来实现线程安全的单例"><a href="#3、犹豫Balking模式还经常用来实现线程安全的单例" class="headerlink" title="3、犹豫Balking模式还经常用来实现线程安全的单例"></a>3、犹豫Balking模式还经常用来实现线程安全的单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p>
<h3 id="3、保护性暂停（Guarded-Suspension）——同步模式"><a href="#3、保护性暂停（Guarded-Suspension）——同步模式" class="headerlink" title="3、保护性暂停（Guarded Suspension）——同步模式"></a>3、保护性暂停（Guarded Suspension）——同步模式</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>保护性暂停（Guarded Suspension）用在一个线程等待另一个线程的执行结果</p>
<p>要点：</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） </li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210805201137709.png" alt="image-20210805201137709"></p>
<h4 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有结果</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 给结果成员变量赋值</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h4><p>一个线程等待另一个线程的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 等待结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>); </span><br><span class="line">        List&lt;String&gt; list = (List&lt;String&gt;) guardedobject.get();</span><br><span class="line">        log.debug(<span class="string">&quot;结果大小: &#123;&#125;&quot;</span> list.size());</span><br><span class="line">    &#125;，<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 子线程执行下载</span></span><br><span class="line">            List&lt;String&gt; list = Downloader.download();</span><br><span class="line">            guardedObject.complete(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection) <span class="keyword">new</span> URL(<span class="string">&quot;https://www.baidu.com/&quot;</span>).openConnection();</span><br><span class="line">        List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader =</span><br><span class="line">             <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lines.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14:42:07.731 c.Test20 [t1] - 等待结果</span><br><span class="line">14:42:07.731 c.Test20 [t2] - 执行下载</span><br><span class="line">14:42:33.636 c.Test20 [t1] - 结果大小: 3</span><br></pre></td></tr></table></figure>



<h4 id="4、带超时版-GuardedObjec"><a href="#4、带超时版-GuardedObjec" class="headerlink" title="4、带超时版 GuardedObjec"></a>4、带超时版 GuardedObjec</h4><p>如果要控制超时时间呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加超时效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="comment">// timeout 表示要等待多久 2000</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 开始时间 15:00:00</span></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 经历的时间</span></span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这一轮循环应该等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="comment">// 经历的时间超过了最大等待时间时，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (timeout - passedTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime); <span class="comment">// 虚假唤醒 15:00:01</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 求得经历时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin; <span class="comment">// 15:00:02  1s</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 给结果成员变量赋值</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>); </span><br><span class="line">        Object response = guardedobject.get(<span class="number">2000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果大小: &#123;&#125;&quot;</span> response);</span><br><span class="line">    &#125;，<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>); </span><br><span class="line">        <span class="comment">// 睡眠1s</span></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        guardedObject.complete(<span class="keyword">new</span> Object());</span><br><span class="line">    &#125;，<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果线程t2睡眠1s，那么get没有超时，可以获得Object对象：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15:51:04.932 c.Test20 [Thread-1] - begin</span><br><span class="line">15:51:04.932 c.Test20 [Thread-0] - begin</span><br><span class="line">15:51:05.935 c.Test20 [Thread-0] - 结果是:java. lang .0bject@455b03c9</span><br></pre></td></tr></table></figure>

<p>如果线程t2睡眠3s，那么get超时，不能获得Object对象：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15:52:07.993 c.Test20 [t2] - begin</span><br><span class="line">15:52:07.993 c.Test20 [t1] - begin</span><br><span class="line">15:52:09.997 c.Test20 [t1] - 结果是:null</span><br></pre></td></tr></table></figure>

<p>测试虚假唤醒问题：把t2线程complete传入null（线程t2睡眠1s）：（如果代码wait传入的是timeout而不是waitTime，这里的等待时间为3s（虚假唤醒1s，加设置的2s = 总共3s），而不是设置的2s）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15:52:11.975 c.Test20 [t2] - begin</span><br><span class="line">15:52:11.975 c.Test20 [t1] - begin</span><br><span class="line">15:52:13.979 c.Test20 [t1] - 结果是:null</span><br></pre></td></tr></table></figure>



<h4 id="5、扩展：多任务版-GuardedObject"><a href="#5、扩展：多任务版-GuardedObject" class="headerlink" title="5、扩展：多任务版 GuardedObject"></a>5、扩展：多任务版 GuardedObject</h4><p>代码：</p>
<p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员</p>
<p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。</p>
<p>注意：<strong>这里的结果等待者和结果产生者是一一对应的，所以采用的是保护性暂停模式，如果不是一一对应的话，使用的是生产者消费者模式</strong>。</p>
<p><img src="/2021/07/19/JUC/image-20210805215400468.png" alt="image-20210805215400468"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.n2.util.Sleeper;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test20&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成3个居民</span></span><br><span class="line">            <span class="keyword">new</span> People().start();</span><br><span class="line">        &#125;</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">            <span class="comment">// 邮递员送信</span></span><br><span class="line">            <span class="keyword">new</span> Postman(id, <span class="string">&quot;内容&quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        GuardedObject guardedObject = Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        Object mail = guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postman</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Postman</span><span class="params">(<span class="keyword">int</span> id, String mail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Mailboxes邮箱类是之间解耦类，并不与业务挂钩，代码可以复用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mailboxes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 产生唯一 id</span></span><br><span class="line">    <span class="comment">// 加上synchronized保证生成id的线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">getGuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里使用的是remove方法，而不是get方法</span></span><br><span class="line">        <span class="comment">// 因为这里的对应关系只需要存在一次，送完信就应该取消对应关系</span></span><br><span class="line">        <span class="comment">// 如果没有取消对应关系的话，由于boxes是static类型，是不会进入垃圾回收的，</span></span><br><span class="line">        <span class="comment">// 造成了内存泄漏，长期以往可能会导致OOM</span></span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">createGuardedObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject go = <span class="keyword">new</span> GuardedObject(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加超时效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识 Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="comment">// timeout 表示要等待多久 2000</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 开始时间 15:00:00</span></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 经历的时间</span></span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这一轮循环应该等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="comment">// 经历的时间超过了最大等待时间时，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (timeout - passedTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime); <span class="comment">// 虚假唤醒 15:00:01</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 求得经历时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin; <span class="comment">// 15:00:02  1s</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 给结果成员变量赋值</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、使用保护性暂停的好处"><a href="#6、使用保护性暂停的好处" class="headerlink" title="6、使用保护性暂停的好处"></a>6、使用保护性暂停的好处</h4><ol>
<li>如果使用的是一个线程（A）使用join来等待另外一个线程（B）的结果的话，如果线程B给线程A结果，但是线程A还不能接收，线程B就不能往下运行，必须等待线程A接收结果之后才能往下运行。</li>
<li>如果使用的是保护性暂停模式的话，线程B在结束下载以后还能往下运行代码，没必要等待线程A接收结果</li>
<li>因为join是线程结束才返回，但是阻塞的线程只需要那个response有值，凭什么要去等另一个线程全部执行完</li>
<li>使用join的话，两线程交互的结果只能设置成全局的，而使用保护性暂停模式，可以把等待的结果设置成局部的（如示例当中的list）</li>
</ol>
<h3 id="4、生产者消费者模式（Producer-Consumer）——异步模式"><a href="#4、生产者消费者模式（Producer-Consumer）——异步模式" class="headerlink" title="4、生产者消费者模式（Producer Consumer）——异步模式"></a>4、生产者消费者模式（Producer Consumer）——异步模式</h3><h4 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h4><p>要点：</p>
<ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li><strong>JDK 中各种阻塞队列，采用的就是这种模式</strong></li>
</ul>
<p><img src="/2021/07/19/JUC/image-20210805231147322.png" alt="image-20210805231147322"></p>
<h4 id="2、实现-2"><a href="#2、实现-2" class="headerlink" title="2、实现"></a>2、实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息类 不设置set方法，加上整个类被final修饰，保证没有其他方法去修改Message里面的值</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息对应的id，用来辨识message，用在查看消息是否发送成功等等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 消息的内容</span></span><br><span class="line">    <span class="keyword">private</span> Object message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列	java线程间通信</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list;</span><br><span class="line">    <span class="comment">// 队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 检查队列是否为空</span></span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列头部获取消息并返回</span></span><br><span class="line">            Message message = queue.removeFirst(); </span><br><span class="line">            log.debug(<span class="string">&quot;已消费消息&#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 检查队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message); </span><br><span class="line">            log.debug(<span class="string">&quot;已生产消息&#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、应用-1"><a href="#3、应用-1" class="headerlink" title="3、应用"></a>3、应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3 个生产者线程, 下载任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// lambda表达式要求里面的变量为不可变的，不能直接写i，可以先将i赋值给id，在写入id</span></span><br><span class="line">        <span class="keyword">int</span> id = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            queue.put(<span class="keyword">new</span> Message(id，<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">        &#125;,<span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1个消费者线程，消费任务</span></span><br><span class="line">    <span class="keyword">new</span> thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每隔1s消费一条消息</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            Message message = queue.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">11:52:21.949 c.MessageQueue [生产者2] - 已生产消息Message&#123;id=2, value=值2&#125;</span><br><span class="line">11:52:21.953 c.MessageQueue [生产者0] - 已生产消息Message&#123;id=0, value=值0&#125;</span><br><span class="line">11:52:21.953 c.MessageQueue [生产者1] - 队列已满，生产者线程等待</span><br><span class="line">11:52:22.948 c.MessageQueue [消费者] - 已消费消息Message&#123;id=2, value=值2&#125;</span><br><span class="line">11:52:22.948 c.MessageQueue [生产者1] - 已生产消息Message&#123;id=1, value=值1&#125;</span><br><span class="line">11:52:23.949 c.MessageQueue [消费者] - 已消费消息Message&#123;id=0, value=值0&#125;</span><br><span class="line">11:52:24.949 c.MessageQueue [消费者] - 已消费消息Message&#123;id=1, value=值1&#125;</span><br><span class="line">11:52:25.949 c.MessageQueue [消费者] - 队列为空,消费者线程等待</span><br></pre></td></tr></table></figure>



<h3 id="5、顺序控制（Sequence-Control）——同步模式"><a href="#5、顺序控制（Sequence-Control）——同步模式" class="headerlink" title="5、顺序控制（Sequence Control）——同步模式"></a>5、顺序控制（Sequence Control）——同步模式</h3><h4 id="1、固定运行顺序"><a href="#1、固定运行顺序" class="headerlink" title="1、固定运行顺序"></a>1、固定运行顺序</h4><p>比如，必须先 2 后 1 打印</p>
<h5 id="1、wait-notify-版"><a href="#1、wait-notify-版" class="headerlink" title="1、wait notify 版"></a>1、wait notify 版</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来同步的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// t2 运行标记， 代表 t2 是否执行过</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> t2runed = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 如果 t2 没有执行过</span></span><br><span class="line">            <span class="keyword">while</span> (!t2runed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// t1 先等一会</span></span><br><span class="line">                    lock.wait();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            t2runed = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15:55:40.793 c.Test25[t2] - 2</span><br><span class="line">15:55:40.796 c.Test25[t1] - 1</span><br></pre></td></tr></table></figure>

<p>实际上使用ReentrantLock的await与signal方法与上面类似，这里不在展示。</p>
<h5 id="2、Park-Unpark-版"><a href="#2、Park-Unpark-版" class="headerlink" title="2、Park Unpark 版"></a>2、Park Unpark 版</h5><p>可以看到，实现上很麻烦：</p>
<ol>
<li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait</li>
<li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题（虚假唤醒问题）</li>
<li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li>
</ol>
<p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test26&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16:02:56.652 c.Test26[t2] - 2</span><br><span class="line">16:02:56.655 c.Test26[t1] - 1</span><br></pre></td></tr></table></figure>

<p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』</p>
<h4 id="2、交替输出"><a href="#2、交替输出" class="headerlink" title="2、交替输出"></a>2、交替输出</h4><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现（与<strong>线程间定制化通信</strong>有区别）</p>
<h5 id="1、wait-notify-版-1"><a href="#1、wait-notify-版-1" class="headerlink" title="1、wait notify 版"></a>1、wait notify 版</h5><p>需要借助等待标记来知道下一个唤醒的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test27&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify wn = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出内容       等待标记     下一个标记</span></span><br><span class="line"><span class="comment">   a           1             2</span></span><br><span class="line"><span class="comment">   b           2             3</span></span><br><span class="line"><span class="comment">   c           3             1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印               a           1             2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、Lock-条件变量版"><a href="#2、Lock-条件变量版" class="headerlink" title="2、Lock 条件变量版"></a>2、Lock 条件变量版</h5><p>Lock就不需要借助等待标记，但是需要主线程来启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test30</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = awaitSignal.newCondition();</span><br><span class="line">        Condition b = awaitSignal.newCondition();</span><br><span class="line">        Condition c = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition current, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：该实现没有考虑 a，b，c 线程都就绪再开始</p>
<h5 id="3、Park-Unpark-版"><a href="#3、Park-Unpark-版" class="headerlink" title="3、Park Unpark 版"></a>3、Park Unpark 版</h5><p>依旧需要主线程来启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test31&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test31</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark pu = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、享元模式（Flyweight-pattern）"><a href="#6、享元模式（Flyweight-pattern）" class="headerlink" title="6、享元模式（Flyweight pattern）"></a>6、享元模式（Flyweight pattern）</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>定义 英文名称：<code>Flyweight pattern</code>. 当需要重用数量有限的同一类对象时</p>
<p>比如说String，为了保证String不可变性，String在进行操作的时候经常使用的方法是：保护性拷贝。这种方式有个缺点：当拷贝的内容相当大的时候，这个时候对系统的性能以及内存的状态是非常不利的，这个时候就需要使用享元模式了</p>
<blockquote>
<p>wikipedia： A ﬂyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects</p>
</blockquote>
<h4 id="2、体现"><a href="#2、体现" class="headerlink" title="2、体现"></a>2、体现</h4><h5 id="1、包装类"><a href="#1、包装类" class="headerlink" title="1、包装类"></a>1、包装类</h5><p>在JDK中 <code>Boolean</code>，<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code>，<code>Character</code> 等包装类提供了 <code>valueOf</code> 方法，例如 Long 的valueOf **==会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象==**，大于这个范围，才会新建 Long 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LongCache的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127 </li>
<li>Character 缓存的范围是 0~127</li>
<li>Integer的默认范围是 -128~127<ul>
<li>最小值不能变</li>
<li>但最大值可以通过调整虚拟机参数 <code>  -Djava.lang.Integer.IntegerCache.high</code> 来改变</li>
</ul>
</li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
</ul>
<h5 id="2、String-串池"><a href="#2、String-串池" class="headerlink" title="2、String 串池"></a>2、String 串池</h5><p>在JVM的StringTable具体说明</p>
<h5 id="3、BigDecimal-BigInteger"><a href="#3、BigDecimal-BigInteger" class="headerlink" title="3、BigDecimal BigInteger"></a>3、BigDecimal BigInteger</h5><p>注意：BigDecimal BigInteger的单个方法是线程安全的，但是方法之间组合组合不一定是线程安全的（有时候使用AutomicIntrger等等原子类来保证它们在组合下的线程安全）</p>
<h4 id="3、DIY"><a href="#3、DIY" class="headerlink" title="3、DIY"></a>3、DIY</h4><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Connection conn = pool.borrow();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(conn);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockConnection</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MockConnection&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nativeSQL</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAutoCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCatalog</span><span class="params">(String catalog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCatalog</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTransactionIsolation</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLWarning <span class="title">getWarnings</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearWarnings</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeMap</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; map)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHoldability</span><span class="params">(<span class="keyword">int</span> holdability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldability</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Savepoint <span class="title">setSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Savepoint <span class="title">setSavepoint</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(Savepoint savepoint)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Savepoint savepoint)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">int</span> resultSetHoldability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">int</span> resultSetHoldability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">int</span> resultSetHoldability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> autoGeneratedKeys)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span>[] columnIndexes)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, String[] columnNames)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clob <span class="title">createClob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Blob <span class="title">createBlob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NClob <span class="title">createNClob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLXML <span class="title">createSQLXML</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientInfo</span><span class="params">(String name, String value)</span> <span class="keyword">throws</span> SQLClientInfoException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientInfo</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLClientInfoException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClientInfo</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getClientInfo</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Array <span class="title">createArrayOf</span><span class="params">(String typeName, Object[] elements)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Struct <span class="title">createStruct</span><span class="params">(String typeName, Object[] attributes)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchema</span><span class="params">(String schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSchema</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">(Executor executor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNetworkTimeout</span><span class="params">(Executor executor, <span class="keyword">int</span> milliseconds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNetworkTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">15:26:48.211 c.Pool [THread-3] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.211 c.Pool [Thread-0] - borrow MockConnection&#123;name= <span class="string">&#x27;连接1&#x27;</span>&#125;</span><br><span class="line">15:26:48.215 c.Pool [Thread-4] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.215 c.Pool [Thread-2] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.211 c.Pool [Thread-1] - borrow MockConnection&#123;name= <span class="string">&#x27;连接2&#x27;</span>&#125;</span><br><span class="line">15:26:48.397 c.Pool [Thread-0] - free MockConnection&#123;name= <span class="string">&#x27;连接1&#x27;</span>&#125;</span><br><span class="line">15:26:48.397 c.Pool [Thread-4] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.397 c.Pool [Thread-2] - borrow MockConnection&#123;name= <span class="string">&#x27;连接1&#x27;</span>&#125;</span><br><span class="line">15:26:48.397 c.Pool [Thread-3] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.412 c.Pool [Thread-1] - free MockConnection&#123;name=<span class="string">&#x27; 连接2&#x27;</span>&#125;</span><br><span class="line">15:26:48.412 c.Pool [Thread-3] - borrow MockConnection&#123;name= <span class="string">&#x27;连接2&#x27;</span>&#125;</span><br><span class="line">15:26:48.412 c.Pool [Thread-4] - <span class="built_in">wait</span>...</span><br><span class="line">15:26:48.796 c.Pool [Thread-3] - free MockConnection&#123;name= <span class="string">&#x27;连接2&#x27;</span>&#125;</span><br><span class="line">15:26:48.796 c.Pool [Thread-4] - borrow MockConnection&#123;name= <span class="string">&#x27;连接2&#x27;</span>&#125;</span><br><span class="line">15:26:49.340 c.Pool [Thread-2] - free MockConnection&#123;name=<span class="string">&#x27; 连接1&#x27;</span>&#125;</span><br><span class="line">15:26:49.561 c.Pool [Thread-4] - free MockConnection&#123;name= <span class="string">&#x27;连接2&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上实现没有考虑：</p>
<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式 hash</li>
</ul>
<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool（redis使用），例如redis连接池可以参考jedis中关于连接池的实现。</p>
<h3 id="7、工作线程模式-Worker-Thread-——异步模式"><a href="#7、工作线程模式-Worker-Thread-——异步模式" class="headerlink" title="7、工作线程模式(Worker Thread)——异步模式"></a>7、工作线程模式(Worker Thread)——异步模式</h3><h4 id="1、定义-3"><a href="#1、定义-3" class="headerlink" title="1、定义"></a>1、定义</h4><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为<strong>分工模式</strong>，它的<strong>典型实现就是线程池，也体现了经典设计模式中的享元模式</strong>。</p>
<p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：<code>Thread-Per-Message</code>）</p>
<p>注意：<strong>不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</strong></p>
<p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p>
<h4 id="2、饥饿"><a href="#2、饥饿" class="headerlink" title="2、饥饿"></a>2、饥饿</h4><p>固定大小线程池会有饥饿现象：</p>
<ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：没啥说的，做就是了</li>
</ul>
</li>
<li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</li>
<li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStarvation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15:28:41.386 c.TestDeadLock [pool-1-thread-1] - 处理点餐...</span><br><span class="line">15:28:41.386 c.TestDeadLock [pool-1-thread-2] - 处理点餐...</span><br></pre></td></tr></table></figure>

<p>解决方法：可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStarvation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15:33:14.925 c.TestDeadLock [pool-1-thread-1] - 处理点餐...</span><br><span class="line">15:33:14.928 c.TestDeadLock [pool-2-thread-1] - 做菜</span><br><span class="line">15:33:14.929 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁</span><br><span class="line">15:33:14.931 c.TestDeadLock [pool-1-thread-1] - 处理点餐...</span><br><span class="line">15:33:14.931 c.TestDeadLock [pool-2-thread-1] - 做菜</span><br><span class="line">15:33:14.931 c.TestDeadLock [pool-1-thread-1] - 上菜: 宫保鸡丁</span><br></pre></td></tr></table></figure>



<h4 id="3、创建多少线程池合适"><a href="#3、创建多少线程池合适" class="headerlink" title="3、创建多少线程池合适"></a>3、创建多少线程池合适</h4><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<h5 id="1、CPU-密集型运算"><a href="#1、CPU-密集型运算" class="headerlink" title="1、CPU 密集型运算"></a>1、CPU 密集型运算</h5><p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，**+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费**</p>
<h5 id="2、I-O-密集型运算"><a href="#2、I-O-密集型运算" class="headerlink" title="2、I/O 密集型运算"></a>2、I/O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>
<p>经验公式：<code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p>
<p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式：<code>4 * 100% * 100% / 50% = 8</code></p>
<p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式：<code>4 * 100% * 100% / 10% = 40</code></p>
<h4 id="4、自定义线程池"><a href="#4、自定义线程池" class="headerlink" title="4、自定义线程池"></a>4、自定义线程池</h4><p>具体参考<code>7、JUC当中的15、ThreadPool线程池的9、自定义线程池</code></p>
<h3 id="5、不可变（Immutability）模式"><a href="#5、不可变（Immutability）模式" class="headerlink" title="5、不可变（Immutability）模式"></a>5、不可变（Immutability）模式</h3><p>如果对象一旦被创建，状态就不会再发生任何变化，并且只允许存在只读方法，这个对象就是不可变对象。利用不可变对象解决并发问题的模式，就是不可变模式。快速实现具备不可变性的类时，将类设置成final，类内的所有属性设置成final，只暴露只读方法即可。</p>
<p>经常用到的String对象和各种基础类型的包装类，比如，Long，Integer都具备不可变性。更进一步，基本数据类型的包装类都用到了享元模式（Flyweight Pattern），即在JVM启动时，创建一个对象池，当创建包装类型的对象时，首先查找对象池是否存在，如果不存在，才会创建新对象，并将其放入对象池中。比如，Long对象就默认缓存了[-128,127]之间的对象。几乎所有用到了享元模式的对象，比如，包装类对象，都不适合做锁，因为看上去是私有的这些对象，其实是共用的，会导致并发问题。</p>
<p>但是在使用不可变模式时，一定要搞清楚特定不可变对象的边界在哪里。比如，一个final类C的final成员变量a，当a的内部存在非final的其他对象时，并且C中存在着get_a的public接口，那么C就不是线程安全的。</p>
<h3 id="6、Copy-on-Write模式"><a href="#6、Copy-on-Write模式" class="headerlink" title="6、Copy-on-Write模式"></a>6、<strong>Copy-on-Write模式</strong></h3><p>Copy-on-Write模式适用于对数据的实时性不敏感，读多写少且对读性能要求极为苛刻的小数据场景。</p>
<p>具体的实现也很简单，当数据需要修改时，先复制一份出来，在复制的数据上进行修改，并发读还是在旧的数据上，当数据修改完成后，再将老数据替换为修改后的新数据即可。但需要注意的是，当发生并发写时，可以使用CAS的策略来完成。</p>
<h3 id="7、线程本地存储"><a href="#7、线程本地存储" class="headerlink" title="7、线程本地存储"></a>7、<strong>线程本地存储</strong></h3><p>Java语言提供ThreadLocal实现避免共享，即每个线程拥有自己的一份数据，线程之间没有竞争关系。</p>
<p>它的具体实现原理有点反直觉，因为ThreadLocal本质上仅仅是一个代理工具类，真正的数据存储在Thread类中。即，当ThreadLocal.get()获取线程本地数据时，通过Thread.currentThread().threadLocals来获取线程内真正的本地对象进行操作。</p>
<p>这种设计方式，从业务上看，线程的本地数据存在线程内部显然更合理，更重要的是，这样做不容易产生内存泄漏，因为线程本地对象和线程同生命周期，当线程被gc时，其数据也同样可以被gc掉。</p>
<p>但需要注意的是，在线程池的场景中，因为线程池中的线程通常与进程是同生共死的，即使线程本地变量的生命周期已经结束了，但因为该线程池尚未被释放，数据也是无法被回收的。因此，在这种场景下，ThreadLocal方案要小心使用。</p>
<h3 id="8、Thread-Per-Message"><a href="#8、Thread-Per-Message" class="headerlink" title="8、Thread-Per-Message"></a>8、<strong>Thread-Per-Message</strong></h3><p>现实世界中，很多事情需要委托他人办理，同样的场景，在并发编程领域，就是Thread-Per_message模式，简而言之，就是由一个线程接收任务，并发的为每一个收到的任务分配一个独立线程，这是最简单的分工方法，实现起来也非常简单。</p>
<p>线程在Java中是成本非常高的对象，本质上并不适合高并发场景。但是，换个角度思考，语言，工具和框架本身应该是帮助我们更敏捷的实现稳定可靠的方案，Thread-Per-Message是一种最简单的分工方法，Java语言支持不了，显然是Java语言本身的问题。</p>
<p>在Go语言中，存在一种轻量级线程，即协程的方案。在协程的架构下，Thread-Per-Message模式就完全没有问题了。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TZ845195485/article/details/109210095">Juc_并发编程目录</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015558984">透彻理解Java并发编程系列</a></p>
<p><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html">Java 全栈知识体系</a></p>
<p><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/jvm/java-jvm-jmm.html#%E5%9F%BA%E7%A1%80">Java 内存模型详解</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115543000">面试官：说一下公平锁和非公平锁的区别？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39054532/article/details/116651035">ReentrantLock中的公平锁可能并不是真正意义上的公平</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GDno-X1N8zc98h9MZ8_KoA">可重入锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hd12370/article/details/82814348">死锁面试题（什么是死锁，产生死锁的原因及必要条件）</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WtAdXvaRuBZ-SXayIKu1mA">乐观锁、悲观锁</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2ac26ca6525">什么是乐观锁，什么是悲观锁</a></p>
<p>本文主要参考自泰迪的bagwell的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/32a15ef2f1bf%E5%92%8Chttps://www.jianshu.com/p/6a14d0b54b8d%EF%BC%8C%E5%9C%A8%E6%AD%A4%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%8F%82%E8%80%83%E4%BA%86%E5%A6%82%E4%B8%8B%E6%96%87%E7%AB%A0">https://www.jianshu.com/p/32a15ef2f1bf和https://www.jianshu.com/p/6a14d0b54b8d，在此基础上参考了如下文章</a></p>
<p>推荐阅读ForkJoinPool的作者Doug Lea的一篇文章《A Java Fork/Join Framework》<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">英文原文地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Seazean/JavaNotes/blob/main/Prog.md">JUC</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97495019">Java并发编程实战（三：并发设计模式）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=25&spm_id_from=pageDriver">黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kw411Z7dF?p=3&spm_id_from=pageDriver">【尚硅谷】大厂必备技术之JUC并发编程2021最新版</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>XGH_little-star
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xgh-user.github.io/2021/07/19/JUC/" title="JUC高并发编程">http://xgh-user.github.io/2021/07/19/JUC/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># JUC高并发编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/25/%E7%AE%97%E6%B3%95/" rel="prev" title="算法">
      <i class="fa fa-chevron-left"></i> 算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/15/Netty/" rel="next" title="Netty">
      Netty <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">JUC高并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">1、Java并发知识体系详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、知识体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81java%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、java高并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Java-%E5%B9%B6%E5%8F%91-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">2、Java 并发 - 理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、并发与并行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%B2%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1、串行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2、并行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3、并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">4、并发与并行的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">5、管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">6、用户线程和守护线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、为什么需要多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、多线程的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%BA%94%E7%94%A8%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">1、应用之异步调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.4.1.1.</span> <span class="nav-text">1、异步与同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.4.1.2.</span> <span class="nav-text">2、设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%BB%93%E8%AE%BA"><span class="nav-number">1.2.4.1.3.</span> <span class="nav-text">3、结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2、应用之提高效率</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.2.4.2.1.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、线程不安全示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%B9%B6%E5%8F%91%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">1.2.6.</span> <span class="nav-text">6、并发出现问题的根源：并发三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9ACPU%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">1、可见性：CPU缓存引起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2、原子性：分时复用引起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">3、有序性：重排序引起</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81CPU%E7%9A%84%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.6.3.1.</span> <span class="nav-text">1、CPU的指令重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%90%8D%E8%AF%8D"><span class="nav-number">1.2.6.3.1.1.</span> <span class="nav-text">1、名词</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.6.3.1.2.</span> <span class="nav-text">2、指令重排序优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%94%AF%E6%8C%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.2.6.3.1.3.</span> <span class="nav-text">3、支持流水线的处理器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81SuperScalar-%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.2.6.3.1.4.</span> <span class="nav-text">4、SuperScalar 处理器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM%EF%BC%89"><span class="nav-number">1.2.6.3.2.</span> <span class="nav-text">2、重排序（Java 内存模型JMM）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.6.3.2.1.</span> <span class="nav-text">1、重排序的分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.6.3.2.2.</span> <span class="nav-text">2、处理器重排序与内存屏障指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number">1.2.6.3.2.3.</span> <span class="nav-text">3、数据依赖性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81as-if-serial-%E8%AF%AD%E4%B9%89"><span class="nav-number">1.2.6.3.2.4.</span> <span class="nav-text">4、as-if-serial 语义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">1.2.6.3.2.5.</span> <span class="nav-text">5、程序顺序规则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.2.6.3.2.6.</span> <span class="nav-text">6、重排序对多线程的影响</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="nav-number">1.2.6.3.3.</span> <span class="nav-text">3、顺序一致性(Java 内存模型JMM)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E4%B8%8E%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.2.6.3.3.1.</span> <span class="nav-text">1、数据竞争与顺序一致性保证</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.6.3.3.2.</span> <span class="nav-text">2、顺序一致性内存模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E6%9E%9C"><span class="nav-number">1.2.6.3.3.3.</span> <span class="nav-text">3、同步程序的顺序一致性效果</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%9C%AA%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.6.3.3.4.</span> <span class="nav-text">4、未同步程序的执行特性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.6.3.4.</span> <span class="nav-text">4、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.6.3.4.1.</span> <span class="nav-text">1、处理器内存模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81JMM%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.6.3.4.2.</span> <span class="nav-text">2、JMM、处理器内存模型与顺序一致性内存模型之间的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81JMM-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.6.3.4.3.</span> <span class="nav-text">3、JMM 的设计</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81JMM-%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.2.6.3.4.4.</span> <span class="nav-text">4、JMM 的内存可见性保证</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81JSR-133-%E5%AF%B9%E6%97%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%AE%E8%A1%A5"><span class="nav-number">1.2.6.3.4.5.</span> <span class="nav-text">5、JSR-133 对旧内存模型的修补</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81JAVA%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9AJMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.7.</span> <span class="nav-text">7、JAVA是怎么解决并发问题的：JMM(Java内存模型)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Avolatile%E3%80%81synchronized-%E5%92%8C-final"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">1、关键字：volatile、synchronized 和 final</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81volatile"><span class="nav-number">1.2.7.1.1.</span> <span class="nav-text">1、volatile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81synchronized"><span class="nav-number">1.2.7.1.2.</span> <span class="nav-text">2、synchronized</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81final"><span class="nav-number">1.2.7.1.3.</span> <span class="nav-text">3、final</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Happens-Before-%E8%A7%84%E5%88%99"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2、Happens-Before 规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%88%99%EF%BC%88Single-Thread-rule%EF%BC%89"><span class="nav-number">1.2.7.2.1.</span> <span class="nav-text">1、单一线程原则（Single Thread rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%AE%A1%E7%A8%8B%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99%EF%BC%88Monitor-Lock-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.2.</span> <span class="nav-text">2、管程锁定规则（Monitor Lock Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81volatile-%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99%EF%BC%88Volatile-Variable-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.3.</span> <span class="nav-text">3、volatile 变量规则（Volatile Variable Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99%EF%BC%88Thread-Start-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.4.</span> <span class="nav-text">4、线程启动规则（Thread Start Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99%EF%BC%88Thread-Join-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.5.</span> <span class="nav-text">5、线程加入规则（Thread Join Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99%EF%BC%88Thread-Interruption-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.6.</span> <span class="nav-text">6、线程中断规则（Thread Interruption Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99%EF%BC%88Finalizer-Rule%EF%BC%89"><span class="nav-number">1.2.7.2.7.</span> <span class="nav-text">7、对象终结规则（Finalizer Rule）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81%E4%BC%A0%E9%80%92%E6%80%A7%EF%BC%88Transitivity%EF%BC%89"><span class="nav-number">1.2.7.2.8.</span> <span class="nav-text">8、传递性（Transitivity）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E7%9C%9F%E5%8D%B3%E5%81%87%E7%9A%84%E5%91%BD%E9%A2%98"><span class="nav-number">1.2.8.</span> <span class="nav-text">8、线程安全：不是一个非真即假的命题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98-Immutable"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">1、不可变(Immutable)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%B4%A0"><span class="nav-number">1.2.8.1.1.</span> <span class="nav-text">1、不可变的设计要素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D%EF%BC%88defensive-copy%EF%BC%89"><span class="nav-number">1.2.8.1.2.</span> <span class="nav-text">2、保护性拷贝（defensive copy）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">2、绝对线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">3、相对线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9"><span class="nav-number">1.2.8.4.</span> <span class="nav-text">4、线程兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B"><span class="nav-number">1.2.8.5.</span> <span class="nav-text">5、线程对立</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.9.</span> <span class="nav-text">9、线程安全的实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">1、互斥同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">2、非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81CAS%EF%BC%88JUC%E4%B8%ADCAS-Unsafe%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="nav-number">1.2.9.2.1.</span> <span class="nav-text">1、CAS（JUC中CAS, Unsafe和原子类相关）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81AtomicInteger"><span class="nav-number">1.2.9.2.2.</span> <span class="nav-text">2、AtomicInteger</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81ABA"><span class="nav-number">1.2.9.2.3.</span> <span class="nav-text">3、ABA</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.9.3.</span> <span class="nav-text">3、无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E5%B0%81%E9%97%AD%EF%BC%88JUC%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="nav-number">1.2.9.3.1.</span> <span class="nav-text">1、栈封闭（JUC中线程池相关）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-Thread-Local-Storage-%EF%BC%88JUC%E4%B8%ADThreadLocal%E8%AF%A6%E8%A7%A3%EF%BC%89"><span class="nav-number">1.2.9.3.2.</span> <span class="nav-text">2、线程本地存储(Thread Local Storage)（JUC中ThreadLocal详解）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81-Reentrant-Code"><span class="nav-number">1.2.9.3.3.</span> <span class="nav-text">3、可重入代码(Reentrant Code)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.9.3.4.</span> <span class="nav-text">4、无状态</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Java-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.</span> <span class="nav-text">3、Java 并发 - 线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1、进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2、线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3、进程与线程的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、线程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1、线程的五状态模型（操作系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2、线程的七状态模型（操作系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B%EF%BC%88java%EF%BC%89"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3、线程的六状态模型（java）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B0%E5%BB%BA%EF%BC%88New%EF%BC%89"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">1、新建（New）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%88Runnable%EF%BC%89"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">2、可运行（Runnable）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%98%BB%E5%A1%9E-Blocking"><span class="nav-number">1.3.3.3.3.</span> <span class="nav-text">3、阻塞(Blocking)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-Waiting"><span class="nav-number">1.3.3.3.4.</span> <span class="nav-text">4、无限期等待(Waiting)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-Timed-Waiting"><span class="nav-number">1.3.3.3.5.</span> <span class="nav-text">5、限期等待(Timed Waiting)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%AD%BB%E4%BA%A1-Terminated"><span class="nav-number">1.3.3.3.6.</span> <span class="nav-text">6、死亡(Terminated)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、线程的四种使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1、实现 Runnable 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2、实现 Callable 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3、继承 Thread 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">4、使用线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Thread-%E4%B8%8E-Runnable-%E7%9A%84%E5%BA%95%E5%B1%82%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">5、Thread 与 Runnable 的底层关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-VS-%E7%BB%A7%E6%89%BF-Thread"><span class="nav-number">1.3.4.6.</span> <span class="nav-text">6、实现接口 VS 继承 Thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E9%A9%AC%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="nav-number">1.3.4.7.</span> <span class="nav-text">7、调用start()方法，线程是否会马上创建？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.8.</span> <span class="nav-text">8、查看进程线程的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.4.9.</span> <span class="nav-text">9、线程运行的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="nav-number">1.3.4.9.1.</span> <span class="nav-text">1、栈与栈帧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Thread-Context-Switch%EF%BC%89"><span class="nav-number">1.3.4.9.2.</span> <span class="nav-text">2、线程上下文切换（Thread Context Switch）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">5、线程的常见方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.6.</span> <span class="nav-text">6、不推荐的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.7.</span> <span class="nav-text">7、基础线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Executor"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">1、Executor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Daemon"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">2、Daemon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81sleep"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">3、sleep()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2CPU%E5%8D%A0%E7%94%A8100"><span class="nav-number">1.3.7.3.1.</span> <span class="nav-text">案例——防止CPU占用100%</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81yield"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">4、yield()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81run-start%E3%80%81sleep-yield%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.3.7.5.</span> <span class="nav-text">5、run&#x2F;start、sleep&#x2F;yield、线程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81run%E4%B8%8Estart"><span class="nav-number">1.3.7.5.1.</span> <span class="nav-text">1、run与start</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81run"><span class="nav-number">1.3.7.5.1.1.</span> <span class="nav-text">1、run</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81start"><span class="nav-number">1.3.7.5.1.2.</span> <span class="nav-text">2、start</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9Arun-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%B8%8D%E8%83%BD%E6%8A%9B%E5%87%BA%EF%BC%8C%E5%8F%AA%E8%83%BD-try-catch"><span class="nav-number">1.3.7.5.1.3.</span> <span class="nav-text">3、面试问题：run() 方法中的异常不能抛出，只能 try&#x2F;catch</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81run%E4%B8%8Estart%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.7.5.1.4.</span> <span class="nav-text">4、run与start之间的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81sleep%E4%B8%8Eyield%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.7.5.2.</span> <span class="nav-text">2、sleep与yield之间的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81sleep"><span class="nav-number">1.3.7.5.2.1.</span> <span class="nav-text">1、sleep</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81yield"><span class="nav-number">1.3.7.5.2.2.</span> <span class="nav-text">2、yield</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88priority%EF%BC%89"><span class="nav-number">1.3.7.5.2.3.</span> <span class="nav-text">3、线程优先级（priority）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">1.3.8.</span> <span class="nav-text">8、线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81InterruptedException"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">1、InterruptedException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81interrupted"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">2、interrupted()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">3、Executor 的中断操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">1.3.9.</span> <span class="nav-text">9、线程互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81synchronized"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">1、synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.3.9.1.1.</span> <span class="nav-text">1、同步一个代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.9.1.2.</span> <span class="nav-text">2、同步一个方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="nav-number">1.3.9.1.3.</span> <span class="nav-text">3、同步一个类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.9.1.4.</span> <span class="nav-text">4、同步一个静态方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ReentrantLock%EF%BC%88JUC%E4%B8%AD%E7%9A%84ReentrantLock%EF%BC%89"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">2、ReentrantLock（JUC中的ReentrantLock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%AF%94%E8%BE%83"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">3、比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">4、使用选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="nav-number">1.3.10.</span> <span class="nav-text">10、线程之间的协作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81join"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">1、join()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81join"><span class="nav-number">1.3.10.1.1.</span> <span class="nav-text">1、为什么需要join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8sleep-%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8join"><span class="nav-number">1.3.10.1.2.</span> <span class="nav-text">2、为什么不用sleep()，而使用join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81join-long"><span class="nav-number">1.3.10.1.3.</span> <span class="nav-text">3、join(long)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81join%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.3.10.1.4.</span> <span class="nav-text">4、join的底层原理——保护性暂停模式的时间增强</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81wait-%E3%80%81notify-%E3%80%81notifyAll"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">2、wait()、notify()、notifyAll()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.10.2.1.</span> <span class="nav-text">1、wait() 和 sleep() 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81wait-%E5%92%8C-sleep-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.3.10.2.2.</span> <span class="nav-text">2、wait() 和 sleep() 的共同点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81await-%E3%80%81signal-%E3%80%81signalAll"><span class="nav-number">1.3.10.3.</span> <span class="nav-text">3、await()、signal()、signalAll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81interrupt"><span class="nav-number">1.3.10.4.</span> <span class="nav-text">4、interrupt</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%93%E6%96%AD-sleep%EF%BC%8Cwait%EF%BC%8Cjoin-%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.10.4.1.</span> <span class="nav-text">1、打断 sleep，wait，join 的线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2"><span class="nav-number">1.3.10.4.2.</span> <span class="nav-text">2、多线程设计模式——两阶段终止</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%89%93%E6%96%AD-park-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.10.4.3.</span> <span class="nav-text">3、打断 park 线程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Asynchronized%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.4.</span> <span class="nav-text">4、关键字：synchronized详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、Synchronized的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1、对象锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">1、代码块形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E9%94%81%E5%BD%A2%E5%BC%8F%EF%BC%9Asynchronized%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%8C%E9%94%81%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E4%B8%BAthis"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">2、方法锁形式：synchronized修饰普通方法，锁对象默认为this</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E9%94%81"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2、类锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81synchronize%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">1、synchronize修饰静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81synchronized%E6%8C%87%E5%AE%9A%E9%94%81%E5%AF%B9%E8%B1%A1%E4%B8%BAClass%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">2、synchronized指定锁对象为Class对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8Esynchronized%E9%94%81%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3、关于synchronized锁的总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、Synchronized的原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">1、加锁和释放锁的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9A%E5%8A%A0%E9%94%81%E6%AC%A1%E6%95%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">2、可重入原理：加锁次数计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">3、保证可见性的原理：内存模型和happens-before规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81synchronized-%E6%98%AF%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%8A%A0%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4、synchronized 是给对象加锁的原理——对象的对象头</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81JVM%E4%B8%AD%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.4.</span> <span class="nav-text">4、JVM中锁的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">1、锁的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">2、自旋锁与自适应自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.4.4.2.1.</span> <span class="nav-text">1、自旋锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.4.4.2.2.</span> <span class="nav-text">2、自适应自旋锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">3、锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">4、锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">5、轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81"><span class="nav-number">1.4.4.5.1.</span> <span class="nav-text">轻量级锁加锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">6、锁膨胀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.4.4.7.</span> <span class="nav-text">7、偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.4.7.1.</span> <span class="nav-text">1、偏向状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="nav-number">1.4.4.7.2.</span> <span class="nav-text">2、偏向锁的撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E4%BB%8D%E5%8F%AF%E5%81%8F%E5%90%91%EF%BC%89"><span class="nav-number">1.4.4.7.2.1.</span> <span class="nav-text">1、方法一：调用对象的hashCode方法（对象仍可偏向）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%BD%93%E6%9C%89%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%81%8F%E5%90%91%E9%94%81%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%B0%86%E5%81%8F%E5%90%91%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%8F%98%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%81%8F%E5%90%91%EF%BC%89"><span class="nav-number">1.4.4.7.2.2.</span> <span class="nav-text">2、方法二：当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁（对象变为不可偏向）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E8%B0%83%E7%94%A8-wait-notify"><span class="nav-number">1.4.4.7.2.3.</span> <span class="nav-text">3、调用 wait&#x2F;notify</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="nav-number">1.4.4.7.3.</span> <span class="nav-text">3、批量重偏向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="nav-number">1.4.4.7.4.</span> <span class="nav-text">4、批量撤销</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.4.8.</span> <span class="nav-text">8、锁的优缺点对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Synchronized%E4%B8%8ELock"><span class="nav-number">1.4.5.</span> <span class="nav-text">5、Synchronized与Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81synchronized%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">1、synchronized的缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Lock%E8%A7%A3%E5%86%B3%E7%9B%B8%E5%BA%94%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">2、Lock解决相应问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9ALock-%E4%B8%8E%E7%9A%84-Synchronized-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">3、总结：Lock 与的 Synchronized 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.6.</span> <span class="nav-text">6、再深入理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Avolatile%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.</span> <span class="nav-text">5、关键字：volatile详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81volatile%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.2.</span> <span class="nav-text">2、volatile的作用详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%98%B2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1、防重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">2、实现可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%8D%95%E6%AC%A1%E8%AF%BB-%E5%86%99"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">3、保证原子性：单次读&#x2F;写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%97%AE%E9%A2%981%EF%BC%9A-i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">1、问题1： i++为什么不能保证原子性?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%97%AE%E9%A2%982%EF%BC%9A-%E5%85%B1%E4%BA%AB%E7%9A%84long%E5%92%8Cdouble%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8volatile"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">2、问题2： 共享的long和double变量的为什么要用volatile?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">3、volatile的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81volatile-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">1、volatile 可见性实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81lock-%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.3.1.1.</span> <span class="nav-text">1、lock 指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.5.3.1.2.</span> <span class="nav-text">2、缓存一致性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81volatile-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">2、volatile 有序性实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81volatile-%E7%9A%84-happens-before-%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">1、volatile 的 happens-before 关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81volatile-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.3.2.2.</span> <span class="nav-text">2、volatile 禁止重排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81double-checked-locking-%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">3、double-checked locking 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81double-checked-locking-%E8%A7%A3%E5%86%B3"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">4、double-checked locking 解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81volatile%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.4.</span> <span class="nav-text">4、volatile的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">1、模式1：状态标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A8%A1%E5%BC%8F2%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83-one-time-safe-publication"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">2、模式2：一次性安全发布(one-time safe publication)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%A8%A1%E5%BC%8F3%EF%BC%9A%E7%8B%AC%E7%AB%8B%E8%A7%82%E5%AF%9F-independent-observation"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">3、模式3：独立观察(independent observation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%A8%A1%E5%BC%8F4%EF%BC%9Avolatile-bean-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">4、模式4：volatile bean 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E5%BC%80%E9%94%80%E8%BE%83%E4%BD%8E%E7%9A%84%E8%AF%BB%EF%BC%8D%E5%86%99%E9%94%81%E7%AD%96%E7%95%A5"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">5、模式5：开销较低的读－写锁策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%A8%A1%E5%BC%8F6%EF%BC%9A%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5-double-checked"><span class="nav-number">1.5.4.6.</span> <span class="nav-text">6、模式6：双重检查(double-checked)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Afinal%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.6.</span> <span class="nav-text">6、关键字：final详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81final%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.2.</span> <span class="nav-text">2、final基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1、修饰类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">2、修饰方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81private-final"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">1、private final</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81final%E6%96%B9%E6%B3%95%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%E7%9A%84"><span class="nav-number">1.6.2.2.2.</span> <span class="nav-text">2、final方法是可以被重载的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BF%AE%E9%A5%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">3、修饰参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">4、修饰变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%89%80%E6%9C%89final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%B8%E9%87%8F%E5%90%97%EF%BC%9F"><span class="nav-number">1.6.2.4.1.</span> <span class="nav-text">1、所有final修饰的字段都是编译器常量吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81static-final"><span class="nav-number">1.6.2.4.2.</span> <span class="nav-text">2、static final</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81blank-final"><span class="nav-number">1.6.2.4.3.</span> <span class="nav-text">3、blank final</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">1.6.3.</span> <span class="nav-text">3、final域重排序规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81final%E5%9F%9F%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">1、final域为基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%86%99final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">1.6.3.1.1.</span> <span class="nav-text">1、写final域重排序规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%AF%BBfinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">1.6.3.1.2.</span> <span class="nav-text">2、读final域重排序规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81final%E5%9F%9F%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">2、final域为引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AF%B9final%E5%9F%9F%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">1、对final域修饰的对象的成员域写操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AF%B9final%E5%9F%9F%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.3.2.2.</span> <span class="nav-text">2、对final域修饰的对象的成员域读操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8Efinal%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">3、关于final重排序的总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81final%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.6.4.</span> <span class="nav-text">4、final再深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81final%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">1、final的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E8%AE%BE%E7%BD%AE-%EF%AC%81nal-%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">1.6.4.1.1.</span> <span class="nav-text">1、设置 ﬁnal 变量的原理：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96-%EF%AC%81nal-%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.4.1.2.</span> <span class="nav-text">2、获取 ﬁnal 变量的原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E2%80%9D%E6%BA%A2%E5%87%BA%E2%80%9D"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">2、为什么final引用不能从构造函数中”溢出”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8final%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">3、使用final的限制条件和局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%86%8D%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">4、再思考一个有趣的现象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81JUC%EF%BC%88java-util-concurrent%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">7、JUC（java.util.concurrent）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0%E3%80%81JUC-%E7%B1%BB%E6%B1%87%E6%80%BB%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E8%A7%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">0、JUC - 类汇总和学习总览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-5"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Overview"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">2、Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E7%B1%BB%E4%B8%8E%E6%A1%86%E6%9E%B6"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">3、相关类与框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Lock%E6%A1%86%E6%9E%B6%E5%92%8CTools%E7%B1%BB"><span class="nav-number">1.7.1.3.1.</span> <span class="nav-text">1、Lock框架和Tools类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Collections%EF%BC%9A%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="nav-number">1.7.1.3.2.</span> <span class="nav-text">2、Collections：并发集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.7.1.3.3.</span> <span class="nav-text">3、Atomic: 原子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Executors%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.1.3.4.</span> <span class="nav-text">4、Executors：线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81JUC%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.2.</span> <span class="nav-text">1、JUC概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">1、什么是JUC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">2、多线程编程步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.2.2.1.</span> <span class="nav-text">虚假唤醒问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.7.2.2.1.1.</span> <span class="nav-text">1、什么是虚假唤醒问题？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.7.2.2.1.2.</span> <span class="nav-text">2、为什么会出现虚假唤醒问题？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%8F%82%E8%80%83%E4%B8%8B%E9%9D%A2%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E5%B0%86%E5%85%B6%E4%B8%AD%E7%9A%84while%E4%BF%AE%E6%94%B9%E4%B8%BAif%EF%BC%8C%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%8F%91%E7%8E%B0%EF%BC%89"><span class="nav-number">1.7.2.2.1.3.</span> <span class="nav-text">3、示例（参考下面进程间通信的代码——将其中的while修改为if，并运行发现）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%88%86%E6%9E%90%EF%BC%88%E5%81%87%E8%AE%BE%E4%B8%80%E5%BC%80%E5%A7%8B%E4%B8%BA0%EF%BC%89"><span class="nav-number">1.7.2.2.1.4.</span> <span class="nav-text">4、分析（假设一开始为0）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E4%BD%BF%E7%94%A8wait-notify%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.2.2.1.5.</span> <span class="nav-text">5、使用wait&#x2F;notify的正确姿势——防止虚假唤醒问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9ACAS%EF%BC%8CUnsafe%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.3.</span> <span class="nav-text">2、JUC原子类：CAS，Unsafe和原子类详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-6"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81CAS"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">2、CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="nav-number">1.7.3.2.1.</span> <span class="nav-text">1、什么是CAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81CAS%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.7.3.2.2.</span> <span class="nav-text">2、CAS使用实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">1.7.3.2.3.</span> <span class="nav-text">3、为什么无锁效率高</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81CAS-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.7.3.2.4.</span> <span class="nav-text">4、CAS 的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81CAS%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.2.5.</span> <span class="nav-text">5、CAS问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.2.5.1.</span> <span class="nav-text">1、ABA问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">1.7.3.2.5.2.</span> <span class="nav-text">2、循环时间长开销大</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.3.2.5.3.</span> <span class="nav-text">3、只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Unsafe%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">3、Unsafe类详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Unsafe%E4%B8%8ECAS"><span class="nav-number">1.7.3.3.1.</span> <span class="nav-text">1、Unsafe与CAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8unsafe"><span class="nav-number">1.7.3.3.2.</span> <span class="nav-text">2、使用unsafe</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8unsafe%E5%8E%BB%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E6%AE%B5-%E5%9F%9F-%E7%9A%84%E5%8F%96%E5%80%BC"><span class="nav-number">1.7.3.3.2.1.</span> <span class="nav-text">1、使用unsafe去修改一个对象的字段(域)的取值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8unsafe%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%80%BC%E6%95%B4%E6%95%B0"><span class="nav-number">1.7.3.3.2.2.</span> <span class="nav-text">2、使用unsafe模拟实现原值整数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Unsafe%E5%BA%95%E5%B1%82"><span class="nav-number">1.7.3.3.3.</span> <span class="nav-text">2、Unsafe底层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Unsafe%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="nav-number">1.7.3.3.4.</span> <span class="nav-text">3、Unsafe其他功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AutomicIntrger"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">4、AutomicIntrger</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.7.3.4.1.</span> <span class="nav-text">1、使用举例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.7.3.4.2.</span> <span class="nav-text">2、源码解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%BB%B6%E4%BC%B8%E5%88%B0%E6%89%80%E6%9C%89%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9A%E5%85%B113%E4%B8%AA"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">5、延伸到所有原子类：共13个</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.3.5.1.</span> <span class="nav-text">1、原子更新基本类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.3.5.2.</span> <span class="nav-text">2、原子更新数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.3.5.3.</span> <span class="nav-text">3、原子更新引用类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E7%B1%BB%EF%BC%88%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%99%A8%EF%BC%89"><span class="nav-number">1.7.3.5.4.</span> <span class="nav-text">4、原子更新字段类（原子更新器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">1.7.3.5.5.</span> <span class="nav-text">5、原子累加器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81LongAdder%E6%BA%90%E7%A0%81"><span class="nav-number">1.7.3.5.5.1.</span> <span class="nav-text">2、LongAdder源码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%BC%93%E5%AD%98%EF%BC%88%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">1.7.3.5.5.2.</span> <span class="nav-text">3、缓存（伪共享问题）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94increment"><span class="nav-number">1.7.3.5.5.3.</span> <span class="nav-text">4、核心方法——increment()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%86%8D%E8%AF%B4AutomicStampedReference%E8%A7%A3%E5%86%B3CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.6.</span> <span class="nav-text">6、再说AutomicStampedReference解决CAS的ABA问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81AutomicStampedReference%E8%A7%A3%E5%86%B3CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.6.1.</span> <span class="nav-text">1、AutomicStampedReference解决CAS的ABA问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.7.3.6.2.</span> <span class="nav-text">2、使用举例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81java%E4%B8%AD%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.7.3.6.3.</span> <span class="nav-text">3、java中还有哪些类可以解决ABA问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%9C%A8%E6%97%A5%E5%B8%B8%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%88%E7%94%A8%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.3.6.4.</span> <span class="nav-text">4、在日常的业务中怎么解决ABA问题？（用乐观锁的方法）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81JUC%E9%94%81%EF%BC%9ALockSupport%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.4.</span> <span class="nav-text">3、JUC锁：LockSupport详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-7"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81LockSupport%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">2、LockSupport简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81LockSupport%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">3、LockSupport源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.4.3.1.</span> <span class="nav-text">1、类的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.2.</span> <span class="nav-text">2、类的构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">1.7.4.3.3.</span> <span class="nav-text">3、核心函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81park%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.3.1.</span> <span class="nav-text">1、park函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81parkNanos%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.3.2.</span> <span class="nav-text">2、parkNanos函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81parkUntil%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.3.3.</span> <span class="nav-text">3、parkUntil函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81unpark%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.3.4.</span> <span class="nav-text">4、unpark函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81park-unpark-%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">4、park&#x2F;unpark 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%88%E8%B0%83%E7%94%A8park"><span class="nav-number">1.7.4.4.1.</span> <span class="nav-text">1、先调用park()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%86%8D%E8%B0%83%E7%94%A8unpark-%EF%BC%9A"><span class="nav-number">1.7.4.4.2.</span> <span class="nav-text">2、再调用unpark()：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%88%E8%B0%83%E7%94%A8unpark-%EF%BC%8C%E5%86%8D%E8%B0%83%E7%94%A8park-%EF%BC%9A"><span class="nav-number">1.7.4.4.3.</span> <span class="nav-text">3、先调用unpark()，再调用park()：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81LockSupport%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">1.7.4.5.</span> <span class="nav-text">5、LockSupport示例说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8wait-notify%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.7.4.5.1.</span> <span class="nav-text">1、使用wait&#x2F;notify实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8park-unpark%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.7.4.5.2.</span> <span class="nav-text">2、使用park&#x2F;unpark实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94"><span class="nav-number">1.7.4.5.3.</span> <span class="nav-text">3、中断响应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.4.6.</span> <span class="nav-text">6、更深入的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Thread-sleep-%E5%92%8CObject-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.6.1.</span> <span class="nav-text">1、Thread.sleep()和Object.wait()的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Thread-sleep-%E5%92%8CCondition-await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.6.2.</span> <span class="nav-text">2、Thread.sleep()和Condition.await()的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Thread-sleep-%E5%92%8CLockSupport-park-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.6.3.</span> <span class="nav-text">3、Thread.sleep()和LockSupport.park()的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Object-wait-%E5%92%8CLockSupport-park-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.6.4.</span> <span class="nav-text">4、Object.wait()和LockSupport.park()的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81LockSupport-park-%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E8%B5%84%E6%BA%90%E5%90%97%EF%BC%9F"><span class="nav-number">1.7.4.6.5.</span> <span class="nav-text">5、LockSupport.park()会释放锁资源吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81AbstractQueuedSynchronizer%EF%BC%88AQS%EF%BC%89"><span class="nav-number">1.7.5.</span> <span class="nav-text">4、AbstractQueuedSynchronizer（AQS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-8"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">2、AbstractQueuedSynchronizer简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.7.5.2.1.</span> <span class="nav-text">1、AQS核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81AQS%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.5.2.2.</span> <span class="nav-text">2、AQS对资源的共享方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81AQS%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BA%86%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.5.2.3.</span> <span class="nav-text">3、AQS底层使用了模板方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.7.5.2.4.</span> <span class="nav-text">4、总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81AbstractQueuedSynchronizer%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">3、AbstractQueuedSynchronizer数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.5.4.</span> <span class="nav-text">4、AbstractQueuedSynchronizer源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.5.4.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.5.4.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94Node%E7%B1%BB"><span class="nav-number">1.7.5.4.3.</span> <span class="nav-text">3、类的内部类——Node类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94ConditionObject%E7%B1%BB"><span class="nav-number">1.7.5.4.4.</span> <span class="nav-text">4、类的内部类——ConditionObject类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.5.4.5.</span> <span class="nav-text">5、类的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.5.4.6.</span> <span class="nav-text">6、类的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94acquire%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.5.4.7.</span> <span class="nav-text">7、类的核心方法——acquire方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94release%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.5.4.8.</span> <span class="nav-text">8、类的核心方法——release方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81AbstractQueuedSynchronizer%E7%A4%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%B8%80"><span class="nav-number">1.7.5.5.</span> <span class="nav-text">5、AbstractQueuedSynchronizer示例详解一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81AbstractQueuedSynchronizer%E7%A4%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%BA%8C"><span class="nav-number">1.7.5.6.</span> <span class="nav-text">6、AbstractQueuedSynchronizer示例详解二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81AbstractQueuedSynchronizer%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.5.7.</span> <span class="nav-text">7、AbstractQueuedSynchronizer总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E4%BD%BF%E7%94%A8AQS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.7.5.8.</span> <span class="nav-text">8、使用AQS自定义同步器——实现不可重入锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Lock%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.6.</span> <span class="nav-text">5、Lock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFLock"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">1、什么是Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Lock%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%BA%90%E7%A0%81%EF%BC%89"><span class="nav-number">1.7.6.2.</span> <span class="nav-text">2、Lock接口（源码）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81lock-%E6%96%B9%E6%B3%95-%E4%B8%8E-unlock-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.6.2.1.</span> <span class="nav-text">1、lock()方法 与 unlock()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81tryLock-%E6%96%B9%E6%B3%95-%E4%B8%8E-tryLock-long-time-TimeUnit-unit-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.6.2.2.</span> <span class="nav-text">2、tryLock()方法 与 tryLock(long time, TimeUnit unit)方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81newCondition-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.6.2.3.</span> <span class="nav-text">3、newCondition()方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Lock%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E2%80%94%E2%80%94ReentrantLock%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">1.7.6.3.</span> <span class="nav-text">3、Lock接口的实现类——ReentrantLock（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-9"><span class="nav-number">1.7.6.3.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.6.3.2.</span> <span class="nav-text">2、ReentrantLock源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-1"><span class="nav-number">1.7.6.3.2.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-1"><span class="nav-number">1.7.6.3.2.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E9%BB%98%E8%AE%A4%E6%98%AF%E9%87%87%E7%94%A8%E7%9A%84%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%89"><span class="nav-number">1.7.6.3.2.3.</span> <span class="nav-text">4、类的构造函数（默认是采用的非公平策略获取锁）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8A%A0%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81"><span class="nav-number">1.7.6.3.2.4.</span> <span class="nav-text">5、核心函数分析——加锁与解锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.6.3.2.5.</span> <span class="nav-text">6、核心函数分析——可重入原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.6.3.2.6.</span> <span class="nav-text">7、核心函数分析——可打断原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.6.3.2.7.</span> <span class="nav-text">8、核心函数分析——条件变量实现原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.7.6.3.3.</span> <span class="nav-text">3、示例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.7.6.3.3.1.</span> <span class="nav-text">公平锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81ReadWriteLock%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.7.</span> <span class="nav-text">6、ReadWriteLock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81ReadWriteLock%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E2%80%94%E2%80%94ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">1、ReadWriteLock接口实现类——ReentrantReadWriteLock读写锁（重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-10"><span class="nav-number">1.7.7.1.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ReentrantReadWriteLock%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.7.1.2.</span> <span class="nav-text">2、ReentrantReadWriteLock数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.7.1.3.</span> <span class="nav-text">3、ReentrantReadWriteLock源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-2"><span class="nav-number">1.7.7.1.3.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-2"><span class="nav-number">1.7.7.1.3.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94Sync%E7%B1%BB"><span class="nav-number">1.7.7.1.3.3.</span> <span class="nav-text">3、内部类——Sync类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.7.1.3.4.</span> <span class="nav-text">6、类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">1.7.7.1.3.5.</span> <span class="nav-text">7、核心函数分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E5%9B%BE%E8%A7%A3ReentrantReadWriteLock%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.7.1.3.6.</span> <span class="nav-text">8、图解ReentrantReadWriteLock执行流程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81ReentrantReadWriteLock%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.7.1.4.</span> <span class="nav-text">4、ReentrantReadWriteLock示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.7.1.5.</span> <span class="nav-text">5、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E5%8D%87%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="nav-number">1.7.7.1.5.1.</span> <span class="nav-text">1、什么是锁升降级？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%94%81%E9%99%8D%E7%BA%A7%E4%B8%AD%E8%AF%BB%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81%E5%91%A2"><span class="nav-number">1.7.7.1.5.2.</span> <span class="nav-text">2、锁降级中读锁的获取是否必要呢?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81RentrantReadWriteLock%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9F"><span class="nav-number">1.7.7.1.5.3.</span> <span class="nav-text">3、RentrantReadWriteLock支不支持锁升级？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%EF%BC%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%EF%BC%89"><span class="nav-number">1.7.7.1.6.</span> <span class="nav-text">6、使用读写锁实现一致性缓存（保证缓存与数据库数据一致）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.7.7.1.6.1.</span> <span class="nav-text">1、缓存更新策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E7%BC%93%E5%AD%98"><span class="nav-number">1.7.7.1.6.2.</span> <span class="nav-text">2、使用读写锁实现一个简单的按需加载缓存</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81ReentrantReadWriteLock%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.7.1.7.</span> <span class="nav-text">7、ReentrantReadWriteLock总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81StampedLock%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.7.1.8.</span> <span class="nav-text">2、StampedLock示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81StampedLock%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9B%BF%E4%BB%A3ReentrantReadWriteLock"><span class="nav-number">1.7.7.1.9.</span> <span class="nav-text">3、StampedLock是否可以替代ReentrantReadWriteLock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.7.8.</span> <span class="nav-text">7、线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.8.1.</span> <span class="nav-text">1、场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.8.2.</span> <span class="nav-text">2、分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8Ei-%E4%B8%8Ei%E2%80%93%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.8.2.1.</span> <span class="nav-text">1、关于i++与i–的字节码及其执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%B4%E7%95%8C%E5%8C%BA-Critical-Section"><span class="nav-number">1.7.8.2.2.</span> <span class="nav-text">2、临界区 Critical Section</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6-Race-Condition"><span class="nav-number">1.7.8.2.3.</span> <span class="nav-text">3、竞态条件 Race Condition</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.8.3.</span> <span class="nav-text">3、解决方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%AE%9A%E5%88%B6%E5%8C%96%E9%80%9A%E4%BF%A1"><span class="nav-number">1.7.9.</span> <span class="nav-text">8、线程间定制化通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.7.10.</span> <span class="nav-text">9、集合的线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81ArrayList%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.7.10.1.</span> <span class="nav-text">1、ArrayList不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%96%B9%E6%A1%881%EF%BC%9A%E7%94%A8Vector%E4%BB%A3%E6%9B%BFArrayList"><span class="nav-number">1.7.10.1.1.</span> <span class="nav-text">1、方案1：用Vector代替ArrayList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%A1%882%EF%BC%9ACollections-synchronizedList%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84ArrayList"><span class="nav-number">1.7.10.1.2.</span> <span class="nav-text">2、方案2：Collections.synchronizedList创建一个同步的ArrayList</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81JUC%E7%9A%84CopyOnWriteArrayList"><span class="nav-number">1.7.10.2.</span> <span class="nav-text">2、JUC的CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-11"><span class="nav-number">1.7.10.2.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.10.2.2.</span> <span class="nav-text">2、CopyOnWriteArrayList源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-3"><span class="nav-number">1.7.10.2.2.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94COWIterator%E7%B1%BB"><span class="nav-number">1.7.10.2.2.2.</span> <span class="nav-text">2、类的内部类——COWIterator类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.10.2.2.3.</span> <span class="nav-text">3、类的属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.10.2.2.4.</span> <span class="nav-text">4、类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94add"><span class="nav-number">1.7.10.2.2.5.</span> <span class="nav-text">7、核心函数分析——add</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94addIfAbsent"><span class="nav-number">1.7.10.2.2.6.</span> <span class="nav-text">8、核心函数分析——addIfAbsent</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94set"><span class="nav-number">1.7.10.2.2.7.</span> <span class="nav-text">9、核心函数分析——set</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E2%80%94%E2%80%94remove"><span class="nav-number">1.7.10.2.2.8.</span> <span class="nav-text">10、核心函数分析——remove</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81CopyOnWriteArrayList%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.10.2.3.</span> <span class="nav-text">3、CopyOnWriteArrayList示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81CopyOnWriteArrayList%E7%9A%84%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%E4%BD%93%E7%8E%B0"><span class="nav-number">1.7.10.2.4.</span> <span class="nav-text">4、CopyOnWriteArrayList的弱一致性体现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81get-%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.7.10.2.4.1.</span> <span class="nav-text">1、get 弱一致性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.7.10.2.4.2.</span> <span class="nav-text">2、迭代器弱一致性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.7.10.2.4.3.</span> <span class="nav-text">3、关于弱一致性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1"><span class="nav-number">1.7.10.2.5.</span> <span class="nav-text">5、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81CopyOnWriteArrayList%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.10.2.5.1.</span> <span class="nav-text">1、CopyOnWriteArrayList的缺陷和使用场景</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81CopyOnWriteArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E8%83%BD%E6%AF%94Vector%E5%A5%BD%EF%BC%9F"><span class="nav-number">1.7.10.2.5.2.</span> <span class="nav-text">2、CopyOnWriteArrayList为什么并发安全性能比Vector好？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81HashMap%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.7.10.3.</span> <span class="nav-text">3、HashMap不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%881%EF%BC%9A%E7%94%A8HashTable%E4%BB%A3%E6%9B%BFHashMap"><span class="nav-number">1.7.10.3.1.</span> <span class="nav-text">方案1：用HashTable代替HashMap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81JUC%E7%9A%84ConcurrentHashMap"><span class="nav-number">1.7.10.4.</span> <span class="nav-text">4、JUC的ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-12"><span class="nav-number">1.7.10.4.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88HashTable%E6%85%A2"><span class="nav-number">1.7.10.4.2.</span> <span class="nav-text">2、为什么HashTable慢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81ConcurrentHashMap-JDK1-7"><span class="nav-number">1.7.10.4.3.</span> <span class="nav-text">3、ConcurrentHashMap - JDK1.7</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.10.4.3.1.</span> <span class="nav-text">1、数据结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.7.10.4.3.2.</span> <span class="nav-text">2、初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81put%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.7.10.4.3.3.</span> <span class="nav-text">3、put过程分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD%EF%BC%9AensureSegment"><span class="nav-number">1.7.10.4.3.4.</span> <span class="nav-text">4、初始化槽：ensureSegment</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81%EF%BC%9AscanAndLockForPut"><span class="nav-number">1.7.10.4.3.5.</span> <span class="nav-text">5、获取写入锁：scanAndLockForPut</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%89%A9%E5%AE%B9%EF%BC%9Arehash"><span class="nav-number">1.7.10.4.3.6.</span> <span class="nav-text">6、扩容：rehash</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81get%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.7.10.4.3.7.</span> <span class="nav-text">7、get过程分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81size%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.10.4.3.8.</span> <span class="nav-text">8、size计算流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9%E3%80%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">1.7.10.4.3.9.</span> <span class="nav-text">9、并发问题分析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81ConcurrentHashMap-JDK1-8"><span class="nav-number">1.7.10.4.4.</span> <span class="nav-text">4、ConcurrentHashMap - JDK1.8</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.7.10.4.4.1.</span> <span class="nav-text">1、数据结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">1.7.10.4.4.2.</span> <span class="nav-text">2、初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81put%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="nav-number">1.7.10.4.4.3.</span> <span class="nav-text">3、put过程分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%EF%BC%9AinitTable"><span class="nav-number">1.7.10.4.4.4.</span> <span class="nav-text">4、初始化数组：initTable</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9AtreeifyBin"><span class="nav-number">1.7.10.4.4.5.</span> <span class="nav-text">5、链表转红黑树：treeifyBin</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%89%A9%E5%AE%B9%EF%BC%9AtryPresize"><span class="nav-number">1.7.10.4.4.6.</span> <span class="nav-text">6、扩容：tryPresize</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%9Atransfer"><span class="nav-number">1.7.10.4.4.7.</span> <span class="nav-text">7、数据迁移：transfer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81get%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.7.10.4.4.8.</span> <span class="nav-text">8、get过程分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9%E3%80%81size-%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.10.4.4.9.</span> <span class="nav-text">9、size 计算流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.10.4.4.10.</span> <span class="nav-text">10、总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.10.4.5.</span> <span class="nav-text">5、对比总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8ConcurrentHashMap%E2%80%94%E2%80%94computeIfAbsent-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.10.4.6.</span> <span class="nav-text">6、正确使用ConcurrentHashMap——computeIfAbsent()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81JDK-7-HashMap-%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.10.4.7.</span> <span class="nav-text">7、JDK 7 HashMap 并发死链问题原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81JDK-7-HashMap-%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.10.4.7.1.</span> <span class="nav-text">1、JDK 7 HashMap 并发死链问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%AD%BB%E9%93%BE%E5%A4%8D%E7%8E%B0"><span class="nav-number">1.7.10.4.7.2.</span> <span class="nav-text">2、死链复现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%80%9A%E8%BF%87JDK-7-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.10.4.7.3.</span> <span class="nav-text">3、通过JDK 7 HashMap源码分析死链问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.7.10.4.7.4.</span> <span class="nav-text">4、小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81HashSet%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.7.10.5.</span> <span class="nav-text">5、HashSet不安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81JUC%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%EF%BC%9ABlockingQueue%E6%8E%A5%E5%8F%A3%EF%BC%88%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">1.7.11.</span> <span class="nav-text">10、JUC并发集合：BlockingQueue接口（阻塞队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-13"><span class="nav-number">1.7.11.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BlockingQueue%E5%92%8CBlockingDeque"><span class="nav-number">1.7.11.2.</span> <span class="nav-text">2、BlockingQueue和BlockingDeque</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BlockingQueue"><span class="nav-number">1.7.11.2.1.</span> <span class="nav-text">1、BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFBlockQueue%EF%BC%9F"><span class="nav-number">1.7.11.2.1.1.</span> <span class="nav-text">1、什么是BlockQueue？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81BlockQueue%EF%BC%9F"><span class="nav-number">1.7.11.2.1.2.</span> <span class="nav-text">2、为什么需要BlockQueue？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E2%80%94%E7%BB%8F%E5%85%B8%E7%9A%84%E2%80%9C%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%9D%E5%92%8C-%E2%80%9C%E6%B6%88%E8%B4%B9%E8%80%85%E2%80%9D%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.7.11.2.1.3.</span> <span class="nav-text">3、适用场景——经典的“生产者”和 “消费者”模型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81BlockingQueue%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.11.2.2.</span> <span class="nav-text">2、BlockingQueue的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81BlockingDeque"><span class="nav-number">1.7.11.2.3.</span> <span class="nav-text">3、BlockingDeque</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81BlockingDeque%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.11.2.4.</span> <span class="nav-text">4、BlockingDeque的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81BlockingQueue%E5%92%8CBlockingDeque%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.11.2.5.</span> <span class="nav-text">5、BlockingQueue和BlockingDeque的关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81BlockingQueue%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.11.3.</span> <span class="nav-text">3、BlockingQueue的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94ArrayBlockingQueue-%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.7.11.3.1.</span> <span class="nav-text">**1、数组阻塞队列——ArrayBlockingQueue**（常用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E2%80%94%E2%80%94DelayQueue"><span class="nav-number">1.7.11.3.2.</span> <span class="nav-text">2、延迟队列——DelayQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%93%BE%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94LinkedBlockingQueue-%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.7.11.3.3.</span> <span class="nav-text">**3、链阻塞队列——LinkedBlockingQueue**（常用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%85%B7%E6%9C%89%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94PriorityBlockingQueue"><span class="nav-number">1.7.11.3.4.</span> <span class="nav-text">4、具有优先级的阻塞队列——PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E2%80%94%E2%80%94SynchronousQueue"><span class="nav-number">1.7.11.3.5.</span> <span class="nav-text">5、同步队列——SynchronousQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E9%93%BE%E9%98%BB%E5%A1%9E%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94LinkedTransferQueue"><span class="nav-number">1.7.11.3.6.</span> <span class="nav-text">6、链阻塞无界队列——LinkedTransferQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81BlockingDeque-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.11.4.</span> <span class="nav-text">4、BlockingDeque 的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%BB%E5%A1%9E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94LinkedBlockDeque"><span class="nav-number">1.7.11.4.1.</span> <span class="nav-text">链阻塞双端队列——LinkedBlockDeque</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81JUC%E9%9B%86%E5%90%88%EF%BC%9ALinkedBlockingQueue%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.12.</span> <span class="nav-text">11、JUC集合：LinkedBlockingQueue详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81LinkedBlockingQueue-%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.12.1.</span> <span class="nav-text">1、LinkedBlockingQueue 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F"><span class="nav-number">1.7.12.1.1.</span> <span class="nav-text">1、基本的入队出队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.12.1.2.</span> <span class="nav-text">2、加锁分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">1.7.12.2.</span> <span class="nav-text">2、性能比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81JUC%E9%9B%86%E5%90%88%EF%BC%9AConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.13.</span> <span class="nav-text">12、JUC集合：ConcurrentLinkedQueue详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-14"><span class="nav-number">1.7.13.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ConcurrentLinkedQueue%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.13.2.</span> <span class="nav-text">2、ConcurrentLinkedQueue数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.13.3.</span> <span class="nav-text">3、ConcurrentLinkedQueue源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-4"><span class="nav-number">1.7.13.3.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-3"><span class="nav-number">1.7.13.3.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7-1"><span class="nav-number">1.7.13.3.3.</span> <span class="nav-text">3、类的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.13.3.4.</span> <span class="nav-text">4、 类的构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">1.7.13.3.5.</span> <span class="nav-text">5、核心函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81offer%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.13.3.5.1.</span> <span class="nav-text">1、offer函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81poll%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.13.3.5.2.</span> <span class="nav-text">2、poll函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81remove%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.13.3.5.3.</span> <span class="nav-text">3、remove函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81size%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.13.3.5.4.</span> <span class="nav-text">4、size函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ConcurrentLinkedQueue%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.13.4.</span> <span class="nav-text">4、ConcurrentLinkedQueue示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.13.5.</span> <span class="nav-text">5、再深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81HOPS%EF%BC%88%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%89%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.7.13.5.1.</span> <span class="nav-text">1、HOPS（延迟更新的策略）的设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ConcurrentLinkedQueue%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.13.5.2.</span> <span class="nav-text">2、ConcurrentLinkedQueue适合的场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="nav-number">1.7.14.</span> <span class="nav-text">13、多线程锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.7.14.1.</span> <span class="nav-text">1、公平锁与非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.7.14.1.1.</span> <span class="nav-text">1、公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.7.14.1.2.</span> <span class="nav-text">2、非公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.7.14.1.3.</span> <span class="nav-text">3、公平锁与非公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94ReentrantLock%EF%BC%88%E5%85%B7%E4%BD%93%E7%9C%8B%E4%B8%80%E7%9C%8B%E4%B8%8A%E6%96%87%E7%9A%84ReentrantLock%EF%BC%89"><span class="nav-number">1.7.14.1.4.</span> <span class="nav-text">4、公平锁与非公平锁的实现——ReentrantLock（具体看一看上文的ReentrantLock）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.14.1.5.</span> <span class="nav-text">5、公平锁与非公平锁的实现过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%B7%B1%E5%85%A5%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%E7%9C%9F%E7%9A%84%E5%85%AC%E5%B9%B3%E5%90%97%EF%BC%9F"><span class="nav-number">1.7.14.1.6.</span> <span class="nav-text">6、深入：公平锁真的公平吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E6%99%AF1%EF%BC%9A"><span class="nav-number">1.7.14.1.6.1.</span> <span class="nav-text">情景1：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BA%90%E7%A0%81%E4%B8%ADhasQueuedPredecessors-%E6%96%B9%E6%B3%95%E4%B8%ADtail%E5%92%8Chead%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.14.1.6.2.</span> <span class="nav-text">关于公平锁源码中hasQueuedPredecessors()方法中tail和head赋值顺序问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.14.1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.7.14.2.</span> <span class="nav-text">2、可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.7.14.2.1.</span> <span class="nav-text">1、什么是重入锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.14.2.2.</span> <span class="nav-text">2、重入锁的实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%AC%E5%B9%B3%E7%9A%84%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.7.14.2.3.</span> <span class="nav-text">3、公平的重入锁与非公平的重入锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Condition"><span class="nav-number">1.7.14.2.4.</span> <span class="nav-text">4、Condition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%98%BE%E7%A4%BA%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88lock%EF%BC%89%E4%B8%8E%E9%9A%90%E5%BC%8F%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Synchronized%EF%BC%89"><span class="nav-number">1.7.14.2.5.</span> <span class="nav-text">5、显示重入锁（lock）与隐式重入锁（Synchronized）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.14.2.6.</span> <span class="nav-text">6、重入锁的使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.14.2.7.</span> <span class="nav-text">7、可重入锁总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.</span> <span class="nav-text">3、死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.1.</span> <span class="nav-text">1、什么是死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.7.14.3.2.</span> <span class="nav-text">2、产生死锁的三大原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.7.14.3.3.</span> <span class="nav-text">3、产生死锁的四大条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.14.3.4.</span> <span class="nav-text">4、验证是否发生死锁的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.14.3.5.</span> <span class="nav-text">5、解决死锁的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.5.1.</span> <span class="nav-text">1、预防死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.5.2.</span> <span class="nav-text">2、避免死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.5.3.</span> <span class="nav-text">3、检测死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="nav-number">1.7.14.3.5.4.</span> <span class="nav-text">4、解除死锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.14.3.6.</span> <span class="nav-text">6、死锁代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%B4%BB%E9%94%81"><span class="nav-number">1.7.14.4.</span> <span class="nav-text">4、活锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%A5%A5%E9%A5%BF"><span class="nav-number">1.7.14.5.</span> <span class="nav-text">5、饥饿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Locking-%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-Pessimistic-Lock"><span class="nav-number">1.7.14.6.</span> <span class="nav-text">6、乐观锁(Optimistic Locking)和悲观锁(Pessimistic Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81-Pessimistic-Lock"><span class="nav-number">1.7.14.6.1.</span> <span class="nav-text">1、悲观锁(Pessimistic Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Locking"><span class="nav-number">1.7.14.6.2.</span> <span class="nav-text">2、乐观锁(Optimistic Locking)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3"><span class="nav-number">1.7.14.6.2.1.</span> <span class="nav-text">乐观锁场景：在线文档</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="nav-number">1.7.14.7.</span> <span class="nav-text">7、表锁和行锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E8%AF%BB%E9%94%81%E4%B8%8E%E5%86%99%E9%94%81"><span class="nav-number">1.7.14.8.</span> <span class="nav-text">8、读锁与写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.7.14.9.</span> <span class="nav-text">9、自旋锁与自适应自旋锁、偏向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94FutureTask%EF%BC%88%E6%9C%AA%E6%9D%A5%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="nav-number">1.7.15.</span> <span class="nav-text">14、JUC线程池——FutureTask（未来任务）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-15"><span class="nav-number">1.7.15.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81FutureTask%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.15.2.</span> <span class="nav-text">2、FutureTask简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81FutureTask%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.15.3.</span> <span class="nav-text">3、FutureTask类关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.15.4.</span> <span class="nav-text">4、FutureTask源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.15.4.1.</span> <span class="nav-text">1、Callable接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Future%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.15.4.2.</span> <span class="nav-text">2、Future接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.15.4.3.</span> <span class="nav-text">3、核心属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.15.4.4.</span> <span class="nav-text">4、构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94run"><span class="nav-number">1.7.15.4.5.</span> <span class="nav-text">5、核心方法——run()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94awaitDone-boolean-timed-long-nanos"><span class="nav-number">1.7.15.4.6.</span> <span class="nav-text">7、核心方法——awaitDone(boolean timed, long nanos)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94cancel-boolean-mayInterruptIfRunning"><span class="nav-number">1.7.15.4.7.</span> <span class="nav-text">8、核心方法——cancel(boolean mayInterruptIfRunning)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81FutureTask%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.15.5.</span> <span class="nav-text">5、FutureTask示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Future%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.15.5.1.</span> <span class="nav-text">1、Future使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81FutureTask-Thread%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.15.5.2.</span> <span class="nav-text">2、FutureTask + Thread例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81JUC%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="nav-number">1.7.16.</span> <span class="nav-text">15、JUC强大的辅助类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81CountDownLatch%EF%BC%88%E5%87%8F%E5%B0%91%E8%AE%A1%E6%95%B0%EF%BC%89"><span class="nav-number">1.7.16.1.</span> <span class="nav-text">1、CountDownLatch（减少计数）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-16"><span class="nav-number">1.7.16.1.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81CountDownLatch%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.16.1.2.</span> <span class="nav-text">2、CountDownLatch介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81CountDownLatch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.16.1.3.</span> <span class="nav-text">3、CountDownLatch源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-5"><span class="nav-number">1.7.16.1.3.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-4"><span class="nav-number">1.7.16.1.3.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7-2"><span class="nav-number">1.7.16.1.3.3.</span> <span class="nav-text">3、类的属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.7.16.1.3.4.</span> <span class="nav-text">4、类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94await%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.1.3.5.</span> <span class="nav-text">5、核心函数——await函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2"><span class="nav-number">1.7.16.1.4.</span> <span class="nav-text">5、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.7.16.1.4.1.</span> <span class="nav-text">1、面试题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">1.7.16.1.4.2.</span> <span class="nav-text">2、使用wait和notify实现：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81CountDownLatch%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.16.1.4.3.</span> <span class="nav-text">3、CountDownLatch实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81CyclicBarrier%EF%BC%88%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%EF%BC%89"><span class="nav-number">1.7.16.2.</span> <span class="nav-text">2、CyclicBarrier（循环栅栏）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-17"><span class="nav-number">1.7.16.2.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81CyclicBarrier%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.16.2.2.</span> <span class="nav-text">2、CyclicBarrier简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81CyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.16.2.3.</span> <span class="nav-text">3、CyclicBarrier源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-6"><span class="nav-number">1.7.16.2.3.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-5"><span class="nav-number">1.7.16.2.3.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7-3"><span class="nav-number">1.7.16.2.3.3.</span> <span class="nav-text">3、类的属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="nav-number">1.7.16.2.3.4.</span> <span class="nav-text">4、类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94dowait%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.2.3.5.</span> <span class="nav-text">5、核心函数——dowait函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94nextGenneration%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.2.3.6.</span> <span class="nav-text">6、核心函数——nextGenneration函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81breakBarrier%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.2.3.7.</span> <span class="nav-text">7、breakBarrier函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81CyclicBarrier%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.16.2.4.</span> <span class="nav-text">4、CyclicBarrier示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.16.2.5.</span> <span class="nav-text">5、新增一个容易理解的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%92%8CCountDownLatch%E5%86%8D%E5%AF%B9%E6%AF%94"><span class="nav-number">1.7.16.2.6.</span> <span class="nav-text">6、和CountDownLatch再对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="nav-number">1.7.16.3.</span> <span class="nav-text">3、Semaphore（信号量）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-18"><span class="nav-number">1.7.16.3.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Semaphore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.16.3.2.</span> <span class="nav-text">2、Semaphore源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-7"><span class="nav-number">1.7.16.3.2.1.</span> <span class="nav-text">1、类的继承关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-6"><span class="nav-number">1.7.16.3.2.2.</span> <span class="nav-text">2、类的内部类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94Sync%E7%B1%BB"><span class="nav-number">1.7.16.3.2.3.</span> <span class="nav-text">3、类的内部类——Sync类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94NonfairSync%E7%B1%BB"><span class="nav-number">1.7.16.3.2.4.</span> <span class="nav-text">4、类的内部类——NonfairSync类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94FairSync%E7%B1%BB"><span class="nav-number">1.7.16.3.2.5.</span> <span class="nav-text">5、类的内部类——FairSync类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.16.3.2.6.</span> <span class="nav-text">6、类的属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.3.2.7.</span> <span class="nav-text">7、类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94acquire%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.3.2.8.</span> <span class="nav-text">8、核心函数——acquire函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9%E3%80%81%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94release%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.16.3.2.9.</span> <span class="nav-text">9、核心函数——release函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10%E3%80%81%E5%9B%BE%E8%A7%A3Semaphore%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.16.3.2.10.</span> <span class="nav-text">10、图解Semaphore的执行流程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Semaphore%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.16.3.3.</span> <span class="nav-text">3、Semaphore示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.16.3.4.</span> <span class="nav-text">4、新增一个容易理解的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81Semaphore%E5%BA%94%E7%94%A8"><span class="nav-number">1.7.16.3.5.</span> <span class="nav-text">5、Semaphore应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.16.3.6.</span> <span class="nav-text">6、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8Semaphore%E6%98%AF%E4%B8%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0AQS%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E7%9A%84"><span class="nav-number">1.7.16.3.6.1.</span> <span class="nav-text">1、单独使用Semaphore是不会使用到AQS的条件队列的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C11%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%90%84%E8%B0%83%E7%94%A81%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.7.16.3.6.2.</span> <span class="nav-text">2、场景问题——semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A811%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.7.16.3.6.3.</span> <span class="nav-text">3、场景问题——semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%891%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C1%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1release%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8acquire-2-%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AD%A4%E7%BA%BF%E7%A8%8B%E8%83%BD%E5%A4%9F%E8%8E%B7%E5%8F%96%E5%88%B0%E8%B6%B3%E5%A4%9F%E7%9A%84%E4%BB%A4%E7%89%8C%E5%B9%B6%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-number">1.7.16.3.6.4.</span> <span class="nav-text">4、场景问题——semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%892%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A81%E6%AC%A1release%E6%96%B9%E6%B3%95%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E8%8E%B7%E5%8F%963%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%BC%9A%E8%8E%B7%E5%8F%96%E5%88%B0%E5%90%97"><span class="nav-number">1.7.16.3.6.5.</span> <span class="nav-text">5、场景问题——semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Phaser-%E7%A7%BB%E7%9B%B8%E5%99%A8"><span class="nav-number">1.7.16.4.</span> <span class="nav-text">4、Phaser(移相器)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-19"><span class="nav-number">1.7.16.4.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.7.16.4.2.</span> <span class="nav-text">2、Phaser运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81Registration-%E6%B3%A8%E5%86%8C"><span class="nav-number">1.7.16.4.2.1.</span> <span class="nav-text">1、Registration(注册)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81Synchronization-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.7.16.4.2.2.</span> <span class="nav-text">2、Synchronization(同步机制)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81Termination-%E7%BB%88%E6%AD%A2%E6%9C%BA%E5%88%B6"><span class="nav-number">1.7.16.4.2.3.</span> <span class="nav-text">3、Termination(终止机制)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81Tiering-%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.16.4.2.4.</span> <span class="nav-text">4、Tiering(分层结构)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81Monitoring-%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-number">1.7.16.4.2.5.</span> <span class="nav-text">5、Monitoring(状态监控)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Phaser%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.16.4.3.</span> <span class="nav-text">3、Phaser源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.16.4.3.1.</span> <span class="nav-text">1、核心参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">1.7.16.4.3.2.</span> <span class="nav-text">2、函数列表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94register"><span class="nav-number">1.7.16.4.3.3.</span> <span class="nav-text">3、方法——register()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94arrive"><span class="nav-number">1.7.16.4.3.4.</span> <span class="nav-text">4、方法——arrive()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94arriveAndAwaitAdvance"><span class="nav-number">1.7.16.4.3.5.</span> <span class="nav-text">5、方法——arriveAndAwaitAdvance()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94awaitAdvance-int-phase"><span class="nav-number">1.7.16.4.3.6.</span> <span class="nav-text">6、方法——awaitAdvance(int phase)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Exchanger-%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="nav-number">1.7.16.5.</span> <span class="nav-text">5、Exchanger(交换器)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-20"><span class="nav-number">1.7.16.5.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Exchanger%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.16.5.2.</span> <span class="nav-text">2、Exchanger简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Exchanger%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.7.16.5.3.</span> <span class="nav-text">3、Exchanger实现机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Exchanger%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.7.16.5.4.</span> <span class="nav-text">4、Exchanger源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94Participant"><span class="nav-number">1.7.16.5.4.1.</span> <span class="nav-text">1、内部类——Participant</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%94%E2%80%94Node"><span class="nav-number">1.7.16.5.4.2.</span> <span class="nav-text">2、内部类——Node</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7-1"><span class="nav-number">1.7.16.5.4.3.</span> <span class="nav-text">3、核心属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.7.16.5.4.4.</span> <span class="nav-text">4、构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94exchange-V-x"><span class="nav-number">1.7.16.5.4.5.</span> <span class="nav-text">5、核心方法——exchange(V x)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81slotExchange-Object-item-boolean-timed-long-ns"><span class="nav-number">1.7.16.5.4.6.</span> <span class="nav-text">6、slotExchange(Object item, boolean timed, long ns)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81arenaExchange-Object-item-boolean-timed-long-ns"><span class="nav-number">1.7.16.5.4.7.</span> <span class="nav-text">7、arenaExchange(Object item, boolean timed, long ns)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E5%89%8D%E9%9D%A2%E6%8F%90%E5%88%B0%E8%BF%87arena%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E4%B8%8D%E5%90%8C%E7%9A%84slot%E5%9C%A8arena%E4%B8%AD%E6%98%AF%E4%B8%8D%E4%BC%9A%E7%9B%B8%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.7.16.5.5.</span> <span class="nav-text">5、前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E7%94%A8-sun-misc-Contended%E6%9D%A5%E8%A7%84%E9%81%BF%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%9F"><span class="nav-number">1.7.16.5.6.</span> <span class="nav-text">6、用@sun.misc.Contended来规避伪共享？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.16.5.7.</span> <span class="nav-text">7、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81SynchronousQueue%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-number">1.7.16.5.7.1.</span> <span class="nav-text">1、SynchronousQueue对比？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E4%B8%8D%E5%90%8CJDK%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BD%95%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="nav-number">1.7.16.5.7.2.</span> <span class="nav-text">2、不同JDK实现有何差别？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81Exchanger%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.16.5.8.</span> <span class="nav-text">8、Exchanger示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.17.</span> <span class="nav-text">16、ThreadPool线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.17.1.</span> <span class="nav-text">1、线程池简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.7.17.2.</span> <span class="nav-text">2、线程池的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.7.17.3.</span> <span class="nav-text">3、线程池的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">1.7.17.4.</span> <span class="nav-text">4、线程池参数说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5-%E9%87%8D%E7%82%B9"><span class="nav-number">1.7.17.5.</span> <span class="nav-text">5、拒绝策略(重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA"><span class="nav-number">1.7.17.6.</span> <span class="nav-text">6、线程池的种类与创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%AD%A5%E9%AA%A42%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.17.6.1.</span> <span class="nav-text">2、步骤2：自定义拒绝策略接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%AD%A5%E9%AA%A43%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.17.6.2.</span> <span class="nav-text">3、步骤3：自定义线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%AD%A5%E9%AA%A44%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.17.6.3.</span> <span class="nav-text">4、步骤4：测试编写好的自定义线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94ThreadPoolExecutor"><span class="nav-number">1.7.18.</span> <span class="nav-text">17、ThreadPool线程池——ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-21"><span class="nav-number">1.7.18.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.18.2.</span> <span class="nav-text">2、为什么需要线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ThreadPoolExecutor%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.18.3.</span> <span class="nav-text">3、ThreadPoolExecutor例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.18.4.</span> <span class="nav-text">4、ThreadPoolExecutor使用详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81Execute%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.18.4.1.</span> <span class="nav-text">1、Execute原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.18.4.2.</span> <span class="nav-text">2、参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.18.4.3.</span> <span class="nav-text">3、三种类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81newFixedThreadPool"><span class="nav-number">1.7.18.4.3.1.</span> <span class="nav-text">1、newFixedThreadPool</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81newSingleThreadPool"><span class="nav-number">1.7.18.4.3.2.</span> <span class="nav-text">2、newSingleThreadPool</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81newCachedThreadPool"><span class="nav-number">1.7.18.4.3.3.</span> <span class="nav-text">3、newCachedThreadPool</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.18.4.3.4.</span> <span class="nav-text">4、区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.18.4.4.</span> <span class="nav-text">4、关闭线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94shutdown"><span class="nav-number">1.7.18.4.4.1.</span> <span class="nav-text">1、关闭方式——shutdown</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94shutdownNow"><span class="nav-number">1.7.18.4.4.2.</span> <span class="nav-text">2、关闭方式——shutdownNow</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.18.5.</span> <span class="nav-text">5、ThreadPoolExecutor源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.18.5.1.</span> <span class="nav-text">1、几个关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81"><span class="nav-number">1.7.18.5.2.</span> <span class="nav-text">2、内部状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">1.7.18.5.3.</span> <span class="nav-text">3、任务的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81execute-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.3.1.</span> <span class="nav-text">1、execute()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81addWorker%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.3.2.</span> <span class="nav-text">2、addWorker方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81Worker%E7%B1%BB%E7%9A%84runworker%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.3.3.</span> <span class="nav-text">3、Worker类的runworker方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81getTask%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.3.4.</span> <span class="nav-text">4、getTask方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">1.7.18.5.4.</span> <span class="nav-text">4、任务的提交</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81submit%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.4.1.</span> <span class="nav-text">1、submit方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81FutureTask%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.18.5.4.2.</span> <span class="nav-text">2、FutureTask对象</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">1.7.18.5.5.</span> <span class="nav-text">5、任务的关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.18.5.6.</span> <span class="nav-text">6、其他方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.7.18.6.</span> <span class="nav-text">6、异常的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1"><span class="nav-number">1.7.18.7.</span> <span class="nav-text">7、更深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8Executors%E5%8E%BB%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="nav-number">1.7.18.7.1.</span> <span class="nav-text">1、为什么线程池不允许使用Executors去创建？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F1"><span class="nav-number">1.7.18.7.1.1.</span> <span class="nav-text">1、推荐方式1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F2"><span class="nav-number">1.7.18.7.1.2.</span> <span class="nav-text">2、推荐方式2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F3"><span class="nav-number">1.7.18.7.1.3.</span> <span class="nav-text">3、推荐方式3</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.7.18.7.2.</span> <span class="nav-text">2、配置线程池需要考虑的因素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.7.18.7.3.</span> <span class="nav-text">3、监控线程池的状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94ScheduledThreadPoolExecutor"><span class="nav-number">1.7.19.</span> <span class="nav-text">18、ThreadPool线程池——ScheduledThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-22"><span class="nav-number">1.7.19.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ScheduledThreadPoolExecutor%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.19.2.</span> <span class="nav-text">2、ScheduledThreadPoolExecutor简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ScheduledThreadPoolExecutor%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.19.3.</span> <span class="nav-text">3、ScheduledThreadPoolExecutor数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.7.19.4.</span> <span class="nav-text">4、ScheduledThreadPoolExecutor源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BBScheduledFutureTask"><span class="nav-number">1.7.19.4.1.</span> <span class="nav-text">1、内部类ScheduledFutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.19.4.1.1.</span> <span class="nav-text">1、属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95run"><span class="nav-number">1.7.19.4.1.2.</span> <span class="nav-text">2、核心方法run()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81cancel%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.19.4.1.3.</span> <span class="nav-text">3、cancel方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.19.4.2.</span> <span class="nav-text">2、核心属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.19.4.3.</span> <span class="nav-text">3、构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94Schedule"><span class="nav-number">1.7.19.4.4.</span> <span class="nav-text">4、核心方法——Schedule</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94shutdown"><span class="nav-number">1.7.19.4.5.</span> <span class="nav-text">6、核心方法——shutdown()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1"><span class="nav-number">1.7.19.5.</span> <span class="nav-text">5、再深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88ThreadPoolExecutor-%E7%9A%84%E8%B0%83%E6%95%B4%E7%AD%96%E7%95%A5%E5%8D%B4%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E-ScheduledThreadPoolExecutor%EF%BC%9F"><span class="nav-number">1.7.19.5.1.</span> <span class="nav-text">1、为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Executors-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E6%9E%84%E9%80%A0-ScheduledThreadPoolExecutor%EF%BC%9F"><span class="nav-number">1.7.19.5.2.</span> <span class="nav-text">2、Executors 提供了哪几种方法来构造 ScheduledThreadPoolExecutor？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81ScheduledThreadPoolExecutor%E5%BA%94%E7%94%A8"><span class="nav-number">1.7.19.6.</span> <span class="nav-text">6、ScheduledThreadPoolExecutor应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19%E3%80%81Tomcat-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.7.20.</span> <span class="nav-text">19、Tomcat 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.20.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%BA%90%E7%A0%81-tomcat-7-0-42"><span class="nav-number">1.7.20.2.</span> <span class="nav-text">2、源码 tomcat-7.0.42</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Connector-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.20.3.</span> <span class="nav-text">3、Connector 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Executor-%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.20.4.</span> <span class="nav-text">4、Executor 线程配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81Fork-Join%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">1.7.21.</span> <span class="nav-text">20、Fork&#x2F;Join分支合并框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-23"><span class="nav-number">1.7.21.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Fork-Join%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.21.2.</span> <span class="nav-text">2、Fork&#x2F;Join框架简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.21.2.1.</span> <span class="nav-text">1、三个模块及关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%EF%BC%88Divide-and-Conquer%EF%BC%89"><span class="nav-number">1.7.21.2.2.</span> <span class="nav-text">2、核心思想：分治算法（Divide-and-Conquer）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9Awork-stealing%EF%BC%88%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%EF%BC%89%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.21.2.3.</span> <span class="nav-text">3、核心思想：work-stealing（工作窃取）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.21.2.4.</span> <span class="nav-text">4、Fork&#x2F;Join 框架的执行流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Fork-Join%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.21.3.</span> <span class="nav-text">3、Fork&#x2F;Join类关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81ForkJoinPool%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.21.3.1.</span> <span class="nav-text">1、ForkJoinPool继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ForkJoinTask%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.21.3.2.</span> <span class="nav-text">2、ForkJoinTask继承关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Fork-Join%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.7.21.4.</span> <span class="nav-text">4、Fork&#x2F;Join框架源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81ForkJoinPool"><span class="nav-number">1.7.21.4.1.</span> <span class="nav-text">1、ForkJoinPool</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-1"><span class="nav-number">1.7.21.4.1.1.</span> <span class="nav-text">1、核心参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81ForkJoinPool-WoekQueue-%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.21.4.1.2.</span> <span class="nav-text">2、ForkJoinPool.WoekQueue 中的相关属性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ForkJoinTask"><span class="nav-number">1.7.21.4.2.</span> <span class="nav-text">2、ForkJoinTask</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.21.4.2.1.</span> <span class="nav-text">核心参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Fork-Join%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.7.21.5.</span> <span class="nav-text">5、Fork&#x2F;Join框架源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.21.5.1.</span> <span class="nav-text">1、构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E2%80%94%E2%80%94%E5%A4%96%E9%83%A8%E4%BB%BB%E5%8A%A1%EF%BC%88external-submissions-task%EF%BC%89%E6%8F%90%E4%BA%A4"><span class="nav-number">1.7.21.5.2.</span> <span class="nav-text">2、执行流程——外部任务（external&#x2F;submissions task）提交</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81externalPush-ForkJoinTask-lt-gt-task"><span class="nav-number">1.7.21.5.2.1.</span> <span class="nav-text">1、externalPush(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81externalSubmit-ForkJoinTask-lt-gt-task"><span class="nav-number">1.7.21.5.2.2.</span> <span class="nav-text">2、externalSubmit(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81signalWork-WorkQueue-ws-WorkQueue-q"><span class="nav-number">1.7.21.5.2.3.</span> <span class="nav-text">3、signalWork(WorkQueue[] ws, WorkQueue q)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81tryAddWorker-long-c"><span class="nav-number">1.7.21.5.2.4.</span> <span class="nav-text">4、tryAddWorker(long c)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81createWorker"><span class="nav-number">1.7.21.5.2.5.</span> <span class="nav-text">5、createWorker()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81registerWorker"><span class="nav-number">1.7.21.5.2.6.</span> <span class="nav-text">6、registerWorker()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.7.21.5.2.7.</span> <span class="nav-text">7、小结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A%E5%AD%90%E4%BB%BB%E5%8A%A1%EF%BC%88Worker-task%EF%BC%89%E6%8F%90%E4%BA%A4"><span class="nav-number">1.7.21.5.3.</span> <span class="nav-text">3、执行流程：子任务（Worker task）提交</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81ForkJoinTask-fork"><span class="nav-number">1.7.21.5.3.1.</span> <span class="nav-text">1、ForkJoinTask.fork()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81ForkJoiPool-WorkQueue-push"><span class="nav-number">1.7.21.5.3.2.</span> <span class="nav-text">2、ForkJoiPool.WorkQueue.push()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.7.21.5.3.3.</span> <span class="nav-text">3、小结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="nav-number">1.7.21.5.4.</span> <span class="nav-text">4、执行流程：任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81ForkJoinWorkerThread-run"><span class="nav-number">1.7.21.5.4.1.</span> <span class="nav-text">1、ForkJoinWorkerThread.run()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81ForkJoinPool-runWorker-WorkerQueue-w"><span class="nav-number">1.7.21.5.4.2.</span> <span class="nav-text">2、ForkJoinPool.runWorker(WorkerQueue w)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81ForkJoinPool-scan-WorkQueue-w-int-r"><span class="nav-number">1.7.21.5.4.3.</span> <span class="nav-text">3、ForkJoinPool.scan(WorkQueue w, int r)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81ForkJoinPool-awaitWork-WorkQueue-w-int-r"><span class="nav-number">1.7.21.5.4.4.</span> <span class="nav-text">4、ForkJoinPool.awaitWork(WorkQueue w, int r)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81WorkQueue-runTask"><span class="nav-number">1.7.21.5.4.5.</span> <span class="nav-text">5、WorkQueue.runTask()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex"><span class="nav-number">1.7.21.5.4.6.</span> <span class="nav-text">6、ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7%E3%80%81%E5%B0%8F%E7%BB%93-1"><span class="nav-number">1.7.21.5.4.7.</span> <span class="nav-text">7、小结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C%E2%80%94%E2%80%94ForkJoinTask-join-ForkJoinTask-invoke"><span class="nav-number">1.7.21.5.5.</span> <span class="nav-text">5、获取任务结果——ForkJoinTask.join()&#x2F;ForkJoinTask.invoke()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81ForkJoinTask-externalAwaitDone"><span class="nav-number">1.7.21.5.5.1.</span> <span class="nav-text">1、ForkJoinTask.externalAwaitDone()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81ForkJoinPool-awaitJoin"><span class="nav-number">1.7.21.5.5.2.</span> <span class="nav-text">2、ForkJoinPool.awaitJoin()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task"><span class="nav-number">1.7.21.5.5.3.</span> <span class="nav-text">3、WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task"><span class="nav-number">1.7.21.5.5.4.</span> <span class="nav-text">4、ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81ForkJoinPool-tryCompensate-WorkQueue-w"><span class="nav-number">1.7.21.5.5.5.</span> <span class="nav-text">5、ForkJoinPool.tryCompensate(WorkQueue w)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81Fork-Join%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.7.21.6.</span> <span class="nav-text">6、Fork&#x2F;Join的陷阱与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84fork"><span class="nav-number">1.7.21.6.1.</span> <span class="nav-text">1、避免不必要的fork()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%B3%A8%E6%84%8Ffork-%E3%80%81compute-%E3%80%81join-%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.7.21.6.2.</span> <span class="nav-text">2、注意fork()、compute()、join()的顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E7%B2%92%E5%BA%A6"><span class="nav-number">1.7.21.6.3.</span> <span class="nav-text">3、选择合适的子任务粒度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E9%81%BF%E5%85%8D%E9%87%8D%E9%87%8F%E7%BA%A7%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6"><span class="nav-number">1.7.21.6.4.</span> <span class="nav-text">4、避免重量级任务划分与结果合并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.21.7.</span> <span class="nav-text">7、再深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9BJDK%E6%BA%90%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86Fork-Join%E6%80%9D%E6%83%B3"><span class="nav-number">1.7.21.7.1.</span> <span class="nav-text">1、有哪些JDK源码中使用了Fork&#x2F;Join思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BAForkJoinPool"><span class="nav-number">1.7.21.7.2.</span> <span class="nav-text">2、使用Executors工具类创建ForkJoinPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8EFork-Join%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.7.21.7.3.</span> <span class="nav-text">3、关于Fork&#x2F;Join异常处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E4%B8%80%E4%BA%9BFork-Join%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.21.8.</span> <span class="nav-text">8、一些Fork&#x2F;Join例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%87%87%E7%94%A8Fork-Join%E6%9D%A5%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%971-2-3-%E2%80%A6%E2%80%A6-10000%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">1.7.21.8.1.</span> <span class="nav-text">1、采用Fork&#x2F;Join来异步计算1+2+3+……+10000的结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">1.7.21.8.2.</span> <span class="nav-text">2、实现斐波那契数列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21%E3%80%81CompletableFuture%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="nav-number">1.7.22.</span> <span class="nav-text">21、CompletableFuture异步回调</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81CompletableFuture-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.22.1.</span> <span class="nav-text">1、CompletableFuture 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Future-%E4%B8%8E-CompletableFuture"><span class="nav-number">1.7.22.2.</span> <span class="nav-text">2、Future 与 CompletableFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Future-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.22.3.</span> <span class="nav-text">3、Future 的主要缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81CompletableFuture%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.7.22.4.</span> <span class="nav-text">4、CompletableFuture的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81CompletableFuture-%E5%85%A5%E9%97%A8"><span class="nav-number">1.7.22.4.1.</span> <span class="nav-text">1、CompletableFuture 入门</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.7.22.4.2.</span> <span class="nav-text">2、没有返回值的同步任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.7.22.4.3.</span> <span class="nav-text">3、有返回值的异步任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BE%9D%E8%B5%96"><span class="nav-number">1.7.22.4.4.</span> <span class="nav-text">4、线程依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%B6%88%E8%B4%B9%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C"><span class="nav-number">1.7.22.4.5.</span> <span class="nav-text">5、消费处理结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.7.22.4.6.</span> <span class="nav-text">6、异常处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6"><span class="nav-number">1.7.22.4.7.</span> <span class="nav-text">7、结果合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BB%93%E6%9E%9CallOf-%E4%B8%8EanyOf"><span class="nav-number">1.7.22.4.8.</span> <span class="nav-text">8、合并多个任务的结果allOf 与anyOf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22%E3%80%81Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.23.</span> <span class="nav-text">22、Java 并发 - ThreadLocal详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-24"><span class="nav-number">1.7.23.1.</span> <span class="nav-text">1、BAT大厂的面试问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ThreadLocal%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.23.2.</span> <span class="nav-text">2、ThreadLocal简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ThreadLocal%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.23.3.</span> <span class="nav-text">3、ThreadLocal理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81ThreadLocal%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.23.4.</span> <span class="nav-text">4、ThreadLocal原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="nav-number">1.7.23.4.1.</span> <span class="nav-text">1、如何实现线程隔离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81ThreadLocalMap%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.7.23.4.2.</span> <span class="nav-text">2、ThreadLocalMap对象是什么</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81ThreadLocal%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.23.5.</span> <span class="nav-text">5、ThreadLocal造成内存泄漏的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%86%8D%E7%9C%8BThreadLocal%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.23.6.</span> <span class="nav-text">6、再看ThreadLocal应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%B4%E6%8A%A4%E4%BA%86%E4%B8%80%E4%B8%AA%E2%80%9C%E5%BA%8F%E5%88%97%E5%8F%B7%E2%80%9D"><span class="nav-number">1.7.23.6.1.</span> <span class="nav-text">1、每个线程维护了一个“序列号”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%86%85%E9%83%A8%E5%88%9B%E5%BB%BAThreadLocal"><span class="nav-number">1.7.23.6.2.</span> <span class="nav-text">3、在线程内部创建ThreadLocal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E4%B8%AD%E6%8E%A8%E8%8D%90%E7%9A%84ThreadLocal"><span class="nav-number">1.7.23.6.3.</span> <span class="nav-text">4、java开发手册中推荐的ThreadLocal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23%E3%80%81%E8%A1%A5%E5%85%85%EF%BC%9A%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B"><span class="nav-number">1.7.24.</span> <span class="nav-text">23、补充：阿姆达尔定律</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.7.24.1.</span> <span class="nav-text">1、阿姆达尔定律定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E4%BE%8B%E5%AD%90"><span class="nav-number">1.7.24.2.</span> <span class="nav-text">2、一个计算例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B%E5%9B%BE%E7%A4%BA"><span class="nav-number">1.7.24.3.</span> <span class="nav-text">3、阿姆达尔定律图示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.24.4.</span> <span class="nav-text">4、优化算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%B8%B2%E8%A1%8C%E5%88%86%E9%87%8F"><span class="nav-number">1.7.24.4.1.</span> <span class="nav-text">优化串行分量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-vs-%E5%8A%A0%E9%80%9F"><span class="nav-number">1.7.24.5.</span> <span class="nav-text">5、运行时间 vs. 加速</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%B5%8B%E9%87%8F%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BB%85%E6%98%AF%E8%AE%A1%E7%AE%97"><span class="nav-number">1.7.24.6.</span> <span class="nav-text">6、测量，不要仅是计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%B9%B6%E5%8F%91%E7%9A%84%E7%9B%B8%E5%85%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">8、并发的相关多线程设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2-Two-Phase-Termination"><span class="nav-number">1.8.1.</span> <span class="nav-text">1、两阶段终止(Two Phase Termination)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1、错误思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%AD%A3%E5%B8%B8%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%EF%BC%88interrupt%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">2、正常做法——两阶段终止模式（interrupt实现）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">1.8.1.2.1.</span> <span class="nav-text">1、实现流程图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.1.2.2.</span> <span class="nav-text">2、实现方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81"><span class="nav-number">1.8.1.2.3.</span> <span class="nav-text">3、代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%AD%A3%E5%B8%B8%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%EF%BC%88volatile%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">3、正常做法——两阶段终止模式（volatile实现）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%8A%B9%E8%B1%AB%E6%A8%A1%E5%BC%8F%EF%BC%88Balking%EF%BC%89%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.2.</span> <span class="nav-text">2、犹豫模式（Balking）——同步模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2、实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%8A%B9%E8%B1%ABBalking%E6%A8%A1%E5%BC%8F%E8%BF%98%E7%BB%8F%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">3、犹豫Balking模式还经常用来实现线程安全的单例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%EF%BC%88Guarded-Suspension%EF%BC%89%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.3.</span> <span class="nav-text">3、保护性暂停（Guarded Suspension）——同步模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">2、实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">3、应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%B8%A6%E8%B6%85%E6%97%B6%E7%89%88-GuardedObjec"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">4、带超时版 GuardedObjec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%89%A9%E5%B1%95%EF%BC%9A%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88-GuardedObject"><span class="nav-number">1.8.3.5.</span> <span class="nav-text">5、扩展：多任务版 GuardedObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.8.3.6.</span> <span class="nav-text">6、使用保护性暂停的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Producer-Consumer%EF%BC%89%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.4.</span> <span class="nav-text">4、生产者消费者模式（Producer Consumer）——异步模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-2"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">2、实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8-1"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">3、应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88Sequence-Control%EF%BC%89%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.5.</span> <span class="nav-text">5、顺序控制（Sequence Control）——同步模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9B%BA%E5%AE%9A%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">1、固定运行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81wait-notify-%E7%89%88"><span class="nav-number">1.8.5.1.1.</span> <span class="nav-text">1、wait notify 版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Park-Unpark-%E7%89%88"><span class="nav-number">1.8.5.1.2.</span> <span class="nav-text">2、Park Unpark 版</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">2、交替输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81wait-notify-%E7%89%88-1"><span class="nav-number">1.8.5.2.1.</span> <span class="nav-text">1、wait notify 版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81Lock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%89%88"><span class="nav-number">1.8.5.2.2.</span> <span class="nav-text">2、Lock 条件变量版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81Park-Unpark-%E7%89%88"><span class="nav-number">1.8.5.2.3.</span> <span class="nav-text">3、Park Unpark 版</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-pattern%EF%BC%89"><span class="nav-number">1.8.6.</span> <span class="nav-text">6、享元模式（Flyweight pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BD%93%E7%8E%B0"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">2、体现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.8.6.2.1.</span> <span class="nav-text">1、包装类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81String-%E4%B8%B2%E6%B1%A0"><span class="nav-number">1.8.6.2.2.</span> <span class="nav-text">2、String 串池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81BigDecimal-BigInteger"><span class="nav-number">1.8.6.2.3.</span> <span class="nav-text">3、BigDecimal BigInteger</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81DIY"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">3、DIY</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F-Worker-Thread-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.7.</span> <span class="nav-text">7、工作线程模式(Worker Thread)——异步模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-3"><span class="nav-number">1.8.7.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%A5%A5%E9%A5%BF"><span class="nav-number">1.8.7.2.</span> <span class="nav-text">2、饥饿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%88%E9%80%82"><span class="nav-number">1.8.7.3.</span> <span class="nav-text">3、创建多少线程池合适</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81CPU-%E5%AF%86%E9%9B%86%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="nav-number">1.8.7.3.1.</span> <span class="nav-text">1、CPU 密集型运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="nav-number">1.8.7.3.2.</span> <span class="nav-text">2、I&#x2F;O 密集型运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.8.7.4.</span> <span class="nav-text">4、自定义线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88Immutability%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.8.</span> <span class="nav-text">5、不可变（Immutability）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Copy-on-Write%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.9.</span> <span class="nav-text">6、Copy-on-Write模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">1.8.10.</span> <span class="nav-text">7、线程本地存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81Thread-Per-Message"><span class="nav-number">1.8.11.</span> <span class="nav-text">8、Thread-Per-Message</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">1.9.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
