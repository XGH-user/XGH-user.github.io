<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
<meta property="og:type" content="website">
<meta property="og:title" content="_little-star_">
<meta property="og:url" content="http://xgh-user.github.io/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xgh-user.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>_little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-11 22:24:19 / 修改时间：22:24:22" itemprop="dateCreated datePublished" datetime="2021-05-11T22:24:19+08:00">2021-05-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="第一章-操作系统引论及概述"><a href="#第一章-操作系统引论及概述" class="headerlink" title="第一章 操作系统引论及概述"></a><strong>第一章 操作系统引论及概述</strong></h2><hr>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-1、概念、功能与目标"><a href="#1-1-1、概念、功能与目标" class="headerlink" title="1.1.1、概念、功能与目标"></a>1.1.1、概念、功能与目标</h3><ol>
<li><p>定义：</p>
<p>操作系统（Operating System，OS）是指<strong>控制和管理</strong>整个计算机系统的<strong>硬件</strong>和<strong>软件</strong>资源，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的<strong>系统软件</strong>。</p>
<ol>
<li>操作系统是系统资源的管理者，负责管理协调硬件、软件等计算机资源的工作</li>
<li>向上层的应用程序、用户提供方便易用的服务</li>
<li>操作系统是最接近硬件的一层软件，是系统软件不是硬件</li>
</ol>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.png" alt="image-20210406102804945"></p>
</li>
<li><p>功能与目标</p>
<ol>
<li><p><strong>操作系统是系统资源的管理者</strong> </p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.png" alt="image-20210406102859419"></p>
</li>
<li><p><strong>向上层提供方便易用的服务</strong></p>
<ul>
<li><p>命令接口</p>
<ul>
<li><p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口</p>
<p>特点：<strong>用户说一句，系统跟着做一句</strong></p>
</li>
<li><p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口</p>
<p>使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。</p>
<p>特点：<strong>用户说一堆，系统跟着做一堆</strong></p>
</li>
</ul>
</li>
<li><p>程序接口</p>
<p>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。</p>
<p>如C盘Windows\System32中有很多的*.dll文件。程序员在程序中调用（该调用过程即为<strong>系统调用</strong>）即可实现创建窗口等功能。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.png" alt="image-20210406104140771"></p>
</li>
<li><p>GUI：图形用户界面（Graphical User Interface）</p>
<p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>例子：在Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.png" alt="image-20210406104309877"></p>
</li>
<li><p><strong>操作系统是最接近硬件的一层软件</strong></p>
<p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.png" alt="image-20210406104343359"></p>
</li>
</ol>
</li>
<li><p>脑图</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/08.png" alt="image-20210406104426461"></p>
</li>
</ol>
<h3 id="1-1-2、操作系统的四个特征"><a href="#1-1-2、操作系统的四个特征" class="headerlink" title="1.1.2、操作系统的四个特征"></a>1.1.2、操作系统的四个特征</h3><ol>
<li><p>并发</p>
<p>并发与并行的区别：</p>
<ul>
<li>并发：两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。</li>
<li>并行：指两个或多个事件<strong>在同一时刻同时发生</strong>。</li>
</ul>
<p>例子：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/09.png" alt="image-20210406111514894"></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。</p>
<p>操作系统就是伴随着“多道程序技术”而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong>。</p>
<p>注意：</p>
<ul>
<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</li>
<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
</li>
<li><p>共享</p>
<p><strong>共享即资源共享</strong>，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li><p>互斥共享方式：</p>
<p>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li><p>同时共享方式:</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：</p>
<ul>
<li>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li>
<li>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li>
</ul>
<p><strong>并发与共享是操作系统最基本的两个特征，两者互为存在条件</strong></p>
<ul>
<li>并发性指计算机系统中同时存在着多个运行着的程序。</li>
<li>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.png" alt="image-20210406112122162"></p>
</li>
<li><p>虚拟</p>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>虚拟技术</p>
<ul>
<li>空分复用技术（如虚拟存储器技术）：实际只有4GB的内存，在用户看来似乎远远大于4GB</li>
<li>时分复用技术（如虚拟处理器）：微观上处理机在各个微小的时间段内交替着为各个进程服务</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong></p>
</li>
<li><p>异步</p>
<p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性。</strong></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.png" alt="image-20210406112516655"></p>
<h3 id="1-1-3、操作系统的发展与分类"><a href="#1-1-3、操作系统的发展与分类" class="headerlink" title="1.1.3、操作系统的发展与分类"></a>1.1.3、操作系统的发展与分类</h3><p>操作系统的发展：</p>
<ol>
<li><p>手工操作阶段</p>
<p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p>
</li>
<li><p>批处理阶段</p>
<ol>
<li><p>单道批处理系统</p>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由**监督程序(操作系统的雏形)**负责控制作业的输入、输出</p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>
<p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
</li>
<li><p>多道批处理系统</p>
<p><strong>操作系统正式诞生</strong>，用于支持多道程序并发运行</p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</p>
<p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）</p>
</li>
</ol>
</li>
<li><p>分时操作系统</p>
<p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>
<p>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/ 作业服务一个时间片，不区分任务的紧急性</p>
</li>
<li><p>实时操作系统</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性</strong>和<strong>可靠性</strong>。</p>
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理。如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统：能接受偶尔违反时间规定。如：12306火车订票系统</li>
</ul>
<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>
</li>
</ol>
<p>操作系统的分类</p>
<ol>
<li><p>网络操作系统</p>
<p>伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
</li>
<li><p>分布式操作系统</p>
<p>主要特点是<strong>分布性</strong>和<strong>并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
</li>
<li><p>个人计算机操作系统</p>
<p>如 Windows XP、MacOS，方便个人使用</p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.png" alt="image-20210406115156103"></p>
<h3 id="1-1-4、操作系统的运行机制与体系结构"><a href="#1-1-4、操作系统的运行机制与体系结构" class="headerlink" title="1.1.4、操作系统的运行机制与体系结构"></a>1.1.4、操作系统的运行机制与体系结构</h3><ol>
<li><p>运行机制</p>
<ul>
<li><p>两种指令</p>
<ul>
<li>特权指令：不允许用户程序使用。如内存清零指令</li>
<li>非特权指令：如普通的运算指令</li>
</ul>
</li>
<li><p>两种处理器状态</p>
<ul>
<li>用户态（目态）：此时CPU只能执行非特权指令</li>
<li>核心态（管态）：特权指令、非特权指令都能执行</li>
</ul>
<p>两种处理器状态用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态，如0表示用户态，1表示核心态。</p>
</li>
<li><p>两种程序</p>
<ul>
<li><p>内核程序</p>
<p>操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，<strong>运行在核心态</strong>。</p>
</li>
<li><p>应用程序</p>
<p>为了保证系统的安全运行，普通应用程序只能执行非特权指令，<strong>运行在用户态</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/14.png" alt="image-20210406125651838"></p>
</li>
<li><p>操作系统内核</p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分</p>
<p>实现操作系统内核功能的那些程序就是<strong>内核程序</strong></p>
<ul>
<li>时钟管理：实现计时管理</li>
<li>中断处理：负责实现中断机制</li>
<li>原语<ul>
<li>是一种特殊的程序</li>
<li>处于操作系统最底层，是最接近硬件的部分</li>
<li>这种程序的运行具有<strong>原子性</strong>，其运行只能一气呵成，<strong>不可中断</strong></li>
<li>运行时间短，调用频繁</li>
</ul>
</li>
<li>对系统资源进行管理的功能（有的操作系统不把这部分功能归为“内核功能”。也就是说，不同的操作系统，对内核功能的划分可能并不一样）<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
<li><p>体系结构</p>
<ul>
<li><p>大内核</p>
<p>将操作系统的主要功能都作为系统内核运行在核心态</p>
<p>优点：高性能</p>
<p>缺点：内核代码大，结构混乱，难以维护</p>
<p>典型的大内核/宏内核/单内核操作系统：Linux、UNIX</p>
</li>
<li><p>微内核</p>
<p>只把最基本的功能保留在内核</p>
<p>优点：内核功能少，结构清晰，方便维护</p>
<p>缺点：需要频繁地在核心态与用户态之间切换，性能低</p>
<p>典型的微内核操作系统：Windows NT</p>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/30.png" alt="image-20210408192745129"></p>
<p>类比：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/16.png" alt="image-20210406131034245"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/15.png" alt="image-20210406130802115"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13.png" alt="image-20210406115337381"></p>
<h3 id="1-1-5、中断与异常"><a href="#1-1-5、中断与异常" class="headerlink" title="1.1.5、中断与异常"></a>1.1.5、中断与异常</h3><ol>
<li><p>中断机制的诞生</p>
<p>在早期的计算机没有中断机制，各个程序只能串行执行，系统资源的利用率低。</p>
<p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p>
<p>本质：<strong>发生中断就意味着需要操作系统介入，开展管理工作</strong></p>
</li>
<li><p>中断的概念与作用</p>
<ul>
<li>当<strong>中断发生</strong>时，CPU立即进入<strong>核心态</strong></li>
<li>当中断发生后，当前运行的进程暂停运行，并有操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p>发生中断就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断</strong>可以使CPU从<strong>用户态切换为核心态</strong>，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p>
<p><strong>中断是实现CPU从用户态切换到核心态的唯一途径</strong>。通过<strong>执行一个特权指令</strong>，将程序状态字（PSW）对标志位设置为“用户态”。</p>
</li>
<li><p>中断（广义的中断）的分类</p>
<ul>
<li>内中断（也称“异常、例外、陷入”）：与当前执行的指令有关，中断信号来源于CPU内部<ul>
<li>自愿中断：指令中断（如：系统调用时使用的访管指令（又叫陷入指令、trap指令））</li>
<li>强迫中断<ul>
<li>硬件故障（如：缺页）</li>
<li>软件故障（如：整数除0）</li>
</ul>
</li>
</ul>
</li>
<li>外中断（也称“中断（狭义的中断）”）：与当前执行的指令无关，中断信号来源于CPU外部<ul>
<li>外设请求（如：I/O操作完成发出的中断信号）</li>
<li>人工干预（如：用户强行终止一个进程）</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/17.png" alt="image-20210406134755249"></p>
<p>另一种分类方式：</p>
<ul>
<li>内中断（也称“异常、例外、陷入”）：与当前执行的指令有关，中断信号来源于CPU内部<ul>
<li>陷阱、陷入（trap）：有意而为之的异常，如系统调用</li>
<li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修<br>复故障后会把CPU使用权还给应用程序，让它继续执行下去。如：缺页故障。</li>
<li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令。</li>
</ul>
</li>
<li>外中断（也称“中断（狭义的中断）”）：与当前执行的指令无关，中断信号来源于CPU外部<ul>
<li>外设请求（如：I/O操作完成发出的中断信号）</li>
<li>人工干预（如：用户强行终止一个进程）</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/18.png" alt="image-20210406135217118"></p>
</li>
<li><p>外中断的处理过程</p>
<ol>
<li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)</li>
<li>根据中断信号类型转入相应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
</li>
<li><p>中断机制的基本原理</p>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p>显然，中断处理程序一定是内核程序，需要运行在“内核态”</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20.png" alt="image-20210406135456448"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/19.png" alt="image-20210406135343449"></p>
<h3 id="1-1-6、系统调用"><a href="#1-1-6、系统调用" class="headerlink" title="1.1.6、系统调用"></a>1.1.6、系统调用</h3><ol>
<li><p>什么是系统调用</p>
<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，<strong>程序接口</strong>由一组<strong>系统调用</strong>组成。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.png" alt="image-20210408185305701"></p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务。</strong></p>
</li>
<li><p>系统调用与库函数调用的区别</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/25.png" alt="image-20210408190637741"></p>
</li>
<li><p>为什么系统调用是必须的</p>
<p>生活场景：去学校打印店打印论文，你按下了WPS 的“打印”选项，打印机开始工作。<br>你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到WPS 和Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。<strong>内核会对各个请求进行协调处理</strong>。</p>
</li>
<li><p>什么功能要用系统调用实现</p>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/24.png" alt="image-20210408190445658"></p>
</li>
<li><p>系统调用的过程</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26.png" alt="image-20210408191025687"></p>
<ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行相应的内请求核程序处理系统调用（核心态）</li>
<li>返回应用程序</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/27.png" alt="image-20210408191123343"></p>
<h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/29.png" alt="image-20210408192546560"></p>
<h2 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 <strong>进程与线程</strong></h2><hr>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/28.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200704185128296.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200704185823567.jpg" alt="在这里插入图片描述"></p>
<h3 id="2-1-1、进程的概念、组成与特征"><a href="#2-1-1、进程的概念、组成与特征" class="headerlink" title="2.1.1、进程的概念、组成与特征"></a>2.1.1、进程的概念、组成与特征</h3><h4 id="1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？"><a href="#1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？" class="headerlink" title="1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？"></a>1、定义——在计算机发展史上，”进程”是为了解决什么问题而被引入的？</h4><h5 id="1、进程的发展"><a href="#1、进程的发展" class="headerlink" title="1、进程的发展"></a>1、进程的发展</h5><p>在早期的计算机中，只支持单道程序。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/31.png" alt="image-20210408193824213"></p>
<p>在引入多道程序技术之后（操作系统）</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/32.png" alt="image-20210408193938895"></p>
<p>进程与程序的区别：</p>
<ul>
<li>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</li>
<li>进程（Process）：是<strong>动态的</strong>，是程序的一次执行过程</li>
</ul>
<p>同一个程序多次执行会对应多个进程。</p>
<h5 id="2、进程的定义"><a href="#2、进程的定义" class="headerlink" title="2、进程的定义"></a>2、进程的定义</h5><p>**程序段、数据段、PCB三部分组成了进程实体(进程映像)**。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p>注意：<strong>PCB是进程存在的唯一标志！</strong></p>
<p>从不同的角度，进程有不同的定义，比较传统典型的定义有：（强调“动态性”）进程的<code>进</code>：<code>正在进行</code></p>
<ol>
<li>进程是程序的<strong>一次执行过程</strong>。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li>
<li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<p>引入进程实体的概念后，可把进程定义为：</p>
<p><strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p>
<p>注：严格来说，进程实体和进程并不一样，<strong>进程实体是静态的</strong>，<strong>进程则是动态的</strong>。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“<strong>进程由程序段、数据段、PCB三部分组成</strong>”</p>
<h4 id="2、组成——每个进程由哪些部分组成"><a href="#2、组成——每个进程由哪些部分组成" class="headerlink" title="2、组成——每个进程由哪些部分组成"></a>2、组成——每个进程由哪些部分组成</h4><ol>
<li><p>PCB（Process Control Block）:<strong>操作系统使用的</strong>。进程的管理者（操作系统）所需的数据都在PCB当中</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/36.png" alt="image-20210408195302165"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/34.png" alt="image-20210408195101713"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/35.png" alt="image-20210408195206139"></p>
</li>
<li><p>程序段：<strong>进程自己使用的</strong>。程序本身的运行所需的数据</p>
<p>存放要执行的代码</p>
</li>
<li><p>数据段：<strong>进程自己使用的</strong>。程序本身的运行所需的数据</p>
<p>存放程序运行过程中处理的各种数据</p>
</li>
</ol>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/37.png" alt="image-20210408195916760"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/33.png" alt="image-20210408194909291"></p>
<h4 id="3、组织方式——系统中的各个进程之间是如何被组织起来的"><a href="#3、组织方式——系统中的各个进程之间是如何被组织起来的" class="headerlink" title="3、组织方式——系统中的各个进程之间是如何被组织起来的"></a>3、组织方式——系统中的各个进程之间是如何被组织起来的</h4><p>在一个系统中，通常有数十数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>
<p>注意：进程的组成讨论的是一个<strong>进程内部</strong>的由哪些部分构成的问题，而<strong>进程的组织</strong>讨论的是<strong>多个进程之间</strong>的组织方式的问题。</p>
<ul>
<li><p>链接方式</p>
<p>按照进程状态将PCB分为多个队列</p>
<p>操作系统持有指向各个队列的指针</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/38.png" alt="image-20210408200538083"></p>
</li>
<li><p>索引方式</p>
<p>根据进程状态的不同，建立几张索引表</p>
<p>操作系统持有指向各个索引表的指针</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/39.png" alt="image-20210408200615846"></p>
</li>
</ul>
<h4 id="4、特征——相比于程序，进程有什么特征"><a href="#4、特征——相比于程序，进程有什么特征" class="headerlink" title="4、特征——相比于程序，进程有什么特征"></a>4、特征——相比于程序，进程有什么特征</h4><ul>
<li><strong>动态性</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性</strong>：内存中有多个进程实体，各进程可以并发执行</li>
<li><strong>独立性</strong>：进程是能独立运行、独立获得资源、独立接收调度的基本单位</li>
<li><strong>异步性</strong>：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供”<strong>进程同步机制</strong>“来解决异步问题</li>
<li><strong>结构性</strong>：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210408200659340.png" alt="image-20210408200659340"></p>
<h4 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40.png" alt="image-20210408200752313"></p>
<h3 id="2-1-2、进程的状态与转换"><a href="#2-1-2、进程的状态与转换" class="headerlink" title="2.1.2、进程的状态与转换"></a>2.1.2、进程的状态与转换</h3><h4 id="1、进程的状态"><a href="#1、进程的状态" class="headerlink" title="1、进程的状态"></a>1、进程的状态</h4><p>进程是程序的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各种进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<p>进程有五种状态，其中有三种基本状态</p>
<p>三种基本状态：</p>
<ul>
<li><p>运行态(Running)：占有CPU，并在CPU上运行</p>
<p>注意：在单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态）</p>
</li>
<li><p>就绪态(Ready)：已经具备运行条件，但由于没有空闲的CPU，而暂时不能运行</p>
<p>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠CPU</p>
</li>
<li><p>阻塞态(Waiting/Blocked,又称：等待态)：因等待某一事件而暂时不能运行</p>
<p>如：等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p>
</li>
</ul>
<p>剩余的两种状态：</p>
<ul>
<li><p>创建状态(New,又称：新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB</p>
<p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p>
</li>
<li><p>终止状态(Terminated,又称：结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p>
<p>进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误，除数为0等等），需要撤销进程。</p>
<p>操作系统需要完成撤销进程的相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作。</p>
</li>
</ul>
<h4 id="2、进程状态间的转换"><a href="#2、进程状态间的转换" class="headerlink" title="2、进程状态间的转换"></a>2、进程状态间的转换</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/41.png" alt="image-20210408210631200"></p>
<ul>
<li>就绪态 =&gt; 运行态</li>
<li>运行态 =&gt; 就绪态</li>
<li>运行态 =&gt; 阻塞态</li>
<li>阻塞态 =&gt; 就绪态</li>
</ul>
<p>注意：不能有阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
<h4 id="脑图-1"><a href="#脑图-1" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/42.png" alt="image-20210408210724237"></p>
<h3 id="2-1-3、进程控制"><a href="#2-1-3、进程控制" class="headerlink" title="2.1.3、进程控制"></a>2.1.3、进程控制</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><h5 id="1、什么是进程控制"><a href="#1、什么是进程控制" class="headerlink" title="1、什么是进程控制"></a>1、什么是进程控制</h5><p>进程控制的主要功能是<strong>对系统中的所有进程实施有效的管理</strong>，它具有<strong>创建新进程</strong>、<strong>撤销已有进程</strong>、<strong>实现进程状态转换</strong>等功能。</p>
<p>简化理解：反正进程控制就是要<strong>实现进程状态转换</strong>。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/21.png" alt="image-20210408223038360"></p>
<h5 id="2、如何实现进程控制——原语"><a href="#2、如何实现进程控制——原语" class="headerlink" title="2、如何实现进程控制——原语"></a>2、如何实现进程控制——<code>原语</code></h5><p><strong>原语</strong>是一种特殊的程序，它的<strong>执行具有原子性</strong>。也就是说，这段程序的<strong>运行必须一气呵成，不可中断</strong>。</p>
<p>如果不能“一气呵成”，就有可能导致<strong>操作系统中的某些关键数据结构信息不统一</strong>的情况，这会影响操作系统进行别的管理工作。</p>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。可以用“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”这两个<strong>特权指令</strong>实现<strong>原子性</strong>。</p>
<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</p>
<p>CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行<strong>开中断指令</strong>之后才会恢复检查。</p>
<p>这样，<strong>关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”。</strong></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/22.png" alt="image-20210408223258148"></p>
<h4 id="2、进程控制相关的原语"><a href="#2、进程控制相关的原语" class="headerlink" title="2、进程控制相关的原语"></a>2、进程控制相关的原语</h4><p>学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标准、简化运行环境保存到PCB、从PCB恢复运行环境）<ol>
<li>所有的进程控制原语一定都会修改进程状态标准</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复其运行环境</li>
</ol>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<ul>
<li><p>进程的创建</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/23.png" alt="image-20210408223606502"></p>
</li>
<li><p>进程的终止</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/43.png" alt="image-20210408223742379"></p>
</li>
<li><p>进程的阻塞与唤醒</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/45.png" alt="image-20210408224532652"></p>
</li>
<li><p>进程的切换</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/46.png" alt="image-20210408224604511"></p>
</li>
</ul>
<h4 id="脑图-2"><a href="#脑图-2" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/44.png" alt="image-20210408223947869"></p>
<h3 id="2-1-4、进程通信"><a href="#2-1-4、进程通信" class="headerlink" title="2.1.4、进程通信"></a>2.1.4、进程通信</h3><p>什么是进程通信？</p>
<p>顾名思义，进程通信就是指进程之间的<strong>信息交换</strong>。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立</strong>。为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。如下：</p>
<h4 id="1、共享存储"><a href="#1、共享存储" class="headerlink" title="1、共享存储"></a>1、共享存储</h4><p>两个进程对共享空间的访问必须是<strong>互斥的</strong>（互斥访问通过操作系统提供的工具实现）。<br>操作系统只负责提供<strong>共享空间</strong>和<strong>同步互斥工具（如P、V操作）</strong></p>
<ul>
<li><p>基于数据结构的共享：</p>
<p>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级</strong>通信方式</p>
</li>
<li><p>基于存储区的共享：</p>
<p>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级</strong>通信方式。</p>
</li>
</ul>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/47.png" alt="image-20210409014400967"></p>
<h4 id="2、消息传递"><a href="#2、消息传递" class="headerlink" title="2、消息传递"></a>2、消息传递</h4><p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p>格式化的信息包含消息头和消息体。在消息头中包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<ul>
<li><p>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/49.png" alt="image-20210409015008639"></p>
</li>
<li><p>间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/50.png" alt="image-20210409015029868"></p>
</li>
</ul>
<h4 id="3、管道通信"><a href="#3、管道通信" class="headerlink" title="3、管道通信"></a>3、管道通信</h4><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/48.png" alt="image-20210409014459852"></p>
<ol>
<li>管道只能采用<strong>半双工通</strong>信，某一时间段内只能实现单向的传输。如果<strong>要实现双向同时通信</strong>，则需要<strong>设置两个管道</strong>。</li>
<li>各进程要<strong>互斥地</strong>访问管道。</li>
<li>数据以<strong>字符流</strong>的形式写入管道，当<strong>管道写满</strong>时，<strong>写进程</strong>的write()系统调用将<strong>被阻塞</strong>，等待读进程将数据取走。当读进程将数据<strong>全部取走</strong>后，<strong>管道变空</strong>，此时<strong>读进程</strong>的read()系统调用将<strong>被阻塞</strong>。</li>
<li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li>
<li><strong>数据一旦被读出，就从管道中被抛弃</strong>，这就意味着<strong>读进程最多只能有一个</strong>，否则可能会有读错数据的情况。</li>
</ol>
<h4 id="脑图-3"><a href="#脑图-3" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/51.png" alt="image-20210409015059025"></p>
<h3 id="2-1-5、线程的概念、特点与多线程模型"><a href="#2-1-5、线程的概念、特点与多线程模型" class="headerlink" title="2.1.5、线程的概念、特点与多线程模型"></a>2.1.5、线程的概念、特点与多线程模型</h3><h4 id="1、什么是线程？为什么要引入线程？"><a href="#1、什么是线程？为什么要引入线程？" class="headerlink" title="1、什么是线程？为什么要引入线程？"></a>1、什么是线程？为什么要引入线程？</h4><p>进程是程序的一次执行。同一进程里不同的功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行（qq当中的视频、文字聊天、传送文件）。而且，当切换进程时，需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/52.png" alt="image-20210409021721725"></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/53.png" alt="image-20210409021850582"></p>
<h4 id="2、与进程相比，线程有什么特点？"><a href="#2、与进程相比，线程有什么特点？" class="headerlink" title="2、与进程相比，线程有什么特点？"></a>2、与进程相比，线程有什么特点？</h4><ul>
<li><p>可以把线程理解为“轻量级进程”。</p>
</li>
<li><p>引入线程前，<strong>进程既是资源分配的基本单位，也是调度的基本单位</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程是资源分配的基本单位</strong>，<strong>线程是调度的基本单位</strong>。<strong>线程也有运行态、就绪态、阻塞态</strong></p>
</li>
<li><p>在<strong>多CPU</strong>环境下，各个线程也可以分派到<strong>不同的CPU上并行</strong>地执行。</p>
</li>
<li><p><strong>线程是一个基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元</strong>。</p>
</li>
<li><p>引入线程后，<strong>进程是资源分配的基本单位</strong>。而<strong>线程几乎不拥有资源</strong>，只拥有极少量的资源（<strong>线程控制块TCB（Thread Control Block）、寄存器信息、堆栈等</strong>）</p>
</li>
<li><p>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p>
</li>
<li><p>进程间并发，开销很大。线程间并发，开销更小。进程间通信必须请求操作系统服务（CPU要切换到核心态），开销大。同进程下的线程间通信，无需操作系统干预，开销更小。<strong>引入线程机制后，并发带来的系统开销降低，系统并发性提升。</strong></p>
<p>注意：从属于不同进程的线程间切换，也必须请求操作系统服务！也会导致进程的切换！开销也大</p>
<p>当切换进程时，需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）</p>
<p>同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力。</p>
</li>
<li><p>从属<strong>同一进程的各个线程共享进程拥有的资源</strong>。</p>
</li>
<li><p>各个进程的内存地址空间相互独立，只能通过请求操作系统内核的帮助来完成进程间通信。</p>
</li>
<li><p>同一进程下的各个线程间共享内存地址空间，可以直接通过读/写内存空间进行通信。</p>
</li>
</ul>
<p>总结：</p>
<p><strong>线程最小执行单位，进程最小分配资源单位</strong>。</p>
<p>进程是可拥有资源的基本单位，频繁创建撤销进程会造成很大时空开销；而线程只是独立调度和分派的基本单位，共享进程的系统资源，线程被频繁创建和撤销也不会造成太大的时空开销。那仍然是执行的一个进程，只不过同时执行一个进程里面的多个线程。有些程序语言里还有更更轻量的<strong>协程</strong>，都是为了降低并发的代价。</p>
<h4 id="3、引入线程机制后，有什么变化？"><a href="#3、引入线程机制后，有什么变化？" class="headerlink" title="3、引入线程机制后，有什么变化？"></a>3、引入线程机制后，有什么变化？</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/54.png" alt="image-20210409023101820"></p>
<p>类比：</p>
<p>切换进程运行环境：有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上<br>同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走。</p>
<h4 id="4、线程有哪些重要的属性？"><a href="#4、线程有哪些重要的属性？" class="headerlink" title="4、线程有哪些重要的属性？"></a>4、线程有哪些重要的属性？</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/55.png" alt="image-20210409023226229"></p>
<h4 id="5、线程的实现方式"><a href="#5、线程的实现方式" class="headerlink" title="5、线程的实现方式"></a>5、线程的实现方式</h4><ul>
<li><p>用户级线程（User-Level Thread, ULT）</p>
<p>用户级线程由应用程序通过线程库实现。</p>
<p>所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</p>
<p>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</p>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（<strong>用户级线程对用户不透明，对操作系统透明</strong>）</p>
<p>可以这样理解，<strong>“用户级线程”就是“从用户视角看能看到的线程”</strong></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png" alt="image-20210409024313592"></p>
</li>
<li><p>内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）</p>
<p>内核级<strong>线程的管理工作</strong>由<strong>操作系统内核完成</strong>。</p>
<p>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</p>
<p>可以这样理解，<strong>“内核级线程”就是“从操作系统内核视角看能看到的线程”</strong></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png" alt="image-20210409024248522"></p>
</li>
</ul>
<p>线程的实现方式：</p>
<p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：<strong>将n个用户级线程映射到m个内核级线程上（n &gt;= m）</strong></p>
<p><strong>重点重点重点：</strong> <strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<p>例如：下边这个模型中，该进程由两个内核级线程，三个用户级线程，在<strong>用户</strong>看来，这个进程中有<strong>三个线程</strong>。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到<strong>两个核</strong>，最多只能有两个用户线程并行执行。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png" alt="image-20210409024124625"></p>
<h4 id="6、多线程模型"><a href="#6、多线程模型" class="headerlink" title="6、多线程模型"></a>6、多线程模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p>
<ul>
<li><p>多对一模型：</p>
<p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/59.png" alt="image-20210409024313592"></p>
</li>
<li><p>一对一模型：</p>
<p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/58.png" alt="image-20210409024248522"></p>
</li>
<li><p>多对多模型</p>
<p>n 用户及线程映射到m 个内核级线程（n &gt;= m）。每个用户进程对应m 个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/57.png" alt="image-20210409024124625"></p>
</li>
</ul>
<h4 id="脑图-4"><a href="#脑图-4" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/56.png" alt="image-20210409024100247"></p>
<h3 id="2-2-1、处理机调度的概念、层次"><a href="#2-2-1、处理机调度的概念、层次" class="headerlink" title="2.2.1、处理机调度的概念、层次"></a>2.2.1、处理机调度的概念、层次</h3><h4 id="1、基本概念-1"><a href="#1、基本概念-1" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则来决定</strong>（如：VIP优先、短作业优先调等等）处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。<br>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度</strong>，就是从就绪队列中<strong>按照一定的算法选择一个进程并将处理机分配给它</strong>运行，以实现进程的并发执行。</p>
<h4 id="2、三个层次"><a href="#2、三个层次" class="headerlink" title="2、三个层次"></a>2、三个层次</h4><h5 id="1、高级调度（作业调度）"><a href="#1、高级调度（作业调度）" class="headerlink" title="1、高级调度（作业调度）"></a>1、高级调度（作业调度）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210138470.png" alt="image-20210504210138470"></p>
<h5 id="2、中级调度（内存调度）"><a href="#2、中级调度（内存调度）" class="headerlink" title="2、中级调度（内存调度）"></a>2、中级调度（内存调度）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210203139.png" alt="image-20210504210203139"></p>
<h5 id="3、低级调度（进程调度）"><a href="#3、低级调度（进程调度）" class="headerlink" title="3、低级调度（进程调度）"></a>3、低级调度（进程调度）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210230216.png" alt="image-20210504210230216"></p>
<h4 id="3、三层调度的联系、对比"><a href="#3、三层调度的联系、对比" class="headerlink" title="3、三层调度的联系、对比"></a>3、三层调度的联系、对比</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210333146.png" alt="image-20210504210333146"></p>
<h4 id="4、补充知识——进程的”挂起态”与七状态模型"><a href="#4、补充知识——进程的”挂起态”与七状态模型" class="headerlink" title="4、补充知识——进程的”挂起态”与七状态模型"></a>4、补充知识——进程的”挂起态”与七状态模型</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210257856.png" alt="image-20210504210257856"></p>
<h4 id="脑图-5"><a href="#脑图-5" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504210409703.png" alt="image-20210504210409703"></p>
<h3 id="2-2-2、进程调度的时机、切换与过程、方式"><a href="#2-2-2、进程调度的时机、切换与过程、方式" class="headerlink" title="2.2.2、进程调度的时机、切换与过程、方式"></a>2.2.2、进程调度的时机、切换与过程、方式</h3><h4 id="1、时机"><a href="#1、时机" class="headerlink" title="1、时机"></a>1、时机</h4><h5 id="1、什么时候需要进程调度"><a href="#1、什么时候需要进程调度" class="headerlink" title="1、什么时候需要进程调度"></a>1、什么时候需要进程调度</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504211825916.png" alt="image-20210504211825916"></p>
<h5 id="2、什么时候不需要进程调度（但是进程在普通临界区中是可以进行调度、切换的。）"><a href="#2、什么时候不需要进程调度（但是进程在普通临界区中是可以进行调度、切换的。）" class="headerlink" title="2、什么时候不需要进程调度（但是进程在普通临界区中是可以进行调度、切换的。）"></a>2、什么时候不需要进程调度（但是进程在普通临界区中是可以进行调度、切换的。）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504211925883.png" alt="image-20210504211925883"></p>
<h5 id="3、临界区与内核程序临界区"><a href="#3、临界区与内核程序临界区" class="headerlink" title="3、临界区与内核程序临界区"></a>3、临界区与内核程序临界区</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212056981.png" alt="image-20210504212056981"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212117707.png" alt="image-20210504212117707"></p>
<p>如果还没退出临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。</p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此<strong>在访问内核程序临界区期间不能进行调度与切换</strong>。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212504714.png" alt="image-20210504212504714"></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。</p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此<strong>在访问普通临界区时可以进行调度与切换</strong>。</p>
<h4 id="2、切换与过程"><a href="#2、切换与过程" class="headerlink" title="2、切换与过程"></a>2、切换与过程</h4><h5 id="1、”狭义的调度”与”进程切换”的区别"><a href="#1、”狭义的调度”与”进程切换”的区别" class="headerlink" title="1、”狭义的调度”与”进程切换”的区别"></a>1、”狭义的调度”与”进程切换”的区别</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212743872.png" alt="image-20210504212743872"></p>
<h4 id="3、方式"><a href="#3、方式" class="headerlink" title="3、方式"></a>3、方式</h4><h5 id="1、非剥夺调度方式（非抢占式）"><a href="#1、非剥夺调度方式（非抢占式）" class="headerlink" title="1、非剥夺调度方式（非抢占式）"></a>1、非剥夺调度方式（非抢占式）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212658968.png" alt="image-20210504212658968"></p>
<h5 id="2、剥夺调度方式（抢占式）"><a href="#2、剥夺调度方式（抢占式）" class="headerlink" title="2、剥夺调度方式（抢占式）"></a>2、剥夺调度方式（抢占式）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212718957.png" alt="image-20210504212718957"></p>
<h4 id="脑图-6"><a href="#脑图-6" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504212903088.png" alt="image-20210504212903088"></p>
<h3 id="2-2-3、调度算法的评价指标"><a href="#2-2-3、调度算法的评价指标" class="headerlink" title="2.2.3、调度算法的评价指标"></a>2.2.3、调度算法的评价指标</h3><h4 id="1、CPU利用率"><a href="#1、CPU利用率" class="headerlink" title="1、CPU利用率"></a>1、CPU利用率</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504213732211.png" alt="image-20210504213732211"></p>
<h4 id="2、系统吞吐量"><a href="#2、系统吞吐量" class="headerlink" title="2、系统吞吐量"></a>2、系统吞吐量</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504213750111.png" alt="image-20210504213750111"></p>
<h4 id="3、周转时间"><a href="#3、周转时间" class="headerlink" title="3、周转时间"></a>3、周转时间</h4><h5 id="1、周转时间、平均周转时间"><a href="#1、周转时间、平均周转时间" class="headerlink" title="1、周转时间、平均周转时间"></a>1、周转时间、平均周转时间</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504213811576.png" alt="image-20210504213811576"></p>
<h5 id="2、带权周转时间、平均带权周转时间"><a href="#2、带权周转时间、平均带权周转时间" class="headerlink" title="2、带权周转时间、平均带权周转时间"></a>2、带权周转时间、平均带权周转时间</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504213904684.png" alt="image-20210504213904684"></p>
<p>即：周转时间都是11s，但是作业1的运行时间是1s，等待时间是10s；而作业2的运行时间是10s，等待时间是1s。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5Cimage-20210504213926076.png" alt="image-20210504213926076"></p>
<h4 id="4、等待时间"><a href="#4、等待时间" class="headerlink" title="4、等待时间"></a>4、等待时间</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504214350127.png" alt="image-20210504214350127"></p>
<h4 id="5、响应时间"><a href="#5、响应时间" class="headerlink" title="5、响应时间"></a>5、响应时间</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504214421607.png" alt="image-20210504214421607"></p>
<h4 id="脑图-7"><a href="#脑图-7" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504214513619.png" alt="image-20210504214513619"></p>
<h3 id="2-2-4、调度算法：先来先服务、最短作业优先、最高响应比优先"><a href="#2-2-4、调度算法：先来先服务、最短作业优先、最高响应比优先" class="headerlink" title="2.2.4、调度算法：先来先服务、最短作业优先、最高响应比优先"></a>2.2.4、调度算法：先来先服务、最短作业优先、最高响应比优先</h3><p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度?</li>
<li>抢占式?非抢占式?</li>
<li>优点和缺点</li>
<li>是否会导致饥饿：<ul>
<li>某进程/作业长期得不到服务</li>
</ul>
</li>
</ol>
<h4 id="1、先来先服务-First-Come-First-Serve：FCFS"><a href="#1、先来先服务-First-Come-First-Serve：FCFS" class="headerlink" title="1、先来先服务(First Come First Serve：FCFS)"></a>1、先来先服务(First Come First Serve：FCFS)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504220945017.png" alt="image-20210504220945017"></p>
<p>相关例题：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221017275.png" alt="image-20210504221017275"></p>
<h4 id="2、短作业优先-Shortest-Job-First：SJF"><a href="#2、短作业优先-Shortest-Job-First：SJF" class="headerlink" title="2、短作业优先( Shortest Job First：SJF)"></a>2、短作业优先( Shortest Job First：SJF)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221101352.png" alt="image-20210504221101352"></p>
<p>相关例题</p>
<h5 id="1、非抢占式的短作业优先"><a href="#1、非抢占式的短作业优先" class="headerlink" title="1、非抢占式的短作业优先"></a>1、非抢占式的短作业优先</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221228030.png" alt="image-20210504221228030"></p>
<h5 id="2、抢占式的短作业优先"><a href="#2、抢占式的短作业优先" class="headerlink" title="2、抢占式的短作业优先"></a>2、抢占式的短作业优先</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221334542.png" alt="image-20210504221334542"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221401081.png" alt="image-20210504221401081"></p>
<p>细节：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221427980.png" alt="image-20210504221427980"></p>
<h4 id="3、对两种算法的思考"><a href="#3、对两种算法的思考" class="headerlink" title="3、对两种算法的思考"></a>3、对两种算法的思考</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221522717.png" alt="image-20210504221522717"></p>
<h4 id="4、高响应比优先-Highest-Response-Ratio-Next：HRRN"><a href="#4、高响应比优先-Highest-Response-Ratio-Next：HRRN" class="headerlink" title="4、高响应比优先(Highest Response Ratio Next：HRRN)"></a>4、高响应比优先(Highest Response Ratio Next：HRRN)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221551173.png" alt="image-20210504221551173"></p>
<p>相关例题：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504221620857.png" alt="image-20210504221620857"></p>
<h4 id="5、知识回顾与重要考点"><a href="#5、知识回顾与重要考点" class="headerlink" title="5、知识回顾与重要考点"></a>5、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504214906931.png" alt="image-20210504214906931"></p>
<h3 id="2-2-5、调度算法：时间片轮转、优先级、多级反馈队列"><a href="#2-2-5、调度算法：时间片轮转、优先级、多级反馈队列" class="headerlink" title="2.2.5、调度算法：时间片轮转、优先级、多级反馈队列"></a>2.2.5、调度算法：时间片轮转、优先级、多级反馈队列</h3><p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度?</li>
<li>抢占式?非抢占式?</li>
<li>优点和缺点</li>
<li>是否会导致饥饿：<ul>
<li>某进程/作业长期得不到服务</li>
</ul>
</li>
</ol>
<h4 id="1、时间片轮转调度算法"><a href="#1、时间片轮转调度算法" class="headerlink" title="1、时间片轮转调度算法"></a>1、时间片轮转调度算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504223036879.png" alt="image-20210504223036879"></p>
<p>相关例题：</p>
<p>时间片为2</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504223228420.png" alt="image-20210504223228420"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504223311894.png" alt="image-20210504223311894"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504223733579.png" alt="image-20210504223733579"></p>
<p>时间片为5</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504223829429.png" alt="image-20210504223829429"></p>
<p>时间片的选取&amp;时间片轮转调度算法与先来先服务算法的关系：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224009814.png" alt="image-20210504224009814"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224059700.png" alt="image-20210504224059700"></p>
<h4 id="2、优先级调度算法"><a href="#2、优先级调度算法" class="headerlink" title="2、优先级调度算法"></a>2、优先级调度算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224852371.png" alt="image-20210504224852371"></p>
<p>相关例题：</p>
<p>非抢占式的优先级调度算法：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224320500.png" alt="image-20210504224320500"></p>
<p>抢占式的优先级调度算法：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224457516.png" alt="image-20210504224457516"></p>
<p>补充：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224802316.png" alt="image-20210504224802316"></p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504224934560.png" alt="image-20210504224934560"></p>
<h4 id="4、多级反馈队列调度算法"><a href="#4、多级反馈队列调度算法" class="headerlink" title="4、多级反馈队列调度算法"></a>4、多级反馈队列调度算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504225527480.png" alt="image-20210504225527480"></p>
<p>相关例题</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504225342558.png" alt="image-20210504225342558"></p>
<h4 id="5、知识回顾与重要考点-1"><a href="#5、知识回顾与重要考点-1" class="headerlink" title="5、知识回顾与重要考点"></a>5、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504225811770.png" alt="image-20210504225811770"></p>
<h3 id="2-3-1、进程同步、进程互斥"><a href="#2-3-1、进程同步、进程互斥" class="headerlink" title="2.3.1、进程同步、进程互斥"></a>2.3.1、进程同步、进程互斥</h3><h4 id="1、进程同步"><a href="#1、进程同步" class="headerlink" title="1、进程同步"></a>1、进程同步</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504230549925.png" alt="image-20210504230549925"></p>
<h4 id="2、进程互斥"><a href="#2、进程互斥" class="headerlink" title="2、进程互斥"></a>2、进程互斥</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504230709464.png" alt="image-20210504230709464"></p>
<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504230942497.png" alt="image-20210504230942497"></p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504231106627.png" alt="image-20210504231106627"></p>
<h4 id="脑图-8"><a href="#脑图-8" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504231143008.png" alt="image-20210504231143008"></p>
<h3 id="2-3-2、进程互斥的软件实现方法"><a href="#2-3-2、进程互斥的软件实现方法" class="headerlink" title="2.3.2、进程互斥的软件实现方法"></a>2.3.2、进程互斥的软件实现方法</h3><p>学习提示：</p>
<ol>
<li>理解各个算法的思想、原理</li>
<li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li>
<li>分析各算法存在的缺陷(结合“实现互斥要遵循的四个原则”进行分析)</li>
</ol>
<h4 id="1、单标志法"><a href="#1、单标志法" class="headerlink" title="1、单标志法"></a>1、单标志法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504231820629.png" alt="image-20210504231820629"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504231746318.png" alt="image-20210504231746318"></p>
<h4 id="2、双标志先检查"><a href="#2、双标志先检查" class="headerlink" title="2、双标志先检查"></a>2、双标志先检查</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232145546.png" alt="image-20210504232145546"></p>
<h4 id="3、双标志后检查"><a href="#3、双标志后检查" class="headerlink" title="3、双标志后检查"></a>3、双标志后检查</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232413700.png" alt="image-20210504232413700"></p>
<h4 id="4、Peterson算法"><a href="#4、Peterson算法" class="headerlink" title="4、Peterson算法"></a>4、Peterson算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232720257.png" alt="image-20210504232720257"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232756435.png" alt="image-20210504232756435"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232829595.png" alt="image-20210504232829595"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232858921.png" alt="image-20210504232858921"></p>
<h4 id="脑图-9"><a href="#脑图-9" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504232928285.png" alt="image-20210504232928285"></p>
<h3 id="2-3-3、进程互斥的硬件实现方法"><a href="#2-3-3、进程互斥的硬件实现方法" class="headerlink" title="2.3.3、进程互斥的硬件实现方法"></a>2.3.3、进程互斥的硬件实现方法</h3><p>学习提示：</p>
<ol>
<li>理解各方法的原理</li>
<li>了解各方法的优缺点</li>
</ol>
<h4 id="1、中断屏蔽方法"><a href="#1、中断屏蔽方法" class="headerlink" title="1、中断屏蔽方法"></a>1、中断屏蔽方法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504233615762.png" alt="image-20210504233615762"></p>
<h4 id="2、TestAndSet（TS指令-TSL指令TestAndSetLock）"><a href="#2、TestAndSet（TS指令-TSL指令TestAndSetLock）" class="headerlink" title="2、TestAndSet（TS指令/TSL指令TestAndSetLock）"></a>2、TestAndSet（TS指令/TSL指令TestAndSetLock）</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504233641846.png" alt="image-20210504233641846"></p>
<h4 id="3、Swap指令（XCHG指令）"><a href="#3、Swap指令（XCHG指令）" class="headerlink" title="3、Swap指令（XCHG指令）"></a>3、Swap指令（XCHG指令）</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504233700709.png" alt="image-20210504233700709"></p>
<h4 id="脑图-10"><a href="#脑图-10" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504233729313.png" alt="image-20210504233729313"></p>
<h3 id="2-3-4、信号量机制"><a href="#2-3-4、信号量机制" class="headerlink" title="2.3.4、信号量机制"></a>2.3.4、信号量机制</h3><p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题?</p>
<ul>
<li>进程互斥的四种软件实现方式(单标志法、双标志先检查、双标志后检查、Peterson算法 )</li>
<li>进程互斥的三种硬件实现方式(中断屏蔽方法、TS/TSL指 令、Swap/XCHG指令)<ul>
<li>在双标志先检查法中，进入区的“检查”、“ 上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题;</li>
<li>所有的解决方案都无法实现“让权等待”</li>
</ul>
</li>
</ul>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制</p>
<h4 id="1、信号量机制"><a href="#1、信号量机制" class="headerlink" title="1、信号量机制"></a>1、信号量机制</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504234407772.png" alt="image-20210504234407772"></p>
<h4 id="2、整型信号量"><a href="#2、整型信号量" class="headerlink" title="2、整型信号量"></a>2、整型信号量</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504235542982.png" alt="image-20210504235542982"></p>
<h4 id="3、纪录型信号量"><a href="#3、纪录型信号量" class="headerlink" title="3、纪录型信号量"></a>3、纪录型信号量</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210504235617935.png" alt="image-20210504235617935"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505000153209.png" alt="image-20210505000153209"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505000232848.png" alt="image-20210505000232848"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505000249924.png" alt="image-20210505000249924"></p>
<h4 id="脑图-11"><a href="#脑图-11" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505000323832.png" alt="image-20210505000323832"></p>
<h3 id="2-3-5、用信号量实现进程互斥、同步、前驱关系"><a href="#2-3-5、用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="2.3.5、用信号量实现进程互斥、同步、前驱关系"></a>2.3.5、用信号量实现进程互斥、同步、前驱关系</h3><p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p>
<p>信号量的值 = 这种资源的剩余数量(信号量的值如果小于0，说明<strong>此时有进程在等待这种资源</strong>)</p>
<p>P(S)——申请一个资源S，如果<strong>资源不够就阻塞等待</strong><br>V(S)——释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong></p>
<h4 id="1、实现进程互斥"><a href="#1、实现进程互斥" class="headerlink" title="1、实现进程互斥"></a>1、实现进程互斥</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505001722795.png" alt="image-20210505001722795"></p>
<h4 id="2、实现进程同步"><a href="#2、实现进程同步" class="headerlink" title="2、实现进程同步"></a>2、实现进程同步</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505001748039.png" alt="image-20210505001748039"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505001810855.png" alt="image-20210505001810855"></p>
<h4 id="3、实现进程的前驱关系"><a href="#3、实现进程的前驱关系" class="headerlink" title="3、实现进程的前驱关系"></a>3、实现进程的前驱关系</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505001831897.png" alt="image-20210505001831897"></p>
<h4 id="脑图-12"><a href="#脑图-12" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505001903980.png" alt="image-20210505001903980"></p>
<h3 id="2-3-6、生产者-消费者问题"><a href="#2-3-6、生产者-消费者问题" class="headerlink" title="2.3.6、生产者-消费者问题"></a>2.3.6、生产者-消费者问题</h3><h4 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505004917915.png" alt="image-20210505004917915"></p>
<h4 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505003435388.png" alt="image-20210505003435388"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505004125366.png" alt="image-20210505004125366"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505004950707.png" alt="image-20210505004950707"></p>
<h4 id="3、问题解决"><a href="#3、问题解决" class="headerlink" title="3、问题解决"></a>3、问题解决</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505005740558.png" alt="image-20210505005740558"></p>
<h4 id="4、思考：能否改变相邻P、V操作的顺序"><a href="#4、思考：能否改变相邻P、V操作的顺序" class="headerlink" title="4、思考：能否改变相邻P、V操作的顺序?"></a>4、思考：能否改变相邻P、V操作的顺序?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505005811868.png" alt="image-20210505005811868"></p>
<p>“使用产品”能不能放在”取出产品之后”（即PV操作之间）：</p>
<p>从逻辑上来说没什么问题，取出一个产品之后马上使用。但是最好不要。因为这会导致临界区的代码量变大，消费者进程在访问临界区资源的时候就会耗费更长的时间，如果此时有别的进程也想访问临界区资源的话是会被阻塞的。</p>
<p>把这些非必要的代码放进临界区的话，就显然会导致进程间的并发度降低，所以最好不要把没有必要的代码放到临界区里面</p>
<h4 id="5、知识回顾与重要考点-2"><a href="#5、知识回顾与重要考点-2" class="headerlink" title="5、知识回顾与重要考点"></a>5、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505004859079.png" alt="image-20210505004859079"></p>
<h3 id="2-3-7、生产者-多消费者"><a href="#2-3-7、生产者-多消费者" class="headerlink" title="2.3.7、生产者-多消费者"></a>2.3.7、生产者-多消费者</h3><h4 id="1、问题描述-1"><a href="#1、问题描述-1" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505011453970.png" alt="image-20210505011453970"></p>
<h4 id="2、问题分析-1"><a href="#2、问题分析-1" class="headerlink" title="2、问题分析"></a>2、问题分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505011627140.png" alt="image-20210505011627140"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505011725280.png" alt="image-20210505011725280"></p>
<h4 id="3、问题解决-1"><a href="#3、问题解决-1" class="headerlink" title="3、问题解决"></a>3、问题解决</h4><p>方式一：使用互斥信号量mutex</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505012011434.png" alt="image-20210505012011434"></p>
<p>方式二：不使用互斥信号量mutex</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505012224581.png" alt="image-20210505012224581"></p>
<p>为什么只可以使用（同步）信号量plate，省略（异步）信号量mutex解决问题呢？</p>
<p>原因在于：<strong>本题中的缓冲区大小为1</strong>，在任何时刻，apple、 orange、 plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</p>
<p>如果把缓冲区的大小设置为2，即盘子里面可以放置两个水果</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505012546283.png" alt="image-20210505012546283"></p>
<h4 id="4、知识回顾与重要考点"><a href="#4、知识回顾与重要考点" class="headerlink" title="4、知识回顾与重要考点"></a>4、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505011103373.png" alt="image-20210505011103373"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505011126965.png" alt="image-20210505011126965"></p>
<h3 id="2-3-8、吸烟者问题"><a href="#2-3-8、吸烟者问题" class="headerlink" title="2.3.8、吸烟者问题"></a>2.3.8、吸烟者问题</h3><h4 id="1、问题描述-2"><a href="#1、问题描述-2" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505013010023.png" alt="image-20210505013010023"></p>
<h4 id="2、问题分析-2"><a href="#2、问题分析-2" class="headerlink" title="2、问题分析"></a>2、问题分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505013811237.png" alt="image-20210505013811237"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505013903213.png" alt="image-20210505013903213"></p>
<h4 id="3、问题解决-2"><a href="#3、问题解决-2" class="headerlink" title="3、问题解决"></a>3、问题解决</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505013926731.png" alt="image-20210505013926731"></p>
<h4 id="4、知识回顾与重要考点-1"><a href="#4、知识回顾与重要考点-1" class="headerlink" title="4、知识回顾与重要考点"></a>4、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505012943618.png" alt="image-20210505012943618"></p>
<h3 id="2-3-9、读者-写者问题"><a href="#2-3-9、读者-写者问题" class="headerlink" title="2.3.9、读者-写者问题"></a>2.3.9、读者-写者问题</h3><h4 id="1、问题描述-3"><a href="#1、问题描述-3" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505014140357.png" alt="image-20210505014140357"></p>
<h4 id="2、问题分析-3"><a href="#2、问题分析-3" class="headerlink" title="2、问题分析"></a>2、问题分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505014119129.png" alt="image-20210505014119129"></p>
<h4 id="3、问题解决-3"><a href="#3、问题解决-3" class="headerlink" title="3、问题解决"></a>3、问题解决</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505014207251.png" alt="image-20210505014207251"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505014235757.png" alt="image-20210505014235757"></p>
<h4 id="4、知识回顾与重要考点-2"><a href="#4、知识回顾与重要考点-2" class="headerlink" title="4、知识回顾与重要考点"></a>4、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505014049722.png" alt="image-20210505014049722"></p>
<h3 id="2-3-10、哲学家进餐问题"><a href="#2-3-10、哲学家进餐问题" class="headerlink" title="2.3.10、哲学家进餐问题"></a>2.3.10、哲学家进餐问题</h3><h4 id="1、问题描述-4"><a href="#1、问题描述-4" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505015934159.png" alt="image-20210505015934159"></p>
<h4 id="2、问题分析-4"><a href="#2、问题分析-4" class="headerlink" title="2、问题分析"></a>2、问题分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505020031496.png" alt="image-20210505020031496"></p>
<h4 id="3、问题解决-4"><a href="#3、问题解决-4" class="headerlink" title="3、问题解决"></a>3、问题解决</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505020244129.png" alt="image-20210505020244129"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505020339544.png" alt="image-20210505020339544"></p>
<p>第一种情况：0号进程拿起左右两支筷子进行吃饭（顺利进行）</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505020554497.png" alt="image-20210505020554497"></p>
<p>第二种情况：在第一种情况的基础下，0号进程正在吃饭，此时1号进程想要吃饭，但是会被阻塞在拿左边筷子的语句P(chopstick[i])上，此时2号进程想要吃饭，但是由于1号进程执行了P(mutex)但是没执行V(mutex)，所以2号进程会被阻塞在语句P(mutex)上，即：2号进程虽然左右两边都有筷子，但是它吃不了饭。</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505021347456.png" alt="image-20210505021347456"></p>
<p>第三种情况：在第一种的情况下，4号进程想吃饭，它会拿起左边的筷子，然后就被阻塞在拿右边筷子的语句P(chopstick[(i+1)%5])上了</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505021537145.png" alt="image-20210505021537145"></p>
<h4 id="4、知识回顾与重要考点-3"><a href="#4、知识回顾与重要考点-3" class="headerlink" title="4、知识回顾与重要考点"></a>4、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505021821006.png" alt="image-20210505021821006"></p>
<h3 id="2-3-11、管程"><a href="#2-3-11、管程" class="headerlink" title="2.3.11、管程"></a>2.3.11、管程</h3><h4 id="1、为什么要引入管程"><a href="#1、为什么要引入管程" class="headerlink" title="1、为什么要引入管程"></a>1、为什么要引入管程</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022123552.png" alt="image-20210505022123552"></p>
<h4 id="2、管程的定义和基本特征"><a href="#2、管程的定义和基本特征" class="headerlink" title="2、管程的定义和基本特征"></a>2、管程的定义和基本特征</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022141694.png" alt="image-20210505022141694"></p>
<h4 id="3、拓展1：用管程解决生产者消费者问题"><a href="#3、拓展1：用管程解决生产者消费者问题" class="headerlink" title="3、拓展1：用管程解决生产者消费者问题"></a>3、拓展1：用管程解决生产者消费者问题</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022231170.png" alt="image-20210505022231170"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022251625.png" alt="image-20210505022251625"></p>
<h4 id="4、拓展2：java中类似于管程的机制"><a href="#4、拓展2：java中类似于管程的机制" class="headerlink" title="4、拓展2：java中类似于管程的机制"></a>4、拓展2：java中类似于管程的机制</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022319316.png" alt="image-20210505022319316"></p>
<h4 id="脑图-13"><a href="#脑图-13" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505022210103.png" alt="image-20210505022210103"></p>
<h3 id="2-4-1、死锁的概念"><a href="#2-4-1、死锁的概念" class="headerlink" title="2.4.1、死锁的概念"></a>2.4.1、死锁的概念</h3><h4 id="1、什么是死锁"><a href="#1、什么是死锁" class="headerlink" title="1、什么是死锁"></a>1、什么是死锁</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505143529683.png" alt="image-20210505143529683"></p>
<h4 id="2、进程死锁、饥饿、死循环的区别"><a href="#2、进程死锁、饥饿、死循环的区别" class="headerlink" title="2、进程死锁、饥饿、死循环的区别"></a>2、进程死锁、饥饿、死循环的区别</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505143807098.png" alt="image-20210505143807098"></p>
<h4 id="3、死锁产生的必要条件"><a href="#3、死锁产生的必要条件" class="headerlink" title="3、死锁产生的必要条件"></a>3、死锁产生的必要条件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144019761.png" alt="image-20210505144019761"></p>
<h4 id="4、什么时候会发生死锁"><a href="#4、什么时候会发生死锁" class="headerlink" title="4、什么时候会发生死锁"></a>4、什么时候会发生死锁</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144120239.png" alt="image-20210505144120239"></p>
<h4 id="5、死锁的处理策略"><a href="#5、死锁的处理策略" class="headerlink" title="5、死锁的处理策略"></a>5、死锁的处理策略</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144149160.png" alt="image-20210505144149160"></p>
<h4 id="脑图-14"><a href="#脑图-14" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144218705.png" alt="image-20210505144218705"></p>
<h3 id="2-4-2、死锁的处理策略——预防死锁"><a href="#2-4-2、死锁的处理策略——预防死锁" class="headerlink" title="2.4.2、死锁的处理策略——预防死锁"></a>2.4.2、死锁的处理策略——预防死锁</h3><h4 id="1、死锁的处理"><a href="#1、死锁的处理" class="headerlink" title="1、死锁的处理"></a>1、死锁的处理</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144445903.png" alt="image-20210505144445903"></p>
<h4 id="2、破坏互斥条件"><a href="#2、破坏互斥条件" class="headerlink" title="2、破坏互斥条件"></a>2、破坏互斥条件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505144725993.png" alt="image-20210505144725993"></p>
<h4 id="3、破坏不剥夺条件"><a href="#3、破坏不剥夺条件" class="headerlink" title="3、破坏不剥夺条件"></a>3、破坏不剥夺条件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505145005522.png" alt="image-20210505145005522"></p>
<h4 id="4、破坏请求和保持条件"><a href="#4、破坏请求和保持条件" class="headerlink" title="4、破坏请求和保持条件"></a>4、破坏请求和保持条件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505145224511.png" alt="image-20210505145224511"></p>
<h4 id="5、破坏循环等待条件"><a href="#5、破坏循环等待条件" class="headerlink" title="5、破坏循环等待条件"></a>5、破坏循环等待条件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505145453127.png" alt="image-20210505145453127"></p>
<h4 id="脑图-15"><a href="#脑图-15" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505145752465.png" alt="image-20210505145752465"></p>
<h3 id="2-4-3、死锁的处理策略——避免死锁"><a href="#2-4-3、死锁的处理策略——避免死锁" class="headerlink" title="2.4.3、死锁的处理策略——避免死锁"></a>2.4.3、死锁的处理策略——避免死锁</h3><h4 id="1、动态策略：避免死锁"><a href="#1、动态策略：避免死锁" class="headerlink" title="1、动态策略：避免死锁"></a>1、动态策略：避免死锁</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505145945572.png" alt="image-20210505145945572"></p>
<h4 id="2、什么是安全序列"><a href="#2、什么是安全序列" class="headerlink" title="2、什么是安全序列"></a>2、什么是安全序列</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505150922419.png" alt="image-20210505150922419"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151042960.png" alt="image-20210505151042960"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151124895.png" alt="image-20210505151124895"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151244599.png" alt="image-20210505151244599"></p>
<h4 id="3、安全序列、不安全状态、死锁的联系"><a href="#3、安全序列、不安全状态、死锁的联系" class="headerlink" title="3、安全序列、不安全状态、死锁的联系"></a>3、安全序列、不安全状态、死锁的联系</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151529696.png" alt="image-20210505151529696"></p>
<h4 id="4、银行家算法"><a href="#4、银行家算法" class="headerlink" title="4、银行家算法"></a>4、银行家算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151659990.png" alt="image-20210505151659990"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151838002.png" alt="image-20210505151838002"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505151927039.png" alt="image-20210505151927039"></p>
<p>不安全的情况：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505152108400.png" alt="image-20210505152108400"></p>
<p>代码实现：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505152424001.png" alt="image-20210505152424001"></p>
<h4 id="5、知识回顾与重要考点-3"><a href="#5、知识回顾与重要考点-3" class="headerlink" title="5、知识回顾与重要考点"></a>5、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505152609859.png" alt="image-20210505152609859"></p>
<h3 id="2-4-4、死锁的处理——策略检测和解除"><a href="#2-4-4、死锁的处理——策略检测和解除" class="headerlink" title="2.4.4、死锁的处理——策略检测和解除"></a>2.4.4、死锁的处理——策略检测和解除</h3><h4 id="1、死锁的检测和解除"><a href="#1、死锁的检测和解除" class="headerlink" title="1、死锁的检测和解除"></a>1、死锁的检测和解除</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505152730364.png" alt="image-20210505152730364"></p>
<h4 id="2、死锁的检测"><a href="#2、死锁的检测" class="headerlink" title="2、死锁的检测"></a>2、死锁的检测</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505152953706.png" alt="image-20210505152953706"></p>
<p>没有发生死锁：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505153349861.png" alt="image-20210505153349861"></p>
<p>发生死锁：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505153629990.png" alt="image-20210505153629990"></p>
<p>死锁定理：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505153748812.png" alt="image-20210505153748812"></p>
<h4 id="3、死锁的解除"><a href="#3、死锁的解除" class="headerlink" title="3、死锁的解除"></a>3、死锁的解除</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505154108164.png" alt="image-20210505154108164"></p>
<h4 id="脑图-16"><a href="#脑图-16" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210505154238217.png" alt="image-20210505154238217"></p>
<h2 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h2><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200704185228380.jpg" alt="img"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200704185503505.jpg" alt="在这里插入图片描述"></p>
<h3 id="3-1-1、内存的基础知识"><a href="#3-1-1、内存的基础知识" class="headerlink" title="3.1.1、内存的基础知识"></a>3.1.1、内存的基础知识</h3><h4 id="1、什么是内存？内存的作用——存储单元与内存地址"><a href="#1、什么是内存？内存的作用——存储单元与内存地址" class="headerlink" title="1、什么是内存？内存的作用——存储单元与内存地址"></a>1、什么是内存？内存的作用——存储单元与内存地址</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508002901851.png" alt="image-20210508002901851"></p>
<h4 id="2、进程运行的基本原理"><a href="#2、进程运行的基本原理" class="headerlink" title="2、进程运行的基本原理"></a>2、进程运行的基本原理</h4><h5 id="1、指令的工作原理"><a href="#1、指令的工作原理" class="headerlink" title="1、指令的工作原理"></a>1、指令的工作原理</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508003140541.png" alt="image-20210508003140541"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508003207444.png" alt="image-20210508003207444"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508003230122.png" alt="image-20210508003230122"></p>
<h5 id="2、逻辑地址-VS-物理地址"><a href="#2、逻辑地址-VS-物理地址" class="headerlink" title="2、逻辑地址 VS 物理地址"></a>2、逻辑地址 VS 物理地址</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508004518010.png" alt="image-20210508004518010"></p>
<h5 id="3、如何实现地址转换"><a href="#3、如何实现地址转换" class="headerlink" title="3、如何实现地址转换"></a>3、如何实现地址转换</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508004749695.png" alt="image-20210508004749695"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508004832543.png" alt="image-20210508004832543"></p>
<h5 id="4、从写程序到程序运行的过程：编辑——编译——链接——装入"><a href="#4、从写程序到程序运行的过程：编辑——编译——链接——装入" class="headerlink" title="4、从写程序到程序运行的过程：编辑——编译——链接——装入"></a>4、从写程序到程序运行的过程：编辑——编译——链接——装入</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508004555654.png" alt="image-20210508004555654"></p>
<h5 id="5、三种装入方式"><a href="#5、三种装入方式" class="headerlink" title="5、三种装入方式"></a>5、三种装入方式</h5><h6 id="1、三种装入方式——绝对装入"><a href="#1、三种装入方式——绝对装入" class="headerlink" title="1、三种装入方式——绝对装入"></a>1、三种装入方式——绝对装入</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005036546.png" alt="image-20210508005036546"></p>
<h6 id="2、三种装入方式——可重定位装入"><a href="#2、三种装入方式——可重定位装入" class="headerlink" title="2、三种装入方式——可重定位装入"></a>2、三种装入方式——可重定位装入</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005056249.png" alt="image-20210508005056249"></p>
<h6 id="3、三种装入方式——动态运行时装入"><a href="#3、三种装入方式——动态运行时装入" class="headerlink" title="3、三种装入方式——动态运行时装入"></a>3、三种装入方式——动态运行时装入</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005114414.png" alt="image-20210508005114414"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005143082.png" alt="image-20210508005143082"></p>
<h5 id="6、三种链接方式"><a href="#6、三种链接方式" class="headerlink" title="6、三种链接方式"></a>6、三种链接方式</h5><h6 id="1、三种链接方式——静态链接"><a href="#1、三种链接方式——静态链接" class="headerlink" title="1、三种链接方式——静态链接"></a>1、三种链接方式——静态链接</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005324193.png" alt="image-20210508005324193"></p>
<h6 id="2、三种链接方式——装入时动态链接"><a href="#2、三种链接方式——装入时动态链接" class="headerlink" title="2、三种链接方式——装入时动态链接"></a>2、三种链接方式——装入时动态链接</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005341688.png" alt="image-20210508005341688"></p>
<h6 id="3、三种链接方式——运行时动态链接"><a href="#3、三种链接方式——运行时动态链接" class="headerlink" title="3、三种链接方式——运行时动态链接"></a>3、三种链接方式——运行时动态链接</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005409340.png" alt="image-20210508005409340"></p>
<h4 id="3、补充知识：几个常用的数量单位"><a href="#3、补充知识：几个常用的数量单位" class="headerlink" title="3、补充知识：几个常用的数量单位"></a>3、补充知识：几个常用的数量单位</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508002939003.png" alt="image-20210508002939003"></p>
<h4 id="脑图-17"><a href="#脑图-17" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005509266.png" alt="image-20210508005509266"></p>
<h3 id="3-1-2、内存管理的概念"><a href="#3-1-2、内存管理的概念" class="headerlink" title="3.1.2、内存管理的概念"></a>3.1.2、内存管理的概念</h3><h4 id="1、内存空间的分配与回收"><a href="#1、内存空间的分配与回收" class="headerlink" title="1、内存空间的分配与回收"></a>1、内存空间的分配与回收</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508010417701.png" alt="image-20210508010417701"></p>
<h4 id="2、内存空间的扩充"><a href="#2、内存空间的扩充" class="headerlink" title="2、内存空间的扩充"></a>2、内存空间的扩充</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508010447793.png" alt="image-20210508010447793"></p>
<h4 id="3、地址转换"><a href="#3、地址转换" class="headerlink" title="3、地址转换"></a>3、地址转换</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508010631873.png" alt="image-20210508010631873"></p>
<h4 id="4、存储保护"><a href="#4、存储保护" class="headerlink" title="4、存储保护"></a>4、存储保护</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508010712814.png" alt="image-20210508010712814"></p>
<h5 id="1、存储保护——方式1"><a href="#1、存储保护——方式1" class="headerlink" title="1、存储保护——方式1"></a>1、存储保护——方式1</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508010856791.png" alt="image-20210508010856791"></p>
<h5 id="2、存储保护——方式2"><a href="#2、存储保护——方式2" class="headerlink" title="2、存储保护——方式2"></a>2、存储保护——方式2</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508011111324.png" alt="image-20210508011111324"></p>
<h4 id="脑图-18"><a href="#脑图-18" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508005842818.png" alt="image-20210508005842818"></p>
<h3 id="3-1-3、覆盖与交换"><a href="#3-1-3、覆盖与交换" class="headerlink" title="3.1.3、覆盖与交换"></a>3.1.3、覆盖与交换</h3><h4 id="1、内存空间的扩充"><a href="#1、内存空间的扩充" class="headerlink" title="1、内存空间的扩充"></a>1、内存空间的扩充</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508083942705.png" alt="image-20210508083942705"></p>
<h5 id="1、覆盖技术"><a href="#1、覆盖技术" class="headerlink" title="1、覆盖技术"></a>1、覆盖技术</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508012819104.png" alt="image-20210508012819104"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508012843411.png" alt="image-20210508012843411"></p>
<h5 id="2、交换技术"><a href="#2、交换技术" class="headerlink" title="2、交换技术"></a>2、交换技术</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508012931347.png" alt="image-20210508012931347"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508012947320.png" alt="image-20210508012947320"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508013003422.png" alt="image-20210508013003422"></p>
<h4 id="脑图-19"><a href="#脑图-19" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508011536720.png" alt="image-20210508011536720"></p>
<h3 id="3-1-4、内存空间的分配与回收——连续分配管理方式"><a href="#3-1-4、内存空间的分配与回收——连续分配管理方式" class="headerlink" title="3.1.4、内存空间的分配与回收——连续分配管理方式"></a>3.1.4、内存空间的分配与回收——连续分配管理方式</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508084011062.png" alt="image-20210508084011062"></p>
<h4 id="3-1-4-1-1、连续分配管理方式——单一连续分配"><a href="#3-1-4-1-1、连续分配管理方式——单一连续分配" class="headerlink" title="3.1.4.1.1、连续分配管理方式——单一连续分配"></a>3.1.4.1.1、连续分配管理方式——单一连续分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090339927.png" alt="image-20210508090339927"></p>
<h4 id="3-1-4-1-2、连续分配管理方式——固定分区分配"><a href="#3-1-4-1-2、连续分配管理方式——固定分区分配" class="headerlink" title="3.1.4.1.2、连续分配管理方式——固定分区分配"></a>3.1.4.1.2、连续分配管理方式——固定分区分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090358501.png" alt="image-20210508090358501"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090412868.png" alt="image-20210508090412868"></p>
<h4 id="3-1-4-1-3、连续分配管理方式——动态分区分配"><a href="#3-1-4-1-3、连续分配管理方式——动态分区分配" class="headerlink" title="3.1.4.1.3、连续分配管理方式——动态分区分配"></a>3.1.4.1.3、连续分配管理方式——动态分区分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090450612.png" alt="image-20210508090450612"></p>
<h5 id="1、动态分区分配问题1——系统要用什么样的数据结构记录内存的使用情况"><a href="#1、动态分区分配问题1——系统要用什么样的数据结构记录内存的使用情况" class="headerlink" title="1、动态分区分配问题1——系统要用什么样的数据结构记录内存的使用情况?"></a>1、动态分区分配问题1——系统要用什么样的数据结构记录内存的使用情况?</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090546098.png" alt="image-20210508090546098"></p>
<h5 id="2、动态分区分配问题2——当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配"><a href="#2、动态分区分配问题2——当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配" class="headerlink" title="2、动态分区分配问题2——当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?"></a>2、动态分区分配问题2——当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090650871.png" alt="image-20210508090650871"></p>
<h5 id="3、动态分区分配问题3——如何进行分区的分配与回收操作"><a href="#3、动态分区分配问题3——如何进行分区的分配与回收操作" class="headerlink" title="3、动态分区分配问题3——如何进行分区的分配与回收操作?"></a>3、动态分区分配问题3——如何进行分区的分配与回收操作?</h5><h6 id="1、分配——分配到相对大的空间中"><a href="#1、分配——分配到相对大的空间中" class="headerlink" title="1、分配——分配到相对大的空间中"></a>1、分配——分配到相对大的空间中</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508090911675.png" alt="image-20210508090911675"></p>
<h6 id="2、分配——分配到刚刚好的空间中"><a href="#2、分配——分配到刚刚好的空间中" class="headerlink" title="2、分配——分配到刚刚好的空间中"></a>2、分配——分配到刚刚好的空间中</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508091146057.png" alt="image-20210508091146057"></p>
<h6 id="3、回收——回收区的后面有一个相邻的空闲分区"><a href="#3、回收——回收区的后面有一个相邻的空闲分区" class="headerlink" title="3、回收——回收区的后面有一个相邻的空闲分区"></a>3、回收——回收区的后面有一个相邻的空闲分区</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508091905607.png" alt="image-20210508091905607"></p>
<h6 id="4、回收——回收区的前面有一个相邻的空闲分区"><a href="#4、回收——回收区的前面有一个相邻的空闲分区" class="headerlink" title="4、回收——回收区的前面有一个相邻的空闲分区"></a>4、回收——回收区的前面有一个相邻的空闲分区</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508091821239.png" alt="image-20210508091821239"></p>
<h6 id="5、回收——回收区的前、后面各有一个相邻的空闲分区"><a href="#5、回收——回收区的前、后面各有一个相邻的空闲分区" class="headerlink" title="5、回收——回收区的前、后面各有一个相邻的空闲分区"></a>5、回收——回收区的前、后面各有一个相邻的空闲分区</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508092028487.png" alt="image-20210508092028487"></p>
<h6 id="6、回收——回收区的前、后都没有相邻的空闲分区"><a href="#6、回收——回收区的前、后都没有相邻的空闲分区" class="headerlink" title="6、回收——回收区的前、后都没有相邻的空闲分区"></a>6、回收——回收区的前、后都没有相邻的空闲分区</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508092245786.png" alt="image-20210508092245786"></p>
<h6 id="7、内部碎片与外部碎片"><a href="#7、内部碎片与外部碎片" class="headerlink" title="7、内部碎片与外部碎片"></a>7、内部碎片与外部碎片</h6><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508093103201.png" alt="image-20210508093103201"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508093318950.png" alt="image-20210508093318950"></p>
<h4 id="脑图-20"><a href="#脑图-20" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508093401065.png" alt="image-20210508093401065"></p>
<h4 id="3-1-5、动态分区分配算法"><a href="#3-1-5、动态分区分配算法" class="headerlink" title="3.1.5、动态分区分配算法"></a>3.1.5、动态分区分配算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508093523120.png" alt="image-20210508093523120"></p>
<h5 id="1、首次适应算法-First-Fit"><a href="#1、首次适应算法-First-Fit" class="headerlink" title="1、首次适应算法(First Fit)"></a>1、首次适应算法(First Fit)</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508094125510.png" alt="image-20210508094125510"></p>
<h5 id="2、最佳适应算法-Best-Fit"><a href="#2、最佳适应算法-Best-Fit" class="headerlink" title="2、最佳适应算法(Best Fit)"></a>2、最佳适应算法(Best Fit)</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508095209932.png" alt="image-20210508095209932"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508095244859.png" alt="image-20210508095244859"></p>
<h5 id="3、最坏适应算法-Worst-Fit"><a href="#3、最坏适应算法-Worst-Fit" class="headerlink" title="3、最坏适应算法(Worst Fit)"></a>3、最坏适应算法(Worst Fit)</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508095837523.png" alt="image-20210508095837523"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508095921779.png" alt="image-20210508095921779"></p>
<h5 id="4、邻近适应算法-Next-Fit"><a href="#4、邻近适应算法-Next-Fit" class="headerlink" title="4、邻近适应算法(Next Fit)"></a>4、邻近适应算法(Next Fit)</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508100315188.png" alt="image-20210508100315188"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508102952416.png" alt="image-20210508102952416"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508103130003.png" alt="image-20210508103130003"></p>
<h5 id="5、知识回顾与重要考点-4"><a href="#5、知识回顾与重要考点-4" class="headerlink" title="5、知识回顾与重要考点"></a>5、知识回顾与重要考点</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508100431925.png" alt="image-20210508100431925"></p>
<h3 id="3-1-4、内存空间的分配与回收——非连续分配管理方式"><a href="#3-1-4、内存空间的分配与回收——非连续分配管理方式" class="headerlink" title="3.1.4、内存空间的分配与回收——非连续分配管理方式"></a>3.1.4、内存空间的分配与回收——非连续分配管理方式</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508105913844.png" alt="image-20210508105913844"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508103253793.png" alt="image-20210508103253793"></p>
<h4 id="3-1-4-2-1、非连续分配管理方式——基本分页存储管理方式"><a href="#3-1-4-2-1、非连续分配管理方式——基本分页存储管理方式" class="headerlink" title="3.1.4.2.1、非连续分配管理方式——基本分页存储管理方式"></a>3.1.4.2.1、非连续分配管理方式——基本分页存储管理方式</h4><p>把“固定分区分配”改造为“非连续分配版本”</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508110554274.png" alt="image-20210508110554274"></p>
<h5 id="1、基本分页存储管理的基本概念"><a href="#1、基本分页存储管理的基本概念" class="headerlink" title="1、基本分页存储管理的基本概念"></a>1、基本分页存储管理的基本概念</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508111128672.png" alt="image-20210508111128672"></p>
<h5 id="2、如何实现地址的转换"><a href="#2、如何实现地址的转换" class="headerlink" title="2、如何实现地址的转换"></a>2、如何实现地址的转换</h5><p>进程在内存中连续存放时：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508111333219.png" alt="image-20210508111333219"></p>
<p>主要思想：<strong>模块在内存中的的“起始地址”+ 目标内存单元相对于起始位置的“偏移量”</strong>。</p>
<p>进程在内存中不连续存放时（采用分页存储）：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508111929405.png" alt="image-20210508111929405"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508112229037.png" alt="image-20210508112229037"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508112510315.png" alt="image-20210508112510315"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508112743184.png" alt="image-20210508112743184"></p>
<p>结论：如果每个页面大小为2KB，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。<br>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p>
<h5 id="3、逻辑地址结构"><a href="#3、逻辑地址结构" class="headerlink" title="3、逻辑地址结构"></a>3、逻辑地址结构</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508113103944.png" alt="image-20210508113103944"></p>
<h5 id="4、页表"><a href="#4、页表" class="headerlink" title="4、页表"></a>4、页表</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508113253320.png" alt="image-20210508113253320"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508113414039.png" alt="image-20210508113414039"></p>
<h5 id="脑图-21"><a href="#脑图-21" class="headerlink" title="脑图"></a>脑图</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508113608275.png" alt="image-20210508113608275"></p>
<h4 id="3-1-6、基本地址变换机构"><a href="#3-1-6、基本地址变换机构" class="headerlink" title="3.1.6、基本地址变换机构"></a>3.1.6、基本地址变换机构</h4><p>基本地址变换机构：用于实现逻辑地址到物理地址转换的一组硬件机构</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508133337702.png" alt="image-20210508133337702"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508133401880.png" alt="image-20210508133401880"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508132845186.png" alt="image-20210508132845186"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508132931955.png" alt="image-20210508132931955"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508133601876.png" alt="image-20210508133601876"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508133911049.png" alt="image-20210508133911049"></p>
<h5 id="脑图-22"><a href="#脑图-22" class="headerlink" title="脑图"></a>脑图</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508134019463.png" alt="image-20210508134019463"></p>
<h4 id="3-1-7、具有快表的地址变换机构"><a href="#3-1-7、具有快表的地址变换机构" class="headerlink" title="3.1.7、具有快表的地址变换机构"></a>3.1.7、具有快表的地址变换机构</h4><h5 id="1、局部性原理"><a href="#1、局部性原理" class="headerlink" title="1、局部性原理"></a>1、局部性原理</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508202404524.png" alt="image-20210508202404524"></p>
<h5 id="2、快表（TLB）"><a href="#2、快表（TLB）" class="headerlink" title="2、快表（TLB）"></a>2、快表（TLB）</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508225440701.png" alt="image-20210508225440701"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508225501750.png" alt="image-20210508225501750"></p>
<h5 id="3、引入快表后，地址的变换过程"><a href="#3、引入快表后，地址的变换过程" class="headerlink" title="3、引入快表后，地址的变换过程"></a>3、引入快表后，地址的变换过程</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508225813674.png" alt="image-20210508225813674"></p>
<h5 id="4、知识回顾与重要考点-4"><a href="#4、知识回顾与重要考点-4" class="headerlink" title="4、知识回顾与重要考点"></a>4、知识回顾与重要考点</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508225906098.png" alt="image-20210508225906098"></p>
<h4 id="3-1-8、两级页表"><a href="#3-1-8、两级页表" class="headerlink" title="3.1.8、两级页表"></a>3.1.8、两级页表</h4><h5 id="1、单级页表存在什么问题-如何解决"><a href="#1、单级页表存在什么问题-如何解决" class="headerlink" title="1、单级页表存在什么问题?如何解决?"></a>1、单级页表存在什么问题?如何解决?</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508234002478.png" alt="image-20210508234002478"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508235354588.png" alt="image-20210508235354588"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508235432906.png" alt="image-20210508235432906"></p>
<h5 id="2、两级页表的原理、逻辑地址结构"><a href="#2、两级页表的原理、逻辑地址结构" class="headerlink" title="2、两级页表的原理、逻辑地址结构"></a>2、两级页表的原理、逻辑地址结构</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508235458794.png" alt="image-20210508235458794"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210508235527071.png" alt="image-20210508235527071"></p>
<h5 id="3、如何实现地址变换"><a href="#3、如何实现地址变换" class="headerlink" title="3、如何实现地址变换?"></a>3、如何实现地址变换?</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509002703906.png" alt="image-20210509002703906"></p>
<h5 id="4、如何解决单级页表的问题"><a href="#4、如何解决单级页表的问题" class="headerlink" title="4、如何解决单级页表的问题?"></a>4、如何解决单级页表的问题?</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509002832170.png" alt="image-20210509002832170"></p>
<h5 id="5、两级页表问题需要注意的几个细节"><a href="#5、两级页表问题需要注意的几个细节" class="headerlink" title="5、两级页表问题需要注意的几个细节"></a>5、两级页表问题需要注意的几个细节</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509003331829.png" alt="image-20210509003331829"></p>
<h5 id="脑图-23"><a href="#脑图-23" class="headerlink" title="脑图"></a>脑图</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509003459726.png" alt="image-20210509003459726"></p>
<h4 id="3-1-4-2-2、非连续分配管理方式——基本分段存储管理方式"><a href="#3-1-4-2-2、非连续分配管理方式——基本分段存储管理方式" class="headerlink" title="3.1.4.2.2、非连续分配管理方式——基本分段存储管理方式"></a>3.1.4.2.2、非连续分配管理方式——基本分段存储管理方式</h4><h5 id="1、分段"><a href="#1、分段" class="headerlink" title="1、分段"></a>1、分段</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509004013708.png" alt="image-20210509004013708"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509004209165.png" alt="image-20210509004209165"></p>
<h5 id="2、段表"><a href="#2、段表" class="headerlink" title="2、段表"></a>2、段表</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509004817652.png" alt="image-20210509004817652"></p>
<h5 id="3、地址变换"><a href="#3、地址变换" class="headerlink" title="3、地址变换"></a>3、地址变换</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509004846961.png" alt="image-20210509004846961"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509004926128.png" alt="image-20210509004926128"></p>
<h5 id="4、分段、分页管理的对比"><a href="#4、分段、分页管理的对比" class="headerlink" title="4、分段、分页管理的对比"></a>4、分段、分页管理的对比</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005230009.png" alt="image-20210509005230009"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005348731.png" alt="image-20210509005348731"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005415434.png" alt="image-20210509005415434"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005436167.png" alt="image-20210509005436167"></p>
<h5 id="脑图-24"><a href="#脑图-24" class="headerlink" title="脑图"></a>脑图</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005500533.png" alt="image-20210509005500533"></p>
<h4 id="3-1-4-2-3、非连续分配管理方式——段页式管理方式"><a href="#3-1-4-2-3、非连续分配管理方式——段页式管理方式" class="headerlink" title="3.1.4.2.3、非连续分配管理方式——段页式管理方式"></a>3.1.4.2.3、非连续分配管理方式——段页式管理方式</h4><h5 id="1、分页、分段的优缺点分析"><a href="#1、分页、分段的优缺点分析" class="headerlink" title="1、分页、分段的优缺点分析"></a>1、分页、分段的优缺点分析</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005829321.png" alt="image-20210509005829321"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005855867.png" alt="image-20210509005855867"></p>
<h5 id="2、分段-分页-段页式管理"><a href="#2、分段-分页-段页式管理" class="headerlink" title="2、分段+分页=段页式管理"></a>2、分段+分页=段页式管理</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509005945705.png" alt="image-20210509005945705"></p>
<h5 id="3、段页式管理的逻辑地址结构"><a href="#3、段页式管理的逻辑地址结构" class="headerlink" title="3、段页式管理的逻辑地址结构"></a>3、段页式管理的逻辑地址结构</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509010126138.png" alt="image-20210509010126138"></p>
<h5 id="4、段表、页表"><a href="#4、段表、页表" class="headerlink" title="4、段表、页表"></a>4、段表、页表</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509010510498.png" alt="image-20210509010510498"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509010923423.png" alt="image-20210509010923423"></p>
<h5 id="脑图-25"><a href="#脑图-25" class="headerlink" title="脑图"></a>脑图</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509011052374.png" alt="image-20210509011052374"></p>
<h3 id="3-2-1、虚拟内存的基本概念"><a href="#3-2-1、虚拟内存的基本概念" class="headerlink" title="3.2.1、虚拟内存的基本概念"></a>3.2.1、虚拟内存的基本概念</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509011129396.png" alt="image-20210509011129396"></p>
<h4 id="1、传统存储管理方式的特征、缺点"><a href="#1、传统存储管理方式的特征、缺点" class="headerlink" title="1、传统存储管理方式的特征、缺点"></a>1、传统存储管理方式的特征、缺点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509011637911.png" alt="image-20210509011637911"></p>
<h4 id="2、局部性原理"><a href="#2、局部性原理" class="headerlink" title="2、局部性原理"></a>2、局部性原理</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509011701550.png" alt="image-20210509011701550"></p>
<h4 id="3、虚拟内存的定义和特征"><a href="#3、虚拟内存的定义和特征" class="headerlink" title="3、虚拟内存的定义和特征"></a>3、虚拟内存的定义和特征</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509011935455.png" alt="image-20210509011935455"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012047548.png" alt="image-20210509012047548"></p>
<h4 id="4、如何实现虚拟内存技术"><a href="#4、如何实现虚拟内存技术" class="headerlink" title="4、如何实现虚拟内存技术"></a>4、如何实现虚拟内存技术</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012152298.png" alt="image-20210509012152298"></p>
<h4 id="脑图-26"><a href="#脑图-26" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012242692.png" alt="image-20210509012242692"></p>
<h3 id="3-2-2、请求分页管理方式"><a href="#3-2-2、请求分页管理方式" class="headerlink" title="3.2.2、请求分页管理方式"></a>3.2.2、请求分页管理方式</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012615162.png" alt="image-20210509012615162"></p>
<h4 id="1、页表机制"><a href="#1、页表机制" class="headerlink" title="1、页表机制"></a>1、页表机制</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012717541.png" alt="image-20210509012717541"></p>
<h4 id="2、缺页中断机构"><a href="#2、缺页中断机构" class="headerlink" title="2、缺页中断机构"></a>2、缺页中断机构</h4><p>内存中存在空闲块：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509013338043.png" alt="image-20210509013338043"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012743561.png" alt="image-20210509012743561"></p>
<p>内存中不存在空闲块：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509013627907.png" alt="image-20210509013627907"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012801635.png" alt="image-20210509012801635"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012828125.png" alt="image-20210509012828125"></p>
<h4 id="3、地址变换机构"><a href="#3、地址变换机构" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012911260.png" alt="image-20210509012911260"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509013853533.png" alt="image-20210509013853533"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509013943280.png" alt="image-20210509013943280"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014238955.png" alt="image-20210509014238955"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014011536.png" alt="image-20210509014011536"></p>
<h4 id="脑图-27"><a href="#脑图-27" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509012956979.png" alt="image-20210509012956979"></p>
<h3 id="3-2-3、页面置换算法"><a href="#3-2-3、页面置换算法" class="headerlink" title="3.2.3、页面置换算法"></a>3.2.3、页面置换算法</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014356859.png" alt="image-20210509014356859"></p>
<h4 id="1、页面置换算法——最佳置换算法-OPT"><a href="#1、页面置换算法——最佳置换算法-OPT" class="headerlink" title="1、页面置换算法——最佳置换算法(OPT)"></a>1、页面置换算法——最佳置换算法(OPT)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014635661.png" alt="image-20210509014635661"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014650392.png" alt="image-20210509014650392"></p>
<h4 id="2、页面置换算法——先进先出置换算法-FIFO"><a href="#2、页面置换算法——先进先出置换算法-FIFO" class="headerlink" title="2、页面置换算法——先进先出置换算法(FIFO)"></a>2、页面置换算法——先进先出置换算法(FIFO)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014718214.png" alt="image-20210509014718214"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014853923.png" alt="image-20210509014853923"></p>
<h4 id="3、页面置换算法——最近最久未使用置换算法-LRU"><a href="#3、页面置换算法——最近最久未使用置换算法-LRU" class="headerlink" title="3、页面置换算法——最近最久未使用置换算法(LRU)"></a>3、页面置换算法——最近最久未使用置换算法(LRU)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509014927703.png" alt="image-20210509014927703"></p>
<h4 id="4、页面置换算法——时钟置换算法-CLOCK"><a href="#4、页面置换算法——时钟置换算法-CLOCK" class="headerlink" title="4、页面置换算法——时钟置换算法(CLOCK )"></a>4、页面置换算法——时钟置换算法(CLOCK )</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509015030833.png" alt="image-20210509015030833"></p>
<h4 id="5、页面置换算法——改进型的时钟置换算法"><a href="#5、页面置换算法——改进型的时钟置换算法" class="headerlink" title="5、页面置换算法——改进型的时钟置换算法"></a>5、页面置换算法——改进型的时钟置换算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509021015176.png" alt="image-20210509021015176"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509021320133.png" alt="image-20210509021320133"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509021715893.png" alt="image-20210509021715893"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022026524.png" alt="image-20210509022026524"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022148622.png" alt="image-20210509022148622"></p>
<h4 id="6、知识回顾与重要考点"><a href="#6、知识回顾与重要考点" class="headerlink" title="6、知识回顾与重要考点"></a>6、知识回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509015408768.png" alt="image-20210509015408768"></p>
<h3 id="3-2-4、页面分配策略"><a href="#3-2-4、页面分配策略" class="headerlink" title="3.2.4、页面分配策略"></a>3.2.4、页面分配策略</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022248848.png" alt="image-20210509022248848"></p>
<h4 id="1、页面分配、置换策略"><a href="#1、页面分配、置换策略" class="headerlink" title="1、页面分配、置换策略"></a>1、页面分配、置换策略</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022843592.png" alt="image-20210509022843592"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509023042278.png" alt="image-20210509023042278"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509023615272.png" alt="image-20210509023615272"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509023233829.png" alt="image-20210509023233829"></p>
<h4 id="2、何时调入页面"><a href="#2、何时调入页面" class="headerlink" title="2、何时调入页面"></a>2、何时调入页面</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022356148.png" alt="image-20210509022356148"></p>
<p><strong>预调页策略和请求调页策略一般会结合着进行使用。</strong></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022420725.png" alt="image-20210509022420725"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022441309.png" alt="image-20210509022441309"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022505874.png" alt="image-20210509022505874"></p>
<h4 id="3、抖动-颠簸-现象"><a href="#3、抖动-颠簸-现象" class="headerlink" title="3、抖动(颠簸)现象"></a>3、抖动(颠簸)现象</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022535523.png" alt="image-20210509022535523"></p>
<h4 id="4、工作集"><a href="#4、工作集" class="headerlink" title="4、工作集"></a>4、工作集</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022604479.png" alt="image-20210509022604479"></p>
<h4 id="脑图-28"><a href="#脑图-28" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210509022634991.png" alt="image-20210509022634991"></p>
<h2 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h2><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2020070418564667.jpg" alt="在这里插入图片描述"></p>
<h3 id="4-1-1、初识文件管理"><a href="#4-1-1、初识文件管理" class="headerlink" title="4.1.1、初识文件管理"></a>4.1.1、初识文件管理</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510172015086.png" alt="image-20210510172015086"></p>
<h4 id="1、Windows操作系统的文件管理"><a href="#1、Windows操作系统的文件管理" class="headerlink" title="1、Windows操作系统的文件管理"></a>1、Windows操作系统的文件管理</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510173929518.png" alt="image-20210510173929518"></p>
<h4 id="2、文件的属性"><a href="#2、文件的属性" class="headerlink" title="2、文件的属性"></a>2、文件的属性</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510172305330.png" alt="image-20210510172305330"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510172426075.png" alt="image-20210510172426075"></p>
<h4 id="3、文件内部的数据应该怎样组织起来"><a href="#3、文件内部的数据应该怎样组织起来" class="headerlink" title="3、文件内部的数据应该怎样组织起来?"></a>3、文件内部的数据应该怎样组织起来?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510173839817.png" alt="image-20210510173839817"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510173958010.png" alt="image-20210510173958010"></p>
<h4 id="4、文件之间应该怎样组织起来"><a href="#4、文件之间应该怎样组织起来" class="headerlink" title="4、文件之间应该怎样组织起来?"></a>4、文件之间应该怎样组织起来?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174052984.png" alt="image-20210510174052984"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174111553.png" alt="image-20210510174111553"></p>
<h4 id="5、操作系统应该向上提供哪些功能"><a href="#5、操作系统应该向上提供哪些功能" class="headerlink" title="5、操作系统应该向上提供哪些功能?"></a>5、操作系统应该向上提供哪些功能?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174132287.png" alt="image-20210510174132287"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174152635.png" alt="image-20210510174152635"></p>
<h4 id="6、从上往下看，文件应如何存放在外存？"><a href="#6、从上往下看，文件应如何存放在外存？" class="headerlink" title="6、从上往下看，文件应如何存放在外存？"></a>6、从上往下看，文件应如何存放在外存？</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174208743.png" alt="image-20210510174208743"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174229192.png" alt="image-20210510174229192"></p>
<h4 id="7、其他需要由操作系统实现的文件管理功能"><a href="#7、其他需要由操作系统实现的文件管理功能" class="headerlink" title="7、其他需要由操作系统实现的文件管理功能"></a>7、其他需要由操作系统实现的文件管理功能</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174244099.png" alt="image-20210510174244099"></p>
<h4 id="脑图-29"><a href="#脑图-29" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174258642.png" alt="image-20210510174258642"></p>
<h3 id="4-1-2、文件的逻辑结构"><a href="#4-1-2、文件的逻辑结构" class="headerlink" title="4.1.2、文件的逻辑结构"></a>4.1.2、文件的逻辑结构</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174403271.png" alt="image-20210510174403271"></p>
<h4 id="1、无结构文件"><a href="#1、无结构文件" class="headerlink" title="1、无结构文件"></a>1、无结构文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174420173.png" alt="image-20210510174420173"></p>
<h4 id="2、有结构文件"><a href="#2、有结构文件" class="headerlink" title="2、有结构文件"></a>2、有结构文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174437959.png" alt="image-20210510174420173"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174511007.png" alt="image-20210510174511007"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174533798.png" alt="image-20210510174533798"></p>
<h4 id="3、有结构文件的逻辑结构"><a href="#3、有结构文件的逻辑结构" class="headerlink" title="3、有结构文件的逻辑结构"></a>3、有结构文件的逻辑结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174614541.png" alt="image-20210510174614541"></p>
<h4 id="4、顺序文件"><a href="#4、顺序文件" class="headerlink" title="4、顺序文件"></a>4、顺序文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174647781.png" alt="image-20210510174647781"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174712891.png" alt="image-20210510174712891"></p>
<h4 id="5、索引文件"><a href="#5、索引文件" class="headerlink" title="5、索引文件"></a>5、索引文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174742627.png" alt="image-20210510174742627"></p>
<h4 id="6、索引顺序文件"><a href="#6、索引顺序文件" class="headerlink" title="6、索引顺序文件"></a>6、索引顺序文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174824341.png" alt="image-20210510174824341"></p>
<h4 id="7、索引顺序文件-检索效率分析"><a href="#7、索引顺序文件-检索效率分析" class="headerlink" title="7、索引顺序文件(检索效率分析)"></a>7、索引顺序文件(检索效率分析)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174900571.png" alt="image-20210510174900571"></p>
<h4 id="8、多级索引顺序文件"><a href="#8、多级索引顺序文件" class="headerlink" title="8、多级索引顺序文件"></a>8、多级索引顺序文件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510174937291.png" alt="image-20210510174937291"></p>
<h4 id="脑图-30"><a href="#脑图-30" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510175000352.png" alt="image-20210510175000352"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510175034205.png" alt="image-20210510175034205"></p>
<h3 id="4-1-3、文件目录"><a href="#4-1-3、文件目录" class="headerlink" title="4.1.3、文件目录"></a>4.1.3、文件目录</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510180705930.png" alt="image-20210510180705930"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510180724124.png" alt="image-20210510180724124"></p>
<h4 id="1、文件控制块"><a href="#1、文件控制块" class="headerlink" title="1、文件控制块"></a>1、文件控制块</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510180808309.png" alt="image-20210510180808309"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181628502.png" alt="image-20210510181628502"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181647855.png" alt="image-20210510181647855"></p>
<h4 id="2、目录结构——单级目录结构"><a href="#2、目录结构——单级目录结构" class="headerlink" title="2、目录结构——单级目录结构"></a>2、目录结构——单级目录结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181719480.png" alt="image-20210510181719480"></p>
<h4 id="3、目录结构——两级目录结构"><a href="#3、目录结构——两级目录结构" class="headerlink" title="3、目录结构——两级目录结构"></a>3、目录结构——两级目录结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181749558.png" alt="image-20210510181749558"></p>
<h4 id="4、目录结构——多级目录结构"><a href="#4、目录结构——多级目录结构" class="headerlink" title="4、目录结构——多级目录结构"></a>4、目录结构——多级目录结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181840085.png" alt="image-20210510181840085"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181919035.png" alt="image-20210510181919035"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510181942460.png" alt="image-20210510181942460"></p>
<h4 id="5、目录结构——无环图目录结构"><a href="#5、目录结构——无环图目录结构" class="headerlink" title="5、目录结构——无环图目录结构"></a>5、目录结构——无环图目录结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510182039884.png" alt="image-20210510182039884"></p>
<h4 id="6、索引结点-FCB的改进"><a href="#6、索引结点-FCB的改进" class="headerlink" title="6、索引结点(FCB的改进)"></a>6、索引结点(FCB的改进)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510182124127.png" alt="image-20210510182124127"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510182257634.png" alt="image-20210510182257634"></p>
<h4 id="脑图-31"><a href="#脑图-31" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510182328384.png" alt="image-20210510182328384"></p>
<h3 id="4-1-4、文件的物理结构（文件分配方式）"><a href="#4-1-4、文件的物理结构（文件分配方式）" class="headerlink" title="4.1.4、文件的物理结构（文件分配方式）"></a>4.1.4、文件的物理结构（文件分配方式）</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510184057179.png" alt="image-20210510184057179"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510184143772.png" alt="image-20210510184143772"></p>
<h4 id="1、文件块、磁盘块"><a href="#1、文件块、磁盘块" class="headerlink" title="1、文件块、磁盘块"></a>1、文件块、磁盘块</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510184202356.png" alt="image-20210510184202356"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510184234195.png" alt="image-20210510184234195"></p>
<h4 id="2、文件分配方式——连续分配"><a href="#2、文件分配方式——连续分配" class="headerlink" title="2、文件分配方式——连续分配"></a>2、文件分配方式——连续分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510184517016.png" alt="image-20210510184517016"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510194304195.png" alt="image-20210510194304195"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510194321776.png" alt="image-20210510194321776"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510194418244.png" alt="image-20210510194418244"></p>
<p>总结：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510194438017.png" alt="image-20210510194438017"></p>
<h4 id="3、文件分配方式——链接分配"><a href="#3、文件分配方式——链接分配" class="headerlink" title="3、文件分配方式——链接分配"></a>3、文件分配方式——链接分配</h4><p><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</p>
<h4 id="4、链接分配——隐式链接"><a href="#4、链接分配——隐式链接" class="headerlink" title="4、链接分配——隐式链接"></a>4、链接分配——隐式链接</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200010895.png" alt="image-20210510200010895"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200055678.png" alt="image-20210510200055678"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200134964.png" alt="image-20210510200134964"></p>
<h4 id="5、链接分配——显式链接"><a href="#5、链接分配——显式链接" class="headerlink" title="5、链接分配——显式链接"></a>5、链接分配——显式链接</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200212233.png" alt="image-20210510200212233"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200226440.png" alt="image-20210510200226440"></p>
<h4 id="6、链接分配-总结"><a href="#6、链接分配-总结" class="headerlink" title="6、链接分配(总结)"></a>6、链接分配(总结)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200242086.png" alt="image-20210510200242086"></p>
<h4 id="7、文件分配方式——索引分配"><a href="#7、文件分配方式——索引分配" class="headerlink" title="7、文件分配方式——索引分配"></a>7、文件分配方式——索引分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200330776.png" alt="image-20210510200330776"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200346364.png" alt="image-20210510200346364"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200418312.png" alt="image-20210510200418312"></p>
<h5 id="1、索引分配——链接方案"><a href="#1、索引分配——链接方案" class="headerlink" title="1、索引分配——链接方案"></a>1、索引分配——链接方案</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200434973.png" alt="image-20210510200434973"></p>
<h5 id="2、索引分配——多层索引"><a href="#2、索引分配——多层索引" class="headerlink" title="2、索引分配——多层索引"></a>2、索引分配——多层索引</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200449834.png" alt="image-20210510200449834"></p>
<h5 id="3、索引分配——混合索引"><a href="#3、索引分配——混合索引" class="headerlink" title="3、索引分配——混合索引"></a>3、索引分配——混合索引</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510203950212.png" alt="image-20210510203950212"></p>
<h4 id="8、索引分配-总结"><a href="#8、索引分配-总结" class="headerlink" title="8、索引分配(总结)"></a>8、索引分配(总结)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200553830.png" alt="image-20210510200553830"></p>
<h4 id="9、知识点回顾与重要考点"><a href="#9、知识点回顾与重要考点" class="headerlink" title="9、知识点回顾与重要考点"></a>9、知识点回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200625936.png" alt="image-20210510200625936"></p>
<h4 id="10、易混难点-支持随机访问"><a href="#10、易混难点-支持随机访问" class="headerlink" title="10、易混难点:支持随机访问"></a>10、易混难点:支持随机访问</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510200653421.png" alt="image-20210510200653421"></p>
<h3 id="4-1-5、文件存储空间管理"><a href="#4-1-5、文件存储空间管理" class="headerlink" title="4.1.5、文件存储空间管理"></a>4.1.5、文件存储空间管理</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204351623.png" alt="image-20210510204351623"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204422297.png" alt="image-20210510204422297"></p>
<h4 id="1、存储空间的划分与初始化"><a href="#1、存储空间的划分与初始化" class="headerlink" title="1、存储空间的划分与初始化"></a>1、存储空间的划分与初始化</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204534899.png" alt="image-20210510204534899"></p>
<h4 id="2、存储空间管理——空闲表法"><a href="#2、存储空间管理——空闲表法" class="headerlink" title="2、存储空间管理——空闲表法"></a>2、存储空间管理——空闲表法</h4><p>分配：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204736595.png" alt="image-20210510204736595"></p>
<p>回收：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204759316.png" alt="image-20210510204759316"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204857398.png" alt="image-20210510204857398"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510204918112.png" alt="image-20210510204918112"></p>
<h4 id="3、存储空间管理——空闲链表法"><a href="#3、存储空间管理——空闲链表法" class="headerlink" title="3、存储空间管理——空闲链表法"></a>3、存储空间管理——空闲链表法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205032206.png" alt="image-20210510205032206"></p>
<h5 id="1、空闲链表法——空闲盘块链"><a href="#1、空闲链表法——空闲盘块链" class="headerlink" title="1、空闲链表法——空闲盘块链"></a>1、空闲链表法——空闲盘块链</h5><p>分配与回收：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205148716.png" alt="image-20210510205148716"></p>
<h5 id="2、空闲链表法——空闲盘区链"><a href="#2、空闲链表法——空闲盘区链" class="headerlink" title="2、空闲链表法——空闲盘区链"></a>2、空闲链表法——空闲盘区链</h5><p>分配与回收：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205259520.png" alt="image-20210510205259520"></p>
<h4 id="4、存储空间管理——位示图法"><a href="#4、存储空间管理——位示图法" class="headerlink" title="4、存储空间管理——位示图法"></a>4、存储空间管理——位示图法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205536697.png" alt="image-20210510205536697"></p>
<p>分配与回收：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205642666.png" alt="image-20210510205642666"></p>
<h4 id="5、存储空间管理——成组链接法"><a href="#5、存储空间管理——成组链接法" class="headerlink" title="5、存储空间管理——成组链接法"></a>5、存储空间管理——成组链接法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510205738193.png" alt="image-20210510205738193"></p>
<p>分配：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210218546.png" alt="image-20210510210218546"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210320053.png" alt="image-20210510210320053"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210351181.png" alt="image-20210510210351181"></p>
<p>回收：</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210747340.png" alt="image-20210510210747340"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210839939.png" alt="image-20210510210839939"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510210915503.png" alt="image-20210510210915503"></p>
<h4 id="脑图-32"><a href="#脑图-32" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211017588.png" alt="image-20210510211017588"></p>
<h3 id="4-1-6、文件的基本操作"><a href="#4-1-6、文件的基本操作" class="headerlink" title="4.1.6、文件的基本操作"></a>4.1.6、文件的基本操作</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211109649.png" alt="image-20210510211109649"></p>
<h4 id="1、创建文件-create系统调用"><a href="#1、创建文件-create系统调用" class="headerlink" title="1、创建文件(create系统调用)"></a>1、创建文件(create系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211530217.png" alt="image-20210510211530217"></p>
<h4 id="2、删除文件-delete系统调用"><a href="#2、删除文件-delete系统调用" class="headerlink" title="2、删除文件(delete系统调用)"></a>2、删除文件(delete系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211600032.png" alt="image-20210510211600032"></p>
<h4 id="3、打开文件-open系统调用"><a href="#3、打开文件-open系统调用" class="headerlink" title="3、打开文件(open系统调用)"></a>3、打开文件(open系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5Cimage-20210510211623264.png" alt="image-20210510211623264"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211657842.png" alt="image-20210510211657842"></p>
<h4 id="4、关闭文件-close系统调用"><a href="#4、关闭文件-close系统调用" class="headerlink" title="4、关闭文件(close系统调用)"></a>4、关闭文件(close系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211854855.png" alt="image-20210510211854855"></p>
<h4 id="5、读文件-read系统调用"><a href="#5、读文件-read系统调用" class="headerlink" title="5、读文件(read系统调用)"></a>5、读文件(read系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211726508.png" alt="image-20210510211726508"></p>
<h4 id="6、写文件-write系统调用"><a href="#6、写文件-write系统调用" class="headerlink" title="6、写文件(write系统调用)"></a>6、写文件(write系统调用)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211835280.png" alt="image-20210510211835280"></p>
<h4 id="脑图-33"><a href="#脑图-33" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510211746762.png" alt="image-20210510211746762"></p>
<h3 id="4-1-7、文件共享"><a href="#4-1-7、文件共享" class="headerlink" title="4.1.7、文件共享"></a>4.1.7、文件共享</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213241349.png" alt="image-20210510213241349"></p>
<h4 id="1、基于索引结点的共享方式-硬链接"><a href="#1、基于索引结点的共享方式-硬链接" class="headerlink" title="1、基于索引结点的共享方式(硬链接)"></a>1、基于索引结点的共享方式(硬链接)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213311954.png" alt="image-20210510213311954"></p>
<h4 id="2、基于符号链的共享方式-软链接"><a href="#2、基于符号链的共享方式-软链接" class="headerlink" title="2、基于符号链的共享方式(软链接)"></a>2、基于符号链的共享方式(软链接)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213347172.png" alt="image-20210510213347172"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213403610.png" alt="image-20210510213403610"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213429991.png" alt="image-20210510213429991"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213445471.png" alt="image-20210510213445471"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213503692.png" alt="image-20210510213503692"></p>
<h4 id="脑图-34"><a href="#脑图-34" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213537878.png" alt="image-20210510213537878"></p>
<h3 id="4-1-8、文件保护"><a href="#4-1-8、文件保护" class="headerlink" title="4.1.8、文件保护"></a>4.1.8、文件保护</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510213617783.png" alt="image-20210510213617783"></p>
<h4 id="1、口令保护"><a href="#1、口令保护" class="headerlink" title="1、口令保护"></a>1、口令保护</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214250894.png" alt="image-20210510214250894"></p>
<h4 id="2、加密保护"><a href="#2、加密保护" class="headerlink" title="2、加密保护"></a>2、加密保护</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214328225.png" alt="image-20210510214328225"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214402046.png" alt="image-20210510214402046"></p>
<h4 id="3、访问控制"><a href="#3、访问控制" class="headerlink" title="3、访问控制"></a>3、访问控制</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214438312.png" alt="image-20210510214438312"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214452912.png" alt="image-20210510214452912"></p>
<h4 id="4、Windows的访问控制"><a href="#4、Windows的访问控制" class="headerlink" title="4、Windows的访问控制"></a>4、Windows的访问控制</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214521631.png" alt="image-20210510214521631"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214610135.png" alt="image-20210510214610135">\</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214635252.png" alt="image-20210510214635252"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214651156.png" alt="image-20210510214651156"></p>
<h4 id="脑图-35"><a href="#脑图-35" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214712283.png" alt="image-20210510214712283"></p>
<h3 id="4-1-9、文件系统的层次结构"><a href="#4-1-9、文件系统的层次结构" class="headerlink" title="4.1.9、文件系统的层次结构"></a>4.1.9、文件系统的层次结构</h3><h4 id="1、文件系统的层次结构"><a href="#1、文件系统的层次结构" class="headerlink" title="1、文件系统的层次结构"></a>1、文件系统的层次结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510215918389.png" alt="image-20210510215918389"></p>
<h4 id="2、知识点回顾与重要考点"><a href="#2、知识点回顾与重要考点" class="headerlink" title="2、知识点回顾与重要考点"></a>2、知识点回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220046997.png" alt="image-20210510220046997"></p>
<h3 id="4-2-1、磁盘的结构"><a href="#4-2-1、磁盘的结构" class="headerlink" title="4.2.1、磁盘的结构"></a>4.2.1、磁盘的结构</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510214754390.png" alt="image-20210510214754390"></p>
<h4 id="1、磁盘、磁道、扇区"><a href="#1、磁盘、磁道、扇区" class="headerlink" title="1、磁盘、磁道、扇区"></a>1、磁盘、磁道、扇区</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220120936.png" alt="image-20210510220120936"></p>
<h4 id="2、如何在磁盘中读-写数据"><a href="#2、如何在磁盘中读-写数据" class="headerlink" title="2、如何在磁盘中读/写数据"></a>2、如何在磁盘中读/写数据</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220141125.png" alt="image-20210510220141125"></p>
<h4 id="3、盘面、柱面"><a href="#3、盘面、柱面" class="headerlink" title="3、盘面、柱面"></a>3、盘面、柱面</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220307505.png" alt="image-20210510220307505"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220318911.png" alt="image-20210510220318911"></p>
<h4 id="4、磁盘的物理地址"><a href="#4、磁盘的物理地址" class="headerlink" title="4、磁盘的物理地址"></a>4、磁盘的物理地址</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220334460.png" alt="image-20210510220334460"></p>
<h4 id="5、磁盘的分类"><a href="#5、磁盘的分类" class="headerlink" title="5、磁盘的分类"></a>5、磁盘的分类</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220354743.png" alt="image-20210510220354743"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220409094.png" alt="image-20210510220409094"></p>
<h4 id="脑图-36"><a href="#脑图-36" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220429976.png" alt="image-20210510220429976"></p>
<h3 id="4-2-2、磁盘调度算法"><a href="#4-2-2、磁盘调度算法" class="headerlink" title="4.2.2、磁盘调度算法"></a>4.2.2、磁盘调度算法</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510220523176.png" alt="image-20210510220523176"></p>
<h4 id="1、一次磁盘读-写操作需要的时间"><a href="#1、一次磁盘读-写操作需要的时间" class="headerlink" title="1、一次磁盘读/写操作需要的时间"></a>1、一次磁盘读/写操作需要的时间</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221358877.png" alt="image-20210510221358877"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221414332.png" alt="image-20210510221414332"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221430472.png" alt="image-20210510221430472"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221444551.png" alt="image-20210510221444551"></p>
<h4 id="2、先来先服务算法-FCFS"><a href="#2、先来先服务算法-FCFS" class="headerlink" title="2、先来先服务算法(FCFS)"></a>2、先来先服务算法(FCFS)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221458167.png" alt="image-20210510221458167"></p>
<h4 id="3、最短寻找时间优先-SSTF"><a href="#3、最短寻找时间优先-SSTF" class="headerlink" title="3、最短寻找时间优先(SSTF)"></a>3、最短寻找时间优先(SSTF)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221515203.png" alt="image-20210510221515203"></p>
<h4 id="4、扫描算法-SCAN"><a href="#4、扫描算法-SCAN" class="headerlink" title="4、扫描算法(SCAN)"></a>4、扫描算法(SCAN)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221530897.png" alt="image-20210510221530897"></p>
<h4 id="5、LOOK调度算法"><a href="#5、LOOK调度算法" class="headerlink" title="5、LOOK调度算法"></a>5、LOOK调度算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221552395.png" alt="image-20210510221552395"></p>
<h4 id="6、循环扫描算法-C-SCAN"><a href="#6、循环扫描算法-C-SCAN" class="headerlink" title="6、循环扫描算法(C-SCAN)"></a>6、循环扫描算法(C-SCAN)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221622445.png" alt="image-20210510221622445"></p>
<h4 id="7、C-LOOK调度算法"><a href="#7、C-LOOK调度算法" class="headerlink" title="7、C-LOOK调度算法"></a>7、C-LOOK调度算法</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221637101.png" alt="image-20210510221637101"></p>
<h4 id="脑图-37"><a href="#脑图-37" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221654417.png" alt="image-20210510221654417"></p>
<h3 id="4-2-3、减少磁盘延迟时间的方法"><a href="#4-2-3、减少磁盘延迟时间的方法" class="headerlink" title="4.2.3、减少磁盘延迟时间的方法"></a>4.2.3、减少磁盘延迟时间的方法</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510221738068.png" alt="image-20210510221738068"></p>
<h4 id="1、减少延迟时间的方法：交替编号"><a href="#1、减少延迟时间的方法：交替编号" class="headerlink" title="1、减少延迟时间的方法：交替编号"></a>1、减少延迟时间的方法：交替编号</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223254723.png" alt="image-20210510223254723"></p>
<h4 id="2、磁盘地址结构的设计"><a href="#2、磁盘地址结构的设计" class="headerlink" title="2、磁盘地址结构的设计"></a>2、磁盘地址结构的设计</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223311665.png" alt="image-20210510223311665"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223329605.png" alt="image-20210510223329605"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223343018.png" alt="image-20210510223343018"></p>
<h4 id="3、减少延迟时间的方法-错位命名"><a href="#3、减少延迟时间的方法-错位命名" class="headerlink" title="3、减少延迟时间的方法:错位命名"></a>3、减少延迟时间的方法:错位命名</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223402335.png" alt="image-20210510223402335"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223414358.png" alt="image-20210510223414358"></p>
<h4 id="脑图-38"><a href="#脑图-38" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510223427091.png" alt="image-20210510223427091"></p>
<h3 id="4-2-4、磁盘的管理"><a href="#4-2-4、磁盘的管理" class="headerlink" title="4.2.4、磁盘的管理"></a>4.2.4、磁盘的管理</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224338889.png" alt="image-20210510224338889"></p>
<h4 id="1、磁盘初始化"><a href="#1、磁盘初始化" class="headerlink" title="1、磁盘初始化"></a>1、磁盘初始化</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224546394.png" alt="image-20210510224546394"></p>
<h4 id="2、引导块"><a href="#2、引导块" class="headerlink" title="2、引导块"></a>2、引导块</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224644253.png" alt="image-20210510224644253"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224801174.png" alt="image-20210510224801174"></p>
<h4 id="3、坏块的管理"><a href="#3、坏块的管理" class="headerlink" title="3、坏块的管理"></a>3、坏块的管理</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224912088.png" alt="image-20210510224912088"></p>
<h4 id="脑图-39"><a href="#脑图-39" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210510224948374.png" alt="image-20210510224948374"></p>
<h2 id="第五章-I-O管理"><a href="#第五章-I-O管理" class="headerlink" title="第五章  I/O管理"></a>第五章  I/O管理</h2><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200704185555587.jpg" alt="img"></p>
<h3 id="5-1-1、I-O设备的概含和分类"><a href="#5-1-1、I-O设备的概含和分类" class="headerlink" title="5.1.1、I/O设备的概含和分类"></a>5.1.1、I/O设备的概含和分类</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511110804479.png" alt="image-20210511110804479"></p>
<h3 id="1、什么是I-O设备"><a href="#1、什么是I-O设备" class="headerlink" title="1、什么是I/O设备"></a>1、什么是I/O设备</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111043854.png" alt="image-20210511111043854"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111059679.png" alt="image-20210511111059679"></p>
<h4 id="2、I-O设备的分类——按使用特性"><a href="#2、I-O设备的分类——按使用特性" class="headerlink" title="2、I/O设备的分类——按使用特性"></a>2、I/O设备的分类——按使用特性</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111151164.png" alt="image-20210511111151164"></p>
<h4 id="3、I-O设备的分类——按传输速率分类"><a href="#3、I-O设备的分类——按传输速率分类" class="headerlink" title="3、I/O设备的分类——按传输速率分类"></a>3、I/O设备的分类——按传输速率分类</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111340325.png" alt="image-20210511111340325"></p>
<h4 id="4、I-O设备的分类——按信息交换的单位分类"><a href="#4、I-O设备的分类——按信息交换的单位分类" class="headerlink" title="4、I/O设备的分类——按信息交换的单位分类"></a>4、I/O设备的分类——按信息交换的单位分类</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111357178.png" alt="image-20210511111357178"></p>
<h4 id="脑图-40"><a href="#脑图-40" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111317058.png" alt="image-20210511111317058"></p>
<h3 id="5-1-2、IO控制器"><a href="#5-1-2、IO控制器" class="headerlink" title="5.1.2、IO控制器"></a>5.1.2、IO控制器</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111508063.png" alt="image-20210511111508063"></p>
<h4 id="1、I-O设备的机械部件"><a href="#1、I-O设备的机械部件" class="headerlink" title="1、I/O设备的机械部件"></a>1、I/O设备的机械部件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112240342.png" alt="image-20210511112240342"></p>
<h4 id="2、I-O设备的电子部件-I-O控制器"><a href="#2、I-O设备的电子部件-I-O控制器" class="headerlink" title="2、I/O设备的电子部件(I/O控制器)"></a>2、I/O设备的电子部件(I/O控制器)</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112302574.png" alt="image-20210511112302574"></p>
<h4 id="3、I-O控制器的组成"><a href="#3、I-O控制器的组成" class="headerlink" title="3、I/O控制器的组成"></a>3、I/O控制器的组成</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112323795.png" alt="image-20210511112323795"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112339935.png" alt="image-20210511112339935"></p>
<h4 id="4、内存映像I-O-VS-寄存器独立编址"><a href="#4、内存映像I-O-VS-寄存器独立编址" class="headerlink" title="4、内存映像I/O VS 寄存器独立编址"></a>4、内存映像I/O VS 寄存器独立编址</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112409008.png" alt="image-20210511112409008"></p>
<h4 id="脑图-41"><a href="#脑图-41" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511111721235.png" alt="image-20210511111721235"></p>
<h3 id="5-1-3、IO控制方式"><a href="#5-1-3、IO控制方式" class="headerlink" title="5.1.3、IO控制方式"></a>5.1.3、IO控制方式</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511112526466.png" alt="image-20210511112526466"></p>
<h4 id="1、程序直接控制方式"><a href="#1、程序直接控制方式" class="headerlink" title="1、程序直接控制方式"></a>1、程序直接控制方式</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114118768.png" alt="image-20210511114118768"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114144636.png" alt="image-20210511114144636"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114203481.png" alt="image-20210511114203481"></p>
<h4 id="2、中断驱动方式"><a href="#2、中断驱动方式" class="headerlink" title="2、中断驱动方式"></a>2、中断驱动方式</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114219032.png" alt="image-20210511114219032"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114237657.png" alt="image-20210511114237657"></p>
<h4 id="3、DMA方式"><a href="#3、DMA方式" class="headerlink" title="3、DMA方式"></a>3、DMA方式</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114254744.png" alt="image-20210511114254744"></p>
<p>DMA控制器</p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114311516.png" alt="image-20210511114311516"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114331876.png" alt="image-20210511114331876"></p>
<h4 id="4、通道控制方式"><a href="#4、通道控制方式" class="headerlink" title="4、通道控制方式"></a>4、通道控制方式</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114349325.png" alt="image-20210511114349325"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114404292.png" alt="image-20210511114404292"></p>
<h4 id="5、知识点回顾与重要考点"><a href="#5、知识点回顾与重要考点" class="headerlink" title="5、知识点回顾与重要考点"></a>5、知识点回顾与重要考点</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114426856.png" alt="image-20210511114426856"></p>
<h3 id="5-1-4、IO软件层次结构"><a href="#5-1-4、IO软件层次结构" class="headerlink" title="5.1.4、IO软件层次结构"></a>5.1.4、IO软件层次结构</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511114507050.png" alt="image-20210511114507050"></p>
<h4 id="1、用户层软件"><a href="#1、用户层软件" class="headerlink" title="1、用户层软件"></a>1、用户层软件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120145365.png" alt="image-20210511120145365"></p>
<h4 id="2、设备独立性软件"><a href="#2、设备独立性软件" class="headerlink" title="2、设备独立性软件"></a>2、设备独立性软件</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120201000.png" alt="image-20210511120201000"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120214522.png" alt="image-20210511120214522"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120232118.png" alt="image-20210511120232118"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120247174.png" alt="image-20210511120247174"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120308807.png" alt="image-20210511120308807"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120347783.png" alt="image-20210511120347783"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120406389.png" alt="image-20210511120406389"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120422617.png" alt="image-20210511120422617"></p>
<h4 id="3、思考：为何不同的设备需要不同的设备驱动程序"><a href="#3、思考：为何不同的设备需要不同的设备驱动程序" class="headerlink" title="3、思考：为何不同的设备需要不同的设备驱动程序?"></a>3、思考：为何不同的设备需要不同的设备驱动程序?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120439359.png" alt="image-20210511120439359"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120454305.png" alt="image-20210511120454305"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120511147.png" alt="image-20210511120511147"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120524487.png" alt="image-20210511120524487"></p>
<h4 id="4、设备驱动程序"><a href="#4、设备驱动程序" class="headerlink" title="4、设备驱动程序"></a>4、设备驱动程序</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120542492.png" alt="image-20210511120542492"></p>
<h4 id="5、中断处理程序"><a href="#5、中断处理程序" class="headerlink" title="5、中断处理程序"></a>5、中断处理程序</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120601060.png" alt="image-20210511120601060"></p>
<h5 id="1、知识点回顾与重要考点"><a href="#1、知识点回顾与重要考点" class="headerlink" title="1、知识点回顾与重要考点"></a>1、知识点回顾与重要考点</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120620181.png" alt="image-20210511120620181"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120633229.png" alt="image-20210511120633229"></p>
<h5 id="2、中断处理程序"><a href="#2、中断处理程序" class="headerlink" title="2、中断处理程序"></a>2、中断处理程序</h5><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511120645686.png" alt="image-20210511120645686"></p>
<h3 id="5-1-5、I-O核心子系统"><a href="#5-1-5、I-O核心子系统" class="headerlink" title="5.1.5、I/O核心子系统"></a>5.1.5、I/O核心子系统</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511200617750.png" alt="image-20210511200617750"></p>
<h4 id="1、这些功能要在哪个层次实现"><a href="#1、这些功能要在哪个层次实现" class="headerlink" title="1、这些功能要在哪个层次实现?"></a>1、这些功能要在哪个层次实现?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201151526.png" alt="image-20210511201151526"></p>
<h4 id="2、I-O调度"><a href="#2、I-O调度" class="headerlink" title="2、I/O调度"></a>2、I/O调度</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201224315.png" alt="image-20210511201224315"></p>
<h4 id="3、设备保护"><a href="#3、设备保护" class="headerlink" title="3、设备保护"></a>3、设备保护</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201256428.png" alt="image-20210511201256428"></p>
<h4 id="4、知识总览"><a href="#4、知识总览" class="headerlink" title="4、知识总览"></a>4、知识总览</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201346880.png" alt="image-20210511201346880"></p>
<h3 id="5-1-6、假脱机技术"><a href="#5-1-6、假脱机技术" class="headerlink" title="5.1.6、假脱机技术"></a>5.1.6、假脱机技术</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201414648.png" alt="image-20210511201414648"></p>
<h4 id="1、什么是假脱机技术"><a href="#1、什么是假脱机技术" class="headerlink" title="1、什么是假脱机技术"></a>1、什么是假脱机技术</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201503446.png" alt="image-20210511201503446"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201645994.png" alt="image-20210511201645994"></p>
<h4 id="2、假脱机技术——输入井和输出井"><a href="#2、假脱机技术——输入井和输出井" class="headerlink" title="2、假脱机技术——输入井和输出井"></a>2、假脱机技术——输入井和输出井</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201850384.png" alt="image-20210511201850384"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201805698.png" alt="image-20210511201805698"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201917534.png" alt="image-20210511201917534"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511201943528.png" alt="image-20210511201943528"></p>
<h4 id="3、假脱机技术——输入-输出缓冲区"><a href="#3、假脱机技术——输入-输出缓冲区" class="headerlink" title="3、假脱机技术——输入/输出缓冲区"></a>3、假脱机技术——输入/输出缓冲区</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511202055139.png" alt="image-20210511202055139"></p>
<h4 id="4、共享打印机原理分析"><a href="#4、共享打印机原理分析" class="headerlink" title="4、共享打印机原理分析"></a>4、共享打印机原理分析</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511202209054.png" alt="image-20210511202209054"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511202654105.png" alt="image-20210511202654105"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511202423159.png" alt="image-20210511202423159"></p>
<h4 id="脑图-42"><a href="#脑图-42" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511202456002.png" alt="image-20210511202456002"></p>
<h3 id="5-1-7、设备的分配与回收"><a href="#5-1-7、设备的分配与回收" class="headerlink" title="5.1.7、设备的分配与回收"></a>5.1.7、设备的分配与回收</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511134320520.png" alt="image-20210511134320520"></p>
<h4 id="1、设备分配时应考虑的因素"><a href="#1、设备分配时应考虑的因素" class="headerlink" title="1、设备分配时应考虑的因素"></a>1、设备分配时应考虑的因素</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184505182.png" alt="image-20210511184505182"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184525700.png" alt="image-20210511184525700"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184540600.png" alt="image-20210511184540600"></p>
<h4 id="2、静态分配与动态分配"><a href="#2、静态分配与动态分配" class="headerlink" title="2、静态分配与动态分配"></a>2、静态分配与动态分配</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184556436.png" alt="image-20210511184556436"></p>
<h4 id="3、设备分配管理中的数据结构"><a href="#3、设备分配管理中的数据结构" class="headerlink" title="3、设备分配管理中的数据结构"></a>3、设备分配管理中的数据结构</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184610941.png" alt="image-20210511184610941"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184623290.png" alt="image-20210511184623290"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184641395.png" alt="image-20210511184641395"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184653652.png" alt="image-20210511184653652"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184714960.png" alt="image-20210511184714960"></p>
<h4 id="4、设备分配的步骤"><a href="#4、设备分配的步骤" class="headerlink" title="4、设备分配的步骤"></a>4、设备分配的步骤</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511185859000.png" alt="image-20210511185859000"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511185912320.png" alt="image-20210511185912320"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511185925978.png" alt="image-20210511185925978"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511185938379.png" alt="image-20210511185938379"></p>
<h4 id="5、设备分配步骤的改进"><a href="#5、设备分配步骤的改进" class="headerlink" title="5、设备分配步骤的改进"></a>5、设备分配步骤的改进</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511185955148.png" alt="image-20210511185955148"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190008933.png" alt="image-20210511190008933"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190025223.png" alt="image-20210511190025223"></p>
<h4 id="脑图-43"><a href="#脑图-43" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190059629.png" alt="image-20210511190059629"></p>
<h3 id="5-1-8、缓冲区管理"><a href="#5-1-8、缓冲区管理" class="headerlink" title="5.1.8、缓冲区管理"></a>5.1.8、缓冲区管理</h3><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511184150637.png" alt="image-20210511184150637"></p>
<h4 id="1、什么是缓冲区-有什么作用"><a href="#1、什么是缓冲区-有什么作用" class="headerlink" title="1、什么是缓冲区?有什么作用?"></a>1、什么是缓冲区?有什么作用?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190337006.png" alt="image-20210511190337006"></p>
<h4 id="2、缓冲区有什么作用"><a href="#2、缓冲区有什么作用" class="headerlink" title="2、缓冲区有什么作用?"></a>2、缓冲区有什么作用?</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190349446.png" alt="image-20210511190349446"></p>
<h4 id="3、单缓冲"><a href="#3、单缓冲" class="headerlink" title="3、单缓冲"></a>3、单缓冲</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190403433.png" alt="image-20210511190403433"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190415564.png" alt="image-20210511190415564"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190430654.png" alt="image-20210511190430654"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190447737.png" alt="image-20210511190447737"></p>
<h4 id="4、双缓冲"><a href="#4、双缓冲" class="headerlink" title="4、双缓冲"></a>4、双缓冲</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190502280.png" alt="image-20210511190502280"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190513456.png" alt="image-20210511190513456"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190526272.png" alt="image-20210511190526272"></p>
<h4 id="5、使用单-双缓冲在通信时的区别"><a href="#5、使用单-双缓冲在通信时的区别" class="headerlink" title="5、使用单/双缓冲在通信时的区别"></a>5、使用单/双缓冲在通信时的区别</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190537821.png" alt="image-20210511190537821"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190551862.png" alt="image-20210511190551862"></p>
<h4 id="6、循环缓冲区"><a href="#6、循环缓冲区" class="headerlink" title="6、循环缓冲区"></a>6、循环缓冲区</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190605054.png" alt="image-20210511190605054"></p>
<h4 id="7、缓冲池"><a href="#7、缓冲池" class="headerlink" title="7、缓冲池"></a>7、缓冲池</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511221515991.png" alt="image-20210511221515991"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511221647687.png" alt="image-20210511221647687"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511221825920.png" alt="image-20210511221825920"></p>
<p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511221937054.png" alt="image-20210511221937054"></p>
<h4 id="脑图-44"><a href="#脑图-44" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210511190720738.png" alt="image-20210511190720738"></p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH">bilibili王道考研</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gl620321/article/details/107128661">操作系统思维导图—（零基础—思维导图详细版本及知识点）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-10 03:25:19 / 修改时间：18:09:44" itemprop="dateCreated datePublished" datetime="2021-05-10T03:25:19+08:00">2021-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/31.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="1-1-1-、概念、组成、功能和分类"><a href="#1-1-1-、概念、组成、功能和分类" class="headerlink" title="1.1.1 、概念、组成、功能和分类"></a>1.1.1 、概念、组成、功能和分类</h3><ol>
<li><p>计算机网络概念：</p>
<p>是<strong>一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</strong>。</p>
<p>计算机网络是<strong>互连的、自治的计算机集合</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.png" alt="image-20210402030633726"></p>
</li>
<li><p>计算机网络的功能</p>
<ol>
<li>数据通信（连通性）</li>
<li>资源共享（硬件、软件、数据，三大资源共享）</li>
<li>分布式处理（多台计算机各自承担同一工作任务的不同部分 如：Hadoop平台）</li>
<li>提高可靠性（替代机）</li>
<li>负载均衡</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.png" alt="image-20210402031009538"></p>
</li>
<li><p>组成</p>
<ol>
<li><p>组成部分（硬件、软件、协议）</p>
<ol>
<li>硬件：主机（端系统），链路（双绞线、光纤），通信设备（路由器，交换机）</li>
<li>软件：QQ，微信等</li>
<li>协议</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.png" alt="image-20210402031120533"></p>
</li>
<li><p>工作方式</p>
<ol>
<li>边缘部分：用户直接使用（C/S方式，P2P方式）</li>
<li>核心部分：为边缘部分服务（网络，路由器，交换机）</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.png" alt="image-20210402031159369"></p>
</li>
<li><p>功能组成</p>
<ol>
<li><p>通信子网：实现数据通信(OSI上三层)</p>
</li>
<li><p>资源子网：实现资源共享/数据处理（OSI下三层）</p>
<blockquote>
<p>传输层：是资源子网和通信子网的接口</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/05.png" alt="image-20210402031240261"></p>
</li>
<li><p>计算机网络的分类</p>
<ol>
<li><p>按分布范围分</p>
<ul>
<li><p>广域网（WAN，交换技术）</p>
</li>
<li><p>城域网（MAN）</p>
</li>
<li><p>局域网（LAN，广播技术）</p>
</li>
<li><p>个人区域网（PAN）</p>
</li>
</ul>
</li>
<li><p>按使用者分</p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li><p>.按交换技术分</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li><p>按拓扑结构分</p>
<ul>
<li>总线型</li>
<li>星型</li>
<li>环形</li>
<li>网状型（常用于广域网）</li>
</ul>
</li>
<li><p>按照传输技术分</p>
<ul>
<li>广播式网络（共享公共通信信道）</li>
<li>点对点网络（使用分组存储转发和路由选择机制）</li>
</ul>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.png" alt="image-20210402031749128"></p>
</li>
</ol>
</li>
</ol>
<p><strong>脑图：</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-2、-标准化工作及相关组织"><a href="#1-1-2、-标准化工作及相关组织" class="headerlink" title="1.1.2、 标准化工作及相关组织"></a>1.1.2、 标准化工作及相关组织</h3><ol>
<li><p>标准化工作</p>
<ol>
<li><p>标准的分类</p>
<ol>
<li><p>法定标准</p>
<p>由权威机构指定的正式的、合法的标准</p>
<p>OSI</p>
</li>
<li><p>事实标准</p>
<p>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准</p>
<p>TCP/IP</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>RFC（Request For Comments）——因特网标准的形式</p>
</li>
</ol>
<p>RFC要上升为因特网正式标准的四个阶段</p>
<ol>
<li><p>因特网草案（Internet Draft）</p>
<p> 这个阶段还不是RFC文档，只是一个构思</p>
</li>
<li><p>建议标准（Proposed Standard）</p>
<pre><code>- 从这个阶段开始成为RFC文档</code></pre>
</li>
<li><p>草案标准（Draft Standard）（现取消）</p>
<ul>
<li>IETF、IAB审核</li>
</ul>
</li>
<li><p>因特网标准（Internet Standard）</p>
</li>
<li><p>标准化工作的相关组织</p>
<ol>
<li>国际标准化组织ISO</li>
</ol>
<p>OSI参考模型、HDLC协议</p>
</li>
<li><p>国际电信联盟ITU</p>
<p>制定通信规则</p>
</li>
<li><p>国际电气电子工程师协会IEEE</p>
<p>学术机构、IEEE802标准、5G</p>
</li>
<li><p>Internet工程任务组IETF</p>
<p>负责因特网相关标准的制定 RFC—XXXX</p>
<p>   <img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/08.png" alt="image-20210405164611745"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/09.png" alt="image-20210405164728541"></p>
<h3 id="1-1-3、-计算机网络的相关性能指标"><a href="#1-1-3、-计算机网络的相关性能指标" class="headerlink" title="1.1.3、 计算机网络的相关性能指标"></a>1.1.3、 计算机网络的相关性能指标</h3><ol>
<li><p>速率</p>
<p>即数据率或称数据传输率或比特率</p>
<p>连接在计算机网络上的主机在数字信道上传输数据位数的速率</p>
<p>补充：</p>
<p>​    速率的单位（千、兆、吉、太）</p>
<p>​    1 Tb/s=10^3 Gb/s=10^6 Mb/s=10^9 kb/s=10^12 b/s</p>
<p>​    存储容量单位：</p>
<p>​    1 Btye=8 bit1 TB/s=2^10 GB/s=2^20 MB/s=2^30 KB/s=2^40 B/s</p>
</li>
<li><p>带宽</p>
<p>原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p>
<p>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力</p>
<p>通常是指单位时间内从网络的某一点到另一点所能通过的<strong>“最高数据率”</strong>。</p>
<p>单位与速率的单位相同。（比特每秒、b/s,kb/s,Mb/s,Gb/s）</p>
<p>可以理解为：<strong>网络设备所支持的最高速度</strong>，即：发送的速率</p>
</li>
<li><p>吞吐量</p>
<p>表示在单位时间内通过某个网络（信道、接口）的数据量。单位b/s，kb/s，Mb/s等</p>
<p>吞吐量受网络的<strong>带宽或网络的额定速率</strong>的限制</p>
<p>所有的链路加一起才是本次网络的数据的真正吞吐量</p>
</li>
<li><p>时延</p>
<p>指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需时间。<br>也叫延迟或者迟延，单位是s</p>
<ol>
<li><p>发送时延/传输时延 = 数据长度/信道带宽（发送速率）</p>
<p>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。</p>
</li>
<li><p>传播时延 = 信道长度/电磁波在信道上的传播速率；<br>取决于电磁波传播速度和链路长度</p>
<p>此处注意：<strong>传输时延</strong>与<strong>传播时延</strong>的区别</p>
<ul>
<li>传输时延：发生在主机内部，一般是发生在网络适配器当中，发生在机器内部的发送器里面</li>
<li>传播时延：发生在机器外部，发送在信道上</li>
</ul>
</li>
<li><p>排队时延</p>
<p>等待输出/输入链路可用</p>
<p>在路由器的缓存空间那里</p>
</li>
<li><p>处理时延</p>
<ul>
<li>检错找出口</li>
</ul>
</li>
<li><p>时延抖动</p>
<p>时延的不均匀性</p>
</li>
</ol>
<p>注意：高速链路（提高发送速率/信号带宽）只是降低了发送时延，对传播时延和传播速率没有影响</p>
</li>
<li><p>时延带宽积 = 传播时延 * 带宽</p>
<p>时延带宽积又称为比特位长度的链路长度</p>
<p>即：某段链路现在有多少比特，有“容量”的意思</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.png" alt="image-20210405173609630"></p>
</li>
<li><p>往返时延RTT</p>
<p>从<strong>发送发发送数据</strong>开始，到<strong>发送方收到接收方的确认</strong>（接收方收到数据后立即发送确认）总共经历的时延<br><strong>RTT越大，在收到确认之前，可以发送的数据越多</strong></p>
<p>RTT包括</p>
<ol>
<li>往返传播时延 = 传播时延 * 2</li>
<li>末端处理时间</li>
</ol>
<p><strong>注意：RTT不包括传输时延</strong></p>
</li>
<li><p>利用率</p>
<ul>
<li><p>信道利用率 = 有数据通过时间 / （有 + 无）数据通过的时间</p>
</li>
<li><p>网络利用率 = 信道利用率加权平均值</p>
</li>
<li><p><strong>利用率如果趋近于1，时延会急剧增大</strong></p>
<p>这些性能指标可以分为三类</p>
<ol>
<li>速率、带宽、吞吐率</li>
<li>时延、时延带宽积、往返时延RTT</li>
<li>利用率（利用率如果趋近于1，时延会急剧增大）</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.png" alt="11"></p>
<h3 id="1-2-1、-分层结构、协议、接口、服务"><a href="#1-2-1、-分层结构、协议、接口、服务" class="headerlink" title="1.2.1、 分层结构、协议、接口、服务"></a>1.2.1、 分层结构、协议、接口、服务</h3><ol>
<li><p>为什么要分层？</p>
<p>发送文件前要完成的工作：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行激活。</li>
<li>要告诉网络如何识别目的主机。</li>
<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li>
<li>确保差错和意外可以解决。</li>
<li>…….</li>
</ol>
<p>所以，在发送文件的过程中，会出现很多问题，需要把这些问题分成一个个小问题，然后解决</p>
</li>
<li><p>怎么分层</p>
<ul>
<li>实体、对等实体</li>
<li>对等实体之间才会有协议</li>
<li>上下层之间的接口</li>
<li>下层给上层提供服务</li>
</ul>
</li>
<li><p>分层的基本原则</p>
<ol>
<li>各层之间<strong>相互独立</strong>，每层只实现一种相对独立的功能</li>
<li>每层之间的<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少</li>
<li>结构上可分隔开。每层都采用<strong>最合适的技术</strong>来实现</li>
<li>保持<strong>下层</strong>对<strong>上层</strong>的独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>整个分层结构应该促进标准化工作。</li>
</ol>
</li>
<li><p>正式认识分层结构</p>
<ol>
<li>实体：第n层中的活动元素称为<strong>n层实体</strong>。同一层的实体叫<strong>对等实体</strong>。</li>
<li>协议：为进行网络中的<strong>对等实体</strong>数据交换为建立的规则、标准或约定称为网络协议。【<strong>水平</strong>】<ul>
<li>语法：规定传输数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：规定各种操作的顺序</li>
</ul>
</li>
<li>接口（访问服务点SAP）：上层使用下层服务的入口。</li>
<li>服务：下层为相邻上层提供的功能调用。【<strong>垂直</strong>】</li>
<li>SDU、PCI、PDU<ul>
<li>SDU服务数据单元：为完成用户所需要的功能而应传输的数据。</li>
<li>PCI协议控制信息：控制协议操作的信息。</li>
<li>PDU协议数据单元：对等层次之间传送的数据单位。</li>
<li>PDU=SDU+PCI</li>
</ul>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/12.png" alt="image-20210405222724021"></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong>。</li>
<li>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</li>
<li><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</li>
<li>第n层在向n+1层提供服务时，此服务<strong>不仅包含第n层本身的功能，还包含由下层服务提供的功能</strong>。</li>
<li>仅仅<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</li>
</ul>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.png" alt="image-20210405223601395"></p>
<h3 id="1-2-2、-OSI参考模型"><a href="#1-2-2、-OSI参考模型" class="headerlink" title="1.2.2、 OSI参考模型"></a>1.2.2、 OSI参考模型</h3><ol>
<li><p>计算机网络分层结构</p>
<ul>
<li>7层OSI参考模型（法定标准）</li>
<li>4层TCP/IP参考模型（事实标准）</li>
<li>5层体系结构（主要是使我们学习计算机网络更加清晰，不是事实标准，也不是法定标准）</li>
</ul>
</li>
<li><p>OSI参考模型是怎么来的？<br>提出第一个网络体系结构：SNA（IBM公司）之后，很多公司和机构纷纷提出自己的网络体系结构<br>DEC公司的DNA，美国国防部的TCP/IP。为了支持异构网络系统的互联互通，<br>国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型。但是，理论成功，市场失败。</p>
</li>
<li><p>OSI7层结构</p>
<ol>
<li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>物、链、网、输、会、示、用<br>物联网淑慧试用</li>
<li>资源子网（数据处理）：上三层：会话层、表示层、应用层</li>
<li>通信子网（数据通信）：下三层：物理层、数据链路层、网络层</li>
</ol>
</li>
<li><p>OSI参考模型解释通信过程</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/14.png" alt="在这里插入图片描述"></p>
<p><strong>上四层</strong>实现的是<strong>端到端</strong>的通信<br><strong>下三层</strong>实现的是<strong>点到点</strong>的通信</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/15.png" alt="在这里插入图片描述"></p>
</li>
<li><p>各层功能与协议</p>
<ol>
<li><p>应用层<br>用户与网络的界面，所有能和用户交互产生网络流量的程序<br>典型应用层服务：</p>
<ul>
<li>文件传输（FTP)</li>
<li>电子邮件（SMTP）</li>
<li>万维网（HTTP）等</li>
</ul>
</li>
<li><p>表示层<br>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<ul>
<li>功能1：数据格式变换（翻译官）</li>
<li>功能2：数据加密和解密</li>
<li>功能3：数据压缩和解压缩</li>
</ul>
<p>没有专门的协议，硬要说的话：主要协议有JPEG、ASCII</p>
</li>
<li><p>会话层<br>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据<br>这是会话，也是<strong>建立同步</strong>（SYN）</p>
<ul>
<li>功能1：建立、管理、终止会话</li>
<li>功能2：使用校验点可以使会话在通信失效时，从校验点/同步点继续恢复通信，实现数据同步。（适用于传输大文件）<br>主要协议：ADSP、ASP</li>
</ul>
</li>
<li><p>传输层<br>负责两个不同主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报。（功能：可差留用）</p>
<ul>
<li>功能1：可靠传输、不可靠传输</li>
<li>功能2：差错控制</li>
<li>功能3：流量控制</li>
<li>功能4：复用分用<ul>
<li>复用：多个应用层进程可同时使用下面运输层的服务。</li>
<li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li>
</ul>
</li>
</ul>
<p>主要协议：TCP、UDP</p>
</li>
<li><p>网络层（最重要）<br>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层传输单位是<strong>数据报</strong>。</p>
<p><strong>数据报过长时，会将数据报切割成一个个小的分组，再放到链路上传递</strong></p>
<ul>
<li>功能1：路由选择（最佳路径）</li>
<li>功能2：流量控制（协调发送端和接收端的速度）</li>
<li>功能3：差错控制（奇偶校验等）</li>
<li>功能4：拥塞控制<br>若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞。</li>
</ul>
<p>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>
</li>
<li><p>数据链路层</p>
<p>主要任务是把网络层传下来的<strong>数据报组装成帧</strong></p>
<p>数据链路层/链路层的传输单位是<strong>帧</strong></p>
<ul>
<li>功能1：成帧（定义帧的开始和结束）</li>
<li>功能2：差错控制（帧错+位错）</li>
<li>功能3：流量控制</li>
<li>功能4：访问（接入）控制  <strong>控制对信道的访问</strong></li>
</ul>
<p>主要协议：SDLC、HDLC、PPP、STP</p>
</li>
<li><p>物理层</p>
<p>傻瓜层</p>
<p><strong>把比特流转成电信号的形式</strong>，然后放到链路上面进行传输，不需要对数据进行改动。<br>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>，传输单位是<strong>比特</strong>。<br>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路层上传送。</p>
<ul>
<li>功能1：定义接口特性</li>
<li>功能2：定义传输模式（单工、半双工、双工）</li>
<li>功能3：定义传输速率</li>
<li>功能4：比特同步</li>
<li>功能5：比特编码</li>
</ul>
<p>主要协议：Rj45、802.3</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/19.png" alt="image-20210405234108810"></p>
<h3 id="1-2-3、-TCP-IP参考模型和5层参考模型"><a href="#1-2-3、-TCP-IP参考模型和5层参考模型" class="headerlink" title="1.2.3、 TCP/IP参考模型和5层参考模型"></a>1.2.3、 TCP/IP参考模型和5层参考模型</h3><p>先有TCP/IP协议栈再有TCP/IP参考模型</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16.png" alt="image-20210405233009957"></p>
<ol>
<li><p>OSI参考模型与TCP/IP参考模型相同点</p>
<ol>
<li>都分层</li>
<li>基于独立的协议栈的概念</li>
<li>都可以实现异构网络互联</li>
</ol>
</li>
<li><p>OSI参考模型与TCP/IP参考模型的不同点</p>
<ol>
<li><p>OSI定义三点：服务、协议、接口</p>
</li>
<li><p>OSI先出现，参考模型先于协议发明，不偏向特定协议</p>
</li>
<li><p>TCP/IP设计之初就考虑到<strong>异构网互联</strong>问题，<strong>将IP作为重要的层次</strong></p>
</li>
<li><p>OSI VS TCP/IP</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">OSI</th>
<th align="center">TCP/IP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">网络层</td>
<td align="center">无连接+面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">面向连接</td>
<td align="center">无连接+面向连接</td>
</tr>
</tbody></table>
<p>面向连接：分为三个阶段</p>
<ol>
<li>建立连接，发出一个建立连接的请求</li>
<li>连接成功之后，开始数据传输</li>
<li>数据传输完毕，释放连接</li>
</ol>
<p>无连接：直接进行数据传输</p>
</li>
<li><p>5层参考模型</p>
<p>综合了OSI和TCP/IP的优点</p>
<p>5层参考模型的分层及每层的功能：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17.png" alt="在这里插入图片描述"></p>
<p>5层参考模型的数据封装与解封装过程：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
</ol>
<h3 id="1-3-第一章总结"><a href="#1-3-第一章总结" class="headerlink" title="1.3 第一章总结"></a>1.3 第一章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25.png" alt="在这里插入图片描述"></p>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/32.png" alt="在这里插入图片描述"></p>
<hr>
<p>第二章要学习的主要内容</p>
<ul>
<li>通信基础</li>
<li>两个公式lim（考研重点）</li>
<li>看图说话（数字信号的波形）</li>
<li>传输介质</li>
<li>物理层设备（中继器、集线器）</li>
</ul>
<h3 id="2-1-1、-物理层基本概念"><a href="#2-1-1、-物理层基本概念" class="headerlink" title="2.1.1、 物理层基本概念"></a>2.1.1、 物理层基本概念</h3><ol>
<li><p>物理层基本概念</p>
<p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体（传输媒体可以看做是第0层，要与物理层分开看）</p>
<p>物理层的主要任务：<strong>确定与传输媒体接口有关的一些特性，定义标准</strong></p>
<p>物理层定义了哪些特性？</p>
<ul>
<li>机械特性<br>定义物理连接的特性，规定物理连接时所采用的的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况</li>
<li>电气特性<br>规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、<strong>传输速率</strong>和<strong>距离限制</strong>等。</li>
<li>功能特性<br>指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途<br>比如：描述一个物理层接口引脚处于高电平时的含义。</li>
<li>规程特性<br>（过程特性）定义各条物理线路的<strong>工作规程和时序</strong>关系。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-、数据通信基础知识"><a href="#2-1-2-、数据通信基础知识" class="headerlink" title="2.1.2 、数据通信基础知识"></a>2.1.2 、数据通信基础知识</h3><p>典型的数据通信模型：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>数据通信相关术语</p>
<p>通信的目的是<strong>传送消息</strong></p>
<ul>
<li><p>数据：传送信息的实体，通常是有意义的符号序列。</p>
</li>
<li><p>信号：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong>。</p>
<ul>
<li><strong>数字信号</strong>：代表消息的参数取值是<strong>离散</strong>的</li>
<li><strong>模拟信号</strong>：代表消息的参数取值是<strong>连续</strong>的</li>
</ul>
</li>
<li><p>信源：产生和发送数据的源头</p>
</li>
<li><p>信宿：接收数据的终点</p>
</li>
<li><p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条<strong>发送信道</strong>和一条<strong>接收信道</strong>.</p>
<p>信道分类</p>
<ul>
<li>按<strong>传输信号</strong>分：数字信道（传送数字信号）、模拟信道（传送模拟信号）</li>
<li>按<strong>传输介质</strong>分：无线信道、有线信道</li>
</ul>
</li>
</ul>
</li>
<li><p>三种通信方式</p>
<p>从通信双方信息的交互方式看，可以有三种基本方式</p>
<ul>
<li>单工通信<br>只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道</li>
<li>半双工通信<br>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道</li>
<li>全双工通信<br>通信双方可以同时发送和接受信息，也需要<strong>两条</strong>信道</li>
</ul>
</li>
<li><p>两种数据传输方式</p>
<p>数据在信道上的传送方式</p>
<ul>
<li>串行传输<br><strong>速度慢，费用低、适合远距离</strong></li>
<li>并行传输<br><strong>速度快、费用高、适合近距离</strong><br>用于<strong>计算机内部数据</strong>传输（打印机，扫描机）</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-、码元、波特、速率、带宽"><a href="#2-1-3-、码元、波特、速率、带宽" class="headerlink" title="2.1.3 、码元、波特、速率、带宽"></a>2.1.3 、码元、波特、速率、带宽</h3><ol>
<li><p>码元<br>指用一个<strong>固定时长</strong>的<strong>信号波形</strong>（数字脉冲），代表<strong>不同离散数值的基本波形</strong>，是数字通信中数字信号的计量单位，<strong>这个时长内的信号称为k进制码元</strong>，而<strong>该时长称为码元宽度</strong>。当码元的离散状态有M个时（M&gt;2），此时码元为M进制码元。</p>
<p><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种表示1状态。而四进制码元，一个码元可以携带2bit信息。（00/01/10/11）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/21.png" alt="image-20210406001148097"></p>
</li>
<li><p>速率、波特</p>
<p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</p>
<ol>
<li><p>码元速率：（码元速率、波形速率、<strong>调制速率</strong>、<strong>符号速率</strong>等等）<br>它表示单位时间内数字通信系统所传输的码元个数（也可称为<strong>脉冲个数</strong>或<strong>信号变化的次数</strong>），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但是<strong>码元速率与进制数无关</strong>。</p>
<p>即：<strong>1s传输了多少码元</strong></p>
</li>
<li><p>信息速率：<br>表示单位时间内数字通信系统传输的<strong>二进制码元个数</strong>（即比特数）<br>单位是比特/秒（b/s）</p>
<p>即：<strong>1s传输多少比特</strong></p>
<p>关系：</p>
<p>*<em>若一个码元携带n bit的信息量，则M Buad的码元传输速率所对应的信息传输速率为M</em>n bit/s**</p>
<p>即：*<em>信息传输速率 = n bit * 码元传输速率*</em></p>
<p>系统传输的是<strong>比特流</strong>，通常比较的的是<strong>信息传输速率</strong>。</p>
</li>
</ol>
</li>
<li><p>带宽<br>表示在单位时间内从网络中的<strong>某一点到另一点</strong>所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p>
</li>
<li><p>相关习题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/22.png" alt="image-20210406002432454"></p>
</li>
</ol>
<h3 id="2-1-4、-奈氏准则和香农定理"><a href="#2-1-4、-奈氏准则和香农定理" class="headerlink" title="2.1.4、 奈氏准则和香农定理"></a>2.1.4、 奈氏准则和香农定理</h3><ol>
<li><p>失真：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/23.png" alt="在这里插入图片描述"></p>
</li>
<li><p>影响失真的因素：</p>
<ol>
<li>码元传输速率（正相关）<br>速率越快，信号失真程度越严重</li>
<li>信号传输距离（正相关）<br>距离越远，衰减越久，干扰越久，对信号影响越大</li>
<li>噪声干扰（负相关）<br>噪声越多，信号失真程度越大</li>
<li>传输媒体质量（负相关）<br>传输媒体质量越差，越失真</li>
</ol>
</li>
<li><p>失真的一种现象——码间串扰</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5C24.png" alt="在这里插入图片描述"></p>
<p>信道带宽：<strong>信道能通过的最高频率和最低频率之差</strong></p>
<p>上图的<strong>信道带宽</strong>是：3300Hz-300Hz=3000Hz</p>
<ol>
<li><p>速率过低为什么不能通过信道？</p>
<p>速度太低，信号在信道上非常容易衰减</p>
</li>
<li><p>速度过高为什么不能通过信道？</p>
<p>振动频率太快了，接收端在接收时区分不出来波形之间的差异（即：码间串扰）</p>
<p>码间串扰：<strong>接收端</strong>收到的信好波形<strong>失去了码元之间清晰界限</strong>的现象</p>
</li>
</ol>
</li>
<li><p>奈氏准则（奈奎斯特定理）</p>
<p>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，<strong>极限码元传输速率为2W Baud</strong>，W是信道带宽，<strong>单位是Hz</strong>。<strong>在奈氏准则和香农定理中带宽的单位是Hz</strong>（不是bit/s）</p>
<p>理想低通信道下的极限传输率=2Wlog2V（b/s）<br>V：码元的种数/码元的离散电平数目</p>
<p>根据奈氏准则可以得到以下4条结论：</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的<strong>频带越宽</strong>（即：能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输</li>
<li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</strong></li>
<li>由于码元的传输速率受奈氏准则的制约，所以要<strong>提高数据的传输速率</strong>，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用<strong>多元制的调制方法</strong>。</li>
</ol>
<p>例：在无噪声的情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅的QAM调制技术，则该通信链路的最大数据传输率是多少?</p>
<p>分析：调相与调幅相结合</p>
<p>解：</p>
<pre><code> 信号有4 * 4=16种变化，则V=16；</code></pre>
<p>​     即：极限传输速率=2Wlog2（V）（b/s）= 2 * 3000 * log2（16）（b/s）= 24000（b/s）</p>
</li>
<li><p>香农定理</p>
<p><strong>噪声</strong>存在于所有的电子设备和通信系统中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是<strong>噪声的影响是相对的，若信号较强，那么噪声影响相对较小</strong>。因此，信噪比就很重要。</p>
<p>信噪比 = <strong>信号</strong>的平均功率/<strong>噪声</strong>的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：<br>信噪比（dB）=10 * log10（S/N） </p>
<p>两者在数值上等价。</p>
<p>而往往信噪比的这个值会很大，所以一般取对数。取了对数这个严格来说就叫做声强级，取对数实际上获得了次方的值，进而得到了声音（信息）的强度。但是两个东西表示的是同一信息。声强级是为了方便读数理解而对信噪比进行的变换（类似科学记数法）</p>
<p>香农定理：</p>
<p>在<strong>带宽受限</strong>且<strong>有噪声</strong>的信道中，为了不产生误差，<strong>信息的数据传输速率</strong>有上限值。</p>
<p>信道的极限数据传输速率=W * log2（1+S/N） （b/s）</p>
<p>S：信道所传信号的平均功率</p>
<p>N：信道内的高斯噪声功率</p>
<p>S/N即：信噪比</p>
<p>W:带宽（Hz）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/26.png" alt="image-20210406010014399"></p>
<p>根据香农定理可以得到以下5条结论：</p>
<ol>
<li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong></li>
<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li>
<li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法实现<strong>无差错传输</strong></li>
<li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li>
<li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限。</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/28.png" alt="image-20210406010235606"></p>
</li>
<li><p>奈氏准则和香农定理的联系与区别：</p>
<p>奈氏准则（内忧，码间串扰）香农定理（外患，外界噪声）<br>有时候既需要使用奈氏准则，也需要使用香农定理，这时，<strong>需要取两者中的最小值</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/27.png" alt="image-20210406010414253"></p>
<p>例：二进制信号在信噪比为127∶1的4kHz信道上传输，最大的数据速率可达到多少?<br>解：</p>
<pre><code>由奈氏准则知：最大数据传输速率为=2 * W * log2（V）
                          =2 * 4000 * 1=8000（b/s）
有香农定理知：最大数据传输速率为=W * log2（1+S/N）
                          =4000 * log2（1+127）
                          =28000（b/s）
最大的数据传输率为8000（b/s）</code></pre>
</li>
</ol>
<h3 id="2-1-5-、编码与调制"><a href="#2-1-5-、编码与调制" class="headerlink" title="2.1.5 、编码与调制"></a>2.1.5 、编码与调制</h3><ol>
<li><p>基带信号与宽带信号</p>
<p>信道上传送的信号</p>
<ol>
<li>基带信号：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输（<strong>基带传输</strong>）<br>基带信号是<strong>来自信源</strong>的信号，就像计算机输出的代表各种文字或者图像文件的数据信号都属于基带信号。<br>基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</li>
<li>宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传到<strong>模拟信道</strong>上去传输（<strong>宽带传输</strong>）<br>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬迁到较高的频段</strong>一遍在信道中传输（即：仅在一段频率范围内能够通过信道）<br>在传输距离较<strong>近</strong>时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）<br>在传输距离较<strong>远</strong>时，计算机网络采用<strong>宽带传输</strong>方式（近距离衰减大，即使信号变化大也能最后过滤出来基带信号）</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/33.png" alt="image-20210407105303305"></p>
</li>
<li><p>编码与调制</p>
<p>数据–&gt;数字信号  编码</p>
<p>数据–&gt;模拟信号  调制</p>
<p>数字数据–数字发送器–&gt;数字信号   编码</p>
<p>数字数据–调制器–&gt;模拟信号      调制</p>
<p>模拟数据–PCM编码器–&gt;数字信号   编码</p>
<p>模拟数据–放大器调制器–&gt;模拟信号 调制</p>
</li>
<li><p>四种编码与调制方法</p>
<ol>
<li>数字数据编码为数字信号</li>
<li>数字数据调制为模拟信号</li>
<li>模拟数据编码为数字信号</li>
<li>模拟数据调制为模拟信号</li>
</ol>
</li>
<li><p>数字数据编码为数字信号</p>
<ol>
<li><p>非归零编码【NRZ】</p>
<p>编码方式：高1低0</p>
<p>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</p>
<p>发送端全1或0，接收端都不好识别，需要确定时间周期</p>
<p>不常用</p>
</li>
<li><p>曼彻斯特编码</p>
<p>综合归零编码、非归零编码、反向不归零编码的优缺点而形成的非常优秀的编码</p>
<p>它可以把时钟信号和数据都放在一块，不需要额外的信道传输时钟信号,就可以实现自己本身的同步，即：自同步<br>编码方式：</p>
<ul>
<li>将一个码元分成两个相同的间隔，前一个间隔为低电平后一个为高电平表示码元1；</li>
<li>码元0则正好相反。也可以采用相反的规定。</li>
</ul>
<p>该编码的特点是：在每一个码元的中间出现电平跳变，位于中间的跳变既作为时钟信号（用于同步），<br>又作为数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。</p>
</li>
<li><p>差分曼彻斯特编码（常用于局域网传输）</p>
<p>编码方式：同1异0</p>
<p>其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。</p>
<p>该编码的特点是：<br>在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码（因为实现算法更复杂）</p>
</li>
<li><p>归零编码【RZ】</p>
<p>编码方式：信号电平在一个码元之内都要回复到零的方式</p>
<p>全零不容易识别</p>
<p>不常用</p>
</li>
<li><p>反向不归零编码【NRZI】</p>
<p>编码方式：信号电平翻转表示0，信号电平不变表示1</p>
<p>发送端全0，接收端容易识别，发送端全1，接收端不好识别</p>
</li>
<li><p>4B/5B编码</p>
<p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%</p>
<p>只采用16种5位码对应16种不同的4位码，其他的16种5位码作为控制码（帧的开始或结束，线路的状态信息等）或保留。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/34.png" alt="image-20210407110138680"></p>
</li>
</ol>
<p>前三种重点掌握，后三种了解即可</p>
</li>
<li><p>数字数据调制为模拟信号</p>
<p>数据调制技术：<br>在发送端将数字信号转化为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<ul>
<li>2ASK 调幅<br>低电平0没有幅动，高电平1有幅动</li>
<li>2FSK 调频<br>低电平0低频，高电平1高频</li>
<li>2PSK 调相<br>0对应一种波形，1对应一种波形</li>
<li>QAM 调幅+调相<br>例如：某通信链路的波特率是1200Baud，采用4个相位，每个相位有4种振幅的QAM调制技术，则该链路的信息传输速率是多少?<br>解：<pre><code>信号有4 * 4 = 16种变化
信息传输速率 = W * log2（V）= 1200 * 4 = 4800（b/s）</code></pre>
</li>
</ul>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/29.png" alt="在这里插入图片描述"></p>
</li>
<li><p>模拟数据编码为数字信号</p>
<ol>
<li><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现<strong>音频数字化</strong>）。</p>
</li>
<li><p>最典型的例子就是对音频信号进行编码的脉码调制（<strong>PCM脉码调制</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。</p>
<p>它主要包括三步:抽样、量化、编码。</p>
<ol>
<li><p>抽样</p>
<p>对模拟信号周期性扫描，把时间上连续的信号变成离散的信号。</p>
<p>为了使所得的离散信号能够无失真地代表被抽样的模拟数据，要使用采样定理进行采样。</p>
<p>采样定理：（奈奎斯特采样定理）<br>f采样频率 &gt;= 2 * f信号最高频率<br>（最高分波形上至少采样两个点）</p>
</li>
<li><p>量化</p>
<p>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p>
</li>
<li><p>编码</p>
<p>把量化的结果转换为与之对应的二进制编码</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5C35.png" alt="image-20210407110815400"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>模拟数据调制为模拟信号<br>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用<strong>频分复用技术</strong>，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用<strong>模拟信号传输模拟数据</strong>的方式;模拟的声音数据是加载到模拟的<strong>载波信号</strong>中传输的。</p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/30.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-1、-物理层传输介质"><a href="#2-2-1、-物理层传输介质" class="headerlink" title="2.2.1、 物理层传输介质"></a>2.2.1、 物理层传输介质</h3><ol>
<li><p>传输介质及分类</p>
<ol>
<li><p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路</p>
</li>
<li><p><strong>传输媒体并不是物理层</strong></p>
<p>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流。</p>
</li>
<li><p>如果称物理层是傻瓜，那么传输媒体连傻瓜都不如</p>
</li>
<li><p>传输媒体分类</p>
<ol>
<li><p>导向性传输媒体</p>
<p>电磁波被导向沿着固体媒体（铜线/光纤）传播</p>
</li>
<li><p>非导向性传输媒体</p>
<p>自由空间，介质可以是空气、真空、海水等。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>导向性传输介质</p>
<ol>
<li><p>双绞线：是古老、又最常用的传输介质，它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的铜导线组成。</p>
<p>绞合可以减少相邻导线的电磁干扰。</p>
<p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线（STP）</p>
<p>无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/39.png" alt="image-20210409094235649"></p>
<p>特点：</p>
<ul>
<li>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</li>
<li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。</li>
<li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器放大衰减的信号</strong>;</li>
<li>对于<strong>数字传输</strong>，要用<strong>中继器将失真的信号整形</strong>。</li>
</ul>
</li>
<li><p>同轴电缆</p>
<p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。</p>
<p>按特性阻抗数值的不同，通常将同轴电缆分为两类:50欧姆同轴电缆和75欧姆同轴电缆。</p>
<p>其中，50欧姆同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用;75欧姆同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/40.png" alt="image-20210409094427395"></p>
<p>双绞线和同轴电缆的区别</p>
<p>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线<strong>好</strong>，被广泛用于传输较高速率的数据，其<strong>传输距离更远</strong>，但<strong>价格</strong>较双绞线<strong>贵</strong>。</p>
</li>
<li><p>光纤</p>
<ol>
<li><p>光纤通信就是利用光导纤维（简称光纤）传递<strong>光脉冲</strong>来进行通信。有光脉冲表示1，无光脉冲表示O。</p>
<p>而可见光的频率大约是10^8MHz，因此光纤通信系统的<strong>带宽远远大</strong>于目前其他各种传输媒体的带宽。</p>
</li>
<li><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲，在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p>
</li>
<li><p>光纤主要由纤芯(实心的!)和包层构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<p>超低损耗，传送超远距离</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/41.png" alt="image-20210409095419124"></p>
</li>
<li><p>分类</p>
<ol>
<li><p>多模光纤</p>
<p>传播过程会有损耗，传播过程中会受到噪声的影响，如果距离过远可能会出现较为严重的失真，适合近距离传输</p>
</li>
<li><p>单模光纤</p>
<p>单模与多模光纤的比较一根光缆少则只有一根光纤，多则包括十至数百根光纤</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/36.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>光纤的特点</p>
<ol>
<li>传输损耗小，中继距离长，对远距离传输特别经济</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无串音干扰，保密性好，也不易被窃听或截取数据</li>
<li>体积小，重量轻</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>非导向性传输介质</p>
<ol>
<li><p>无线电波</p>
<p>信号向<strong>所有方向</strong>传播</p>
<p>较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域（手机通信）</p>
</li>
<li><p>微波</p>
<p>信号固定方向传播</p>
<p>微波通信频率较高、频段范围宽，因此数据率很高</p>
<ol>
<li><p>地面微波接力通信</p>
<p>中继站</p>
</li>
<li><p>卫星通信</p>
<p>同步卫星起到了中继站的作用</p>
<ul>
<li>优点<ol>
<li>通信容量大</li>
<li>距离远</li>
<li>覆盖广</li>
<li>广播通信和多址通信</li>
</ol>
</li>
<li>缺点<ol>
<li>传播时延长（250-270ms）</li>
<li>受气候影响大（eg：强风、太阳黑子爆发）</li>
<li>误码率较高</li>
<li>成本高</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>红外线、激光</p>
<p>信号固定方向传播</p>
<p>把要传输的信号分别<strong>转换为各自的信号格式</strong>，即红外光信号和激光信号，再在空间中传播。<br>(微波不需要转换格式）</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/37.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-2-、物理层设备"><a href="#2-2-2-、物理层设备" class="headerlink" title="2.2.2 、物理层设备"></a>2.2.2 、物理层设备</h3><ol>
<li><p>中继器</p>
<ol>
<li><p>诞生的背景：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将会造成信号失真。</p>
</li>
<li><p>中继器的功能：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p>
</li>
</ol>
</li>
</ol>
<p>   简而言之：<strong>再生数字信号</strong>。</p>
<ol start="3">
<li><p>中继器的两端：</p>
<ol>
<li><p>两端的网络部分是<strong>网段</strong>，而不是子网，适用于<strong>完全相同的两类网络的互连</strong>，且<strong>两个网段速率要相同</strong>。</p>
</li>
<li><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误或不适于网段的数据。</p>
</li>
<li><p><strong>两端可连相同的媒体，也可连不通的媒体</strong>。</p>
</li>
<li><p>中继器两端的网段一定要是<strong>同一个协议</strong>。（<strong>中继器不会存储转发</strong>）</p>
</li>
</ol>
</li>
<li><p>5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p>
<p>5个网段，4个网络设备，3个段可以连接计算机</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/42.png" alt="image-20210409164354784"></p>
</li>
<li><p>集线器（多口中继器）</p>
<ol>
<li><p>再生，放大信号</p>
</li>
<li><p>集线器的功能:对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。<strong>不具备信号的定向传送能力，是一个共享式设备</strong>。</p>
</li>
<li><p>星型拓扑（广播通信）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/43.png" alt="image-20210409165035181"></p>
</li>
<li><p>集线器<strong>不能分割冲突域</strong>。当有超过两台主机同时发送数据给集线器就会发生信息碰撞，要等待随机一段时间之后在发送数据。当集线器连接的主机数目越来越多的时候，由于产生信息碰撞的概念变大，集线器的工作效率也会降低。连在集线器上的工作主机平分带宽。  </p>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-、第二章总结"><a href="#2-3-、第二章总结" class="headerlink" title="2.3 、第二章总结"></a>2.3 、第二章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/38.png" alt="在这里插入图片描述"></p>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/44.png" alt="在这里插入图片描述"></p>
<hr>
<p>第三章学习的主要内容是：</p>
<ol>
<li>链路层的功能</li>
<li>链路层的两种信道</li>
<li>局域网、广域网</li>
<li>链路层的设备</li>
</ol>
<h3 id="3-1-1、-数据链路层功能概述"><a href="#3-1-1、-数据链路层功能概述" class="headerlink" title="3.1.1、 数据链路层功能概述"></a>3.1.1、 数据链路层功能概述</h3><ol>
<li><p>数据链路层的研究思想：</p>
<p>想象数据是直接从发送端的数据链路层，经过中间系统<strong>水平发送</strong>到接收端的数据链路层</p>
</li>
<li><p>数据链路层的基本概念</p>
<ol>
<li><p>结点：主机、路由器</p>
</li>
<li><p>链路：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
</li>
<li><p>数据链路：网络中两点之间的<strong>逻辑通道</strong>，把实际控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成了数据链路。</p>
</li>
<li><p>帧：链路层的协议数据单元，<strong>封装网络层的数据报</strong></p>
</li>
</ol>
<p>数据链路层负责通过一条链路从一个节点向另一个物理链路直接相邻的相邻结点传送数据报。</p>
</li>
<li><p>数据链路层功能概述</p>
<p>在物理层提供服务的基础之上向<strong>网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻结点的目标机网络层。</p>
<p>其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p>
<ul>
<li>功能1：为网络层提供服务。<strong>无确认连接服务</strong>，<strong>有确认无连接服务</strong>，<strong>有确认面向连接服务</strong>。（有连接一定有确认！）<ul>
<li>无确认连接服务：通常用于实时通信或者误码率比较低的通信信道。源主机在发送数据的时候不用事先与目的主机建立好链路的连接，而且目的主机收到数据帧的时候也不用返回确认。如果数据帧丢失了数据链路层也不负责重发，而直接交给上一层处理。（不负责但很快）</li>
<li>有确认无连接服务：通常用于无线通信或者误码率比较高的通信信道。源主机在发送数据的时候不用事先与目的主机建立好链路的连接，但是目的主机收到数据帧的时候需要向源主机返回确认。如果源主机发现在规定时间内没有收到目的主机发送的确认信号，它就把刚才没有收到确认的这个数据帧重新发送，以此来提高数据链路层的可靠性。</li>
<li>有确认面向连接服务：源主机在发送数据的时事先与目的主机建立好链路的连接，目的主机收到数据帧的时也向源主机返回确认。源主机发现确认信号才能发送下一个。（最安全最可靠但速度也是最慢的）</li>
</ul>
</li>
<li>功能2：链路管理，即连接的建立、维持、释放（用于面向连接的服务）</li>
<li>功能3：组帧</li>
<li>功能4：流量控制，限制发送方</li>
<li>功能5：差错控制（帧错/位错）</li>
</ul>
</li>
</ol>
<h3 id="3-1-2、-封装成帧和透明传输"><a href="#3-1-2、-封装成帧和透明传输" class="headerlink" title="3.1.2、 封装成帧和透明传输"></a>3.1.2、 封装成帧和透明传输</h3><ol>
<li><p>封装成帧</p>
<ol>
<li><p>概念：</p>
<p>就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就构成了一个帧。</p>
<p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p>首部和尾部包含许多的控制信息，他们的一个重要的作用：<strong>帧定界</strong>（确定帧的界限）</p>
</li>
<li><p>帧同步：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>
</li>
<li><p>组帧的四种方法</p>
<ol>
<li>字符计数法</li>
<li>字符（节）填充法</li>
<li>零比特填充法</li>
<li>违规编码法</li>
</ol>
</li>
<li><p>示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/45.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>透明传输</p>
<p>指：不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p>
<p>因此，链路层就“看不见”有什么妨碍数据传输的东西。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，必须采取适当的措施，使接收方不会将这样的数据错误认为是某种控制信息，这样才能保证数据链路层的传输是透明的。</p>
</li>
<li><p>字符计数法（不常用）</p>
<p>帧首部使用一个计数字段（第一个字节，8位）来表明帧内字符数（字节数）。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/47.png" alt="image-20210409182821894"></p>
<p>痛点：鸡蛋装在一个篮子里。</p>
<p>如果第一个字节（计数字段）是错误的，则后面的帧全部发生错误。这样接收方没有办法正确接收每一个帧。</p>
</li>
<li><p>字符填充法</p>
<p>当传送的帧是由文本文件组成时（文本文件的字符都是从键盘输入的，都是ASCII码），不管从键盘上输入什么字符都可以放在帧里面传过去，即<strong>透明传输</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/48.png" alt="image-20210409182945627"></p>
<p>当传送的帧是由非ASCII码的文本文件组成时（二进制代码的程序或图像等），就采用<strong>字符填充法</strong>实现透明传输。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/49.png" alt="image-20210409183020592"></p>
<p>字符填充法的示意图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/46.png" alt="在这里插入图片描述"></p>
</li>
<li><p>零比特填充法</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/50.png" alt="image-20210409192047830"></p>
<p>操作</p>
</li>
<li><p>在发送端，扫描整个信息字段（原始数据），只要连续5个1，就立即填入1个0</p>
<p>即：5”1”，1”0”</p>
</li>
<li><p>在信息字段前后都加上0111110，作为帧的边界</p>
</li>
<li><p>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。</p>
<p>发现连续5个1时，就把后面的0删除。</p>
<p>保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</p>
</li>
<li><p>违规编码法</p>
<p>对于曼彻斯特编码，可以使用高-高，低-低来定帧的起始和终止。</p>
<p>局域网的IEE802标准就采用了该方法。</p>
</li>
</ol>
<p>总结：</p>
<p>由于字节计数法中Count字段（第一个字节）的脆弱性（其值若有差错将导致灾难性后果）及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>
<h3 id="3-1-3-、差错控制（比特错，检错编码，纠错编码）"><a href="#3-1-3-、差错控制（比特错，检错编码，纠错编码）" class="headerlink" title="3.1.3 、差错控制（比特错，检错编码，纠错编码）"></a>3.1.3 、差错控制（比特错，检错编码，纠错编码）</h3><ol>
<li><p>差错从何而来？</p>
<p>概括来说，传输中的差错都是由于噪声引起的。</p>
<ol>
<li><p>全局性：由于线路本身<strong>电气特性</strong>所产生的的<strong>随机噪声</strong>（热噪声），是信道固有的，随机存在的。</p>
<p>解决办法：<strong>提高信噪比</strong>来减少或避免干扰。（<strong>对传感器下手</strong>）</p>
</li>
<li><p>局部性：外界特定的短暂原因所造成的<strong>冲击噪声</strong>，产生差错的主要原因。</p>
<p>解决办法：通常利用<strong>编码技术</strong>来解决。</p>
</li>
</ol>
</li>
<li><p>差错的分类</p>
<ol>
<li><p>位错：比特位出错，1变成0,0变成1</p>
</li>
<li><p>帧错：分为三种：丢失，重复，失序</p>
<p>例如：要传输三个帧[#1]-[#2]-[#3]，则：</p>
<ul>
<li>帧丢失：[#1]-[#3]</li>
<li>帧重复：[#1]-[#2]-[#2]-[#3]</li>
<li>帧失序：[#3]-[#2]-[#1]</li>
</ul>
<p>针对这些帧错误，会采用帧编号、确认重传机制等来进行帧的差错控制。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/53.png" alt="image-20210409195542838"></p>
<p>这是过去OSI模型的观点，现在通信链路的质量大大提高，因为通信链路质量不好引起的差错概率越来越小。</p>
<p>现在的因特网会采用较为灵活的方法，针对不同的网络，我们会选择是否采用确认重传机制。</p>
</li>
</ol>
</li>
<li><p>链路层为网络层提供的服务：</p>
<ol>
<li>无确认无连接服务</li>
<li>有确认无连接服务</li>
<li>有确认面向连接服务</li>
</ol>
<p>若通信质量好，比如有线传输链路，链路层协议就不会采用确认和重传机制，而且也不要求链路层向网络层提供有效可靠传输的服务（即只有无确认无连接服务），如果发生差错，改错任务会交给上层协议(传输层)。</p>
<p>若通信质量差，比如无线传输链路，链路层协议就会采用确认和重传机制数据链路层就需要向上提供可靠传输的服务（即需要提供有确认无连接服务和有确认面向连接服务）</p>
</li>
<li><p>数据链路层的差错控制（比特错，帧错会在后面讲解）</p>
<p>差错控制：</p>
<ol>
<li>检错编码<ol>
<li>奇偶校验码</li>
<li>循环冗余码CRC</li>
</ol>
</li>
<li>纠错编码<ol>
<li>海明码</li>
</ol>
</li>
<li>数据链路层编码和物理层编码的区别<ul>
<li>数据链路层编码和物理层的<strong>数据编码与调制不同</strong>。</li>
<li><strong>物理层编码针对的是单个比特</strong>，解决传输过程中比特的同步等问题，如曼彻斯特编码。</li>
<li>而<strong>数据链路层的编码针对的是一组比特</strong>，它通过冗余码的技术实现一组二进制比特串在传输过程中是否出现了差错。</li>
</ul>
</li>
</ol>
</li>
<li><p>奇偶校验码</p>
<p>​    n-1位信息元，1位校验元</p>
<ol>
<li><p>奇校验码</p>
<p>信息元和校验元中，“1”的个数为奇数</p>
</li>
<li><p>偶校验码</p>
<p> 信息元和校验元中，“1”的个数为偶数</p>
</li>
</ol>
<p>奇偶校验码特点：只能检查出奇数个比特错误，检错能力为50%</p>
</li>
<li><p>CRC循环冗余码</p>
<ol>
<li><p>发送端最终发送的数据：要发送的数据+帧检验序列FCS</p>
<p>计算冗余码（FCS帧检验序列）</p>
<ol>
<li><p>第1步：加0  假设生成多项式G(x)的阶为r，则加r个0（多项式是n位，则阶是n-1位）</p>
<p>加0是为了不改变原发送数据，FSC帧检验直接跟在原发送数据的后面即可</p>
</li>
<li><p>第2步：模2除法。数据加0后除以多项式，余数就是冗余码FCS。</p>
<p>在除法过程中应该做减法的步骤，在模2除法中替换为异或</p>
</li>
</ol>
</li>
<li><p>接收端检错过程</p>
<p>把接收的每一帧都除以相同的除数（发送端的生成多项式），然后检查得到的除数R</p>
<ul>
<li>若R==0，判定这个帧没有差错，接受</li>
<li>若R!=0，判断这个帧有差错（无法确认到位），丢弃</li>
</ul>
</li>
<li><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p>
</li>
<li><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无比特差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。</p>
<p>可以认为：“<strong>凡是接收端数据链路层接收的帧均无差错”</strong></p>
<p>接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。</p>
</li>
<li><p>但是帧的无差错接受不是可靠传输，CRC循环冗余码只能检验出帧有错误并丢弃，但是不能对错误的帧进行校正。</p>
<p>可靠传输是指：数据链路层发送端发送什么，接收端就收到什么。</p>
</li>
</ol>
</li>
<li><p>海明码</p>
<ol>
<li><p>发现双比特错，纠正单比特错</p>
</li>
<li><p>工作原理：牵一发而动全身</p>
</li>
<li><p>工作流程</p>
<ol>
<li><p>确定校验码位数r</p>
<p>海明不等式：2^r &gt;= k+r+1  (r是冗余信息位，k为信息位)</p>
</li>
<li><p>确认校验码和数据的位置</p>
<p>校验码只能填在2的n次方的位置（包括第一个位置）</p>
<p>原码按顺序插入</p>
</li>
<li><p>求出校验码的值</p>
<p>首先将数据位从低位到高位按1，2，3…进行编号，然后将编号用二进制表示，记录二进制表示中的第n位为1的数据位，令这些数据位上的上的数据异或=0，则Pn即为所求这些数据位上包括Pn，则公式可以改进为：Pn=这些数据位除了Pn之外异或（原理：相同异或为零）</p>
<p>补充：异或的性质</p>
<ol>
<li><p>任意二进制数与0异或之后是本身</p>
</li>
<li><p>任意二进制数与1异或之后是取反</p>
</li>
<li><p>偶数个1异或是0（2 * k个1，即在1的基础上进行2 * k-1次取反操作），</p>
<p>奇数个1异或是1（2 * k+1个1，即在1的基础上进行2 * k次取反操作），</p>
<p>无论0有多少个</p>
</li>
</ol>
</li>
<li><p>检错并纠错</p>
<p>记录二进制表示中的第n位为1的数据位，求这些数据位上的上的数据异或，则Jn即为所求<br>J=JN…J1J2将J转换为十进制JT，即第JT位发生错误</p>
</li>
</ol>
</li>
<li><p>比如：D=101101</p>
<ol>
<li><p>第1步：先求出校验码的位数：2^4=16&gt;=4+6+1,所以校验码为4位</p>
</li>
<li><p>第2步：按位数分别给校验码、原码编号，原码一共有6位，即编号为：D6 D5 D4 D3 D2 D1</p>
<p>校验码一共有4位，即编号为P4 P3 P2 P1</p>
<p>校验码和原码的位置分配：D6   D5   P4   D4   D3   D2   P3   D1   P2   P1</p>
<p>​                            位置编号 10   9    8    7    6    5    4    3    2    1<br>​            位置二进制编码 1010 1001 1000 0111 0110 0101 0100 0011 0010 0001  </p>
</li>
<li><p>第3步：求P1，D5 D4 D2 D1 P1的位置编码的第一位是1，所以令D5 D4 D2 D1 P1的异或=0，求出P1</p>
<p>Pn的求法同理，先把能求的求出来，最后把之前不能求的再求出来</p>
<p>求得：P1=P2=P3=0，P4=1</p>
</li>
<li><p>第4步：求得海明码1011100100</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/51.png" alt="在这里插入图片描述"></p>
<h3 id="3-1-4-、流量控制与可靠传输机制"><a href="#3-1-4-、流量控制与可靠传输机制" class="headerlink" title="3.1.4 、流量控制与可靠传输机制"></a>3.1.4 、流量控制与可靠传输机制</h3><ol>
<li><p>数据链路层的流量控制</p>
<ol>
<li><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</li>
<li>流量控制在<strong>传输层</strong>也有</li>
<li>链路层与传输层流量控制的区别：<ol>
<li><strong>数据链路层</strong>的流量控制是<strong>点对点</strong>的，而<strong>传输层</strong>的流量控制是<strong>端到端</strong>的。</li>
<li><strong>数据链路层</strong>流量控制的手段：<strong>接收方收不下就不回复确认</strong></li>
<li><strong>传输层</strong>流量控制手段：<strong>接收端给发送端一个窗口公告</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>流量控制的方法</p>
<ol>
<li><p>停止等待协议（也可以算是一个特殊的滑动窗口协议，这种协议内发送和接收窗口都是1）</p>
<p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p>
<p>效率低</p>
<p>发送窗口大小=1，接收窗口大小=1;窗口大小固定</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/52.png" alt="在这里插入图片描述"></p>
</li>
<li><p>滑动窗口协议</p>
<ol>
<li><p>后退N帧协议（GBN）</p>
<p>发送窗口大小&gt;1，接收窗口大小=1;窗口大小固定</p>
</li>
<li><p>选择重传协议（SR）</p>
<p>发送窗口大小&gt;1，接收窗口大小&gt;1;窗口大小固定</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>可靠传输、滑动窗口、流量控制概念解析</p>
<ol>
<li>可靠传输：发送端发啥，接收端收啥</li>
<li>流量控制：控制发送速率，使接收方有足够的换种空间来接收每一帧。</li>
<li>滑动窗口是解决流量控制（收不下就不给确认，想发也发不了）和可靠传输（发送方自动重传）的方式</li>
</ol>
</li>
</ol>
<h4 id="3-1-4-1、-停止-等待协议"><a href="#3-1-4-1、-停止-等待协议" class="headerlink" title="3.1.4.1、 停止-等待协议"></a>3.1.4.1、 停止-等待协议</h4><ol>
<li><p>停止-等待协议究竟是哪一层？</p>
<p>在早期的计算机网络中，由于通信链路质量差，出现差错比较多，为了提高传输效率，数据链路层应该承担一部分可靠传输的任务，把停止-等待协议放在了数据链路层。</p>
<p>在现在的计算机网络中，通信链路质量大大提高，出现差错的情况很少，不用承担可靠传输的任务，提高了通信速度，降低了延迟。</p>
<p>把<strong>停止-等待协议放在了传输层</strong>，<strong>链路层则主要负责差错控制</strong>。</p>
</li>
<li><p>为什么要有停止-等待协议？</p>
<ol>
<li><p>除了<strong>比特出差错</strong>，底层信道还会出现丢包问题</p>
<p>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因会导致数据包的丢失<br>（数据包其实就是一个数据，在<strong>数据链路层叫帧</strong>，在<strong>网络层就叫IP数据报或者分组</strong>，在<strong>传输层也可以叫报文段</strong>）</p>
</li>
<li><p>为了解决丢包问题（可靠控制）和流量控制就出现了停止-等待协议</p>
</li>
</ol>
</li>
<li><p>研究停止等待协议的前提？</p>
<ol>
<li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）</li>
<li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一层次上传送的</li>
<li>“停止-等待”就是每发送完一个分组就停止发送没等待对方确认，在收到确认后再发送下一个分组。</li>
</ol>
</li>
<li><p>停止等待协议有几种应用情况？</p>
<ol>
<li><p>无差错情况</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/57.png" alt="image-20210409211423472"></p>
</li>
<li><p>有差错情况</p>
<ol>
<li><p>数据帧丢失和检测到帧出错</p>
<ol>
<li><p>超时计时器：每发送一个帧就启动一个计时器</p>
</li>
<li><p>如果在计时器到期之前收到了确认帧，则计时器终止。</p>
<p>如果计时器到期了还没有收到确认帧，则发送方会重新发送没收到确认帧的数据帧</p>
</li>
<li><p>超时计时器设置的重传时间应当比帧传输的平均RTT（往返传播时延）更长一些</p>
</li>
<li><p>注意事项</p>
<ol>
<li>发送完一个帧后，必须保留它的副本。</li>
<li>数据帧和确认帧必须编号</li>
</ol>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/58.png" alt="image-20210409211646062"></p>
</li>
<li><p>ACK丢失（确认帧丢失）</p>
<p>发送方超时计时器到期后没有收到确认帧，发送方重传数据帧</p>
<p>接收方收到了重复的数据帧，丢弃重复的数据帧，并重传确认帧</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/59.png" alt="image-20210409211747811"></p>
</li>
<li><p>ACK迟到（确认帧迟到）</p>
<p>超时还没收到确认帧则重传数据帧，接收方收到了重复的数据帧，并丢弃重复的数据帧</p>
<p>发送方之后在等待另一个确认帧时，收到了迟到的确认帧，会不对迟到的数据帧做处理</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/60.png" alt="image-20210409211901849"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>停止-等待协议性能分析</p>
<ol>
<li><p>优点：简单</p>
</li>
<li><p>缺点：信道利用率太低</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/61.png" alt="image-20210409212059380"></p>
<p>信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率信道利用率 = （L/C）/ T</p>
<ul>
<li>L：T内发送L比特数据</li>
<li>C：发送方数据传输率</li>
<li>T：发送周期，从发送数据开始，到收到第一个确认帧为止（一般包括发送时间和RTT，接收数据帧的时间可以忽略）</li>
</ul>
<p>信道吞吐率 = 信道利用率 * 发送方的发送速率</p>
</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/62.png" alt="image-20210409212300872"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/63.png" alt="image-20210409212332589"></p>
<h4 id="3-1-4-2-、后退N帧协议（GBN）"><a href="#3-1-4-2-、后退N帧协议（GBN）" class="headerlink" title="3.1.4.2 、后退N帧协议（GBN）"></a>3.1.4.2 、后退N帧协议（GBN）</h4><p>停止等待协议的弊端：信道利用率太低，太闲了。</p>
<p>采用流水线技术对停止-等待协议（一个数据帧跟着数据帧发送）进行改进。</p>
<p>使用流水线技术后：    </p>
<ol>
<li>必须增加数据帧序号的范围</li>
<li>发送方需要缓存多个分组</li>
</ol>
<p>所以出现了<strong>后退N帧协议（GBN）</strong>和<strong>选择重传协议（SR）</strong></p>
<ol>
<li><p>后退N帧协议中的滑动窗口</p>
<p>发送窗口：发送方维持一组连续的允许发送的帧的序号</p>
<p>接收窗口：接收方维持一组连续的允许接收帧的序号。</p>
<p>​    在后退N帧协议中，接收窗口只有一个</p>
<p>​    在选择重传协议中，接收窗口有多个</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/64.png" alt="image-20210409213121135"></p>
</li>
<li><p>后退N帧协议执行过程</p>
<ol>
<li><p>GBN发送方必须响应的三件事</p>
<ol>
<li><p>上层(网络层)的调用</p>
<p>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送；</p>
<p>如果窗口已满，发送方只需将数据返回给上层，暗示上层<strong>窗口已满</strong>。上层等一会再发送（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧。）</p>
</li>
<li><p>收到了一个ACK</p>
<p>GBN协议中，对n号帧的确认采用<strong>累计确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。</p>
<p>累计确认：例如：接收方返回了一个对于3号帧的确认帧，而数据帧的编号也是从0号开始的（0/1/2/3/4/….）。如果接收方将一个3号帧对应的确认帧给发送方。发送方就知道接收方已经接收到3号帧以及3号帧以前的所有的帧（0/1/2帧）。也就是说0到3号帧接收方已经完全接收了。这就是累积确认方式。</p>
<p>也就是说，在GBN协议当中，接收方不用对于每一个数据帧都逐个返回一个对应的确认帧。他可以隔一会在发送一个确认帧。它这个确认帧就是想告诉发送方：包括这个帧，以及这个帧以前的所有帧，它都已经全部正确接收了。</p>
</li>
<li><p>超时事件</p>
<p>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p>
</li>
</ol>
</li>
<li><p>GBN接收方要做的事</p>
<p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p>
<p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息: expectedseqnum(下一个按序接收的帧序号）。</p>
<p>即：接收方很专一，如果没有接收到对应帧的到来，后面的帧即使到了也会被丢弃</p>
</li>
<li><p>示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/54.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>滑动窗口长度可以无限长吗？</p>
<p>若采用n个比特对帧编号，那么发送窗口的尺寸WT,应满足：1 &lt;= W &lt;= 2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧（新帧与旧帧的帧编号相同）。</p>
</li>
<li><p>GBN协议重点总结</p>
<ol>
<li><strong>累计确认</strong>（偶尔捎带确认，接收方把确认帧放在了接收方要发给发送方的数据里）</li>
<li>接收方只按顺序接收帧，不按序无情丢弃</li>
<li>确认序列号最大的，按序到达的帧</li>
<li><strong>发送窗口最大为2^n-1，接收窗口大小为1</strong></li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/65.png" alt="image-20210409215055723"></p>
</li>
<li><p>GBN协议性能分析</p>
<ol>
<li><p>优点：因连续发送数据帧而提高了信道利用率</p>
</li>
<li><p>缺点：在重传时，必须把原来已经正确传送的数据帧重传，使得传送效率降低</p>
<p>选择<strong>重传协议</strong>可以解决这个缺点</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/66.png" alt="image-20210409215131878"></p>
<h4 id="3-1-4-3-、选择重传协议（SR）"><a href="#3-1-4-3-、选择重传协议（SR）" class="headerlink" title="3.1.4.3 、选择重传协议（SR）"></a>3.1.4.3 、选择重传协议（SR）</h4><p>GBN协议的弊端：累计确认—&gt;批量重传。</p>
<p>可不可以只重传出错的帧？</p>
<p>解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p>
<ol>
<li><p>选择重传协议中的滑动窗口示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/55.png" alt="在这里插入图片描述"></p>
</li>
<li><p>SR发送方必须响应的三件事</p>
<ol>
<li><p>上层的调用</p>
<p>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧;</p>
<p>否则就像GBN一样，要么<strong>将数据缓存</strong>，要么<strong>返回给上层</strong>之后再传输。</p>
</li>
<li><p>收到了一个ACK</p>
<p>如果<strong>收到ACK</strong>，加入该帧序号在窗口内，则sR发送方将那个被确认的帧标记为已接收。</p>
<p>如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处。</p>
<p>如果窗口移动了并且有序号在窗白内的未发送帧，则发送这些帧。</p>
</li>
<li><p>超时事件</p>
<p>每一个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</p>
<p>哪个帧的超时器超时，则重传哪个帧</p>
</li>
</ol>
</li>
<li><p>SR接收方要做的事情</p>
<ol>
<li><p>窗口内的帧来者不拒</p>
</li>
<li><p>SR接收方将确<strong>认一个正确接收的帧</strong>而<strong>不管其是否按序</strong>。</p>
<p>失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧【<strong>收谁就确认谁</strong>】，直到失序前面所有帧（即序号更小的帧）皆被接收到为止，这时才可以将一批帧按序交付给上层，然后<strong>向前滑动窗口</strong>。</p>
</li>
<li><p>如果收到了窗口序号外（小于窗口下界）的帧，就返回一个ACK</p>
</li>
<li><p>其他情况就忽略该帧</p>
</li>
</ol>
</li>
<li><p>SR协议运行过程示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/56.png" alt="在这里插入图片描述"></p>
</li>
<li><p>滑动窗口长度可以无限长吗？</p>
<ol>
<li><p>发送窗口大小最好等于接收窗口（大了会溢出，小了没意义）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/67.png" alt="image-20210409223428612"></p>
</li>
<li><p>WTmax=WRmax=2^(n-1)</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/68.png" alt="image-20210409223645651"></p>
</li>
</ol>
</li>
<li><p>SR协议重点总结</p>
<ol>
<li>对数据帧逐一确认，收一个确认一个</li>
<li>只重传出错帧</li>
<li>接收方有缓存</li>
<li>WTmax=WRmax=2^(n-1)</li>
</ol>
</li>
</ol>
<p>例题:</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/69.png" alt="image-20210409223859479"></p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/70.png" alt="image-20210409223919103"></p>
<h3 id="3-2-1-、信道划分介质访问控制"><a href="#3-2-1-、信道划分介质访问控制" class="headerlink" title="3.2.1 、信道划分介质访问控制"></a>3.2.1 、信道划分介质访问控制</h3><ol>
<li><p>传输数据使用的两种链路</p>
<ol>
<li><p>点对点链路</p>
<p>两个相邻节点通过一个链路相连，没有第三者。</p>
<p>应用：<strong>PPP协议</strong>，<strong>常用于广域网</strong>。</p>
</li>
<li><p>广播式链路</p>
<p>所有主机共享通信介质。</p>
<p>应用：早期的总线以太网、无线局域网，<strong>常用于局域网</strong></p>
<p>典型拓扑结构：总线型、星型（逻辑总线型）</p>
</li>
</ol>
</li>
<li><p>介质访问控制</p>
<p>介质访问控制的内容就是，采取一定的措施，使得两对界限之间的通信不会发生相互干扰的情况</p>
<p>介质访问控制分类</p>
<ol>
<li><p>静态划分信道，即信道划分介质访问控制（C!WTF）</p>
<ol>
<li>频分多路复用FDM（frequency）</li>
<li>时分多路复用TDM（time）</li>
<li>波分多路复用WDM（wave）</li>
<li>码分多路复用CDM（code）</li>
</ol>
</li>
<li><p>动态分配信道</p>
<ol>
<li><p>轮询访问介质访问控制</p>
<p>令牌传递协议</p>
</li>
<li><p>随机访问介质访问控制</p>
<ol>
<li>ALOHA协议</li>
<li>CSMA协议</li>
<li>CSMA/CD协议（重要）</li>
<li>CSMA/CA协议（重要）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>信道划分介质访问控制</p>
<p>将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域和频域资源</strong>合理地分配给网络上的设备</p>
<ol>
<li><p>多路复用技术</p>
<p>把多个信号组合放在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率</p>
<p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，<strong>实际就是把广播信道转变为点对点信道</strong>。</p>
<p>图示：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/71.png" alt="在这里插入图片描述"></p>
</li>
<li><p>静态划分信道（信道划分介质访问控制）</p>
<ol>
<li><p>频分多路复用FDM</p>
<ol>
<li><p>概念：</p>
<p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
<p><strong>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源。</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/75.png" alt="image-20210410023214368"></p>
</li>
<li><p>优点：充分利用传输介质带宽，系统效率更高；由于技术比较成熟，实现也比较容易。</p>
</li>
</ol>
</li>
<li><p>时分多路复用TDM</p>
<ol>
<li><p>概念：</p>
<p>将时间划分为一段段等长的时分复用帧（TDM帧）。</p>
<p>每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道。</p>
<p>TDM帧与数据链路层的帧不同，<strong>TDM帧是在物理层传送的比特流所划分的帧，标志一个周期</strong>(cpu的时间片轮转)。</p>
</li>
</ol>
<p>这一个周期对应的是在一个周期内可以发送多少个比特。</p>
<ol start="2">
<li><p>频分复用–“并行”</p>
<p>时分复用–“并发”</p>
</li>
<li><p>改进的时分复用–统计时分复用STDM(增加了信道的利用率)</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/72.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>波分多路复用WDM</p>
<p>概念：波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/76.png" alt="image-20210410023757326"></p>
</li>
<li><p>码分多路复用CDM</p>
<p>注意：码分多址（CDMA）是码分复用的一种方式，注意与码分多路复用区分</p>
<ol>
<li><p>概念：<br>把1个比特分为多个码片/芯片（chip），每一个站点被指定一个唯一的m位（m位通常是128位或64位）的芯片序列发送1时，站点发送送芯片序列，发送0时发送芯片序列的反码（在芯片序列中，把0写成-1，正交的码片，CDM原理是利用向量正交为0.）</p>
</li>
<li><p>如何不打架：多个站点同时发送数据的时候，要求各个站点芯片序列<strong>相互正交</strong>（<strong>规格内积化是0</strong>）</p>
<p>规格内积化：将对应的各位相乘，然后相加，最后在除于总的位数。</p>
</li>
<li><p>如何合并：各路数据在信道中被<strong>线性相加</strong>（对应的各个位进行相加）</p>
</li>
<li><p>如何分离：合并数据和原站（芯片序列 ）规格化内积</p>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/77.png" alt="image-20210410024814953"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-2-2-、随机访问介质访问控制"><a href="#3-2-2-、随机访问介质访问控制" class="headerlink" title="3.2.2 、随机访问介质访问控制"></a>3.2.2 、随机访问介质访问控制</h3><p><strong>动态分配信道，也叫动态媒体接入控制/多点接入</strong>。</p>
<p>特点：信道<strong>并非</strong>在用户通信时<strong>固定</strong>分配给用户。</p>
<p>随机访问介质访问控制：所有用户可以随机发送信息，发送信息时占<strong>全部带宽</strong>。（不协调 =》冲突 =》 协议解决）</p>
<ul>
<li>ALOHA协议 不听就说</li>
<li>CSMA协议 先听再说</li>
<li>CSMA/CD协议（重要） 先听再说，边听边说</li>
<li>CSMA/CA协议（重要）</li>
</ul>
<h4 id="1、ALOHA协议"><a href="#1、ALOHA协议" class="headerlink" title="1、ALOHA协议"></a>1、ALOHA协议</h4><p>ALOHA协议（非重点）</p>
<ol>
<li><p>纯ALOHA协议</p>
<ol>
<li><p>思想：不监听信道，不按时间槽发送，随机重发。（想发就发）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/78.png" alt="image-20210410025200886"></p>
<p>其中T0规定的是一个数据帧的长度。（一般一个数据帧的长度都是用比特来衡量，这里用T0衡量是什么意思呢？）T0指的是这样一个数据帧的发送时间。这里面的发送时间既包括传输时间，也包括传播时间。也就是一个数据帧从刚开始发送到发送成功为止的这样一段时间就叫做T0。</p>
</li>
<li><p>冲突如何检测？</p>
<p>如果发生冲突，接收方就会检测出差错，然后发送否定确认帧或者不发送确认帧，发送方在一定时间内收不到确认帧就判断冲突。</p>
</li>
<li><p>冲突如何解决？</p>
<p>超时后等一随机时间再重传。</p>
</li>
</ol>
</li>
<li><p>时隙ALOHA协议</p>
<p>思想：把时间分成若干个相同的时间片（T0，也可以叫做时间槽），所有用户的时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。（控制想发就发的随意性）</p>
<p>主要特点：</p>
<ul>
<li>每一个站点在发送帧的时候，只能在一个时间片/时间槽的开始来发送</li>
<li>若站点当前想要发送数据帧，但是还没到一个时间片的开始，那么站点就会等待一个时间片的到来之后在进行发送</li>
<li>如果数据帧在发送过程中发生碰撞，那么这个结点就会在时隙结束之后，也就是经过一个T0之后，发送方发现了这样一个碰撞（接收方没有返回一个确认帧），发送方就判定数据在发送过程中发生了冲突。于是发送方进行超时重传。</li>
<li>发送方进行超时重传是依旧遵循之前的协议。在一个时隙（时间片）开始的时候来重传数据帧</li>
</ul>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/79.png" alt="image-20210410030015295"></p>
</li>
<li><p>关于ALOHA协要知道的事</p>
<ol>
<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>
<li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发</li>
<li>不冲突概率=p(1-p)^2(N-1) = 1/2e，而时隙ALOHA只考虑一个时隙开始时，所以时隙ALOHA的效率是纯ALOHA效率的两倍</li>
</ol>
</li>
</ol>
<h4 id="2、CSMA协议"><a href="#2、CSMA协议" class="headerlink" title="2、CSMA协议"></a>2、CSMA协议</h4><ol>
<li><p>名词详解</p>
<p>载波监听多路访问协议CSMA（carrier sense multiple access）</p>
<ul>
<li><p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<ul>
<li><p>如何监听？</p>
<p>当几个站同时在总线上发送数据时，总线上的信号<strong>电压摆动值</strong>将会增大（互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p>
</li>
</ul>
</li>
<li><p>MA：多点接入，表示许多计算以多点接入的方式连接在一根总线上</p>
</li>
</ul>
</li>
<li><p>协议思想：发送帧之前，监听信道</p>
<p>监听结果：</p>
<ol>
<li>信道空闲：发送完整数据帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持CSMA</li>
<li>非坚持CSMA</li>
<li>P坚持CSMA</li>
</ul>
</li>
</ol>
</li>
<li><p>1-坚持CSMA</p>
<ul>
<li><p>坚持是指：对于监听信道<strong>忙</strong>之后的坚持。</p>
</li>
<li><p>1-坚持CSMA思想：</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li>监听结果空闲，则不必等待直接发送</li>
<li>监听结果为<strong>忙，则一直监听，直到空闲马上传输</strong></li>
<li>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听（等待随机长的时间这一点与ALOHA协议类似，后同），重复上述过程。</li>
</ul>
</li>
<li><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的丢失</p>
</li>
<li><p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免</p>
<p>比如这多个站点全部采用1-坚持CSMA，则一检测到信道空闲，就会同时发送信息，就会发生冲突。</p>
</li>
</ul>
</li>
<li><p>非坚持CSMA</p>
<ol>
<li><p>非坚持CSMA思想：</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li>监听结果空闲，则不必等待直接发送</li>
<li>监听结果为<strong>忙，则等待以后随机时间之后再进行监听</strong>。</li>
</ul>
</li>
<li><p>优点：采用随机的重发延迟时间，可以减少冲突发生的可能性</p>
</li>
<li><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率低。</p>
</li>
</ol>
</li>
<li><p>P-坚持CSMA</p>
<ol>
<li><p>P-坚持是指：对于<strong>监听信道空闲</strong>的处理。</p>
</li>
<li><p>P-坚持CSMA的思想</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li><strong>空闲则以p概率直接传输，不必等待;概率1-p等待到下一个时间槽再传输。</strong></li>
<li>忙则等待下一个时隙开始才监听，故叫做持续监听，重复上述过程</li>
</ul>
</li>
<li><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间。</p>
</li>
<li><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费（这是所有CSMA的缺点，1-坚持、非坚持、P-坚持CSMA都有的缺点）</p>
</li>
</ol>
<p>三种CSMA的对比（注意P-坚持CSMA不太一样）：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/81.png" alt="image-20210410032318214"></p>
</li>
</ol>
<h4 id="3、CSMA-CD协议（重要）"><a href="#3、CSMA-CD协议（重要）" class="headerlink" title="3、CSMA/CD协议（重要）"></a>3、CSMA/CD协议（重要）</h4><ol>
<li><p>大体思想：边发送数据，边监听信道，如果发生冲突就停止发送数据</p>
</li>
<li><p>名词详解</p>
<p>载波监听多点接入/CD（也叫碰撞检测CSMA） （carrier sense multiple access with collision detection）</p>
<p>CS：载波侦听/监听，每一个站点在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</p>
<p>与CSMA不同的是：CSMA/CD在发送数据时也会监听信道</p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。=》 <strong>总线型网络</strong></p>
<p>CD：碰撞检测（冲突检测），“<strong>边发送边监听</strong>”，应用于适配器边发送数据，边检测信道上信号电压的变化情况，以便判断自己在发送数据时，其他站是否也在发送数据。</p>
<p>应用于：<strong>半双工网络</strong></p>
<p>主要应用于<strong>总线式以太网</strong></p>
</li>
<li><p>为什么先监听后发送还会产生冲突？</p>
<p>因为：电磁波在总线上总是以有限的速率传播的。</p>
<p>传播时延对载波监听的影响：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/82.png" alt="image-20210410032912095"></p>
<p>假设：单程端到端传播时延：t    最迟多久才能知道自己发送的数据没和别人碰撞？</p>
<p>最多是两倍的总线到端的传播时延（2 * t），即总线的端到端的往返传播时延（2 * t）</p>
<p>只要经过2 * t时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/83.png" alt="image-20210410033340427"></p>
</li>
<li><p>如何确定碰撞后的重传时机？</p>
<p>如果检测到碰撞立即重发会导致恶性循环：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/84.png" alt="image-20210410033509456"></p>
<p>截断二进制指数规避算法</p>
<ol>
<li><p>确定基本退避（<strong>推迟</strong>）时间为争用期2t</p>
</li>
<li><p>定义参数k,它等于<strong>重传次数</strong>，但k不超过10，即k=min[重传次数，10]。</p>
<ul>
<li>当重传次数不超过10时，k等于重传次数；</li>
<li>当重传次数大于10时，k就不再增大而一直等于10。</li>
</ul>
</li>
<li><p>从离散的整数集合[0,1,…,2^k-1]中随机取出一个数r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即2 * r * t。</p>
</li>
<li><p>当重传达<strong>16次</strong>（最大重传次数）仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</p>
<p>截断二进制指数规避算法使用示例</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/73.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/85.png" alt="image-20210410034142801"></p>
</li>
<li><p>最小帧长问题：</p>
<p>A站发了一个很短的帧，但是发生了碰撞，不过帧在发送完毕后才检测出发生碰撞，没法停止发送。为了使CSMA/CD协议有意义，要定义一个最小帧长。</p>
<p><strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong></p>
<p>帧的传输时延 = 帧长（bit）/ 数据传输率 &gt;= 2 * 总线传播时延</p>
<p>即：最小帧长 = 2 * 总线传播时延 * 数据传输速率 = 2 * t * 数据传输速率</p>
<p>补充：以太网规定最短帧长为<strong>64B</strong>，凡是长度小于64B的都是由于冲突而异常终止的无效帧。因此，以太网为了达到这个最小帧长，对于一个比较短的帧，它会对它进行一个<strong>填充</strong>操作，使它的帧长大于等于64B，然后才能将它放到链路上进行发送。</p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/86.png" alt="image-20210410034655978"></p>
</li>
</ol>
<h4 id="4、CSMA-CA协议（重要）"><a href="#4、CSMA-CA协议（重要）" class="headerlink" title="4、CSMA/CA协议（重要）"></a>4、CSMA/CA协议（重要）</h4><p>CA：对碰撞的避免</p>
<p>CD：对碰撞的检测</p>
<ol>
<li><p>名词解释</p>
<ol>
<li><p>载波监听多点接入/CA（碰撞避免CSMA，不能检测碰撞）（carrier sense multiple access with collision avoidance）</p>
</li>
<li><p>为什么要有CSMA/CA？</p>
<p>主要是因为：CA主要应用于<strong>无线局域网</strong></p>
<ol>
<li><p>在无线局域网中无法使用CD协议，不能做到360度全面检测碰撞</p>
<ul>
<li>CD主要应用于总线式以太网</li>
</ul>
</li>
<li><p>隐蔽站问题，当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会发生冲突。</p>
<p>C相对于A就是隐蔽站</p>
</li>
</ol>
</li>
<li><p>有礼貌的CSMA/CA：不光是先听后发，在听了之后，发送数据之前会等一小段时间。</p>
</li>
</ol>
</li>
<li><p>CSMA/CA工作原理</p>
<p>发送数据之前，先检测信道是否空闲。</p>
<p>若空闲则发出RTS（request to send），RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；RTS可发可不发，<strong>发RTS是为了解决隐蔽站的问题</strong>。</p>
<p>若信道忙，则等待。接收端收到RTS后，将响应CTS（clear to send）</p>
<p>RTS和CTS就是用来解决隐蔽站的问题：</p>
<ul>
<li><p>发送端收到CTS后，开始发送数据帧（同时开始预约信道：发送方告知其他站点自己要传多久数据）</p>
</li>
<li><p>接收端收到数据帧后，将用CRC（CRC循环冗余检验）来检验数据是否正确，正确则响应ACK帧</p>
</li>
<li><p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止</p>
<p>（这里跟CD协议一样，采用二进制指数退避算法来确定随机的推迟时间。）</p>
</li>
</ul>
</li>
<li><p>三个机制实现碰撞避免</p>
<ol>
<li>预约信道</li>
<li>ACK帧</li>
<li>RTS/CTS帧（可选，主要是解决隐蔽站的问题）</li>
</ol>
</li>
<li><p>CD和CA协议的比较</p>
<ul>
<li><p>相同点：</p>
<p>CD和CA机制都从属于CDMA的思路，其核心就是<strong>先听再说</strong>。</p>
<p>换言之，两个在接入信道前都要进行监听。当发现信道空闲后，才能进行接入。</p>
</li>
<li><p>不同点：</p>
<ol>
<li>传输介质不同<ul>
<li>CD用于总线式以太网【有线】</li>
<li>CA用于无线局域网【无线】</li>
</ul>
</li>
<li>载波检测方式不同<ul>
<li>应传输介质不同，CD和CA的检测方式也不同。</li>
<li>CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；</li>
<li>CA采用能量检测（ED）、载波检测（CS）和能量载波检测三种检测信道空闲的方式。</li>
<li><strong>CSMA/CD检测冲突</strong>，<strong>CSMA/CA避免冲突</strong>，两者出现冲突后都会进行<strong>有上限的重传。</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-3-、轮询访问介质访问控制"><a href="#3-2-3-、轮询访问介质访问控制" class="headerlink" title="3.2.3 、轮询访问介质访问控制"></a>3.2.3 、轮询访问介质访问控制</h3><p>信道划分介质访问控制（MAC Multiple Access Control）协议：</p>
<ul>
<li>基于多路复用技术划分资源</li>
<li>网络负载重时，共享信道效率高，且公平</li>
<li>网络负载轻时：共享信道效率低</li>
</ul>
<p>随机访问MAC协议：</p>
<ul>
<li>用户根据意愿随机发送信息，发送信息时可独占信道带宽</li>
<li>网络负载重时，产生冲突开销</li>
<li>网络负载轻时，共享信道效率高，单个结点可利用信道全部带宽</li>
</ul>
<p>轮询访问MAC协议/轮流协议/轮转访问MAC协议：</p>
<p>综合信道划分介质访问控制协议和随机访问MAC协议，既不产生冲突，也要发送时占用全部带宽</p>
<ul>
<li><p>轮询协议</p>
<p>主结点轮流“邀请”从属结点发送数据</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504145458454-1620111300402.png" alt="image-20210504145458454"></p>
<p>问题：</p>
<ol>
<li>轮询开销</li>
<li>靠后结点有等待延迟</li>
<li>单点故障：主结点发生故障</li>
</ol>
</li>
<li><p>令牌传递协议（重要）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504145553598-1620111355000.png" alt="image-20210504145553598"></p>
</li>
</ul>
<p>主机</p>
<p>TCU（转发器）</p>
<p>令牌：一个特殊格式的MAC控制帧，不含任何信息</p>
<p>控制信道的使用，确保同一时刻只有一个结点独占信道。</p>
<p>每一个结点都可以在一定的时间内（令牌持有时间内）获得发送数据的权利，并不是无限制地持有令牌</p>
<p>问题：</p>
<ol>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障（一个主机宕机后，线路故障）</li>
</ol>
<p>通常应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p>
<p>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p>
<p>介质访问控制总结：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150943372-1620112185046.png" alt="image-20210504150943372"></p>
<h3 id="3-3-1-、局域网基本概念和体系结构"><a href="#3-3-1-、局域网基本概念和体系结构" class="headerlink" title="3.3.1 、局域网基本概念和体系结构"></a>3.3.1 、局域网基本概念和体系结构</h3><p>局域网（LAN，Local Area Network）</p>
<ol>
<li><p>概念：是指某一区域内由多台计算机互连成的计算机组，使用广播信道</p>
</li>
<li><p>特点</p>
<ol>
<li>覆盖地理范围小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li>
<li>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s-10Gb/s）</li>
<li>通信延迟时间短，误码率低，可靠性高</li>
<li>各站点为平等关系，共享传输信道</li>
<li>多采用分布式控制和广播式通信，能进行广播和组播</li>
</ol>
</li>
<li><p>决定局域网的主要要素为：<strong>网络拓扑</strong>，<strong>传播介质</strong>与<strong>介质访问控制方法</strong></p>
<ol>
<li><p>局域网的网络拓扑</p>
<ol>
<li><p>星型拓扑</p>
<p>中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构形简单、建网容易、便于控制和管理。但这种网络系统，网络可靠性低，网络共享能力差，<strong>有单点故障问题</strong>。</p>
</li>
<li><p>总线型拓扑（常用）</p>
<p>网络可靠性高、网络节点间响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便，当某个工作站节点出现故障时，对整个网络系统影响小。</p>
</li>
<li><p>环形拓扑</p>
<p>系统中通信设备和线路比较节省。<strong>有单点故障问题</strong>；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p>
</li>
<li><p>树形拓扑</p>
<p>易于拓展，易于隔离故障，也<strong>容易有单点故障。</strong></p>
</li>
</ol>
</li>
<li><p>局域网传输介质</p>
<ol>
<li>有线局域网 常用介质：双绞线、同轴电缆、光纤</li>
<li>无线局域网 常用介质：电磁波</li>
</ol>
</li>
<li><p>局域网介质访问控制方法</p>
<ol>
<li><p>CSMA/CD 常用于<strong>总线型局域网</strong>，也用于<strong>树型网络</strong></p>
</li>
<li><p>令牌总线常用于<strong>总线型局域网</strong>，也用于<strong>树型网络</strong></p>
<p>   它是把<strong>总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环</strong>。只有令牌持有者才能控制总线，才有发送信息的权力。</p>
</li>
<li><p>令牌环 用于环形局域网，如<strong>令牌环网</strong></p>
<ul>
<li><strong>逻辑拓扑：环型</strong>（逻辑拓扑主要受通信思想的制约）</li>
<li><strong>物理拓扑：星型</strong>（物理拓扑主要受限制的制约）</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>局域网的分类</p>
<ol>
<li><p>以太网</p>
<p> 以太网是应用最广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，它们都符合IEEE 802.3系列标准规范。</p>
<p>逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD</p>
</li>
<li><p>令牌环网</p>
<p>造价高，不是很实用，已是明日黄花</p>
<p>物理拓扑星型，逻辑拓扑环型</p>
</li>
<li><p>FDDI网（Fiber Distributed Data Interface）（了解）</p>
<p>用的很少</p>
<p>物理双环拓扑，逻辑环型拓扑</p>
</li>
<li><p>ATM网（Asynchronous Transfer Mode）（了解）</p>
<p>较新型的单元交换技术，使用53字节固定长度的单元进行交换</p>
</li>
<li><p>无线局域网（Wireless Local Area Network，WLAN）</p>
<p>采用IEEE 802.11标准</p>
</li>
</ol>
</li>
<li><p>IEEE 802标准</p>
<p>IEEE802系列标准是IEEE802LAN/MAN标准委员会制定的局域网、城域网技术标准（1980年2月成立）其中最广泛使用的有以太网、令牌环网、无线局域网。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>
<ol>
<li><p><strong>IEEE802.3标准</strong></p>
<p><strong>以太网</strong>介质访问控制协议及物理层技术规范</p>
</li>
<li><p><strong>IEEE802.5标准</strong></p>
<p><strong>令牌环网</strong>的介质访问控制协议及物理层技术规范</p>
</li>
<li><p><strong>IEEE802.8标准</strong></p>
<p>光纤技术咨询组，提供有关光纤联网的技术咨询（<strong>FDDI网</strong>）</p>
</li>
<li><p><strong>IEEE802.11</strong></p>
<p><strong>无线局域网（WLAN）</strong>的介质访问控制协议及物理层技术规范</p>
</li>
</ol>
</li>
<li><p>MAC子层和LLC子层</p>
<p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的<strong>数据链路层和物理层</strong>，它将数据链路层划分为<strong>逻辑链路层LLC子层</strong>、<strong>介质访问控制MAC子层</strong>。</p>
<ol>
<li><p>LLC负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。</p>
<p>为网络层提供服务:无确认无连接、面向连接、带确认无连接、高速传送。</p>
</li>
<li><p>MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。</p>
<p>MAC子层的存在屏蔽了不同物理链路种类的差异性。</p>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150742911-1620112064581.png" alt="image-20210504150742911"></p>
</li>
</ol>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150832973-1620112114455.png" alt="image-20210504150832973"></p>
<h3 id="3-3-2、以太网概述"><a href="#3-3-2、以太网概述" class="headerlink" title="3.3.2、以太网概述"></a>3.3.2、以太网概述</h3><ol>
<li><p>概念</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。<strong>以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术</strong>。</p>
</li>
<li><p>以太网在局域网各种技术中占<strong>统治地位</strong></p>
<ol>
<li>造价低廉（以太网网卡不到100块）</li>
<li>是应用最广泛的局域网技术</li>
<li>比令牌环网、ATM网便宜，简单</li>
<li>满足网络速率的要求，10Mbps-10Gbps</li>
</ol>
</li>
<li><p>以太网的两个标准</p>
<ol>
<li>DIX Ethernet V2：第一个局域网产品（以太网）规约。</li>
<li>IEEE802.3：IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准</li>
</ol>
<p>这两个标准的区别不大，只是在帧的格式上有两个字节的差异，<br>因此只要满足两个标准中的一个都叫以太网，以太网也叫802.3局域网</p>
</li>
<li><p>以太网提供无连接、不可靠的服务</p>
<ul>
<li>无连接：发送方和接收方之间无“握手过程”。</li>
<li>不可靠：<ul>
<li>不对发送方的数据帧编号，</li>
<li>接收方不向发送方进行确认，</li>
<li>差错帧直接丢弃，</li>
<li>差错纠正由高层负责。</li>
</ul>
</li>
</ul>
<p><strong>以太网只实现无差错接受，不实现可靠传输</strong>。</p>
</li>
<li><p>以太网传输介质和拓扑结构的发展</p>
<ul>
<li>传输介质：粗同轴电缆–&gt;细同轴电缆–&gt;双绞线+集线器</li>
<li>物理拓扑：总线型–&gt;星型<ul>
<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议</li>
</ul>
</li>
<li>以太网拓扑：逻辑上总线型，物理上星型</li>
</ul>
</li>
<li><p>10BASE-T以太网</p>
<ul>
<li>10BASE-T是传送基带信号的<strong>双绞线</strong>以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），<strong>传输速率是10Mb/s</strong>。</li>
<li><strong>物理上采用星型拓扑、逻辑上总线型，每段双绞线最长100m</strong></li>
<li>采用<strong>曼彻斯特编码</strong></li>
<li>采用<strong>CSMA/CD</strong>介质访问控制</li>
</ul>
</li>
<li><p>适配器与MAC地址</p>
<ul>
<li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。<ul>
<li>网络接口板</li>
<li>网络接口卡NIC（network interface card），现在不再使用网卡</li>
<li>适配器上装有处理器和存储器（包括RAM和ROM）</li>
<li><strong>ROM上有计算机硬件地址MAC地址</strong></li>
</ul>
</li>
<li>在局域网中，<strong>硬件地址又称为物理地址</strong>，或<strong>MAC地址</strong>。【实际上是<strong>标识符</strong>】</li>
<li>MAC地址：每个适配器由全球唯一的二进制地址，前24位代表厂家（有IEEE规定），后24位厂家自己指定。常用<strong>6个十六进制数</strong>表示。即：这个是12个16进制数决定，前六位是厂家，后六位是各个网络制造商自己规定的。如02-60-8c-e4-b1-21</li>
</ul>
</li>
<li><p>以太网MAC帧</p>
<ul>
<li><p>最常用的MAC帧是<strong>以太网V2的格式</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000153735.png" alt="img"></p>
<ul>
<li>目的地址有三种情况<ul>
<li>单播地址，一个专有的MAC地址。传播给固定主机</li>
<li>广播地址：8B的前导码全”1”（二进制）,或者全”F”（十六进制）。会发生给所有主机</li>
<li>多播地址</li>
</ul>
</li>
</ul>
</li>
<li><p>与IEE 802.3的区别：</p>
<ol>
<li>第三个字段是长度/类型</li>
<li>当长度/类型字段值小于0x0600时，数据字段必须装入LLC子层。</li>
</ol>
</li>
</ul>
</li>
<li><p>高速以太网    </p>
<ol>
<li><p>100BASE-T以太网</p>
<ul>
<li><p>在<strong>双绞线</strong>上传送<strong>100Mb/s基带信号</strong>的<strong>星型拓扑以太网</strong>，仍使用IEEE802.3的<strong>CSMA/CD</strong>协议。</p>
</li>
<li><p>支持全双工和半双工，可在<strong>全双工方式下工作而无冲突</strong>（不使用CSMA/CD协议）。</p>
<ul>
<li><p>全双工（<strong>交换机可以隔离冲突域</strong>，每一个交换机的端口都是一个冲突域，一个主机在一个冲突域当中不存在冲突）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153357428-1620113639265.png" alt="image-20210504153357428"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>吉比特以太网</p>
<ul>
<li>在<strong>光纤或双绞线</strong>上传送<strong>1Gb/s信号</strong>。</li>
<li><strong>支持全双工和半双工，可在全双工方式下工作而无冲突</strong>。</li>
</ul>
</li>
<li><p>10吉比特</p>
<ul>
<li>10吉比特以太网在<strong>光纤</strong>上传送<strong>10Gb/s信号</strong>。</li>
<li>只支持全双工，无争用问题</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153615323-1620113777239.png" alt="image-20210504153615323"></p>
<h3 id="3-3-3、无线局域网"><a href="#3-3-3、无线局域网" class="headerlink" title="3.3.3、无线局域网"></a>3.3.3、无线局域网</h3><p>IEEE802.11是无线局与通信用的标准，它是由IEEE所定义的无线通信的标准</p>
<p>wifi是WLAN的一种应用，WLAN可以比较大。</p>
<p>802.11的MAC帧头格式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153957809.png" alt="image-20210504153957809"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154046849.png" alt="image-20210504154046849"></p>
<p>总结一下：</p>
<ul>
<li>IBSS就是一个服务集内的移动站点不通过基站的直接通信</li>
<li>To AP 就是服务集内的移动站点向基站的通信</li>
<li>From AP 就是服务集内基站向移动站的通信</li>
<li>WDS就是不同服务集内的两个移动站之间的通信（漫游）</li>
</ul>
<p>无线局域网的分类：</p>
<ol>
<li><p>有固定基础设施无线局域网</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154529596.png" alt="image-20210504154529596"></p>
</li>
<li><p>无固定基础设施无线局域网的自组织网络</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154658400.png" alt="image-20210504154658400"></p>
</li>
</ol>
<h3 id="3-3-4、PPP协议和HDLC协议"><a href="#3-3-4、PPP协议和HDLC协议" class="headerlink" title="3.3.4、PPP协议和HDLC协议"></a>3.3.4、PPP协议和HDLC协议</h3><p>广域网（WAN，Wide Area Network）通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p>
<p>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。如因特网(Internet)是世界范围内最大的广域网。</p>
<p><strong>广域网强调资源共享，局域网强调数据传输</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154840374.png" alt="image-20210504154840374"></p>
<ol>
<li><p>PPP协议：</p>
<ol>
<li><p>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用PPP协议</p>
<ul>
<li><strong>只支持全双工链路</strong></li>
</ul>
</li>
<li><p>PPP协议应满足的要求：</p>
<ul>
<li><strong>简单</strong> 对于链路层的帧，无需纠错，无需序号，无需流量传输</li>
<li><strong>封装成帧</strong> 帧定界符</li>
<li><strong>透明传输</strong> 与帧定界符一样比特组合的数据应该如何处理：<strong>异步线路用字节填充</strong>，<strong>同步线路用比特填充</strong></li>
<li><strong>多种网络层协议</strong> 封装的IP数据报可以采用多种协议</li>
<li><strong>多种类型链路</strong> 串行/并行，异步/同步，光/电</li>
<li><strong>差错检测</strong> 错就丢弃</li>
<li><strong>检测连接状态</strong> 链路是否正常</li>
<li><strong>最大传送单元</strong> 数据部分最大长度MTU(默认不超过1500B)</li>
<li><strong>网络层地址协商</strong> 知道通信双方的网络层地址</li>
<li><strong>数据压缩协商</strong></li>
</ul>
</li>
<li><p>PPP协议无需满足的要求：</p>
<ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>对帧编序号</strong></li>
<li><strong>不支持多点线路</strong></li>
</ul>
</li>
<li><p>PPP协议的三个组成部分：</p>
<ol>
<li>一个将IP数据报封装到擦混行链路（同步串行/异步串行）的方法 </li>
<li>链路控制协议LCP：建立并维护数据链路连接。（物理连接）<ul>
<li>应用：身份验证</li>
</ul>
</li>
<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接（逻辑连接）</li>
</ol>
</li>
<li><p>PPP协议的状态图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000226542.png" alt="img"></p>
</li>
<li><p>PPP协议的帧格式</p>
<ul>
<li><p>帧格式是什么东西?</p>
</li>
<li><p>还有MAC帧格式（以字节为单位）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000236673.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>HDLC协议</p>
<p>高级数据链路控制（High-Level Data Link Control或简称HDLC)，是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议，它是由国际标准化组织(<strong>ISO</strong>)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的。</p>
<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p>
<p><strong>采用全双工通信</strong></p>
<p><strong>所有帧采用CRC检验，对信息帧进行顺序编号</strong>，<strong>可防止漏收或重份，传输可靠性高</strong>。</p>
<p>HDLC的站：<strong>主站</strong>、<strong>从站</strong>、<strong>复合站</strong></p>
<ol>
<li>主站的主要功能是发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li>
<li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li>
<li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li>
</ol>
<p>HDLC的三种数据操作方式：</p>
<ol>
<li><p>正常响应方式</p>
<p>从站发送消息要经过主站的同意，主站命令从站发送数据，从站才可以发送数据</p>
</li>
<li><p>异步平衡方式</p>
<p>每一个复合站都可以对其他站的数据传输，每个站都是平等的地位</p>
</li>
<li><p>异步响应方式</p>
<p>从站可以不经过主站的同意就进行数据的传输</p>
</li>
</ol>
<p>HDLC的帧格式：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504160825465.png" alt="image-20210504160825465"></p>
<p>对于地址A：取决于当前选择的数据操作方式</p>
<ul>
<li>正常响应方式/异步响应方式：从站的地址</li>
<li>异步平衡方式：对应站（应答站），也就是对方的地址</li>
</ul>
<p>对于控制C：决定了HDLC帧的类型（无奸细）</p>
<ul>
<li><strong>信息帧(I)**：</strong>第1位为0<strong>，用来</strong>传输数据信息<strong>，或使用捎带技术</strong>对数据进行确认**;</li>
<li><strong>监督帧(S)**：</strong>10**, 用于<strong>流量控制和差错控制</strong>，执行<strong>对信息帧的确认、请求重发和请求暂停发送</strong>等功能</li>
<li><strong>无编号帧(U)**：</strong>11**, 用于提供对<strong>链路的建立、拆除</strong>等多种控制功能。</li>
</ul>
</li>
<li><p>PPP协议 &amp; HDLC协议</p>
<p>相同点：</p>
<ul>
<li>HDLC、PPP<strong>只支持全双工链路</strong></li>
<li>都可以实现差错检测，但不纠正差错</li>
<li>都可以<strong>实现透明传输</strong><ul>
<li>关于透明传输的一点小差别：<ul>
<li>PPP协议既可以实现0比特填充的比特型的填充方法，也可以实现字节填充的方法</li>
<li>HDLC协议只能实现0比特填充的比特型的填充方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>区别：</p>
<table>
<thead>
<tr>
<th>PPP协议</th>
<th>面向字节</th>
<th>2B协议字段</th>
<th>无序号和确认机制</th>
<th>不可靠</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HDLC协议</strong></td>
<td><strong>面向比特</strong></td>
<td><strong>没有</strong></td>
<td><strong>有编号和确认机制</strong></td>
<td><strong>可靠</strong></td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162250883.png" alt="image-20210504162250883"></p>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162337180.png" alt="image-20210504162337180"></p>
<h3 id="3-4-1、链路层设备"><a href="#3-4-1、链路层设备" class="headerlink" title="3.4.1、链路层设备"></a>3.4.1、链路层设备</h3><h4 id="3-4-1-1、物理层扩展以太网"><a href="#3-4-1-1、物理层扩展以太网" class="headerlink" title="3.4.1.1、物理层扩展以太网"></a>3.4.1.1、物理层扩展以太网</h4><p>采用光纤的方式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162926611.png" alt="image-20210504162926611"></p>
<p>采用集线器的方式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504163113104.png" alt="image-20210504163113104"></p>
<p>可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的<strong>所有设备</strong>变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥</p>
<h4 id="3-4-1-2、数据链路层扩展以太网"><a href="#3-4-1-2、数据链路层扩展以太网" class="headerlink" title="3.4.1.2、数据链路层扩展以太网"></a>3.4.1.2、数据链路层扩展以太网</h4><p>采用网桥的方式：</p>
<p>网桥根据<strong>MAC帧</strong>的目的地址对帧进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504163354054.png" alt="image-20210504163354054"></p>
<p>网桥优点：</p>
<ul>
<li>过滤通信量，增大吞吐量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ul>
<p>网桥的分类：</p>
<ul>
<li><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。</p>
<ul>
<li><p>关于自学习</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504164127428.png" alt="image-20210504164127428"></p>
</li>
</ul>
</li>
<li><p>源路由网桥：在发送帧时，把详细的最佳路由信息( 路由最少/时间最短)放在帧的首部中。</p>
<p>方法：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504164759387.png" alt="image-20210504164759387"></p>
</li>
</ul>
<p>采用交换机的方法</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504165249409.png" alt="image-20210504165249409"></p>
<p>以太网交换机的两种交换方式：</p>
<ul>
<li>直通式交换机：查完目的地址(6B) 就立刻转发。<ul>
<li>优点：延迟小</li>
<li>缺点：可靠性低，无法支持具有不同速率的端口的交换。</li>
</ul>
</li>
<li>存储转发式交换机（常用）：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<ul>
<li>优点：<strong>可靠性高，可以支持具有不同速率的端口的交换</strong>。</li>
<li>缺点：延迟大</li>
</ul>
</li>
</ul>
<p>冲突域 VS 广播域</p>
<ul>
<li>冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是<strong>同一时间内只能有一台设备发送信息的范围</strong>。</li>
<li>广播域：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说<strong>如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备[傻瓜]<br>(中继器、集线器)</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>链路层设备[路人]<br>(网桥、交换机)</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>网络层设备[大佬]<br>(路由器)</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>相关例题：（广播域看路由器，冲突域：交换机每一个接口就是一个冲突域）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170220974.png" alt="image-20210504170220974"></p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170343115.png" alt="image-20210504170343115"></p>
<h3 id="3-5、第三章总结"><a href="#3-5、第三章总结" class="headerlink" title="3.5、第三章总结"></a>3.5、第三章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170510895.png" alt="image-20210504170510895"></p>
<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2020070417434323.jpg" alt="img"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200704174405272.jpg" alt="img"></p>
<h3 id="4-1、网络层的任务与功能"><a href="#4-1、网络层的任务与功能" class="headerlink" title="4.1、网络层的任务与功能"></a>4.1、网络层的任务与功能</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155309690.png" alt="image-20210505155309690"></p>
<h3 id="4-2、数据交换方式"><a href="#4-2、数据交换方式" class="headerlink" title="4.2、数据交换方式"></a>4.2、数据交换方式</h3><h4 id="1、网络的“掌中宝”——路由器"><a href="#1、网络的“掌中宝”——路由器" class="headerlink" title="1、网络的“掌中宝”——路由器"></a>1、网络的“掌中宝”——路由器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155454971.png" alt="image-20210505155454971"></p>
<h4 id="2、为什么要数据交换"><a href="#2、为什么要数据交换" class="headerlink" title="2、为什么要数据交换"></a>2、为什么要数据交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155727387.png" alt="image-20210505155727387"></p>
<h4 id="3、数据交换的方式"><a href="#3、数据交换的方式" class="headerlink" title="3、数据交换的方式"></a>3、数据交换的方式</h4><p>数据交换可分为三种方式：</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换<ul>
<li>数据报方式</li>
<li>虚电路方式</li>
</ul>
</li>
</ul>
<h4 id="4、电路交换"><a href="#4、电路交换" class="headerlink" title="4、电路交换"></a>4、电路交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505160852979.png" alt="image-20210505160852979"></p>
<h4 id="5、报文交换"><a href="#5、报文交换" class="headerlink" title="5、报文交换"></a>5、报文交换</h4><h4 id="6、分组交换"><a href="#6、分组交换" class="headerlink" title="6、分组交换"></a>6、分组交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505161751869.png" alt="image-20210505161751869"></p>
<h4 id="7、报文交换-amp-分组交换"><a href="#7、报文交换-amp-分组交换" class="headerlink" title="7、报文交换 &amp; 分组交换"></a>7、报文交换 &amp; 分组交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505162605543.png" alt="image-20210505162605543"></p>
<h4 id="8、三种数据交换方式比较总结"><a href="#8、三种数据交换方式比较总结" class="headerlink" title="8、三种数据交换方式比较总结"></a>8、三种数据交换方式比较总结</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505162837182.png" alt="image-20210505162837182"></p>
<h4 id="9、数据报方式-amp-虚电路方式"><a href="#9、数据报方式-amp-虚电路方式" class="headerlink" title="9、数据报方式&amp;虚电路方式"></a>9、数据报方式&amp;虚电路方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505163608737.png" alt="image-20210505163608737"></p>
<h4 id="10、几种传输单元名词辨析"><a href="#10、几种传输单元名词辨析" class="headerlink" title="10、几种传输单元名词辨析"></a>10、几种传输单元名词辨析</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164202246.png" alt="image-20210505164202246"></p>
<h4 id="11、数据报-应用于因特网"><a href="#11、数据报-应用于因特网" class="headerlink" title="11、数据报(应用于因特网)"></a>11、数据报(应用于因特网)</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164423826.png" alt="image-20210505164423826"></p>
<h4 id="12、虚电路"><a href="#12、虚电路" class="headerlink" title="12、虚电路"></a>12、虚电路</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164740761.png" alt="image-20210505164740761"></p>
<h4 id="13、数据报-amp-虚电路"><a href="#13、数据报-amp-虚电路" class="headerlink" title="13、数据报 &amp; 虚电路"></a>13、数据报 &amp; 虚电路</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164918003.png" alt="image-20210505164918003"></p>
<h3 id="4-3-1、IP数据报格式"><a href="#4-3-1、IP数据报格式" class="headerlink" title="4.3.1、IP数据报格式"></a>4.3.1、IP数据报格式</h3><h4 id="1、TCP-IP协议栈"><a href="#1、TCP-IP协议栈" class="headerlink" title="1、TCP/IP协议栈"></a>1、TCP/IP协议栈</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505165458233.png" alt="image-20210505165458233"></p>
<h4 id="2、IP数据报格式"><a href="#2、IP数据报格式" class="headerlink" title="2、IP数据报格式"></a>2、IP数据报格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505165620439.png" alt="image-20210505165620439"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171044015.png" alt="image-20210505171044015"></p>
<h3 id="4-3-2、IP数据报分片"><a href="#4-3-2、IP数据报分片" class="headerlink" title="4.3.2、IP数据报分片"></a>4.3.2、IP数据报分片</h3><h4 id="1、最大传送单元MTU"><a href="#1、最大传送单元MTU" class="headerlink" title="1、最大传送单元MTU"></a>1、最大传送单元MTU</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171323581.png" alt="image-20210505171323581"></p>
<h4 id="2、IP数据报格式——分片相关"><a href="#2、IP数据报格式——分片相关" class="headerlink" title="2、IP数据报格式——分片相关"></a>2、IP数据报格式——分片相关</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171749113.png" alt="image-20210505171749113"></p>
<h4 id="3、IP数据报分片例题"><a href="#3、IP数据报分片例题" class="headerlink" title="3、IP数据报分片例题"></a>3、IP数据报分片例题</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172207007.png" alt="image-20210505172207007"></p>
<h4 id="4、IP数据报格式——相关单位"><a href="#4、IP数据报格式——相关单位" class="headerlink" title="4、IP数据报格式——相关单位"></a>4、IP数据报格式——相关单位</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172335655.png" alt="image-20210505172335655"></p>
<h3 id="4-3-3、IPv4地址"><a href="#4-3-3、IPv4地址" class="headerlink" title="4.3.3、IPv4地址"></a>4.3.3、IPv4地址</h3><h4 id="1、IP地址"><a href="#1、IP地址" class="headerlink" title="1、IP地址"></a>1、IP地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172546692.png" alt="image-20210505172546692"></p>
<h4 id="2、IP编址的历史阶段"><a href="#2、IP编址的历史阶段" class="headerlink" title="2、IP编址的历史阶段"></a>2、IP编址的历史阶段</h4><ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网(无分类编址方法)</li>
</ul>
<h4 id="3、分类的IP地址"><a href="#3、分类的IP地址" class="headerlink" title="3、分类的IP地址"></a>3、分类的IP地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172901070.png" alt="image-20210505172901070"></p>
<h5 id="1、互联网中的IP地址："><a href="#1、互联网中的IP地址：" class="headerlink" title="1、互联网中的IP地址："></a>1、互联网中的IP地址：</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173055123.png" alt="image-20210505173055123"></p>
<h5 id="2、分类的IP地址："><a href="#2、分类的IP地址：" class="headerlink" title="2、分类的IP地址："></a>2、分类的IP地址：</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173438999.png" alt="image-20210505173438999"></p>
<h5 id="3、特殊IP地址"><a href="#3、特殊IP地址" class="headerlink" title="3、特殊IP地址"></a>3、特殊IP地址</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173834400.png" alt="image-20210505173834400"></p>
<h5 id="4、私有IP地址"><a href="#4、私有IP地址" class="headerlink" title="4、私有IP地址"></a>4、私有IP地址</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505174001052.png" alt="image-20210505174001052"></p>
<h5 id="5、分类IP使用个数"><a href="#5、分类IP使用个数" class="headerlink" title="5、分类IP使用个数"></a>5、分类IP使用个数</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505192925617.png" alt="image-20210505192925617"></p>
<h3 id="4-3-4、网络地址转换NAT"><a href="#4-3-4、网络地址转换NAT" class="headerlink" title="4.3.4、网络地址转换NAT"></a>4.3.4、网络地址转换NAT</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505193330114.png" alt="image-20210505193330114"></p>
<p>网络地址转换NAT：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505193808509.png" alt="image-20210505193808509"></p>
<h3 id="4-3-5、子网划分和子网掩码"><a href="#4-3-5、子网划分和子网掩码" class="headerlink" title="4.3.5、子网划分和子网掩码"></a>4.3.5、子网划分和子网掩码</h3><h4 id="1、子网划分"><a href="#1、子网划分" class="headerlink" title="1、子网划分"></a>1、子网划分</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194037834.png" alt="image-20210505194037834"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194204411.png" alt="image-20210505194204411"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194311386.png" alt="image-20210505194311386"></p>
<h4 id="2、子网掩码"><a href="#2、子网掩码" class="headerlink" title="2、子网掩码"></a>2、子网掩码</h4><p>子网掩码：是为了区分网段的 掩码和主机号与主机号比较来判断属不属于该网段</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194758394.png" alt="image-20210505194758394"></p>
<p>相关习题：</p>
<p>习题1：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505195105282.png" alt="image-20210505195105282"></p>
<p>习题2：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505200049573.png" alt="image-20210505200049573"></p>
<h4 id="3、使用子网时分组的转发"><a href="#3、使用子网时分组的转发" class="headerlink" title="3、使用子网时分组的转发"></a>3、使用子网时分组的转发</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505200430899.png" alt="image-20210505200430899"></p>
<h3 id="4-3-6、无分类编址CIDR"><a href="#4-3-6、无分类编址CIDR" class="headerlink" title="4.3.6、无分类编址CIDR"></a>4.3.6、无分类编址CIDR</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201051592.png" alt="image-20210505201051592"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201235591.png" alt="image-20210505201235591"></p>
<h4 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201651932.png" alt="image-20210505201651932"></p>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505202925728.png" alt="image-20210505202925728"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505203331296.png" alt="image-20210505203331296"></p>
<h3 id="4-3-7、ARP协议"><a href="#4-3-7、ARP协议" class="headerlink" title="4.3.7、ARP协议"></a>4.3.7、ARP协议</h3><h4 id="1、发送数据的过程"><a href="#1、发送数据的过程" class="headerlink" title="1、发送数据的过程"></a>1、发送数据的过程</h4><p>IP2与IP3发送数据：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505203902705.png" alt="image-20210505203902705"></p>
<p>IP1与IP5发送数据：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505212537717.png" alt="image-20210505212537717"></p>
<h4 id="2、ARP协议"><a href="#2、ARP协议" class="headerlink" title="2、ARP协议"></a>2、ARP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505212854516.png" alt="image-20210505212854516"></p>
<p>ARP地址的相关习题</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505213228348.png" alt="image-20210505213228348"></p>
<h3 id="4-3-8、DHCP协议"><a href="#4-3-8、DHCP协议" class="headerlink" title="4.3.8、DHCP协议"></a>4.3.8、DHCP协议</h3><h4 id="1、主机如何获得IP地址"><a href="#1、主机如何获得IP地址" class="headerlink" title="1、主机如何获得IP地址?"></a>1、主机如何获得IP地址?</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505223656891.png" alt="image-20210505223656891"></p>
<h4 id="2、DHCP协议"><a href="#2、DHCP协议" class="headerlink" title="2、DHCP协议"></a>2、DHCP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505224535421.png" alt="image-20210505224535421"></p>
<h3 id="4-3-9、ICMP协议"><a href="#4-3-9、ICMP协议" class="headerlink" title="4.3.9、ICMP协议"></a>4.3.9、ICMP协议</h3><h4 id="1、ICMP协议作用"><a href="#1、ICMP协议作用" class="headerlink" title="1、ICMP协议作用"></a>1、ICMP协议作用</h4><p>为了更有效地转发IP数据报和提高交付成功的机会</p>
<h4 id="2、网际控制报文协议ICMP"><a href="#2、网际控制报文协议ICMP" class="headerlink" title="2、网际控制报文协议ICMP"></a>2、网际控制报文协议ICMP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505225626767.png" alt="image-20210505225626767"></p>
<h4 id="3、ICMP差错报告报文-5种"><a href="#3、ICMP差错报告报文-5种" class="headerlink" title="3、ICMP差错报告报文(5种)"></a>3、ICMP差错报告报文(5种)</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505225923078.png" alt="image-20210505225923078"></p>
<h4 id="4、ICMP差错报告报文数据字段"><a href="#4、ICMP差错报告报文数据字段" class="headerlink" title="4、ICMP差错报告报文数据字段"></a>4、ICMP差错报告报文数据字段</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230122748.png" alt="image-20210505230122748"></p>
<h4 id="5、不应发送ICMP差错报文的情况"><a href="#5、不应发送ICMP差错报文的情况" class="headerlink" title="5、不应发送ICMP差错报文的情况"></a>5、不应发送ICMP差错报文的情况</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230238989.png" alt="image-20210505230238989"></p>
<h4 id="6、ICMP询问报文"><a href="#6、ICMP询问报文" class="headerlink" title="6、ICMP询问报文"></a>6、ICMP询问报文</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230910474.png" alt="image-20210505230910474"></p>
<h4 id="7、ICMP的应用"><a href="#7、ICMP的应用" class="headerlink" title="7、ICMP的应用"></a>7、ICMP的应用</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505231645689.png" alt="image-20210505231645689"></p>
<h3 id="4-4、IPv6"><a href="#4-4、IPv6" class="headerlink" title="4.4、IPv6"></a>4.4、IPv6</h3><h4 id="1、为什么有IPv6"><a href="#1、为什么有IPv6" class="headerlink" title="1、为什么有IPv6"></a>1、为什么有IPv6</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505232136621.png" alt="image-20210505232136621"></p>
<h4 id="2、IPv6数据报格式"><a href="#2、IPv6数据报格式" class="headerlink" title="2、IPv6数据报格式"></a>2、IPv6数据报格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505233127480.png" alt="image-20210505233127480"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505233806463.png" alt="image-20210505233806463"></p>
<h4 id="3、IPv6-VS-IPv4"><a href="#3、IPv6-VS-IPv4" class="headerlink" title="3、IPv6  VS IPv4"></a>3、IPv6  VS IPv4</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234147607.png" alt="image-20210505234147607"></p>
<h4 id="4、IPv6地址表示形式"><a href="#4、IPv6地址表示形式" class="headerlink" title="4、IPv6地址表示形式"></a>4、IPv6地址表示形式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234335367.png" alt="image-20210505234335367"></p>
<h4 id="5、IPv6基本地址类型"><a href="#5、IPv6基本地址类型" class="headerlink" title="5、IPv6基本地址类型"></a>5、IPv6基本地址类型</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234545274.png" alt="image-20210505234545274"></p>
<h4 id="6、IPv6向IPv4过渡的策略"><a href="#6、IPv6向IPv4过渡的策略" class="headerlink" title="6、IPv6向IPv4过渡的策略"></a>6、IPv6向IPv4过渡的策略</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234827815.png" alt="image-20210505234827815"></p>
<h4 id="7、脑图"><a href="#7、脑图" class="headerlink" title="7、脑图"></a>7、脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234924693.png" alt="image-20210505234924693"></p>
<h3 id="4-5、路由算法及路由协议"><a href="#4-5、路由算法及路由协议" class="headerlink" title="4.5、路由算法及路由协议"></a>4.5、路由算法及路由协议</h3><h4 id="1、路由算法"><a href="#1、路由算法" class="headerlink" title="1、路由算法"></a>1、路由算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000134403.png" alt="image-20210506000134403"></p>
<h4 id="2、路由算法的分类"><a href="#2、路由算法的分类" class="headerlink" title="2、路由算法的分类"></a>2、路由算法的分类</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000028662.png" alt="image-20210506000028662"></p>
<h4 id="3、分层次的路由选择协议"><a href="#3、分层次的路由选择协议" class="headerlink" title="3、分层次的路由选择协议"></a>3、分层次的路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000422048.png" alt="image-20210506000422048"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000456424.png" alt="image-20210506000456424"></p>
<h3 id="4-6-1、RIP协议与距离向量算法"><a href="#4-6-1、RIP协议与距离向量算法" class="headerlink" title="4.6.1、RIP协议与距离向量算法"></a>4.6.1、RIP协议与距离向量算法</h3><h4 id="1、RIP协议"><a href="#1、RIP协议" class="headerlink" title="1、RIP协议"></a>1、RIP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000832013.png" alt="image-20210506000832013"></p>
<h4 id="2、RIP协议和谁交换-多久交换一次-交换什么"><a href="#2、RIP协议和谁交换-多久交换一次-交换什么" class="headerlink" title="2、RIP协议和谁交换?多久交换一次? 交换什么?"></a>2、RIP协议和谁交换?多久交换一次? 交换什么?</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001325532.png" alt="image-20210506001325532"></p>
<h4 id="3、距离向量算法"><a href="#3、距离向量算法" class="headerlink" title="3、距离向量算法"></a>3、距离向量算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001614574.png" alt="image-20210506001614574"></p>
<p>相关例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001913695.png" alt="image-20210506001913695"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002345004.png" alt="image-20210506002345004"></p>
<h4 id="4、RIP协议的报文格式"><a href="#4、RIP协议的报文格式" class="headerlink" title="4、RIP协议的报文格式"></a>4、RIP协议的报文格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002716945.png" alt="image-20210506002716945"></p>
<h4 id="5、RIP协议好消息传得快，坏消息传得慢"><a href="#5、RIP协议好消息传得快，坏消息传得慢" class="headerlink" title="5、RIP协议好消息传得快，坏消息传得慢"></a>5、RIP协议好消息传得快，坏消息传得慢</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002829463.png" alt="image-20210506002829463"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002927178.png" alt="image-20210506002927178"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003058016.png" alt="image-20210506003058016"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003123096.png" alt="image-20210506003123096"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003157668.png" alt="image-20210506003157668"></p>
<h4 id="6、脑图"><a href="#6、脑图" class="headerlink" title="6、脑图"></a>6、脑图</h4><p>补充下，RIP与距离向量算法不一样：因数据报服务在分组转发时，每个分组独立选择路由转发，从而引出了路由选择协议。RIP叫路由信息协议。为了找出RIP的最短距离引出了距离向量算法。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003352720.png" alt="image-20210506003352720"></p>
<h3 id="4-6-2、OSPF协议与链路状态算法"><a href="#4-6-2、OSPF协议与链路状态算法" class="headerlink" title="4.6.2、OSPF协议与链路状态算法"></a>4.6.2、OSPF协议与链路状态算法</h3><h4 id="1、OSPF协议"><a href="#1、OSPF协议" class="headerlink" title="1、OSPF协议"></a>1、OSPF协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003646135.png" alt="image-20210506003646135"></p>
<h4 id="2、链路状态路由算法"><a href="#2、链路状态路由算法" class="headerlink" title="2、链路状态路由算法"></a>2、链路状态路由算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004006614.png" alt="image-20210506004006614"></p>
<h4 id="3、OSPF的区域"><a href="#3、OSPF的区域" class="headerlink" title="3、OSPF的区域"></a>3、OSPF的区域</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004158704.png" alt="image-20210506004158704"></p>
<h4 id="4、OSPF分组"><a href="#4、OSPF分组" class="headerlink" title="4、OSPF分组"></a>4、OSPF分组</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004522231.png" alt="image-20210506004522231"></p>
<h4 id="5、OSPF其他特点"><a href="#5、OSPF其他特点" class="headerlink" title="5、OSPF其他特点"></a>5、OSPF其他特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004650863.png" alt="image-20210506004650863"></p>
<h3 id="4-6-3、BGP协议"><a href="#4-6-3、BGP协议" class="headerlink" title="4.6.3、BGP协议"></a>4.6.3、BGP协议</h3><h4 id="1、BGP协议"><a href="#1、BGP协议" class="headerlink" title="1、BGP协议"></a>1、BGP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004817609.png" alt="image-20210506004817609"></p>
<h4 id="2、BGP协议交换信息的过程"><a href="#2、BGP协议交换信息的过程" class="headerlink" title="2、BGP协议交换信息的过程"></a>2、BGP协议交换信息的过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005743562.png" alt="image-20210506005743562"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005824214.png" alt="image-20210506005824214"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005844401.png" alt="image-20210506005844401"></p>
<h4 id="3、BGP协议报文格式"><a href="#3、BGP协议报文格式" class="headerlink" title="3、BGP协议报文格式"></a>3、BGP协议报文格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005948843.png" alt="image-20210506005948843"></p>
<h4 id="4、BGP协议特点"><a href="#4、BGP协议特点" class="headerlink" title="4、BGP协议特点"></a>4、BGP协议特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010034467.png" alt="image-20210506010034467"></p>
<h4 id="5、BGP-4的四种报文"><a href="#5、BGP-4的四种报文" class="headerlink" title="5、BGP-4的四种报文"></a>5、BGP-4的四种报文</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010126542.png" alt="image-20210506010126542"></p>
<h4 id="6、三种路由协议比较"><a href="#6、三种路由协议比较" class="headerlink" title="6、三种路由协议比较"></a>6、三种路由协议比较</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010314753.png" alt="image-20210506010314753"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010353924.png" alt="image-20210506010353924"></p>
<h3 id="4-7、IP组播"><a href="#4-7、IP组播" class="headerlink" title="4.7、IP组播"></a>4.7、IP组播</h3><h4 id="1、IP数据报的三种传输方式"><a href="#1、IP数据报的三种传输方式" class="headerlink" title="1、IP数据报的三种传输方式"></a>1、IP数据报的三种传输方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010805488.png" alt="image-20210506010805488"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010910591.png" alt="image-20210506010910591"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506011014041.png" alt="image-20210506011014041"></p>
<h4 id="2、IP组播地址"><a href="#2、IP组播地址" class="headerlink" title="2、IP组播地址"></a>2、IP组播地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506011327598.png" alt="image-20210506011327598"></p>
<h4 id="3、硬件组播"><a href="#3、硬件组播" class="headerlink" title="3、硬件组播"></a>3、硬件组播</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012222229.png" alt="image-20210506012222229"></p>
<h4 id="4、IGMP协议与组播路由选择协议"><a href="#4、IGMP协议与组播路由选择协议" class="headerlink" title="4、IGMP协议与组播路由选择协议"></a>4、IGMP协议与组播路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012400642.png" alt="image-20210506012400642"></p>
<h4 id="5、网际组管理协议IGMP"><a href="#5、网际组管理协议IGMP" class="headerlink" title="5、网际组管理协议IGMP"></a>5、网际组管理协议IGMP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012545893.png" alt="image-20210506012545893"></p>
<p><strong>ICMP和IGMP都使用IP数据报传递报文</strong>。</p>
<h4 id="6、IGMP工作的两个阶段"><a href="#6、IGMP工作的两个阶段" class="headerlink" title="6、IGMP工作的两个阶段"></a>6、IGMP工作的两个阶段</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012720613.png" alt="image-20210506012720613"></p>
<h4 id="7、组播路由选择协议"><a href="#7、组播路由选择协议" class="headerlink" title="7、组播路由选择协议"></a>7、组播路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012924832.png" alt="image-20210506012924832"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013034949.png" alt="image-20210506013034949"></p>
<p>组播路由选择协议常使用的三种算法：</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播(稀疏/密集)</li>
</ul>
<h4 id="8、脑图"><a href="#8、脑图" class="headerlink" title="8、脑图"></a>8、脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013212541.png" alt="image-20210506013212541"></p>
<h3 id="4-8、移动IP"><a href="#4-8、移动IP" class="headerlink" title="4.8、移动IP"></a>4.8、移动IP</h3><h4 id="1、移动IP相关术语"><a href="#1、移动IP相关术语" class="headerlink" title="1、移动IP相关术语"></a>1、移动IP相关术语</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013719153.png" alt="image-20210506013719153"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013851391.png" alt="image-20210506013851391"></p>
<h4 id="2、移动IP通信过程"><a href="#2、移动IP通信过程" class="headerlink" title="2、移动IP通信过程"></a>2、移动IP通信过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014144890.png" alt="image-20210506014144890"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014312720.png" alt="image-20210506014312720"></p>
<h3 id="4-9、网络层设备"><a href="#4-9、网络层设备" class="headerlink" title="4.9、网络层设备"></a>4.9、网络层设备</h3><h4 id="1、路由器"><a href="#1、路由器" class="headerlink" title="1、路由器"></a>1、路由器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014602052.png" alt="image-20210506014602052"></p>
<h4 id="2、输入端口对线路上收到的分组的处理"><a href="#2、输入端口对线路上收到的分组的处理" class="headerlink" title="2、输入端口对线路上收到的分组的处理"></a>2、输入端口对线路上收到的分组的处理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014713942.png" alt="image-20210506014713942"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014800212.png" alt="image-20210506014800212"></p>
<h4 id="3、三层设备的区别"><a href="#3、三层设备的区别" class="headerlink" title="3、三层设备的区别"></a>3、三层设备的区别</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014928456.png" alt="image-20210506014928456"></p>
<h4 id="4、路由表与路由转发"><a href="#4、路由表与路由转发" class="headerlink" title="4、路由表与路由转发"></a>4、路由表与路由转发</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015046620.png" alt="image-20210506015046620"></p>
<h3 id="4-10、网络层总结"><a href="#4-10、网络层总结" class="headerlink" title="4.10、网络层总结"></a>4.10、网络层总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015143791.png" alt="image-20210506015143791"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015239776.png" alt="image-20210506015239776"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015254927.png" alt="image-20210506015254927"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015310030.png" alt="image-20210506015310030"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015341546.png" alt="image-20210506015341546"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015440181.png" alt="image-20210506015440181"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015614088.png" alt="image-20210506015550548"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015658610.png" alt="image-20210506015658610"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015721592.png" alt="image-20210506015721592"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015734462.png" alt="image-20210506015734462"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015810700.png" alt="image-20210506015810700"></p>
<h2 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2020070417445825.jpg" alt="在这里插入图片描述"></p>
<h3 id="5-1、传输层概述"><a href="#5-1、传输层概述" class="headerlink" title="5.1、传输层概述"></a>5.1、传输层概述</h3><h4 id="1、什么是传输层"><a href="#1、什么是传输层" class="headerlink" title="1、什么是传输层"></a>1、什么是传输层</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509091650713.png" alt="image-20210509091650713"></p>
<h4 id="2、传输层的两个协议"><a href="#2、传输层的两个协议" class="headerlink" title="2、传输层的两个协议"></a>2、传输层的两个协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509130716955.png" alt="image-20210509130716955"></p>
<h4 id="3、传输层的寻址与端口"><a href="#3、传输层的寻址与端口" class="headerlink" title="3、传输层的寻址与端口"></a>3、传输层的寻址与端口</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131021768.png" alt="image-20210509131021768"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131114772.png" alt="image-20210509131114772"></p>
<h3 id="5-2、UDP协议"><a href="#5-2、UDP协议" class="headerlink" title="5.2、UDP协议"></a>5.2、UDP协议</h3><h4 id="1、用户数据报协议UDP概述"><a href="#1、用户数据报协议UDP概述" class="headerlink" title="1、用户数据报协议UDP概述"></a>1、用户数据报协议UDP概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131452260.png" alt="image-20210509131452260"></p>
<h4 id="2、UDP首部格式"><a href="#2、UDP首部格式" class="headerlink" title="2、UDP首部格式"></a>2、UDP首部格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131719115.png" alt="image-20210509131719115"></p>
<h4 id="3、UDP校验"><a href="#3、UDP校验" class="headerlink" title="3、UDP校验"></a>3、UDP校验</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131902697.png" alt="image-20210509131902697"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132143163.png" alt="image-20210509132143163"></p>
<h3 id="5-3-1、TCP协议特点和TCP报文段格式"><a href="#5-3-1、TCP协议特点和TCP报文段格式" class="headerlink" title="5.3.1、TCP协议特点和TCP报文段格式"></a>5.3.1、TCP协议特点和TCP报文段格式</h3><h4 id="1、TCP协议的特点"><a href="#1、TCP协议的特点" class="headerlink" title="1、TCP协议的特点"></a>1、TCP协议的特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132448448.png" alt="image-20210509132448448"></p>
<h4 id="2、TCP协议的特点-amp-TCP报文段首部格式"><a href="#2、TCP协议的特点-amp-TCP报文段首部格式" class="headerlink" title="2、TCP协议的特点 &amp; TCP报文段首部格式"></a>2、TCP协议的特点 &amp; TCP报文段首部格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133753564.png" alt="image-20210509133753564"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132848748.png" alt="image-20210509132848748"></p>
<p>TCP首部——序号：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133439721.png" alt="image-20210509133439721"></p>
<p>TCP首部——确认号</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133333378.png" alt="image-20210509133333378"></p>
<p>相关控制位：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135329970.png" alt="image-20210509135329970"></p>
<p>TCP首部控制位——紧急位URG</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509134247734.png" alt="image-20210509134247734"></p>
<p>TCP首部控制位——推送位PSH</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509134713094.png" alt="image-20210509134713094"></p>
<p>TCP首部——窗口</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135449995.png" alt="image-20210509135449995"></p>
<p>TCP首部——紧急指针</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135608155.png" alt="image-20210509135608155"></p>
<h3 id="5-3-2、TCP连接管理"><a href="#5-3-2、TCP连接管理" class="headerlink" title="5.3.2、TCP连接管理"></a>5.3.2、TCP连接管理</h3><h4 id="1、TCP连接管理"><a href="#1、TCP连接管理" class="headerlink" title="1、TCP连接管理"></a>1、TCP连接管理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135759910.png" alt="image-20210509135759910"></p>
<h4 id="2、TCP的连接建立"><a href="#2、TCP的连接建立" class="headerlink" title="2、TCP的连接建立"></a>2、TCP的连接建立</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509140112306.png" alt="image-20210509140112306"></p>
<h4 id="3、SYN洪泛攻击"><a href="#3、SYN洪泛攻击" class="headerlink" title="3、SYN洪泛攻击"></a>3、SYN洪泛攻击</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509143604587.png" alt="image-20210509143604587"></p>
<h4 id="4、TCP的连接释放"><a href="#4、TCP的连接释放" class="headerlink" title="4、TCP的连接释放"></a>4、TCP的连接释放</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509143655748.png" alt="image-20210509143655748"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144000502.png" alt="image-20210509144000502"></p>
<h3 id="5-3-3、TCP可靠传输"><a href="#5-3-3、TCP可靠传输" class="headerlink" title="5.3.3、TCP可靠传输"></a>5.3.3、TCP可靠传输</h3><h4 id="1、TCP可靠传输"><a href="#1、TCP可靠传输" class="headerlink" title="1、TCP可靠传输"></a>1、TCP可靠传输</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144114911.png" alt="image-20210509144114911"></p>
<h4 id="2、序号"><a href="#2、序号" class="headerlink" title="2、序号"></a>2、序号</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144335882.png" alt="image-20210509144335882"></p>
<h4 id="3、确认"><a href="#3、确认" class="headerlink" title="3、确认"></a>3、确认</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144702310.png" alt="image-20210509144702310"></p>
<h4 id="4、重传"><a href="#4、重传" class="headerlink" title="4、重传"></a>4、重传</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144948012.png" alt="image-20210509144948012"> </p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509145112616.png" alt="image-20210509145112616"></p>
<h4 id="5-3-4、TCP流量控制"><a href="#5-3-4、TCP流量控制" class="headerlink" title="5.3.4、TCP流量控制"></a>5.3.4、TCP流量控制</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509145413434.png" alt="image-20210509145413434"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150152054.png" alt="image-20210509150152054"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150246065.png" alt="image-20210509150246065"></p>
<h3 id="5-3-5、TCP拥塞控制"><a href="#5-3-5、TCP拥塞控制" class="headerlink" title="5.3.5、TCP拥塞控制"></a>5.3.5、TCP拥塞控制</h3><h4 id="1、TCP拥塞控制"><a href="#1、TCP拥塞控制" class="headerlink" title="1、TCP拥塞控制"></a>1、TCP拥塞控制</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150503776.png" alt="image-20210509150503776"></p>
<h4 id="2、拥塞控制四种算法"><a href="#2、拥塞控制四种算法" class="headerlink" title="2、拥塞控制四种算法"></a>2、拥塞控制四种算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150710651.png" alt="image-20210509150710651"></p>
<h4 id="3、拥塞控制四种算法——慢开始和拥塞避免"><a href="#3、拥塞控制四种算法——慢开始和拥塞避免" class="headerlink" title="3、拥塞控制四种算法——慢开始和拥塞避免"></a>3、拥塞控制四种算法——慢开始和拥塞避免</h4><p>传输轮次：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509151158840.png" alt="image-20210509151158840"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509151631221.png" alt="image-20210509151631221"></p>
<h4 id="4、拥塞控制四种算法——快重传和快恢复"><a href="#4、拥塞控制四种算法——快重传和快恢复" class="headerlink" title="4、拥塞控制四种算法——快重传和快恢复"></a>4、拥塞控制四种算法——快重传和快恢复</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152156033.png" alt="image-20210509152156033"></p>
<h3 id="5-4、传输层总结"><a href="#5-4、传输层总结" class="headerlink" title="5.4、传输层总结"></a>5.4、传输层总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152240332.png" alt="image-20210509152240332"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152327273.png" alt="image-20210509152327273"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152352593.png" alt="image-20210509152352593"></p>
<h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200704174557419.jpg" alt="img"></p>
<h3 id="6-1、网络应用模型"><a href="#6-1、网络应用模型" class="headerlink" title="6.1、网络应用模型"></a>6.1、网络应用模型</h3><h4 id="1、应用层概述"><a href="#1、应用层概述" class="headerlink" title="1、应用层概述"></a>1、应用层概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510103902295.png" alt="image-20210510103902295"></p>
<h4 id="2、网络应用模型"><a href="#2、网络应用模型" class="headerlink" title="2、网络应用模型"></a>2、网络应用模型</h4><h5 id="1、客户-服务器模型-Client-Server"><a href="#1、客户-服务器模型-Client-Server" class="headerlink" title="1、客户/服务器模型(Client/Server)"></a>1、客户/服务器模型(Client/Server)</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104239979.png" alt="image-20210510104239979"></p>
<h5 id="2、P2P模型-Peer-to-peer"><a href="#2、P2P模型-Peer-to-peer" class="headerlink" title="2、P2P模型(Peer-to-peer )"></a>2、P2P模型(Peer-to-peer )</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104646313.png" alt="image-20210510104646313"></p>
<h3 id="6-2、域名解析（DNS）系统"><a href="#6-2、域名解析（DNS）系统" class="headerlink" title="6.2、域名解析（DNS）系统"></a>6.2、域名解析（DNS）系统</h3><h4 id="1、DNS系统"><a href="#1、DNS系统" class="headerlink" title="1、DNS系统"></a>1、DNS系统</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104903931.png" alt="image-20210510104903931"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105032397.png" alt="image-20210510105032397"></p>
<h4 id="2、域名"><a href="#2、域名" class="headerlink" title="2、域名"></a>2、域名</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105410771.png" alt="image-20210510105410771"></p>
<p>域名树</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105508640.png" alt="image-20210510105508640"></p>
<h4 id="3、域名服务器"><a href="#3、域名服务器" class="headerlink" title="3、域名服务器"></a>3、域名服务器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105950375.png" alt="image-20210510105950375"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110153218.png" alt="image-20210510110153218"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110230680.png" alt="image-20210510110230680"></p>
<h4 id="4、域名解析过程"><a href="#4、域名解析过程" class="headerlink" title="4、域名解析过程"></a>4、域名解析过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110758844.png" alt="image-20210510110758844"></p>
<h3 id="6-3、文件传输协议FTP"><a href="#6-3、文件传输协议FTP" class="headerlink" title="6.3、文件传输协议FTP"></a>6.3、文件传输协议FTP</h3><h4 id="1、文件传送协议"><a href="#1、文件传送协议" class="headerlink" title="1、文件传送协议"></a>1、文件传送协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111014038.png" alt="image-20210510111014038"></p>
<h4 id="2、FTP服务器和客户端"><a href="#2、FTP服务器和客户端" class="headerlink" title="2、FTP服务器和客户端"></a>2、FTP服务器和客户端</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111137982.png" alt="image-20210510111137982"></p>
<h4 id="3、FTP工作原理"><a href="#3、FTP工作原理" class="headerlink" title="3、FTP工作原理"></a>3、FTP工作原理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111724834.png" alt="image-20210510111724834"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510112854765.png" alt="image-20210510112854765"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111833815.png" alt="image-20210510111833815"></p>
<h3 id="6-4、电子邮件"><a href="#6-4、电子邮件" class="headerlink" title="6.4、电子邮件"></a>6.4、电子邮件</h3><h4 id="1、电子邮件系统概述——电子邮件的的信息格式"><a href="#1、电子邮件系统概述——电子邮件的的信息格式" class="headerlink" title="1、电子邮件系统概述——电子邮件的的信息格式"></a>1、电子邮件系统概述——电子邮件的的信息格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114256285.png" alt="image-20210510114256285"></p>
<h4 id="2、电子邮件系统概述——组成结构"><a href="#2、电子邮件系统概述——组成结构" class="headerlink" title="2、电子邮件系统概述——组成结构"></a>2、电子邮件系统概述——组成结构</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114344542.png" alt="image-20210510114344542"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114417744.png" alt="image-20210510114417744"></p>
<h4 id="3、简单邮件传送协议SMTP"><a href="#3、简单邮件传送协议SMTP" class="headerlink" title="3、简单邮件传送协议SMTP"></a>3、简单邮件传送协议SMTP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114439779.png" alt="image-20210510114439779"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114512955.png" alt="image-20210510114512955"></p>
<h4 id="4、MIME"><a href="#4、MIME" class="headerlink" title="4、MIME"></a>4、MIME</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114546291.png" alt="image-20210510114546291"></p>
<h4 id="5、邮局协议POP3"><a href="#5、邮局协议POP3" class="headerlink" title="5、邮局协议POP3"></a>5、邮局协议POP3</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114622467.png" alt="image-20210510114622467"></p>
<h4 id="6、网际报文存取协议IMAP"><a href="#6、网际报文存取协议IMAP" class="headerlink" title="6、网际报文存取协议IMAP"></a>6、网际报文存取协议IMAP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114808711.png" alt="image-20210510114808711"></p>
<h4 id="7、基于万维网的电子邮件"><a href="#7、基于万维网的电子邮件" class="headerlink" title="7、基于万维网的电子邮件"></a>7、基于万维网的电子邮件</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114701163.png" alt="image-20210510114701163"></p>
<h4 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114720692.png" alt="image-20210510114720692"></p>
<h3 id="6-5、万维网和HTTP协议"><a href="#6-5、万维网和HTTP协议" class="headerlink" title="6.5、万维网和HTTP协议"></a>6.5、万维网和HTTP协议</h3><h4 id="1、万维网概述"><a href="#1、万维网概述" class="headerlink" title="1、万维网概述"></a>1、万维网概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510115838121.png" alt="image-20210510115838121"></p>
<h4 id="2、超文本传输协议HTTP"><a href="#2、超文本传输协议HTTP" class="headerlink" title="2、超文本传输协议HTTP"></a>2、超文本传输协议HTTP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510115923321.png" alt="image-20210510115923321"></p>
<h4 id="3、HTTP协议的特点"><a href="#3、HTTP协议的特点" class="headerlink" title="3、HTTP协议的特点"></a>3、HTTP协议的特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510120008065.png" alt="image-20210510120008065"></p>
<h4 id="4、HTTP协议的连接方式"><a href="#4、HTTP协议的连接方式" class="headerlink" title="4、HTTP协议的连接方式"></a>4、HTTP协议的连接方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510120102536.png" alt="image-20210510120102536"></p>
<h4 id="5、超文本传输协议HTTP——报文结构"><a href="#5、超文本传输协议HTTP——报文结构" class="headerlink" title="5、超文本传输协议HTTP——报文结构"></a>5、超文本传输协议HTTP——报文结构</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123648179.png" alt="image-20210510123648179"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123711370.png" alt="image-20210510123711370"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123757619.png" alt="image-20210510123757619"></p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/inv1796915552/article/details/108597883">计算机网络（2019 王道考研）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gl620321/article/details/107126941">计算机网络思维导图</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 09:50:41" itemprop="dateCreated datePublished" datetime="2021-04-19T09:50:41+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-04 01:02:32" itemprop="dateModified" datetime="2021-05-04T01:02:32+08:00">2021-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="上篇：内存与垃圾回收"><a href="#上篇：内存与垃圾回收" class="headerlink" title="上篇：内存与垃圾回收"></a>上篇：内存与垃圾回收</h2><h3 id="1、JVM与Java体系结构"><a href="#1、JVM与Java体系结构" class="headerlink" title="1、JVM与Java体系结构"></a>1、JVM与Java体系结构</h3><h4 id="1、关于Java与JVM"><a href="#1、关于Java与JVM" class="headerlink" title="1、关于Java与JVM"></a>1、关于Java与JVM</h4><p>Java：跨平台的语言</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<p>JVM：跨语言的平台</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<h4 id="2、字节码"><a href="#2、字节码" class="headerlink" title="2、字节码"></a>2、字节码</h4><p>随着JDK7.0的正式发布，JVM平台上运行非Java语言编写的程序。</p>
<p>JVM根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含JVM的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong>。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联， Class文件中包含了JVM指令集(或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。</p>
<h4 id="3、多语言混合编程"><a href="#3、多语言混合编程" class="headerlink" title="3、多语言混合编程"></a>3、多语言混合编程</h4><p><strong>Java平台上的多语言混合编程</strong>正成为主流，<strong>通过特定领域的语言去解决特定领域的问题</strong>是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>例如：在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</strong>。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进(如DaVinci Machine项目、 Nashorn引擎、InvokeDynamic指令、java. lang. invoke包等)，<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展</strong>。</p>
<h4 id="4、虚拟机与JVM（java虚拟机）"><a href="#4、虚拟机与JVM（java虚拟机）" class="headerlink" title="4、虚拟机与JVM（java虚拟机）"></a>4、虚拟机与JVM（java虚拟机）</h4><h5 id="1、什么是虚拟机"><a href="#1、什么是虚拟机" class="headerlink" title="1、什么是虚拟机"></a>1、什么是虚拟机</h5><p>所谓虚拟机(Virtual Machine)，就是一台虚拟的计算机它是<strong>一款软件</strong>，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>大名鼎鼎的Visual Box, VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它<strong>专门为执行单个计算机程序而设计</strong>，在Java虛拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>但无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h5 id="2、JVM（java虚拟机）"><a href="#2、JVM（java虚拟机）" class="headerlink" title="2、JVM（java虚拟机）"></a>2、JVM（java虚拟机）</h5><p>JVM是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享JVM带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p><strong>Java技术的核心就是Java虚拟机</strong>(JVM，Java Virtual Machine) ,因为所有的Java程序都运行在JVM内部。</p>
<h5 id="3、JVM的作用"><a href="#3、JVM的作用" class="headerlink" title="3、JVM的作用"></a>3、JVM的作用</h5><p><strong>JVM就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h5 id="4、JVM的特点"><a href="#4、JVM的特点" class="headerlink" title="4、JVM的特点"></a>4、JVM的特点</h5><ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p>带来的好处：</p>
<ul>
<li>从代码层面：降低了内存泄漏与内存溢出的风险</li>
<li>从程序员层面：让程序员将自己对重心放在业务层面，不用再去手动地进行垃圾回收</li>
</ul>
<p>带来的坏处：</p>
<ul>
<li>降低了对程序员对要求，当出现内存方面的问题时不能有效解决。</li>
</ul>
<h5 id="5、JVM的位置"><a href="#5、JVM的位置" class="headerlink" title="5、JVM的位置"></a>5、JVM的位置</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt="第01章_JVM所处位置"></p>
<p><strong>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</strong></p>
<p><strong>JVM模拟的是系统</strong>，在不同系统之上，构建了一个统一的系统平台。所以在安装JDK的时候要关注JDK是安装在哪个操作系统上，因为不同的操作系统上安装的JVM是不同的。</p>
<p>JDK的构成：下图来自JDK8官网。</p>
<p><img src="/2021/04/19/JVM/image-20210420004314261.png" alt="image-20210420004314261"></p>
<p>java程序想要正确运行需要经历两个过程：</p>
<ul>
<li>java文件 –(编译)–&gt; class字节码文件：使用的编译器为：前端编译器。典型：javac</li>
<li>class字节码文件–(解释)–&gt; 二进制文件：运行。解释会用到：Java SE API 还有后端编译器（将class字节码文件编译为二进制文件）（后端编译器在JVM当中）</li>
</ul>
<h4 id="5、JVM的整体结构"><a href="#5、JVM的整体结构" class="headerlink" title="5、JVM的整体结构"></a>5、JVM的整体结构</h4><p>HotSpotVM是目前市面上高性能虚拟机的代表作之一。</p>
<p>它采用<strong>解释器与即时编译器并存的架构</strong>。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C+ +程序- -较高下的地步。</p>
<p>JVM的架构简图：程序的解释运行图</p>
<p><img src="/2021/04/19/JVM/image-20210420010019562.png" alt="第02章_JVM架构-简图"></p>
<p>其中将其分成三层：</p>
<ol>
<li><p>上层：class字节码文件进入类装载器子系统（Class loader），将class字节码文件加载到内存当中，生成一个大的class对象。这个过程中会涉及到：</p>
<ol>
<li>加载</li>
<li>链接（分成三步）</li>
<li>初始化</li>
</ol>
</li>
<li><p>中层：</p>
<ul>
<li><strong>方法区和栈是多线程共享</strong></li>
<li><strong>（Java栈（本地方法栈），本地方法栈，程序计数器是每个线程独有一份</strong></li>
</ul>
</li>
<li><p>下层：把字节码文件加载到内存以后，就可以进行解释运行了。执行引擎（Execution Engine），有三部分内容：</p>
<ol>
<li><p>解释器（Interpreter）：<strong>负责字节码文件的解释运行</strong>。<strong>主要保证程序执行的响应时间</strong></p>
</li>
<li><p>及时编译器（JIT Compiler）：对于反复运行的热点代码进行提前的<strong>编译缓存</strong>。及时编译器又叫做<strong>后端编译器</strong>，用来<strong>将字节码文件字节码指令编译成操作系统能读懂的机器指令</strong>。（高级语言-&gt;机器语言）<strong>主要负责程序的执行性能</strong>。</p>
</li>
<li><p>垃圾回收器（Garbage Collection，简称GC）：实现<strong>垃圾的自动回收</strong></p>
<p><img src="/2021/04/19/JVM/image-20210420011524768.png" alt="image-20210420011524768"></p>
</li>
</ol>
</li>
</ol>
<h4 id="6、java代码的执行流程"><a href="#6、java代码的执行流程" class="headerlink" title="6、java代码的执行流程"></a>6、java代码的执行流程</h4><p><img src="/2021/04/19/JVM/image-20210420013453679.png" alt="image-20210420013453679"></p>
<h4 id="7、JVM的架构模型"><a href="#7、JVM的架构模型" class="headerlink" title="7、JVM的架构模型"></a>7、JVM的架构模型</h4><p>Java编译器输入的指令流基本上分为两种：</p>
<ul>
<li>是一种<strong>基于栈的指令集架构</strong></li>
<li>另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</li>
</ul>
<p>两种架构的区别：</p>
<ul>
<li>基于栈式架构的特点：<ul>
<li>设计和实现更简单，<strong>适用于资源受限的系统</strong>；</li>
<li>避开了寄存器的分配难题:<strong>使用零地址指令方式分配</strong>;</li>
<li>指令流中的指令<strong>大部分是零地址指令</strong>，其执行过程依赖于操作栈。<strong>指令集更小</strong>，编译器容易实现。</li>
<li><strong>不需要硬件支持，可移植性更好，更好实现跨平台</strong></li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虛拟机；</li>
<li>指令集架构则<strong>完全依赖硬件，可移植性差</strong></li>
<li><strong>性能优秀</strong>和<strong>执行更高效</strong>;</li>
<li>花费<strong>更少的指令去完成一项操作</strong>。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<ul>
<li>优点是<strong>跨平台， 指令集小，编译器容易实现</strong></li>
<li>缺点是<strong>性能下降，实现同样的功能需要更多的指令</strong></li>
</ul>
</li>
<li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了(准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了)，那么为什么不将架构更换为基于寄存器的架构呢?<ol>
<li>基于栈式的架构<strong>在设计与实现上</strong>比基于寄存器架构的设计要<strong>简单</strong></li>
<li>基于栈式的架构<strong>在非资源受限的场景当中也是可以使用</strong>的</li>
<li>主要还是因为<strong>栈式架构可以实现跨平台</strong>，而基于寄存器架构由于与硬件的耦合度太高，不能实现跨平台。</li>
</ol>
</li>
</ul>
<h4 id="8、JVM的生命周期"><a href="#8、JVM的生命周期" class="headerlink" title="8、JVM的生命周期"></a>8、JVM的生命周期</h4><h5 id="1、虚拟机的启动"><a href="#1、虚拟机的启动" class="headerlink" title="1、虚拟机的启动"></a>1、虚拟机的启动</h5><p>Java虛拟机的启动是通过<strong>引导类加载器(bootstrap class loader) 创建一个初始类(initial class) 来完成</strong>的，这个类是由虚拟机的具体实现指定的。</p>
<p>程序的执行：主方法（main）所在类加载到内存当中。而自定义的类的加载是通过系统类加载器（应用类加载器）实现的。由于<strong>父类的加载要早于子类</strong>，这就导致了java虚拟机的启动，创建一个初始类(initial class) ,然后调用初始类（initial class）当中的main方法，在这main方法当中使用其他的一些类来相继地加载后继的所有类。</p>
<p>类加载器分成：</p>
<ul>
<li>引导类加载器（负责超类的加载（如Object））</li>
<li>扩展类加载器</li>
<li>系统类加载器（负责自定义类的类加载）</li>
<li>启动类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
<h5 id="2、虚拟机的执行"><a href="#2、虚拟机的执行" class="headerlink" title="2、虚拟机的执行"></a>2、虚拟机的执行</h5><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：<strong>执行Java程序</strong>。</li>
<li><strong>程序开始执行</strong>时他才<strong>运行</strong>，<strong>程序结束</strong>时他就<strong>停止</strong>。</li>
<li>执行一个所谓的Java程序的时候，真真正正在<strong>执行的是一个叫做Java虛拟机的进程</strong>。</li>
</ul>
<h5 id="3、虚拟机的退出"><a href="#3、虚拟机的退出" class="headerlink" title="3、虚拟机的退出"></a>3、虚拟机的退出</h5><p>有如下的几种情况：</p>
<ul>
<li>程序<strong>正常执行结束</strong></li>
<li>程序<strong>在执行过程中遇到了异常或错误</strong>而异常终止</li>
<li>由于<strong>操作系统出现错误而导致Java虛拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或System类的exit方法</strong>，或<strong>Runtime类的halt方法</strong>，并且<strong>Java安全管理器也允许这次exit或halt操作</strong>。</li>
<li>除此之外，JNI ( Java Native Interface) 规范描述了<strong>用JNI Invocation API来加载或卸载Java虚拟机</strong>时，Java虚拟机的退出情况。</li>
</ul>
<h4 id="9、JVM的发展历程"><a href="#9、JVM的发展历程" class="headerlink" title="9、JVM的发展历程"></a>9、JVM的发展历程</h4><h5 id="1、Sun-Classic-VM（SUN）"><a href="#1、Sun-Classic-VM（SUN）" class="headerlink" title="1、Sun Classic VM（SUN）"></a>1、Sun Classic VM（SUN）</h5><p>Sun公司发布的<strong>世界上第一款商用Java虚拟机</strong>，在JDK1.4时被完全淘汰。</p>
<p>这款虚拟机内部<strong>只提供解释器</strong>。</p>
<p>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。（<strong>两者只能存一</strong>）</p>
<ul>
<li>只使用解释器：当代码中重复的代码多（如循环等等）的时候执行效率低</li>
<li>只使用JIT编译器：由于将字节码文件当中字节码指令编译成机器指令进行缓存也是需要时间的。这就导致了程序启动时间过长，加上占用的缓存空间有限。</li>
</ul>
<p>现在<strong>hotspot内置了此虚拟机</strong>。</p>
<h5 id="2、Exact-VM（SUN）"><a href="#2、Exact-VM（SUN）" class="headerlink" title="2、Exact VM（SUN）"></a>2、Exact VM（SUN）</h5><p>为了解决上一个虚拟机问题，JDK1.2时， sun提供了此虚拟机。</p>
<p>Exact Memory Management：<strong>准确式内存管理</strong></p>
<ul>
<li>也可以叫Non-Conservative/ Accurate Memory Management</li>
<li><strong>虚拟机可以知道内存中某个位置的数据具体是什么类型。</strong></li>
</ul>
<p>具备现代高性能虚拟机的雏形</p>
<ul>
<li><strong>热点探测</strong></li>
<li><strong>编译器与解释器混合工作模式</strong></li>
</ul>
<p>只在Solaris平台短暂使用，其他平台上还是classic vm。最终被Hotspot虚拟机替代</p>
<h5 id="3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）"><a href="#3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）" class="headerlink" title="3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）"></a>3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）</h5><p>JDK1.3时，HotSpot VM成为默认虚拟机</p>
<p>目前<strong>Hotspot占有绝对的市场地位</strong>：</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是<br>HotSpot</li>
<li>Sun/Oracle JDK和OpenJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虛拟机都是HotSpot，相关机制也主要是指<strong>HotSpot的GC机</strong><br><strong>制</strong>。(比如<strong>其他两个商用虚拟机都没有方法区的概念</strong>)</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li><strong>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</strong></li>
<li>通过<strong>编译器与解释器协同工作</strong>，<strong>在最优化的程序响应时间与最佳执行性能中取得平衡</strong></li>
</ul>
<h5 id="4、JRockit（三大虚拟机之一）（BEA-Oracle）"><a href="#4、JRockit（三大虚拟机之一）（BEA-Oracle）" class="headerlink" title="4、JRockit（三大虚拟机之一）（BEA\Oracle）"></a>4、JRockit（三大虚拟机之一）（BEA\Oracle）</h5><p><strong>专注于服务器端应用</strong></p>
<ul>
<li>它可以不太关注程序启动速度，因此<strong>JRockit内部不包含解析器实现</strong>，全部代码<strong>都靠即时编译器编译</strong>后执行。</li>
</ul>
<p>大量的行业基准测试显示，<strong>JRockit JVM是 世界上最快的JVM</strong>。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50号)</li>
</ul>
<p>优势：<strong>全面的Java运行时解决方案组合</strong></p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案：<strong>JRockit Real Time</strong>提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li><strong>MissionControl服务套件</strong>：它是一组以极低的开销来监控、管理和分析生产<br>环境中的应用程序的工具。<ul>
<li>JDK Mission Control（JMC）（Oracle公司整合）(主要是用来监控内存泄漏)<ul>
<li>内存泄漏监测器</li>
<li>JVM运行时分析器</li>
<li>管理的控制台</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2008年，BEA被Oracle收购。</p>
<p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<h5 id="5、J9（三大虚拟机之一）（IBM）"><a href="#5、J9（三大虚拟机之一）（IBM）" class="headerlink" title="5、J9（三大虚拟机之一）（IBM）"></a>5、J9（三大虚拟机之一）（IBM）</h5><p>全称: IBM Technology for Java Virtual Machine， 简称IT4J，内部代号: J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等<strong>多用途VM</strong>，广泛用于IBM的各种Java产品。</p>
<p>目前，<strong>有影响力的三大商用服务器之一</strong>，也号称是世界上最快的Java虚拟机（在使用自己家产品时）。</p>
<p>2017年左右，IBM发布了开源J9 VM，命名为openJ9，交给Eclipse基金会管理，也称为Ecilpse OpenJ9</p>
<h5 id="6、KVM和CDC-CLDC-Hotspot"><a href="#6、KVM和CDC-CLDC-Hotspot" class="headerlink" title="6、KVM和CDC/ CLDC Hotspot"></a>6、KVM和CDC/ CLDC Hotspot</h5><p>Oracle在Java ME产品线上的两款虚拟机为: CDC/CLDC HotSpot Implementation VM</p>
<p>KVM (Kilobyte)是CLDC- HI早期产品</p>
<p>目前移动领域地位尴尬，智能手机被Android和iOS二分天下。</p>
<p>KVM简单、轻量、高度可移植，而向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p><strong>所有的虚拟机的原则：一次编译，到处运行</strong>。</p>
<h5 id="7、Azul-VM（Azul-Systems）"><a href="#7、Azul-VM（Azul-Systems）" class="headerlink" title="7、Azul VM（Azul Systems）"></a>7、Azul VM（Azul Systems）</h5><p>前而三大“高性能Java虚拟机”使用在<strong>通用硬件平台</strong>上</p>
<p>这里Azul VM和BEA Liquid VM是与<strong>特定硬件平台绑定、软硬件配合的专有虚拟机</strong>（高性能Java虚拟机中的战斗机）<br>Azul VM是Azul Systems 公司在HotSpot基础上进行大量改进，运行于Azul Systems 公司的专有硬件Vega系统上的Java虚拟机。</p>
<p><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线</strong><br><strong>程调度等优秀特性。</strong></p>
<p>2010年，Azul Systems 公司开始从硬件转向软件，发布了自己的<strong>Zing JVM</strong>，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h5 id="8、Liquid-VM（BEA）"><a href="#8、Liquid-VM（BEA）" class="headerlink" title="8、Liquid VM（BEA）"></a>8、Liquid VM（BEA）</h5><p>高性能Java虚拟机中的战斗机</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上</p>
<p>Liquid VM即是现在的JRockit VM（Virtual Edition），<strong>Liquid VM不需要成操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</p>
<p>随着JRockit虚拟机终止开发，Liquid VM项目也停止了。</p>
<h5 id="9、Apache-Harmony（IBM和Inter）"><a href="#9、Apache-Harmony（IBM和Inter）" class="headerlink" title="9、Apache Harmony（IBM和Inter）"></a>9、Apache Harmony（IBM和Inter）</h5><p>Apache Harmony是IBM和Inter联合开发的开源JVM，受到同样开源的OpenJDK的压制。</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h5 id="10、Microsoft-JVM（Microsoft）"><a href="#10、Microsoft-JVM（Microsoft）" class="headerlink" title="10、Microsoft JVM（Microsoft）"></a>10、Microsoft JVM（Microsoft）</h5><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在Window平台下运行。但确实是当时Windows下性能最好的Java VM。</p>
<p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h5 id="11、TaobaoJVM（Alibaba）"><a href="#11、TaobaoJVM（Alibaba）" class="headerlink" title="11、TaobaoJVM（Alibaba）"></a>11、TaobaoJVM（Alibaba）</h5><p>Alibaba基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于OpenJDK HotSpot VM发布的<strong>国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机</strong>。</p>
<ul>
<li>创新GCIH （GC invisible heap）技术实现了off-heap，<strong>即将生命周期较长的java对象从heap中移到heap之外，并且GC不能管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li>
<li>GCIH中的<strong>对象还能够在多个java虚拟机进程中实现共享</strong>。</li>
<li>使用crc32指令顺序JVM intrinsic降低JNI 的调用开销</li>
<li>PMU hardware的java profiling tool 的诊断协助功能</li>
<li>针对大数据场景的ZenGC</li>
</ul>
<p>taobao NM应用在阿里产品上性能高，<strong>硬件严重依赖Intel的CPU，损失了兼容性，但提高 了性能</strong>。</p>
<p>目前已经在淘宝、天猫上线，把Oracle官方版本全部替换了。</p>
<h5 id="12、Dalvik-VM（Google）"><a href="#12、Dalvik-VM（Google）" class="headerlink" title="12、Dalvik VM（Google）"></a>12、Dalvik VM（Google）</h5><p>谷歌开发的，应用与Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik VM只能称作虚拟机，而不能称作”Java 虚拟机”，它<strong>没有遵循Java虚拟机规范</strong></p>
<p><strong>不能执行Java的Class文件</strong></p>
<p><strong>基于寄存器架构，不是jvm的栈架构</strong></p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语法编写的应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android5.0使用支持提前编译（Ahead of Time Compila，AOT）的ART VM替换了Dalvik VM</p>
<h5 id="13、Graal-VM"><a href="#13、Graal-VM" class="headerlink" title="13、Graal VM"></a>13、Graal VM</h5><p>2018年4月，Oracle Labs公开了Graal VM，号称”<strong>Run Programs Faster Anywhere</strong>“。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>Graal VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机</strong>，<strong>可以作为”任何语言”的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等。</p>
<p>支持不同语言中混合对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理：将这些语言的源代码或源代码编译后的中间格式，通过解释器转换成能被Graal VM接收的中间表示。Graal VM通过Truffle工具快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>。但是Java的软件生态没有丝毫变化。</p>
<h5 id="14、其他虚拟机"><a href="#14、其他虚拟机" class="headerlink" title="14、其他虚拟机"></a>14、其他虚拟机</h5><ul>
<li>Java Card VM</li>
<li>Squawk VM</li>
<li>JavaInJava</li>
<li>Maxine VM</li>
<li>Jikes RVM</li>
<li>IKVM.NET</li>
<li>Jam VM</li>
<li>Cacao VM</li>
<li>Sable VM</li>
<li>Kaffe</li>
<li>Jelatine JVM</li>
<li>Nano VM</li>
<li>MRP</li>
<li>Moxie JVM</li>
</ul>
<hr>
<h3 id="2、类加载器子系统（Class-Loader）"><a href="#2、类加载器子系统（Class-Loader）" class="headerlink" title="2、类加载器子系统（Class Loader）"></a>2、类加载器子系统（Class Loader）</h3><h4 id="1、内部结构概述"><a href="#1、内部结构概述" class="headerlink" title="1、内部结构概述"></a>1、内部结构概述</h4><h5 id="1、类加载器子系统作用"><a href="#1、类加载器子系统作用" class="headerlink" title="1、类加载器子系统作用"></a>1、类加载器子系统作用</h5><ul>
<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息存放与一块称为方法区的内存空间。除了类信息以外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）常量池在运行过程中加载到内存里，叫运行时常量池。</li>
</ul>
<h5 id="2、类加载器ClassLoader角色"><a href="#2、类加载器ClassLoader角色" class="headerlink" title="2、类加载器ClassLoader角色"></a>2、类加载器ClassLoader角色</h5><p><img src="/2021/04/19/JVM/image-20210420231839277.png" alt="image-20210420231839277"></p>
<ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来<br>根据这个文件实例化出n个一模一样的实例。</li>
<li>class file 加载到JVM中,被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt; JVM -&gt;最终成为元数据模板,此过程就要一个运输工具(类装载器Class Loader) ,扮演一个快递员的角色。</li>
</ol>
<h4 id="2、类加载器与类的加载过程"><a href="#2、类加载器与类的加载过程" class="headerlink" title="2、类加载器与类的加载过程"></a>2、类加载器与类的加载过程</h4><h5 id="1、JVM架构"><a href="#1、JVM架构" class="headerlink" title="1、JVM架构"></a>1、JVM架构</h5><p>JVM架构-简图：<br><img src="/2021/04/19/JVM/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"></p>
<p>JVM架构-详细图解（中英文）：</p>
<p><img src="/2021/04/19/JVM/image-20210420161504521.png" alt="image-20210420161504521"></p>
<h5 id="2、类加载的过程"><a href="#2、类加载的过程" class="headerlink" title="2、类加载的过程"></a>2、类加载的过程</h5><p>类加载的过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232214018.png" alt="image-20210420232214018"></p>
<p>程序加载过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232257344.png" alt="image-20210420232257344"></p>
<h5 id="3、类加载的三个阶段"><a href="#3、类加载的三个阶段" class="headerlink" title="3、类加载的三个阶段"></a>3、类加载的三个阶段</h5><h6 id="1、阶段一：Loading（加载）"><a href="#1、阶段一：Loading（加载）" class="headerlink" title="1、阶段一：Loading（加载）"></a>1、阶段一：Loading（加载）</h6><p>加载：</p>
<ol>
<li>通过一个类的<strong>全限定类名</strong>获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>。</li>
<li><strong>在内存中生成一个代表这个类的java. lang.Class对象</strong>， 作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>补充:加载.class文件的方式：</p>
<ul>
<li>从<strong>本地系统</strong>中直接加载</li>
<li>通过<strong>网络</strong>获取，典型场景: Web Applet</li>
<li>从<strong>zip压缩包</strong>中读取，成为日后jar、war格式的基础</li>
<li><strong>运行时计算生成</strong>，使用最多的是：动态代理技术（java.lang.reflect.proxy）</li>
<li>由<strong>其他文件生成</strong>，典型场景：JSP应用</li>
<li>从<strong>专有数据库</strong>中提取.class文件,比较少见</li>
<li>从<strong>加密文件</strong>中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h6 id="2、阶段二：Linking（链接）"><a href="#2、阶段二：Linking（链接）" class="headerlink" title="2、阶段二：Linking（链接）"></a>2、阶段二：Linking（链接）</h6><p><strong>验证(Verify) :</strong></p>
<ul>
<li><p>目的在于<strong>确保Class文件的字节流中包含信息符合当前虚拟机要求</strong>，<strong>保证被加载类的正确性</strong>，不会危害虚拟机自身安全。</p>
</li>
<li><p>主要包括四种验证</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
<li><p>例如：class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）</p>
<p><img src="/2021/04/19/JVM/image-20210420234046557.png" alt="image-20210420234046557"></p>
</li>
</ul>
<p><strong>准备(Prepare) ：</strong></p>
<ul>
<li>为<strong>类变量分配内存并且设置该类变量的默认初始值</strong>，即零值。</li>
<li>这里<strong>不包含用final修饰的static（即：常量）</strong>，因为final在编译的时候就会分配了，准备阶段会显式初始化。</li>
<li>这里<strong>不会为实例变量分配初始化</strong>，<strong>类变量会分配在方法区</strong>中，而<strong>实例变量是会随着对象一起分配到Java堆</strong>中。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prepare: a = 0 ---&gt; Initialization : a = 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中数据类型不同，默认初始值也就不同：</p>
<ul>
<li>整型（byte\short\int\long）：0</li>
<li>浮点型（float\double）:0.0f</li>
<li>字符型（char）：\u0000</li>
<li>布尔型（boolean）：false</li>
<li>引用类型：null</li>
</ul>
<p><strong>解析(Resolve) :</strong></p>
<ul>
<li>将<strong>常量池内的符号引用转换为直接引用</strong>的过程。</li>
<li>事实上，解析操作往往会伴随着<strong>JVM在执行完初始化之后</strong>再执行。</li>
<li>符号引用就是<strong>一组符号来描述所引用的目标</strong>。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。</li>
<li>解析动作主要针对<strong>类</strong>或<strong>接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>等。对应常量池中的CONSTANT_ Class_ info、CONSTANT Fieldref_ info、 CONSTANT Methodref_ info等。</li>
</ul>
<h6 id="3、阶段三：Initialization（初始化）"><a href="#3、阶段三：Initialization（初始化）" class="headerlink" title="3、阶段三：Initialization（初始化）"></a>3、阶段三：Initialization（初始化）</h6><p>初始化：</p>
<ul>
<li><p><strong>初始化阶段就是执行类构造器方法<clinit>()的过程</clinit></strong>。</p>
</li>
<li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并而来。</p>
<p>当不涉及到类变量的赋值动作与有关静态static（包括静态代码快、静态构造器，静态变量等等）的动作时，类构造器方法<clinit>()不会创建。</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任何一个类声明以后，内部至少存在一个类的构造器&lt;init&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210421005041972.png" alt="image-20210421005041972"></p>
</li>
<li><p>构造器方法中<strong>指令按语句在源文件中出现的顺序执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// 赋值</span></span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;  <span class="comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><clinit> ()不同于类的构造器</clinit></strong>。(关联: 构造器是虚拟机视角下的<init> ())</init></p>
<p>任何一个类声明以后，内部至少存在一个类的构造器<init>（可以是自己声明的，也可以说系统默认提供的）</init></p>
<p><img src="/2021/04/19/JVM/image-20210421005632840.png" alt="image-20210421005632840"></p>
</li>
<li><p>若该类具有父类，JVM会保证<strong>子类的<clinit> ()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载Father类，其次加载Son类。</span></span><br><span class="line">        System.out.println(Son.B);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟机必须保证<strong>一个类的<clinit>()方法在多线程下被同步加锁</clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 若一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</span></span><br><span class="line">            <span class="comment">// 那么这里的打印代码就只会执行一次</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<blockquote>
<p>线程2开始<br>线程1开始<br>线程2初始化当前类</p>
</blockquote>
<p>一个类只需要往内存中加载一次就可以了，加载之后将其放在方法区（方法区在JDK7之前被称为永久代，JDK7之后被称为源空间），源空间其实使用的是本地内存，即类加载到内存之后是使用直接内存进行缓存。若以后使用到该类，那么使用的都是内存中已经存在的类本身。所以，<strong>虚拟机在加载类的时候只会调用一次<clinit>方法</clinit></strong>。</p>
</li>
</ul>
<h4 id="3、类加载器分类"><a href="#3、类加载器分类" class="headerlink" title="3、类加载器分类"></a>3、类加载器分类</h4><h5 id="1、类加载器分类"><a href="#1、类加载器分类" class="headerlink" title="1、类加载器分类"></a>1、类加载器分类</h5><p>JVM支持<strong>两种类型的类加载器</strong>，分别为<strong>引导类加载器( Bootstrap ClassLoader)**和</strong>自定义类加载器(User-Defined ClassLoader)** 。</p>
<ul>
<li><p>引导类加载器( Bootstrap ClassLoader)：</p>
<ul>
<li>本身不是使用java语言编写，而是使用C与C++进行编写</li>
</ul>
</li>
<li><p>自定义类加载器(User-Defined ClassLoader)</p>
<ul>
<li><p>使用java语言编写</p>
</li>
<li><p>派生与抽象类ClassLoader。所以扩展类加载器（Extinction Class Loader）与系统类加载器（System Class Loader）都属于自定义类加载器</p>
<p>其中sun.misc.Launcher它是一个java虚拟机的入口应用</p>
<p><img src="/2021/04/19/JVM/image-20210421012614177.png" alt="image-20210421012614177"></p>
</li>
</ul>
</li>
</ul>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个：</p>
<p><img src="/2021/04/19/JVM/image-20210421011954294.png" alt="image-20210421011954294"></p>
<p>这里的四者之间的关系是<strong>包含关系</strong>。不是上层下层，也不是子父类的继承关系。</p>
<p>对于引导类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）与系统类加载器（System Class Loader）三者的关系：</p>
<ul>
<li>系统类加载器（System Class Loader）的上层就是扩展类加载器（Extension Class Loader）：对于用户自定义类来说：默认使用系统类加载器进行加载</li>
<li>扩展类加载器（Extension Class Loader）的上层是引导类加载器（Bootstrap Class Loader）</li>
<li>引导类加载器（Bootstrap Class Loader）是最高层的类加载器：<strong>Java的核心类库</strong>都是使用引导类加载器进行加载的。并且我们获取不到引导类加载器。因为引导类加载器并不是所以java语言进行编写的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）"><a href="#2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）"></a>2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）</h5><ul>
<li>这个类加载<strong>使用C/C++语言实现</strong>的，嵌套在JVM内部，是JVM的一部分。</li>
<li>它用来<strong>加载Java的核心库</strong>(JAVA HOME/jre/lib/rt.jar、resources. jar或sun.boot.class.path路径下的内容) , 用于<strong>提供JVM自身需要的类</strong></li>
<li>并<strong>不继承自java. lang .ClassLoader</strong>,<strong>没有父加载器</strong>。</li>
<li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong>。</li>
<li>出于安全考虑，Bootstrap启动类加载器<strong>只加载包名为java、javax、sun等开头的类</strong></li>
</ul>
<h5 id="3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）"><a href="#3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）"></a>3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><p><strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</p>
</li>
<li><p><strong>派生于ClassLoader类</strong></p>
</li>
<li><p><strong>父类加载器为启动类加载器</strong></p>
</li>
<li><p>从java. ext. dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。</p>
<p><strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</strong></p>
</li>
<li><p><strong>JDK9以后</strong>扩展类加载器改为<strong>平台类加载器</strong></p>
</li>
</ul>
<h5 id="4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）"><a href="#4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）" class="headerlink" title="4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）"></a>4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><strong>java语言编写</strong>，由sun.misc.Launcher$AppClassLoader实现</li>
<li><strong>派生于ClassLoader类</strong></li>
<li><strong>父类加载器为扩展类加载器</strong></li>
<li>它负责<strong>加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li>
<li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，<strong>Java应用的类都是由它来完成加载</strong></li>
<li><strong>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</strong></li>
</ul>
<h5 id="5、用户自定义类加载器"><a href="#5、用户自定义类加载器" class="headerlink" title="5、用户自定义类加载器"></a>5、用户自定义类加载器</h5><ul>
<li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li><p>为什么要自定义类加载器：</p>
<ul>
<li><p><strong>隔离加载类</strong>：</p>
<p>在某些框架中需要使用中间件，然而中间件与应用模块是隔离的。所以需要把类加载到不同的环境当中，确保应用当中引用到的框架的jar包与中间件的jar包是不冲突的（冲突：框架与中间件的某些类的类名一样，路径也相同）。</p>
<p>所以需要做一个类的仲裁。一般主流的容器类框架都会自定义类加载器，让本身与不同中间件之间是隔离的，避免类的冲突。</p>
</li>
<li><p><strong>修改类加载的方式</strong>：</p>
<p>除了引导类加载器，其他类加载器都可以在需要的时候进行动态加载</p>
</li>
<li><p><strong>扩展加载源</strong>：</p>
<p>可以从数据库当中，或者电视机的机饼盒等等加载字节码文件的来源</p>
</li>
<li><p><strong>防止源码泄漏</strong>：</p>
<p>对字节码文件进行加密，防止被反编译篡改。</p>
<p>加密之后运行代码时就需要进行解密，这时候就可以通过自定义加载器的方式进行解密</p>
</li>
</ul>
</li>
<li><p>用户自定义类加载器实现步骤：</p>
<ol>
<li><p>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求；</p>
</li>
<li><p>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是<strong>在JDK1.2之后</strong>已不再建议用户去覆盖loadClass()方法，而是<strong>建议把自定义的类加载逻辑写在findClass()方法中</strong>。（findClass()方法与defineClass()方法配合使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,result,<span class="number">0</span>,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>,<span class="keyword">true</span>,customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编写自定义类加载器时，<strong>如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就<strong>可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</strong>。</p>
</li>
</ol>
</li>
</ul>
<h4 id="4、Class-Loader的使用说明"><a href="#4、Class-Loader的使用说明" class="headerlink" title="4、Class Loader的使用说明"></a>4、Class Loader的使用说明</h4><p>ClassLoader类，它是一个<strong>抽象类</strong>，其后<strong>所有的类加载器都继承自ClassLoader</strong> (不包括启动类加载器）</p>
<p>相关方法与描述：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法名称</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中的内容转换为一个Java类,返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的途径:</p>
<ol>
<li><p>获取当前类的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前线程上下文的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取系统的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取调用者的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5、双亲委派机制"><a href="#5、双亲委派机制" class="headerlink" title="5、双亲委派机制"></a>5、双亲委派机制</h4><h5 id="1、什么是双亲委派机制"><a href="#1、什么是双亲委派机制" class="headerlink" title="1、什么是双亲委派机制"></a>1、什么是双亲委派机制</h5><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即<strong>把请求交由父类处理</strong>，它是一种任务委派模式。</p>
<h5 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h5><ol>
<li>如果一个类加载器收到类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210421103744316.png" alt="image-20210421103744316"></p>
<h5 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h5><p><img src="/2021/04/19/JVM/image-20210421105124634.png" alt="image-20210421105124634"></p>
<ul>
<li>SPI接口是由引导类加载器加载的</li>
<li>具体接口的实现类由于使用了第三方jdbc.jar，所以是由线程上下文类加载器加载的，而线程上下文类加载器的默认就是系统类加载器。（反向委派）</li>
</ul>
<h5 id="4、优势"><a href="#4、优势" class="headerlink" title="4、优势"></a>4、优势</h5><ul>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang,ShkStart</li>
</ul>
</li>
</ul>
<p>在src目录下新建java.lang.String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>在类 java.lang.String 中找不到 main 方法</p>
</blockquote>
<p>在src目录下新建java.lang并在该包下编写自定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：java.lang.SecurityException：Prohibited package name：java.lang</p>
</blockquote>
<p><strong>沙箱安全机制</strong>：</p>
<p>自定义String类，但是在加载自定义String类的时候会率先随意引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h4 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h4><h5 id="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"><a href="#1、在JVM中表示两个class对象是否为同一个类存在两个必要条件" class="headerlink" title="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"></a>1、在JVM中表示两个class对象是否为同一个类存在两个必要条件</h5><ul>
<li><strong>类的完整类名必须一致，包括包名</strong>。</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li>
</ul>
<p>换句话说：在JVM中，既使这两个类对象（class对象）来源于同一个Class文件，被同一个虚拟机所加载，但<strong>只要加载它们的ClassLoader实例对象不同</strong>，那么这两个类对象也是<strong>不相等</strong>的。</p>
<h5 id="2、对类加载器的引用"><a href="#2、对类加载器的引用" class="headerlink" title="2、对类加载器的引用"></a>2、对类加载器的引用</h5><p>JVM必须知道一个类型是由启动类加载器加载的还是有用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h5 id="3、类的主动使用与被动使用"><a href="#3、类的主动使用与被动使用" class="headerlink" title="3、类的主动使用与被动使用"></a>3、类的主动使用与被动使用</h5><p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li><p>主动使用，又分为七种情况：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName(“com.atguigu.Test”)）</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK7开始通过动态语言支持：</p>
<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ul>
</li>
<li><p>被动使用：除了上述七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
</li>
</ul>
<hr>
<h3 id="3、运行时数据区概述及线程"><a href="#3、运行时数据区概述及线程" class="headerlink" title="3、运行时数据区概述及线程"></a>3、运行时数据区概述及线程</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、经典的JVM内存布局"><a href="#1、经典的JVM内存布局" class="headerlink" title="1、经典的JVM内存布局"></a>1、经典的JVM内存布局</h5><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局：</p>
<p><img src="/2021/04/19/JVM/image-20210421112837894.png" alt="image-20210421112837894"></p>
<p>其中：方法区在JVM规范中是一个逻辑概念，由虚拟机自己进行具体实现。</p>
<ul>
<li><strong>HotSpot7和以前的版本</strong>用的是堆上的<strong>永久代</strong>实现方法区</li>
<li><strong>HotSpot8之后</strong>使用<strong>元数据区</strong>实现方法区</li>
<li><strong>常量池</strong>在jdk8以后也被放到了堆中</li>
</ul>
<h5 id="2、进程同步与线程同步："><a href="#2、进程同步与线程同步：" class="headerlink" title="2、进程同步与线程同步："></a>2、进程同步与线程同步：</h5><p>Java虚拟机定义了若干种程序运行期间会使用到的<strong>运行时数据区</strong>，其中有一些会<strong>随着虚拟机启动而创建，随着虚拟机退出而销毁(进程同步)**。另外一些则是</strong>与线程一一对应的<strong>，这些</strong>与线程对应的数据区域会随着线程开始和结束而创建和销毁**。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即:</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>每个进程：<strong>线程间共享</strong>，堆、堆外内存(永久代或元空间、代码缓存)（问题：怎么保证线程安全）</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421113146594.png" alt="image-20210421113146594"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="第03章_线程共享和私有的结构"></p>
<p>​    其中：（一个线程一份）</p>
<ul>
<li>PC：程序计数器</li>
<li>VMS：虚拟机栈</li>
<li>NMS：本地方法栈</li>
</ul>
<h5 id="3、关于线程间共享的说明："><a href="#3、关于线程间共享的说明：" class="headerlink" title="3、关于线程间共享的说明："></a>3、关于线程间共享的说明：</h5><p><img src="/2021/04/19/JVM/image-20210421114556021.png" alt="image-20210421114556021"></p>
<p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框（运行时数据区(Runtime Data Area)）：运行时环境。</p>
<h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><h5 id="1、关于线程"><a href="#1、关于线程" class="headerlink" title="1、关于线程"></a>1、关于线程</h5><p><strong>线程是一个程序里的运行单元</strong>。JVM允许<strong>一个应用有多个线程并行</strong>的执行。</p>
<p>在Hotspot JVM里，<strong>每个线程都与操作系统的本地线程直接映射</strong>。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<h5 id="2、线程的分类"><a href="#2、线程的分类" class="headerlink" title="2、线程的分类"></a>2、线程的分类</h5><ul>
<li>普通线程</li>
<li>守护线程</li>
</ul>
<h5 id="3、JVM的系统线程"><a href="#3、JVM的系统线程" class="headerlink" title="3、JVM的系统线程"></a>3、JVM的系统线程</h5><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。</p>
<p>这些<strong>后台线程不包括</strong>调用public static void main (String[])的<strong>main线程以及所有这个main线程自己创建的线程</strong>。</p>
<p>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：</p>
<ul>
<li><p><strong>虚拟机线程</strong>：</p>
<p>这种线程的操作是需要<strong>JVM达到安全点</strong>才会出现。这些操作必须<strong>在不同的线程中发生的原因是他们都需要JVM达到安全点</strong>，这样堆才不会变化。这种线程的执行类型包括**”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销**。</p>
</li>
<li><p><strong>周期任务线程</strong>：</p>
<p>这种线程是<strong>时间周期事件的体现(比如中断)**，他们</strong>一般用于周期性操作的调度执行**。</p>
</li>
<li><p><strong>GC线程</strong>：</p>
<p>这种线程<strong>对在JVM里不同种类的垃圾收集行为提供了支持</strong>。</p>
</li>
<li><p><strong>编译线程</strong>：</p>
<p>这种线程在运行时会<strong>将字节码编译成到本地代码</strong>。</p>
</li>
<li><p><strong>信号调度线程</strong>：</p>
<p>这种线程接收信号并<strong>发送给JVM</strong>， <strong>在它内部通过调用适当的方法进行处理</strong>。</p>
</li>
</ul>
<h3 id="4、程序计数器（PC寄存器）"><a href="#4、程序计数器（PC寄存器）" class="headerlink" title="4、程序计数器（PC寄存器）"></a>4、程序计数器（PC寄存器）</h3><h4 id="1、PC-Register介绍"><a href="#1、PC-Register介绍" class="headerlink" title="1、PC Register介绍"></a>1、PC Register介绍</h4><p><img src="/2021/04/19/JVM/image-20210422000432697.png" alt="image-20210422000432697"></p>
<p>JVM中的程序计数寄存器(Program Counter Register) 中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。<strong>CPU只有把数据装载到寄存器才能够运行</strong>。</p>
<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</p>
<p><strong>作用</strong>：</p>
<p>PC寄存器<strong>用来存储指向下一条指令的地址</strong>，也即将要执行的指令代码。<strong>由执行引擎读取下一条指令</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210421201053065.png" alt="image-20210421201053065"></p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li>
<li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的</strong>，<strong>生命周期与线程的生命周期保持一致</strong>。</li>
<li><strong>任何时间一个线程都只有一个方法在执行</strong>，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，<strong>如果是在执行native方法，则是未指定值(undefned)</strong></li>
<li><strong>它是程序控制流的指示器</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li><strong>字节码解释器</strong>工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。</li>
<li>它<strong>不存在垃圾回收</strong>问题。</li>
<li>它是<strong>唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域</strong>。</li>
<li>即：<strong>无GC，无OOM</strong></li>
</ul>
<h4 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h4><p><img src="/2021/04/19/JVM/image-20210422001738599.png" alt="image-20210422001738599"></p>
<p><img src="/2021/04/19/JVM/image-20210422001753431.png" alt="image-20210422001753431"></p>
<p>针对<code>5</code>进行举例：（PC寄存器的意义或者作用）</p>
<ol>
<li>指令地址<code>5</code>就是PC寄存器里面存放的值</li>
<li>执行引擎会在PC寄存器里面获取指令地址对应的操作指令（istore_2）</li>
<li>执行引擎得到操作指令后会执行下面两个操作：<ol>
<li>操作虚拟机栈（如局部变量表、操作数栈等等），实现数据的存取操作以及一些求和运算等等。</li>
<li>把字节码指令翻译为机器指令</li>
</ol>
</li>
<li>机器指令可以让对应的CPU做运算</li>
</ol>
<h4 id="3、两个常见问题"><a href="#3、两个常见问题" class="headerlink" title="3、两个常见问题"></a>3、两个常见问题</h4><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>因为CPU需要不停的切换各个进程，这时候切换回来以后，就得知道从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="第04章_PC寄存器"></p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p>我们都知道所谓的<strong>多线程在一个特定的时间段内只会执行其中某一个线程的方法</strong>，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，<strong>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况</strong>。</p>
<p>由于<strong>CPU时间片轮限制</strong>，众多线程在并发执行过程中，任何一个确定的时刻，<strong>一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</strong>。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p><strong>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响</strong>。</p>
</li>
</ol>
<h4 id="4、CPU时间片"><a href="#4、CPU时间片" class="headerlink" title="4、CPU时间片"></a>4、CPU时间片</h4><p><strong>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片</strong>。</p>
<p>在<strong>宏观</strong>上：我们可以<strong>同时打开多个应用程序，每个程序并行不悖，同时运行</strong>。</p>
<p>但在<strong>微观</strong>上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平？一种方法就是<strong>引入时间片，每个程序轮流执行</strong>。</p>
<p>并行与并发：</p>
<ul>
<li>并行就是两个核同时算</li>
<li>并发就是一个核算两个一人一段。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421202826450.png" alt="image-20210421202826450"></p>
<h3 id="5、虚拟机栈"><a href="#5、虚拟机栈" class="headerlink" title="5、虚拟机栈"></a>5、虚拟机栈</h3><h4 id="1、虚拟机栈概述"><a href="#1、虚拟机栈概述" class="headerlink" title="1、虚拟机栈概述"></a>1、虚拟机栈概述</h4><h5 id="1、虚拟机栈出现的背景"><a href="#1、虚拟机栈出现的背景" class="headerlink" title="1、虚拟机栈出现的背景"></a>1、虚拟机栈出现的背景</h5><p>由于跨平台性的设计，<strong>Java的指令都是根据栈来设计</strong>的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>跨平台</li>
<li>指令集小</li>
<li>编译器容易实现，</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>性能下降</li>
<li>实现同样的功能需要更多的指令</li>
</ul>
<h5 id="2、内存中的栈与堆"><a href="#2、内存中的栈与堆" class="headerlink" title="2、内存中的栈与堆"></a>2、内存中的栈与堆</h5><p>栈：</p>
<ul>
<li><strong>栈是运行时的单位</strong></li>
<li><strong>栈解决程序的运行问题</strong>，即程序如何执行，或者说如何处理数据</li>
</ul>
<p>堆：</p>
<ul>
<li><strong>堆是存储的单位</strong></li>
<li><strong>堆解决的是数据存储的问题</strong>，即数据怎么放、放在哪里。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422005102514.png" alt="image-20210422005102514"></p>
<h5 id="3、虚拟机栈基本内容"><a href="#3、虚拟机栈基本内容" class="headerlink" title="3、虚拟机栈基本内容"></a>3、虚拟机栈基本内容</h5><p>Java虚拟机栈是什么?</p>
<p>Java虚拟机栈(Java Virtual Machine Stack) ，早期也叫Java栈。<strong>每个线程在创建时都会创建一个虚拟机栈，其内部保存一一个个的栈帧</strong>(Stack Frame) （栈存储数据的基本单位），<strong>对应着一次次的Java方法调用</strong>。</p>
<ul>
<li>是线程私有的</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422012357234.png" alt="image-20210422012357234"></p>
<p>Java虚拟机栈生命周期：</p>
<ul>
<li><strong>生命周期和线程一致</strong>。</li>
</ul>
<p>Java虚拟机栈作用：</p>
<ul>
<li>主管Java程序的运行，它保存方法的**局部变量(8种基本数据类型、对象的引用)**、部分结果，并参与方法的调用和返回。</li>
</ul>
<p>栈的特点(优点)：</p>
<ul>
<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li><p>JVM直接对Java栈的操作只有两个:</p>
<ul>
<li>每个方法执行，伴随着进栈(入栈、压栈)</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li><p>对于栈来说<strong>不存在垃圾回收问题</strong>，但是存在内存溢出的情况。</p>
</li>
<li><p>即：<strong>无GC，有OOM</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422013552022.png" alt="image-20210422013552022"></p>
</li>
</ul>
<p>栈中可能存在的异常：</p>
<p>Java虚拟机规范<strong>允许Java栈的大小是动态的或者是固定不变</strong>的。</p>
<ul>
<li><p>如果采用<strong>固定大小</strong>的Java虚拟机栈，那<strong>每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定</strong>。如果<strong>线程请求分配的栈容量超过Java虚拟机栈允许的最大容量</strong>，Java虚拟机将会抛出一个<strong>StackOverflowError异常</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210422013326303.png" alt="image-20210422013326303"></p>
</li>
<li><p>如果Java虚拟机栈可以<strong>动态扩展</strong>，并且<strong>在尝试扩展的时候无法申请到足够的内存</strong>，或者<strong>在创建新的线程时没有足够的内存去创建对应的虚拟机栈</strong>，那Java虚拟机将会抛出一个<strong>OytOfMemoryError异常</strong>。</p>
</li>
</ul>
<p>设置栈内存大小：</p>
<p>我们可以使用<strong>参数-Xss选项来设置线程的最大栈空间</strong>，**栈的大小直接决定了函数调用的最大可达<code>深度**</code>。</p>
<p><img src="/2021/04/19/JVM/image-20210422014055436.png" alt="image-20210422014055436"></p>
<p>设置步骤：</p>
<ol>
<li><p>在IDEA点开<code>Run</code></p>
<p><img src="/2021/04/19/JVM/image-20210422014347776.png" alt="image-20210422014347776"></p>
</li>
<li><p>在Run下面有选项<code>Edit Configurations...</code></p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210422014445720.png" alt="image-20210422014445720"></p>
</li>
<li><p>在当前类下的<code>VM options</code>中进行参数设置。（参数参考上-Xss的设置）程序调优的一种方案：<strong>参数调优</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422014706947.png" alt="image-20210422014706947"></p>
</li>
</ol>
<p>参数设置后的测试方法：</p>
<p><img src="/2021/04/19/JVM/image-20210422013442292.png" alt="image-20210422013442292"></p>
<h4 id="2、栈的存储单位"><a href="#2、栈的存储单位" class="headerlink" title="2、栈的存储单位"></a>2、栈的存储单位</h4><h5 id="1、栈中存储什么"><a href="#1、栈中存储什么" class="headerlink" title="1、栈中存储什么?"></a>1、栈中存储什么?</h5><ul>
<li><strong>每个线程都有自己的栈</strong>，栈中的数据都是<strong>以栈帧(Stack Frame)为基本存储单位</strong>的格式存在。</li>
<li>在这个线程上正在执行的<strong>每个方法都各自对应一一个栈帧(Stack Frame)</strong></li>
<li>栈帧是一个<strong>内存区块</strong>，是一个<strong>数据集</strong>，<strong>维系着方法执行过程中的各种数据信息</strong>。</li>
</ul>
<h5 id="2、栈的运行原理"><a href="#2、栈的运行原理" class="headerlink" title="2、栈的运行原理"></a>2、栈的运行原理</h5><ul>
<li><p>JVM直接对Java栈的操作只有两个，就是<strong>对栈帧的压栈和出栈</strong>，<strong>遵循“先进后出”/“后进先出”原则</strong>。</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈项栈帧)是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong> ，与当前栈帧相对应的方法就是<strong>当前方法(Current Method)**，定义这个方法的类就是</strong>当前类(Current Class)** 。</p>
</li>
<li><p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong>。</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A0%88%E6%A1%A2.jpg" alt="第05章_方法与栈桢"></p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧之中引用另外一个线程的栈帧</strong>。</p>
</li>
<li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
</li>
<li><p>Java方法有两种返回函数的方式：</p>
<ul>
<li><strong>正常的函数返回，使用return指令</strong></li>
<li><strong>抛出异常</strong></li>
</ul>
<p>不管使用哪种方式，都会导致<strong>栈帧被弹出</strong>。</p>
</li>
</ul>
<h5 id="3、栈帧的内部结构"><a href="#3、栈帧的内部结构" class="headerlink" title="3、栈帧的内部结构"></a>3、栈帧的内部结构</h5><p>每个栈帧中存储着:</p>
<ul>
<li><strong>局部变量表(Local Variables：LV)</strong></li>
<li><strong>操作数栈(Operand Stack) (或表达式栈 )</strong></li>
<li>动态链接(Dynamic Linking) ( 或指向运行时常量池的方法引用) </li>
<li>方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="第05章_栈桢内部结构"></p>
<p><img src="/2021/04/19/JVM/image-20210422173049395.png" alt="image-20210422173049395"></p>
<h4 id="3、局部变量表-Local-Variables"><a href="#3、局部变量表-Local-Variables" class="headerlink" title="3、局部变量表( Local Variables)"></a>3、局部变量表( Local Variables)</h4><h5 id="1、局部变量表的概述"><a href="#1、局部变量表的概述" class="headerlink" title="1、局部变量表的概述"></a>1、局部变量表的概述</h5><ul>
<li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括<strong>各类基本数据类型</strong>、<strong>对象引用(reference)</strong> ，以及<br><strong>return Address类型</strong>。（因为各类数据类型都可以通过<strong>数字</strong>来表示）</li>
<li>由于局部变量表是建立在<strong>线程的栈上</strong>，是<strong>线程的私有数据</strong>，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来</strong>的，并<strong>保存在方法的Code属性的maximum local variables数据项</strong>中。 在方法<strong>运行期间是不会改变</strong>局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</li>
</ul>
<h5 id="2、对程序编译后的字节码文件的查看方法"><a href="#2、对程序编译后的字节码文件的查看方法" class="headerlink" title="2、对程序编译后的字节码文件的查看方法"></a>2、对程序编译后的字节码文件的查看方法</h5><p>程序代码：（以main方法为例，其他方法类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210422180804881.png" alt="image-20210422180804881"></p>
<p><img src="/2021/04/19/JVM/image-20210422181213595.png" alt="image-20210422181213595"></p>
<p><img src="/2021/04/19/JVM/image-20210422181755767.png" alt="image-20210422181755767"></p>
<p><img src="/2021/04/19/JVM/image-20210422182334511.png" alt="image-20210422182334511"></p>
<p><img src="/2021/04/19/JVM/image-20210422193112649.png" alt="image-20210422193112649"></p>
<p><img src="/2021/04/19/JVM/image-20210422193542032.png" alt="image-20210422193542032"></p>
<h5 id="3、关于Slot的理解"><a href="#3、关于Slot的理解" class="headerlink" title="3、关于Slot的理解"></a>3、关于Slot的理解</h5><ul>
<li><p><strong>参数值的存放总是在局部变量数组的index0开始</strong>，到数组长度-1的索引结束。</p>
</li>
<li><p><strong>局部变量表的最基本的存储单元是Slot (变量槽)</strong></p>
</li>
<li><p><strong>局部变量：表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</strong></p>
</li>
<li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot (包括returnAddress类型)，64位的类型(long和double)占用两个slot</strong>。</p>
<ul>
<li>byte、short 、char、在存储前被转换为int，boolean 也被转换为int，0表示false，非0表示true，float、<strong>引用数据类型的引用</strong></li>
<li>long和double则占据两个Slot。</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的基本变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个Slot上</p>
</li>
<li><p><strong>如果需要访问局部变量表中一个64bit的基本变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或double类型变量）</p>
<p><img src="/2021/04/19/JVM/image-20210422200200175.png" alt="image-20210422200200175"></p>
</li>
<li><p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，那么<strong>该<code>对象引用this</code>将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
</li>
<li><p><strong>在静态(static)方法中不能引用this</strong>：因为this变量不存在于静态方法的局部变量表中！！</p>
<p><img src="/2021/04/19/JVM/image-20210422201450476.png" alt="image-20210422201450476"></p>
</li>
</ul>
<h5 id="4、Slot的重复利用"><a href="#4、Slot的重复利用" class="headerlink" title="4、Slot的重复利用"></a>4、Slot的重复利用</h5><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<p>变量c使用之前已经销毁的变量b占据的slot的位置：</p>
<p><img src="/2021/04/19/JVM/image-20210422202145932.png" alt="image-20210422202145932"></p>
<h5 id="5、静态变量与局部变量的对比"><a href="#5、静态变量与局部变量的对比" class="headerlink" title="5、静态变量与局部变量的对比"></a>5、静态变量与局部变量的对比</h5><p><strong>变量的分类</strong>：</p>
<ul>
<li>按照数据类型分：<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量（static修饰）： linking的prepare阶段：给类变量默认赋值  —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li>
<li>实例变量（没有static修饰）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li>
</ul>
</li>
</ul>
<p><strong>静态变量（类变量）与局部变量对比</strong>：</p>
<ul>
<li><p>参数表分配完毕之后，再<strong>根据方法体内定义的变量的顺序和作用域分配</strong>。</p>
</li>
<li><p>我们知道<strong>类变量</strong>表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对<strong>类变量设置零值</strong>，另一次则是在“<strong>初始化</strong>”阶段，赋予<strong>程序员在代码中定义的初始值</strong>。</p>
</li>
<li><p>和类变量初始化不同的是，<strong>局部变量表**</strong>不存在系统初始化<strong>的过程，这意味着</strong>一旦**<br><strong>定义了局部变量则必须人为的初始化，否则无法使用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 报错：没有赋值不能够使用。</span></span><br><span class="line">    System.out.println(i).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6、补充说明："><a href="#6、补充说明：" class="headerlink" title="6、补充说明："></a>6、补充说明：</h5><ul>
<li>在栈帧中，与<strong>性能调优</strong>关系最为密切的部分就是<strong>局部变量表</strong>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><strong>局部变量表中的变量也是重要的<code>垃圾回收根节点</code>（根搜索算法\可达性分析），只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</li>
</ul>
<h4 id="4、操作数栈-Operand-Stack"><a href="#4、操作数栈-Operand-Stack" class="headerlink" title="4、操作数栈(Operand Stack)"></a>4、操作数栈(Operand Stack)</h4><ul>
<li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<strong>后进先出(Last- In-First-Out：LIFO)的操作数栈</strong>，也可以称之为<strong>表达式栈(Expression Stack)</strong> 。</p>
</li>
<li><p><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push) /出栈(pop)。</strong></p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p>
</li>
<li><p>比如：执行复制、交换、求和等操作</p>
<p><img src="/2021/04/19/JVM/image-20210422204325546.png" alt="image-20210422204325546"></p>
</li>
</ul>
</li>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量<code>临时</code>的存储空间</strong>。</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</p>
</li>
<li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其<strong>所需的最大深度在编译期就定义好了</strong>，在方法<strong>运行期间是不会改变</strong>操作数栈的大小的。保存在方法的<code>Code</code>属性中，为<code>max_ stack</code>的值。</p>
</li>
<li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p>
<ul>
<li><strong>32bit</strong>的类型占用<strong>一个</strong>栈单位深度</li>
<li><strong>64bit</strong>的类型占用<strong>两个</strong>栈单位深度</li>
</ul>
</li>
<li><p>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是<strong>只能通过标准的入栈(push)和出栈(pop) 操作</strong>来完成一次数据访问。</p>
</li>
<li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p><img src="/2021/04/19/JVM/image-20210422211053093.png" alt="image-20210422211053093"></p>
</li>
<li><p><strong>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配</strong>，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是<strong>操作数栈</strong>。</p>
</li>
</ul>
<h4 id="5、代码跟踪"><a href="#5、代码跟踪" class="headerlink" title="5、代码跟踪"></a>5、代码跟踪</h4><h5 id="1、对操作数栈相关知识点的代码分析"><a href="#1、对操作数栈相关知识点的代码分析" class="headerlink" title="1、对操作数栈相关知识点的代码分析"></a>1、对操作数栈相关知识点的代码分析</h5><p><img src="/2021/04/19/JVM/image-20210422210316458.png" alt="image-20210422210316458"></p>
<p><img src="/2021/04/19/JVM/image-20210422210545629.png" alt="image-20210422210545629"></p>
<p><img src="/2021/04/19/JVM/image-20210422210620080.png" alt="image-20210422210620080"></p>
<p><img src="/2021/04/19/JVM/image-20210422210641231.png" alt="image-20210422210641231"></p>
<p><img src="/2021/04/19/JVM/image-20210422210655579.png" alt="image-20210422210655579"></p>
<h5 id="2、面试问题：i-VS-i"><a href="#2、面试问题：i-VS-i" class="headerlink" title="2、面试问题：i++ VS ++i"></a>2、面试问题：i++ VS ++i</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第1类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        i1++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">10</span>;</span><br><span class="line">        ++i2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = i3++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i6 = ++i5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i7 = <span class="number">10</span>;</span><br><span class="line">        i7 = i7++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">10</span>;</span><br><span class="line">        i8 = ++i8;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第4类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i9 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i10 = i9++ + ++i9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一类问题：两种没什么区别，都是实现变量的加1操作</p>
<h4 id="6、栈顶缓存技术"><a href="#6、栈顶缓存技术" class="headerlink" title="6、栈顶缓存技术"></a>6、栈顶缓存技术</h4><p>前面提过，基于栈式架构的虛拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派( instruction dispatch) 次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了<strong>栈顶缓存(ToS，Top-of-stack Cashing) 技术</strong>，<strong>将栈顶元素全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<h4 id="7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）"><a href="#7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）" class="headerlink" title="7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）"></a>7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）</h4><ul>
<li><p>每一个栈帧内部都包含一个指向**<code>运行时常量池</code><strong>中</strong>该栈帧所属方法的引用<strong>。包含这个引用的目的就是为了</strong>支持当前方法的代码能够实现动态链接(Dynamic Linking)** 。比如: invokedynamic指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用</strong>(Symbolic Reference) <strong>保存在class文件的常量池里</strong>。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了<strong>将这些符号引用转换为调用方法的直接引用</strong>。（多态也是通过动态链接实现的）</p>
</li>
<li><p>类被加载之后，Class文件中的常量池会被复制一份到方法区，成为“运行时常量池”</p>
<p><img src="/2021/04/19/JVM/image-20210422213416813.png" alt="image-20210422213416813"></p>
</li>
<li><p>为什么需要常量池呢?      常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
</li>
</ul>
<h4 id="8、方法的调用：解析与分派"><a href="#8、方法的调用：解析与分派" class="headerlink" title="8、方法的调用：解析与分派"></a>8、方法的调用：解析与分派</h4><h5 id="1、静态链接与动态链接"><a href="#1、静态链接与动态链接" class="headerlink" title="1、静态链接与动态链接"></a>1、静态链接与动态链接</h5><p>在JVM中，将符号引用转换为调用方法的直接引用与<strong>方法的绑定机制</strong>相关。</p>
<ul>
<li><p>静态链接：<br>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且<strong>运行期保持不变</strong>时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</li>
<li><p>动态链接：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<h5 id="2、方法的绑定机制"><a href="#2、方法的绑定机制" class="headerlink" title="2、方法的绑定机制"></a>2、方法的绑定机制</h5><p>对应的方法的绑定机制为：<strong>早期绑定(Early Binding) 和晚期绑定(Late Binding)</strong> 。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用</strong>的过程，这<strong>仅仅发生一次</strong>。</p>
<ul>
<li><p>早期绑定：</p>
<p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p>晚期绑定：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<h5 id="3、虚方法与非虚方法"><a href="#3、虚方法与非虚方法" class="headerlink" title="3、虚方法与非虚方法"></a>3、虚方法与非虚方法</h5><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p>
<p>Java中<strong>任何一个普通的方法其实都具备虚函数的特征</strong>，它们相当于C++语言中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中<strong>不希望某个方法拥有虛函数的特征</strong>时，则可以<strong>使用关键字final来标记这个方法</strong>。（通过final修饰不能重写）</p>
<p>子类对象的多态性的使用前提（多态 &lt;–&gt; 虚方法）</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p>非虚方法：</p>
<ul>
<li><strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</strong>。这样的方法称为<strong>非虚方法</strong>。</li>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法（因为java没有多继承所以调用父类的方法是非虚方法：super.xxx()可以找到调用的是哪个方法）都是非虚方法</strong>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p><strong>虚拟机中提供了以下几条方法调用指令</strong>：</p>
<ul>
<li>普通调用指令：<ol>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、 私有及父类方法，解析阶段确定唯一方法版本</init></strong></li>
<li>invokevirtual：调用所有虛方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令:<ol start="5">
<li>invokedynamic: 动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p><strong>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本</strong>。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虛方法，其余的(final修饰的除外)称为虚方法</strong>。</p>
<h5 id="4、关于invokedynamic"><a href="#4、关于invokedynamic" class="headerlink" title="4、关于invokedynamic"></a>4、关于invokedynamic</h5><ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<strong>Java为了实现「动态类型语言」支持而做的一种改进</strong>。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式</strong>。</li>
<li>Java7中增加的动态语言类型支持的本质是<strong>对Java虚拟机规范的修改，而不是对Java语言规则的修改</strong>，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是<strong>运行在Java平台的动态语言的编译器</strong>。</li>
<li>动态类型语言和静态类型语言：<ul>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者（编译期）就是静态类型语言，反之（运行期）是动态类型语言。</li>
<li>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息</strong>；<strong>动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。</li>
</ul>
</li>
</ul>
<h5 id="5、方法重写的本质"><a href="#5、方法重写的本质" class="headerlink" title="5、方法重写的本质"></a>5、方法重写的本质</h5><p><strong>Java语言中方法重写的本质</strong>： </p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作<code>C</code>。</li>
<li>如果在类型<code>C</code>中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则<strong>返回这个方法的直接引用</strong>，查找过程结束；如果不通过，则<strong>返回java.lang.illegalAccessError异常</strong>。</li>
<li>否则，<strong>按照继承关系从下往上依次对<code>C</code>的各个父类进行第2步的搜索和验证过程</strong>。</li>
<li>如果始终没有找到合适的方法，则<strong>抛出java.lang.AbstractMethodError异常</strong>。</li>
</ol>
<p><strong>IllegalAccessError介绍</strong>：</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h5 id="6、虚方法表"><a href="#6、虚方法表" class="headerlink" title="6、虚方法表"></a>6、虚方法表</h5><ul>
<li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，<strong>JVM采用在类的方法区建立一个虚方法表(virtual method table) (非虚方法不会出现在表中)来实现。使用索引表来代替查找</strong>。</p>
</li>
<li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li><p>那么虚方法表什么时候被创建?</p>
<p>虚方法表会在类加载的链接阶段（解析Resolve）被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</li>
</ul>
<p>每个类有一个虚方法表，使用某方法时直接在这表里查找该方法在哪个类里了。</p>
<p>没有虚方法表的情况下，需要在当前类查找，找不到再去父类查找。</p>
<p><img src="/2021/04/19/JVM/image-20210422225120851.png" alt="image-20210422225120851"></p>
<p><img src="/2021/04/19/JVM/image-20210422225328056.png" alt="image-20210422225328056"></p>
<p><img src="/2021/04/19/JVM/image-20210422225533000.png" alt="image-20210422225533000"></p>
<p><img src="/2021/04/19/JVM/image-20210422225747189.png" alt="image-20210422225747189"></p>
<h4 id="9、方法返回地址-Return-Address"><a href="#9、方法返回地址-Return-Address" class="headerlink" title="9、方法返回地址(Return Address)"></a>9、方法返回地址(Return Address)</h4><ul>
<li><strong>存放调用该方法的pc寄存器的值</strong>。</li>
<li>一个方法的结束，有两种方式：<ul>
<li><strong>正常执行完成</strong></li>
<li><strong>出现未处理的异常，非正常退出</strong></li>
</ul>
</li>
<li>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。方法<strong>正常退出</strong>时，<strong>调用者的pc计数器的值作为返回地址</strong>，即<strong>调用该方法的指令的下一条指令的地址</strong>。而通过<strong>异常退出</strong>的，返回地址是要<strong>通过异常表来确定，栈帧中一般不会保存这部分信息</strong>。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令(return) ，会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含<code>ireturn</code> (当返回值是boolean、 byte、char、short和int类型时使用)、<code>lreturn</code>、 <code>freturn</code>、<code>dreturn</code>以及<code>areturn</code>，另外还有一个<code>return</code>指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
</li>
<li><p>在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p><strong>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表</strong>，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="/2021/04/19/JVM/image-20210423004042185.png" alt="image-20210423004042185"></p>
</li>
</ol>
<p>本质上，<strong>方法的退出就是当前栈帧出栈</strong>的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h4 id="10、一些附加信息"><a href="#10、一些附加信息" class="headerlink" title="10、一些附加信息"></a>10、一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对<strong>程序调试提供支持的信息</strong>。</p>
<h4 id="11、栈的相关面试题"><a href="#11、栈的相关面试题" class="headerlink" title="11、栈的相关面试题"></a>11、栈的相关面试题</h4><ul>
<li><p>举例栈溢出的情况? (StackOverflowError)</p>
<ul>
<li>通过-Xss设置栈的大小OOM</li>
</ul>
</li>
<li><p>调整栈大小，就能保证不出现溢出吗?</p>
<ul>
<li>不能</li>
</ul>
</li>
<li><p>分配的栈内存越大越好吗?</p>
<ul>
<li>不是!</li>
</ul>
</li>
<li><p>垃圾回收是否会涉及到虚拟机栈?</p>
<ul>
<li>不会的!</li>
</ul>
</li>
<li><p>方法中定义的局部变量是否线程安全?</p>
<ul>
<li>具体问题具体分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 7:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="12、关于运行时数据区的五大部分的OOM与GC问题"><a href="#12、关于运行时数据区的五大部分的OOM与GC问题" class="headerlink" title="12、关于运行时数据区的五大部分的OOM与GC问题"></a>12、关于运行时数据区的五大部分的OOM与GC问题</h4><table>
<thead>
<tr>
<th>运行时数据区</th>
<th>GC</th>
<th>OOM</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器（PC寄存器）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>方法区</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<hr>
<h3 id="6、本地方法接口"><a href="#6、本地方法接口" class="headerlink" title="6、本地方法接口"></a>6、本地方法接口</h3><p><img src="/2021/04/19/JVM/image-20210423090739894.png" alt="image-20210423090739894"></p>
<h4 id="1、什么是本地方法"><a href="#1、什么是本地方法" class="headerlink" title="1、什么是本地方法?"></a>1、什么是本地方法?</h4><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>在定义一个native method时， 并不提供实现体(有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是<strong>融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</strong>。</p>
<p><strong>标识符native可以与所以其它的java标识符连用，但是<code>abstract</code>除外</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native 与 public、void</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 static</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// native 与 private、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 默认</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、为什么要使用Native-Method"><a href="#2、为什么要使用Native-Method" class="headerlink" title="2、为什么要使用Native Method?"></a>2、为什么要使用Native Method?</h4><p>Java使用起来非常方便，然而有些层次的任务用<strong>Java实现起来不容易</strong>，或者我们<strong>对程序的效率很在意</strong>时，问题就来了。</p>
<ul>
<li>与Java环境外交互：<br>有时<strong>Java应用需要与Java外面的环境交互</strong>，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li>与操作系统交互:<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过<strong>使用本地方法我们得以用Java实现了jre的与底层系统的交互</strong>，<strong>甚至JVM的一些部分就是用c写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li>Sun’s Java<br><strong>Sun的解释器是用C实现的</strong>，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API。 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。</li>
</ul>
<h4 id="3、现状"><a href="#3、现状" class="headerlink" title="3、现状"></a>3、现状</h4><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<hr>
<h3 id="7、本地方法栈-Native-Method-Stack"><a href="#7、本地方法栈-Native-Method-Stack" class="headerlink" title="7、本地方法栈(Native Method Stack)"></a>7、本地方法栈(Native Method Stack)</h3><ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</p>
</li>
<li><p>本地方法栈，也是<strong>线程私有</strong>的。</p>
</li>
<li><p>允许被实现成<strong>固定或者是可动态扩展的内存大小</strong>。(在内存溢出方面是相同的)</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虛拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的。</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p><img src="/2021/04/19/JVM/image-20210423094103986.png" alt="image-20210423094103986"></p>
</li>
<li><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。<strong>它和虚拟机拥有同样的权限</strong>。</p>
<ul>
<li>本地方法可以通过<code>本地方法接口</code>来<strong>访问虛拟机内部的运行时数据区</strong>。</li>
<li>它甚至可以<strong>直接使用本地处理器中的寄存器</strong></li>
<li><strong>直接从本地内存的堆中分配任意数量的内存</strong>。</li>
</ul>
</li>
<li><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。(这里存在本地方法栈只是对于HotSpot JVM而言)</p>
</li>
<li><p>在HotSpot JVM中，直接将<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
</li>
</ul>
<hr>
<h3 id="8、堆（Heap）"><a href="#8、堆（Heap）" class="headerlink" title="8、堆（Heap）"></a>8、堆（Heap）</h3><h4 id="1、堆的核心概述"><a href="#1、堆的核心概述" class="headerlink" title="1、堆的核心概述"></a>1、堆的核心概述</h4><ul>
<li><p><strong>一个JVM实例只存在一个堆内存，堆也是Java<code>内存管理</code>的核心区域</strong>。</p>
</li>
<li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是<strong>JVM管理的最大一块内存空间</strong>。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间</strong>中，但<strong>在逻辑上</strong>它应该被视为<strong>连续</strong>的。</p>
<p>这里涉及到对象实例在堆内存中的存储方式，<strong>物理内存连续的采用指针碰撞</strong>，<strong>不连续的采用动态链表</strong></p>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Al location Buffer, <strong>TLAB</strong>) 。</p>
</li>
<li><p>《Java虛拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p>
<ul>
<li>The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li>
<li>我要说的是：“<strong>几乎</strong>”所有的对象实例都在这里分配内存。——从实际使用角度看的。</li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用</strong>，<strong>这个引用指向对象或者数组在堆中的位置</strong>。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
</li>
<li><p><strong>堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210423155400525.png" alt="image-20210423155400525"></p>
</li>
<li><p>内存细分：</p>
<p>现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为：</p>
<ul>
<li><strong>Java 7</strong>及之前堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>永久区</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分 为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/Tenure</li>
<li>Permanent Space    永久区    Perm</li>
</ul>
</li>
<li><strong>Java 8</strong>及之后堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>元空间</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/ Tenure</li>
<li>Meta Space     元空间    Meta</li>
</ul>
</li>
</ul>
<p>约定：</p>
<ul>
<li>新生区 &lt;=&gt; 新生代 &lt;=&gt; 年轻代</li>
<li>养老区 &lt;=&gt; 老年区 &lt;=&gt; 老年代</li>
<li>永久区 &lt;=&gt; 永久代</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
<p>堆空间的内部结构：</p>
<p><img src="/2021/04/19/JVM/image-20210423160441505.png" alt="image-20210423160441505"></p>
</li>
</ul>
<h4 id="2、设置堆内存大小与OOM"><a href="#2、设置堆内存大小与OOM" class="headerlink" title="2、设置堆内存大小与OOM"></a>2、设置堆内存大小与OOM</h4><ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”<code>- Xmx</code>“和”``-Xms`”来进行设置。<ul>
<li><strong>“<code>-Xms</code>“用于表示堆区（年轻代+老年代）的<code>起始内存</code>，等价于-XX: InitialHeapSize</strong><ul>
<li>-X是JVM的运行参数</li>
<li>ms是memory start</li>
</ul>
</li>
<li><strong>“<code>-Xmx</code>”则用于表示堆区（年轻代+老年代）的<code>最大内存</code>，等价于-XX :MaxHeapSize</strong></li>
</ul>
</li>
<li>查看设置的参数：<ol>
<li>jps   /  jstat -gc 进程id</li>
<li>-XX:+PrintGCDetails</li>
</ol>
</li>
<li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</li>
<li>开发中建议将初始堆内存和最大的堆内存设置成相同的值。即将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能，避免系统压力</strong>。</li>
<li>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 手动设置600M之后：575M</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210423165450302.png" alt="image-20210423165450302"></p>
<p>结论：<strong>新生代的存储总量为一个伊甸园区加一个幸存者区</strong>(1或2，不能并存)，所以虽然设置了600M，但是实际上为575M。</p>
<p><strong>关于异常（Exception）与错误（Error）</strong>：</p>
<p>Java 语言规范将派生于 Error 类或 RuntimeException 类的所有异常称为非检查型（unchecked）异常，所有其他的异常称为检查型（checked）异常</p>
<h4 id="3、年轻代与老年代"><a href="#3、年轻代与老年代" class="headerlink" title="3、年轻代与老年代"></a>3、年轻代与老年代</h4><ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以划分为<strong>年轻代</strong>(YoungGen)和<strong>老年代</strong>(OldGen)</p>
</li>
<li><p>其中年轻代又可以划分为<strong>Eden空间</strong>、 <strong>Survivor0空间</strong>和<strong>Survivor1空间</strong>(有时也叫做<strong>from区</strong>、<strong>to区</strong>)</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E8%8A%82.jpg" alt="第08章_堆空间细节"></p>
</li>
<li><p>相关的参数设置与默认值（在开发中一般不会改变）</p>
<ul>
<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比。<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改- XX: NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
</li>
<li>-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例。默认值是8<ul>
<li>在HotSpot中， Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。</li>
<li>当然开发人员可以通过选项“-XX:SurvivorRatio””调整这个空间比例。比如-XX: SurvivorRatio=8</li>
<li>但在实际测试当中发现其实JVM分配Eden空间和两个Survivor空间的时候比例为6:1:1，即默认值为6而不是8，但是java官方表示的默认值就是8。如果要将比例修改为8:1:1，需要设置：<ul>
<li>-XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）（但发现没用，还是6:1:1）</li>
<li>-XX: SurvivorRatio=8，手动设置SurvivorRatio为8。（这还算什么默认值。。。）</li>
</ul>
</li>
</ul>
</li>
<li>-Xmn：设置新生代的空间的大小。（一般不设置）<ul>
<li>但一般新生代与老年代的空间分配是-XX:NewRatio设置的，默认为2。</li>
<li>当设置了-Xmn的时候，就与-XX:NewRatio冲突了</li>
<li>这时候JVM使用的是-Xmn设置的值（JDK8下测试）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>**几乎所有</code>的Java对象都是在Eden区被new出来的**。</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM公司的专门研究表明，新生代中80号的对象都是“朝生夕死”的。</li>
</ul>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小。</p>
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423173418189.png" alt="image-20210423173418189"></p>
</li>
</ul>
<h4 id="4、图解大小分配过程"><a href="#4、图解大小分配过程" class="headerlink" title="4、图解大小分配过程"></a>4、图解大小分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中停生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li><p>当<strong>伊甸园的空间填满</strong>时，程序又需要创建对象，JVM的垃圾回收器**(Minor GC)将对伊甸园区进行垃圾回收**，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区（to区）。</p>
</li>
<li><p>如果再次触发垃圾回收，此时JVM的垃圾回收器(Minor GC)对伊甸园区进行垃圾回收（<strong>主动：伊甸园区满即触发</strong>），会放到幸存者1区（to区）。以及同时上次幸存下来的放到幸存者0区（from区）的，如果没有回收，也会放到幸存者1区（to区）。（被动：就算幸存者1区（to区）满了也不触发Minor GC垃圾回收器）</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li><p>啥时候能去养老区呢?可以设置次数。<strong>默认是<code>15</code>次</strong>。</p>
<p>可以设置参数: -XX:MaxTenuringThreshold=<N>进行设置。</N></p>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC， 进行养老区的内存清理。</p>
</li>
<li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常：<br> java. lang.OutOfMemoryError：Java heap space</p>
<p><img src="/2021/04/19/JVM/image-20210423181733858.png" alt="image-20210423181733858"></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to。</li>
<li>关于垃圾回收:频繁在新生区收集，<strong>很少在养老区收集</strong>，<strong>几乎不在永久区/元空间收集</strong>。</li>
</ul>
<p>对象分配流程图（含特殊情况）：</p>
<p><img src="/2021/04/19/JVM/image-20210423191247043.png" alt="image-20210423191247043"></p>
<p>VisualVM状态图分析：</p>
<p><img src="/2021/04/19/JVM/image-20210423192127797.png" alt="image-20210423192127797"></p>
<p>常用的调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Eclipse : Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h4 id="5、minor-GC、Major-GC、Full-GC"><a href="#5、minor-GC、Major-GC、Full-GC" class="headerlink" title="5、minor GC、Major GC、Full GC"></a>5、minor GC、Major GC、Full GC</h4><h5 id="1、GC的分类"><a href="#1、GC的分类" class="headerlink" title="1、GC的分类"></a>1、GC的分类</h5><ul>
<li>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</li>
<li>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集(Minor GC / Young GC)：只是新生代（Eden/S0、S1）的垃圾收集</li>
<li>老年代收集(MajorGC/0ldGC)：只是老年代的垃圾收集。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><strong>注意，很多时候Major GC会和Fu1l GC混淆使用，需要具体分辨是老年代回收还是整堆回收</strong>。</li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Fu11 GC)：收集整个java堆和方法区的垃圾收集。</li>
</ul>
</li>
</ul>
<h5 id="2、最简单的分代式GC策略的触发条件"><a href="#2、最简单的分代式GC策略的触发条件" class="headerlink" title="2、最简单的分代式GC策略的触发条件"></a>2、最简单的分代式GC策略的触发条件</h5><ul>
<li><p>年轻代GC(Minor GC )触发机制:</p>
<ul>
<li>当年轻代空间不足时， 就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)</li>
<li>因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423195836487.png" alt="image-20210423195836487"></p>
</li>
<li><p>老年代GC (Major GC/Fu11 GC)触发机制:</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Fu11 GC”发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Para11el Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>MajorGC的速度一般会比MinorGC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</li>
<li><p>Fu1l GC触发机制：(后面细讲)</p>
<ul>
<li>触发Full GC执行的情况有如下五种：<ol>
<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0 (From Space)区向survivor space1 (To Space)区复制时，对象大小大于To Space可用 内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
</li>
<li>说明: <strong>full gc是开发或调优中尽量要避免的。这样暂时时间会短一些</strong>。</li>
</ul>
</li>
</ul>
<h4 id="6、堆空间分代思想"><a href="#6、堆空间分代思想" class="headerlink" title="6、堆空间分代思想"></a>6、堆空间分代思想</h4><p>为什么需要把java堆分代?不分代就不能正常工作了吗?</p>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor (又称为from/to， s0/s1)构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。</p>
<p>而很多对象都是<strong>朝生夕死</strong>的，如果分代的话，把新创建的对象放到某一地方， 当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<h4 id="7、内存分配策略-或对象提升-Promotion-规则"><a href="#7、内存分配策略-或对象提升-Promotion-规则" class="headerlink" title="7、内存分配策略(或对象提升(Promotion)规则)"></a>7、内存分配策略(或对象提升(Promotion)规则)</h4><p>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对 象年龄设为1。对象在Survivor区中每熬过一次MinorGC ，年龄就增加1 岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、 每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项<code>-XX: MaxTenuringThreshold</code>来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li><strong>大对象直接分配到老年代</strong><ul>
<li>尽量避免程序中出现过多的大对象（特别是朝生夕死的大对象），防止过多的STW</li>
</ul>
</li>
<li><strong>长期存活(15岁)的对象分配到老年代</strong></li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX: HandlePromotionFailure</code> </li>
</ul>
</li>
</ul>
<h4 id="8、为对象分配内存：TLAB"><a href="#8、为对象分配内存：TLAB" class="headerlink" title="8、为对象分配内存：TLAB"></a>8、为对象分配内存：TLAB</h4><h5 id="1、为什么有TLAB-Thread-Local-Allocation-Buffer"><a href="#1、为什么有TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="1、为什么有TLAB ( Thread Local Allocation Buffer ) ?"></a>1、为什么有TLAB ( Thread Local Allocation Buffer ) ?</h5><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此<strong>在并发环境下从堆区中划分内存空间是线程不安全</strong>的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h5 id="2、什么是TLAB？"><a href="#2、什么是TLAB？" class="headerlink" title="2、什么是TLAB？"></a>2、什么是TLAB？</h5><ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM<strong>为每个线程分配了一个私有缓存区域</strong>，它<strong>包含在Eden空间</strong>内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_TLAB.jpg" alt="第08章_TLAB"></p>
<h5 id="3、TLAB相关说明"><a href="#3、TLAB相关说明" class="headerlink" title="3、TLAB相关说明"></a>3、TLAB相关说明</h5><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li>
<li>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启TLAB空间。<strong>默认为开启</strong>。</li>
<li>默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项“<code>-XX:TLABWasteTargetPercent</code>”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而<strong>直接在Eden空间中分配内存</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg" alt="第08章_对象分配过程"></p>
<h4 id="9、小结堆空间的常用的JVM参数设置"><a href="#9、小结堆空间的常用的JVM参数设置" class="headerlink" title="9、小结堆空间的常用的JVM参数设置"></a>9、小结堆空间的常用的JVM参数设置</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官网说明</a>：</p>
<ul>
<li>-XX: +PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX: +PrintFlagsFinal：查看所有的参数的最终值(可能会存在修改，不再是初始值)</li>
<li>-Xms：初始堆空间内存 (默认为物理内存的1/64)</li>
<li>-Xmx：最大堆空间内存(默认为物理内存的1/4)</li>
<li>-Xmn：设置新生代的大小。(初始值及最大值)</li>
<li>-XX:NewRatio: 配置新生代与老年代在堆结构的占比</li>
<li>-XX: SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX: MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX: +PrintGCDetails：输出详细的GC处理日志<ul>
<li>打印gc简要信息：</li>
<li>-XX: +PrintGC</li>
<li>-verbose: gc </li>
</ul>
</li>
<li>XX: HandlePromotionFailure：是否设置空间分配担保</li>
</ul>
<p>在发生MinorGC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX: HandlePromotionFailure设置值是否允许担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会<strong>继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Full GC。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24（JDK7）之后，HandlePromotionFailure参数不会再影响到虛拟机的空间分配担保策略，观察0penJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小就会进行Minor GC</strong>， 否则将进行Full GC。</p>
<h4 id="10、堆是分配对象的唯一选择吗？"><a href="#10、堆是分配对象的唯一选择吗？" class="headerlink" title="10、堆是分配对象的唯一选择吗？"></a>10、堆是分配对象的唯一选择吗？</h4><h5 id="1、堆是分配对象的唯一选择吗？"><a href="#1、堆是分配对象的唯一选择吗？" class="headerlink" title="1、堆是分配对象的唯一选择吗？"></a>1、堆是分配对象的唯一选择吗？</h5><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着<strong>JIT编译期的发展</strong>与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</p>
<p>此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<h5 id="2、逃逸分析概述"><a href="#2、逃逸分析概述" class="headerlink" title="2、逃逸分析概述"></a>2、逃逸分析概述</h5><h6 id="1、什么是逃逸分析？"><a href="#1、什么是逃逸分析？" class="headerlink" title="1、什么是逃逸分析？"></a>1、什么是逃逸分析？</h6><ul>
<li><p>如何将堆上的对象分配到栈，需要使用<strong>逃逸分析手段</strong>。</p>
</li>
<li><p>这是一种可以有效减少Java程序中<strong>同步负载</strong>和<strong>内存堆分配压力</strong>的<strong>跨函数全局数据流分析算法</strong>。</p>
</li>
<li><p>通过逃逸分析，Java HotSpot编译器能够分析出<strong>一个新的对象的引用的使用范围</strong>从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p>当<strong>一个对象在方法中被定义</strong>后，<strong>对象只在方法内部使用</strong>，则认为<strong>没有发生逃逸</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">//use v</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p>
</blockquote>
</li>
<li><p>当<strong>一个对象在方法中被定义</strong>后，它<strong>被外部方法所引用</strong>，则认为<strong>发生逃逸</strong>。例如作为<strong>调用参数</strong>传递到其他地方中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer() ;</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append (s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发生了逃逸的对象StringBuffer，作为返回值被返回回去了，在方法外可以被调用</p>
</blockquote>
<p>改进代码，让StringBuffer sb逃不出去：（转换为String类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1) ;</span><br><span class="line">    sb.append(s2) ;</span><br><span class="line">    <span class="keyword">return</span> sb.toString() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="2、逃逸分析的几种情况："><a href="#2、逃逸分析的几种情况：" class="headerlink" title="2、逃逸分析的几种情况："></a>2、逃逸分析的几种情况：</h6><p>如何快速的判断是否发生了逃逸分析，大家就看**<code>new的对象实体</code>是否有可能在方法外被调用**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">    //思考：如果当前的obj引用声明为static的？</span></span><br><span class="line"><span class="comment">    		仍然会发生逃逸。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、逃逸分析相关的参数设置："><a href="#3、逃逸分析相关的参数设置：" class="headerlink" title="3、逃逸分析相关的参数设置："></a>3、逃逸分析相关的参数设置：</h6><ul>
<li>在JDK 6u23（JDK7）版本之后，<strong>HotSpot中默认就已经开启了逃逸分析</strong>。</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“<code>-XX: +DoEscapeAnalysis</code>“显式开启逃逸分析</li>
<li>通过选项“<code>-XX: +PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<h6 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论:"></a>4、结论:</h6><p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
<h6 id="5、逃逸分析的代码优化"><a href="#5、逃逸分析的代码优化" class="headerlink" title="5、逃逸分析的代码优化"></a>5、逃逸分析的代码优化</h6><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>。<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
<li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么<strong>对于这个对象的操作可以不考虑同步</strong>。</li>
<li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分( 或全部)可以不存储在内存，而是<strong>存储在CPU寄存器</strong>中。</li>
</ol>
<h6 id="6、代码优化之栈上分配"><a href="#6、代码优化之栈上分配" class="headerlink" title="6、代码优化之栈上分配"></a>6、代码优化之栈上分配</h6><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果<strong>一个对象并没有逃逸出方法的话，就可能被优化成栈上分配</strong>。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的栈上分配的场景<ul>
<li>在逃逸分析中，已经说明了。分别是<strong>给成员变量赋值</strong>、<strong>方法返回值</strong>、<strong>实例引用传递</strong>。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx256 -Xms256 -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 先关闭逃逸分析：-XX:-DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 在打开逃逸分析：-XX:+DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭逃逸分析的时候：代码执行时间：55ms，发生了GC</p>
<p>在开启逃逸分析的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<p>逃逸分析优化了对非逃逸对象的内存分配，实现了栈上分配。加快了程序的执行效率，并消除了GC，没有了STW，用户线程不会被阻碍。</p>
<h6 id="7、代码优化之同步省略（锁消除）"><a href="#7、代码优化之同步省略（锁消除）" class="headerlink" title="7、代码优化之同步省略（锁消除）"></a>7、代码优化之同步省略（锁消除）</h6><ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的<br>同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫<strong>同步省略</strong>，也叫<strong>锁消除</strong>。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。（在字节码文件下依旧存在synchronized的身影，即：字节码当中的monitorenter与monitorexit中间包裹的部分，只是在运行阶段进行了代码优化）</p>
<p>优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object() ;</span><br><span class="line">    System.out.println(hollis) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8、代码优化之标量替换"><a href="#8、代码优化之标量替换" class="headerlink" title="8、代码优化之标量替换"></a>8、代码优化之标量替换</h6><p>**标量(Scalar)**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现<strong>一个对象不会被外界访问</strong>的话，那么经过JIT优化，就会把这个<strong>对象拆解成若干个其中包含的若干个成员变量来代替</strong>。这个过程就是<strong>标量替换</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 先关闭标量替换：-XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 在打开标量替换：-XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭标量替换的时候：代码执行时间：57ms，发生了GC</p>
<p>在开启标量替换的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<ul>
<li><p>代码优化：（在alloc()方法中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Uesr这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个标量了。</p>
<p>那么标量替换有什么好处呢?</p>
<p>就是可以<strong>大大减少堆内存的占用</strong>。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p><strong>标量替换为栈上分配提供了很好的基础。</strong></p>
</li>
<li><p>另外，在开启<code>-XX:+DoEscapeAnalysis</code>即逃逸分析，同时关闭标量替换的时候为什么还会存在GC？</p>
<p>可以理解为（弹幕，不一定对）：</p>
<ul>
<li>栈上分配是要基于标量替换，即使开启了逃逸分析但是没有开启标量替换，他还是会在堆上分配。</li>
<li>对象未发生逃逸 + 开启标量替换 = 栈上分配 </li>
<li>可以将“栈上分配”理解为1个概念，具体要通过逃逸分析和标量替换两个参数决定</li>
</ul>
</li>
<li><p>标量替换参数设置：</p>
<p>参数<code>-XX: +EliminateAllocations</code>：开启了标量替换(默认打开)，允许将对象打散分配在栈上。</p>
</li>
<li><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。 使用如下参数运行上述代码：（逃逸分析在JDK7之后已经自动添加，这里针对的是服务器端）</p>
<ul>
<li>-server</li>
<li>-Xmx100m</li>
<li>-Xms100m</li>
<li>-XX: +DoEscapeAnalysis</li>
<li>-XX: +PrintGC</li>
<li>-XX: +EliminateAllGcations</li>
</ul>
<p>这里使用参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为<strong>在Server模式下，才可以启用逃逸分析</strong>。（java的JVM默认就是一个Server模式，不用我们手动开启）</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-xx: +PrintGC：将打印GC日志。</li>
<li>参数-XX:+E1 iminateAllocations：开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</li>
</ul>
</li>
</ul>
<h6 id="9、逃逸分析总结"><a href="#9、逃逸分析总结" class="headerlink" title="9、逃逸分析总结"></a>9、逃逸分析总结</h6><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，<strong>intern字符串缓存和静态变量</strong>并不是被转移到元数据区，而是<strong>直接在堆上分配</strong>，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</li>
</ul>
<h4 id="11、堆总结"><a href="#11、堆总结" class="headerlink" title="11、堆总结"></a>11、堆总结</h4><ul>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者Ful1GC。一般的，MinorGC 的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>
<hr>
<h3 id="9、方法区（Method-Area）"><a href="#9、方法区（Method-Area）" class="headerlink" title="9、方法区（Method Area）"></a>9、方法区（Method Area）</h3><h4 id="1、栈、堆、方法区的交互关系"><a href="#1、栈、堆、方法区的交互关系" class="headerlink" title="1、栈、堆、方法区的交互关系"></a>1、栈、堆、方法区的交互关系</h4><p>从线程是否共享的角度来看</p>
<p><img src="/2021/04/19/JVM/image-20210424010349347.png" alt="image-20210424010349347"></p>
<p>从代码看出栈、堆、方法区的交互关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210424010520101.png" alt="image-20210424010520101"></p>
<h4 id="2、方法区的理解"><a href="#2、方法区的理解" class="headerlink" title="2、方法区的理解"></a>2、方法区的理解</h4><h5 id="1、官方文档："><a href="#1、官方文档：" class="headerlink" title="1、官方文档："></a>1、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">官方文档</a>：</h5><p><img src="/2021/04/19/JVM/image-20210424010921229.png" alt="image-20210424010921229"></p>
<h5 id="2、方法区的位置"><a href="#2、方法区的位置" class="headerlink" title="2、方法区的位置"></a>2、方法区的位置</h5><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫做**Non-Heap (非堆)**，目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<h5 id="3、方法区和基本理解"><a href="#3、方法区和基本理解" class="headerlink" title="3、方法区和基本理解"></a>3、方法区和基本理解</h5><ul>
<li>方法区(Method Area) 与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</li>
<li>方法区在<strong>JVM启动的时候被创建</strong>，并且它的实际的<strong>物理内存空间</strong>中和Java堆区一样都<strong>可以是不连续</strong>的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li><strong>方法区的大小决定了系统可以保存多少个类</strong>，如果系统定义了太多的类，导致方法区溢出，虛拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:<strong>PermGen space</strong> （JDK7）或者 java.lang.OutOfMemoryError: <strong>Metaspace</strong>（JDK8）<ul>
<li><strong>加载大量的第三方的jar包；Tomcat 部署的工程过多(30-50个)，大量动态的生成反射类</strong></li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h5 id="4、Hotspot中方法区的演进"><a href="#4、Hotspot中方法区的演进" class="headerlink" title="4、Hotspot中方法区的演进"></a>4、Hotspot中方法区的演进</h5><ul>
<li><p>在<strong>JDK7及以前</strong>，习惯上把方法区，称为<strong>永久代</strong>。<strong>JDK8</strong>开始，使用<strong>元空间</strong>取代了永久代。</p>
<blockquote>
<p>In JDK8,classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
</li>
<li><p>本质上，<strong>方法区和永久代并不等价</strong>。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。 例如: <strong>BEA JRockit/ IBM J9中不存在永久代</strong>的概念。</p>
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM (超过-XX : MaxPermSize上限)</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
</li>
<li><p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间( Metaspace)来代替。</p>
<p><img src="/2021/04/19/JVM/image-20210424014427319.png" alt="image-20210424014427319"></p>
</li>
<li><p>元空间的本质和永久代类似，都是<strong>对JVM规范中方法区的实现</strong>。不过元空间与永久代最大的区别在于：<strong>元空间不在虛拟机设置的内存中，而是使用本地内存</strong>。</p>
</li>
<li><p>永久代、元空间二者并不只是名字变了，内部结构也调整了。</p>
<ul>
<li>根据《Java虚拟机规范》的规定，如果<strong>方法区</strong>无法满足新的内存分配需求时，将抛出<strong>OOM异常</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3、设置方法区大小与OOM"><a href="#3、设置方法区大小与OOM" class="headerlink" title="3、设置方法区大小与OOM"></a>3、设置方法区大小与OOM</h4><ul>
<li><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
</li>
<li><p>JDK7及以前：</p>
<ul>
<li><p>通过<code>-XX:PermSize</code>来设置永久代<strong>初始</strong>分配空间。<strong>默认值是20.75M</strong></p>
</li>
<li><p><code>-XX:MaxPermSize</code>来设定永久代<strong>最大</strong>可分配空间。<strong>32位机器默认是64M</strong>，<strong>64位机器模式是82M</strong></p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError : PermGen space</p>
<p><img src="/2021/04/19/JVM/image-20210424014940690.png" alt="image-20210424014940690"></p>
</li>
</ul>
</li>
<li><p>jdk8及以后:</p>
<ul>
<li><p>元数据区大小可以使用参数<code>-XX :MetaspaceSize</code>和<code>-XX :MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</p>
</li>
<li><p><strong>默认值依赖于平台</strong>。<strong>windows下，-XX:MetaspaceSize是21M， -XX: MaxMetaspaceSize的值是-1， 即没有限制</strong>。</p>
</li>
<li><p>参数设置方法：</p>
<ul>
<li>jdk7及以前：-XX:PermSize=100m -XX:MaxPermSize=100m</li>
<li>jdk8及以后：-XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m(这个一般不会改)</li>
</ul>
</li>
<li><p>与永久代不同，<strong>如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存</strong>。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace</p>
</li>
<li><p><code>-XX : MetaspaceSize</code>：<br><strong>设置初始的元空间大小</strong>。对于一个<strong>64位的服务器端JVM</strong>来说，其默认的-XX :MetaspaceSize值为<strong>21MB</strong>。这就是<strong>初始的高水位线</strong>，一 旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活)，然后这个高水位线将会重置。<strong>新的高水位线的值取决于GC后释放了多少元空间</strong>。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p><img src="/2021/04/19/JVM/image-20210424015216603.png" alt="image-20210424015216603"></p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议<strong>将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4、如何解决OOM"><a href="#4、如何解决OOM" class="headerlink" title="4、如何解决OOM"></a>4、如何解决OOM</h4><ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是<strong>确认内存中的对象是否是必要</strong>的，也就是要先分清楚到底是<strong>出现了内存泄漏(MemoryLeak)**还是</strong>内存溢出(Memory Overflow)<strong>。</strong>内存泄漏堆积会导致内存溢出<strong>，所以</strong>判断内存溢出第一步是查看内存是否泄漏**。</li>
<li>如果是<strong>内存泄漏</strong>，可进一步通过工具<strong>查看泄漏对象到GC Roots的引用链</strong>。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当<strong>检查虚拟机的堆参数</strong>(-Xmx与-Xms) ，<strong>与机器物理内存对比看是否还可以调大</strong>，从<strong>代码</strong>上检查<strong>是否存在某些对象生命周期过长、持有状态时间过长</strong>的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h4 id="5、方法区的内部结构"><a href="#5、方法区的内部结构" class="headerlink" title="5、方法区的内部结构"></a>5、方法区的内部结构</h4><p><img src="/2021/04/19/JVM/image-20210424020826940.png" alt="image-20210424020826940"></p>
<h5 id="1、方法区存储的内容"><a href="#1、方法区存储的内容" class="headerlink" title="1、方法区存储的内容"></a>1、方法区存储的内容</h5><p>《深入理解Java虚拟机》书中对方法区(Method Area)存储内容描述如下：</p>
<p>它用于存储已<strong>被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/2021/04/19/JVM/image-20210424020942369.png" alt="image-20210424020942369"></p>
<h5 id="2、方法区和内部结构"><a href="#2、方法区和内部结构" class="headerlink" title="2、方法区和内部结构"></a>2、方法区和内部结构</h5><h6 id="1、类型信息"><a href="#1、类型信息" class="headerlink" title="1、类型信息"></a>1、类型信息</h6><p>对每个加载的类型( 类calss、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的<strong>完整有效名称</strong>(全名=包名.类名)</li>
<li>这个类型<strong>直接父类的完整有效名</strong>(对于interface或是java. lang.object， 都没有父类)</li>
<li>这个类型的<strong>修饰符</strong>(public, abstract, final的某个子集)</li>
<li>这个类型<strong>直接接口的一个有序列表</strong></li>
</ol>
<h6 id="2、域（Field）信息"><a href="#2、域（Field）信息" class="headerlink" title="2、域（Field）信息"></a>2、域（Field）信息</h6><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符：public，private，protected，static，final，volatile，transient的某个子集</li>
</ul>
<h6 id="3、方法（Method）信息"><a href="#3、方法（Method）信息" class="headerlink" title="3、方法（Method）信息"></a>3、方法（Method）信息</h6><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的一个子集)</li>
<li>方法的字节码 (bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</li>
<li>异常表(abstract和native方法除外)<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h6 id="4、non-final的类变量"><a href="#4、non-final的类变量" class="headerlink" title="4、non-final的类变量"></a>4、non-final的类变量</h6><ul>
<li>静态变量和类关联在一起，<strong>随着类的加载而加载</strong>，它们成为类数据在逻辑上的一部分。</li>
<li><strong>类变量被类的所有实例共享，即使没有类实例时你也可以访问它</strong>。</li>
<li><clinit> javac编译器自动搜集字节码中的类变量的赋值动作和静态代码块组成的语句</clinit></li>
</ul>
<h6 id="5、全局常量：static-final"><a href="#5、全局常量：static-final" class="headerlink" title="5、全局常量：static final"></a>5、全局常量：static final</h6><p><strong>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424024056293.png" alt="image-20210424024056293"></p>
<h5 id="3、运行时常量池-VS-常量池"><a href="#3、运行时常量池-VS-常量池" class="headerlink" title="3、运行时常量池 VS 常量池"></a>3、运行时常量池 VS 常量池</h5><p><img src="/2021/04/19/JVM/image-20210424024352733.png" alt="image-20210424024352733"></p>
<ul>
<li><p><strong>方法区</strong>，内部包含了<strong>运行时常量池</strong>。</p>
</li>
<li><p><strong>字节码文件</strong>，内部包含了<strong>常量池</strong>。</p>
</li>
<li><p>方法区的运行时常量池就是class字节码文件中的常量池经过类加载器进行加载之后存放进内存之后得到。</p>
<p>但由于方法区的运行时常量池是具备动态性，所以可能比字节码文件里的常量池要大。</p>
</li>
<li><p>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</p>
</li>
<li><p>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">官网描述如下</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210424030341079.png" alt="image-20210424030341079"></p>
</li>
<li><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是<strong>常量池表(Constant Pool Table)</strong> ，**包括各种字面量和对类型、域和方法的<code>符号引用</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210424030544494.png" alt="image-20210424030544494"></p>
</li>
</ul>
<h5 id="4、为什么需要常量池？"><a href="#4、为什么需要常量池？" class="headerlink" title="4、为什么需要常量池？"></a>4、为什么需要常量池？</h5><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，<strong>这个字节码包含了指向常量池的<code>引用</code>**。在</strong>动态链接的时候会用到运行时常量池**。</p>
<p>比如如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHel1o</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object obj = new Object();经过编译之后会生成如下字节码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:	new #2				&#x2F;&#x2F; Class java&#x2F; lang&#x2F; object</span><br><span class="line">1:	dup</span><br><span class="line">2:	invokespecial #3	&#x2F;&#x2F; Method java&#x2F; lang&#x2F;object &quot;&lt;init&gt;&quot;( ) V</span><br></pre></td></tr></table></figure>

<p>虽然编译过后的class文件只有194字节，但是里面却使用了String、System、 PrintStream及object等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多!这里就需要常量池了!</p>
<h5 id="5、常量池中的内容"><a href="#5、常量池中的内容" class="headerlink" title="5、常量池中的内容"></a>5、常量池中的内容</h5><p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<h5 id="6、常量池小结"><a href="#6、常量池小结" class="headerlink" title="6、常量池小结"></a>6、常量池小结</h5><p><strong>常量池</strong>，可以看做是<strong>一张表</strong>，虚拟机指令根据这张常量表<strong>找到要执行的类名、方法名、参数类型、字面量等类型</strong>。</p>
<h5 id="7、运行时常量池"><a href="#7、运行时常量池" class="headerlink" title="7、运行时常量池"></a>7、运行时常量池</h5><ul>
<li><strong>运行时常量池</strong>( Runtime Constant Pool) 是<strong>方法区的一部分</strong>。</li>
<li><strong>常量池表</strong>( Constant Pool Table) 是<strong>Class文件的一部分</strong>，<strong>用于存放<code>编译期</code>生成的<code>各种字面量与符号引用</code>**，</strong>这部分内容将在<code>类加载后</code>存放到方法区的运行时常量池中**。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过**<code>索引访问</code>**的。</li>
<li>运行时常量池中包含多种不同的常量，<strong>包括编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong>。此时不再是常量池中的符号地址了，这里换为<code>真实地址</code>。<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：**<code>具备动态性</code>**。<ul>
<li>String. intern( )</li>
</ul>
</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表(symboltable)，但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</li>
</ul>
<h4 id="6、方法区使用举例"><a href="#6、方法区使用举例" class="headerlink" title="6、方法区使用举例"></a>6、方法区使用举例</h4><p><img src="/2021/04/19/JVM/image-20210424165338137.png" alt="image-20210424165338137"></p>
<p><img src="/2021/04/19/JVM/image-20210424165401780.png"></p>
<p><img src="/2021/04/19/JVM/image-20210424165459908.png" alt="image-20210424165459908"></p>
<h4 id="7、方法区的演进细节"><a href="#7、方法区的演进细节" class="headerlink" title="7、方法区的演进细节"></a>7、方法区的演进细节</h4><h5 id="1、方法区的演进"><a href="#1、方法区的演进" class="headerlink" title="1、方法区的演进"></a>1、方法区的演进</h5><p>首先明确：<strong>只有HotSpot才有永久代</strong>。</p>
<p>BEA JRockit、 IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jdk1.6及之前</td>
<td>有永久代(permanent generation)，静态变量存放在永久代上</td>
</tr>
<tr>
<td>jdk1.7</td>
<td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>jdk1.8及之后</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</td>
</tr>
</tbody></table>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82-hotspot.jpg" alt="第08章_方法区的演进细节-hotspot"></p>
<h5 id="2、元空间-VS-永久代"><a href="#2、元空间-VS-永久代" class="headerlink" title="2、元空间 VS 永久代"></a>2、元空间 VS 永久代</h5><p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">永久代为什么要被元空间替换</a>？</p>
<ul>
<li><p>随着Java8 的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间(Metaspace)。</p>
</li>
<li><p>由于类的元数据分配在<strong>本地内存</strong>中，<strong>元空间的最大可分配空间就是系统可用内存空间</strong>。</p>
</li>
<li><p>这项改动是很有必要的，原因有:</p>
<ol>
<li><p><strong>为永久代设置空间大小是很难确定的</strong>。</p>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread ‘dubbo client x.x connector’ java.lang OutOfMemoryError: PermGen space</p>
<p>而元空间和永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li><p>对<strong>永久代进行调优是很困难</strong>的。</p>
</li>
</ol>
</li>
</ul>
<h5 id="3、StringTable的调整"><a href="#3、StringTable的调整" class="headerlink" title="3、StringTable的调整"></a>3、StringTable的调整</h5><p>StringTable为什么要调整?</p>
<p><strong>jdk7</strong>中将StringTable放到了<strong>堆空间</strong>中。因为<strong>永久代的回收效率很低</strong>，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就<strong>导致StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h5 id="4、静态变量的位置"><a href="#4、静态变量的位置" class="headerlink" title="4、静态变量的位置"></a>4、静态变量的位置</h5><p>结论：<strong>静态引用对应的对象实体始终都存在堆空间</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>staticObj（静态变量）</strong>随着Test的类型信息存放在<strong>方法区</strong>，<strong>instanceObj（实例变量）</strong>随着Test的对象实例存放在<strong>Java堆</strong>，<strong>localObject（局部变量）</strong>则是存放在foo( )方法栈帧的<strong>局部变量表</strong>中。</p>
<p>三个对象的数据在<strong>内存中的地址</strong>都落在<strong>Eden区范围内</strong>。</p>
<p>所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<p>接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：</p>
<p><img src="/2021/04/19/JVM/image-20210424172219770.png" alt="image-20210424172219770"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有<strong>Class相关的信息都应该存放在方法区</strong>之中，但方法区该如何实现，《Java虚拟机规范》 并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。</p>
<p>JDK 7及其以后版本的HotSpot虚拟机选择把<strong>静态变量</strong>与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点。</p>
<h4 id="8、方法区的垃圾回收"><a href="#8、方法区的垃圾回收" class="headerlink" title="8、方法区的垃圾回收"></a>8、方法区的垃圾回收</h4><p>有些人认为方法区K如HotSpot虚拟机中的元空间或者永久代)是没有垃圾收集行为的，其实不然。《Java虚拟机规范》 对方法区的约束是非常宽松的，提到过<strong>可以不要求虚拟机在方法区中实现垃圾收集</strong>。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK11时期的ZGC收集器就不支持类卸载)。</p>
<p><strong>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的</strong>。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虛拟机对此区域未完全回收而导致内存泄漏。</p>
<p>**方法区的垃圾收集主要回收两部分内容：<code>常量池中废弃的常量</code>和<code>不再使用的类型</code>**。</p>
<ul>
<li>先来说说方法区内**常量池之中主要存放的两大类常量：<code>字面量</code>和<code>符号引用</code>**。<br>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</li>
<li>而符号引用则属于编译原理方面的概念，包括下面三类常量：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要<strong>常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>判定<strong>一个常量是否“废弃”</strong>还是相对简单，而要判定<strong>一个类型是否属于“不再被使用的类”</strong>的条件就比较苛刻了。需要同时满足下面三个条件：<ol>
<li>该类所有的实例都已经被回收，也就是<strong>Java堆中不存在该类及其任何派生子类的实例</strong>。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong>。</li>
</ol>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“<strong>被允许</strong>”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX: +TraceClass-Loading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h4 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC09%E7%AB%A0_%E5%B0%8F%E7%BB%93.jpg" alt="第09章_小结"></p>
<h4 id="10、常见面试题"><a href="#10、常见面试题" class="headerlink" title="10、常见面试题"></a>10、常见面试题</h4><ul>
<li>百度:<ul>
<li>三面：说一下JVM内存模型吧，有哪些区?分别干什么的?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么?</li>
<li>一面: JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么两个survivor区?</li>
<li>二面: Eden和Survior的比例分配</li>
</ul>
</li>
<li>小米:<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>二面: Java的内存分区</li>
<li>二面:讲讲jvm运行时数据库区</li>
<li>什么时候对象会进入老年代?</li>
</ul>
</li>
<li>京东:<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面: JVM的内存模型，Java8做了什么修改</li>
</ul>
</li>
<li>拼多多:<ul>
<li>JVM 内存分哪几个区，每个区的作用是什么?</li>
</ul>
</li>
<li>美团:<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗?</li>
<li>一面: jvm内存分区，为什么要有新生代和老年代?</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、对象的实例化、内存布局与访问定位"><a href="#10、对象的实例化、内存布局与访问定位" class="headerlink" title="10、对象的实例化、内存布局与访问定位"></a>10、对象的实例化、内存布局与访问定位</h3><h4 id="1、对象的实例化"><a href="#1、对象的实例化" class="headerlink" title="1、对象的实例化"></a>1、对象的实例化</h4><h5 id="1、大厂面试题"><a href="#1、大厂面试题" class="headerlink" title="1、大厂面试题"></a>1、大厂面试题</h5><ul>
<li>美团:<ul>
<li>对象在JVM中是怎么存储的?</li>
<li>对象头信息里面有哪些东西?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>二面: java对象头里有什么</li>
</ul>
</li>
</ul>
<h5 id="2、对象实例化"><a href="#2、对象实例化" class="headerlink" title="2、对象实例化"></a>2、对象实例化</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg" alt="第10章_对象的实例化"></p>
<p>创建对象的字节码解析：</p>
<p><img src="/2021/04/19/JVM/image-20210424193206898.png" alt="image-20210424193206898"></p>
<p>创建步骤：</p>
<ol>
<li><p>判断对象对应的类是否加载、链接、初始化</p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。( 即<strong>判断类元信息是否存在</strong>)。如果没有，那么在<strong>双亲委派模式</strong>下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。</p>
</li>
<li><p>为对象分配内存</p>
<p>首先<strong>计算对象占用空间大小</strong>，接着在堆中划分一块内存给新对象。</p>
<p><strong>如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</strong>。</p>
<ul>
<li><p>如果内存规整，使用<strong>指针碰撞</strong>：</p>
<p>如果内存是规整的，那么虚拟机将采用的是**指针碰撞法(Bump The Pointer)**来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>如果内存不规整，虚拟机需要维护-一个列表，使用<strong>空闲列表分配</strong>：</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是<strong>虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表(Free List)“。</p>
</li>
</ul>
<p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。</p>
</li>
<li><p>处理并发安全问题</p>
<p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p>
<ol>
<li>CAS ( Compare And Swap )失败重试、区域加锁：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲区</strong>，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过<code>-XX: +/-UseTLAB</code>参数来设定（’+’：打开 ‘-‘：关闭）。</li>
</ol>
</li>
<li><p>初始化分配到的空间</p>
<p>内存分配结束，虚拟机将分配到的内存空间都**初始化为零值(不包括对象头)**。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>设置对象的对象头</p>
<p>将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p>执行init方法进行初始化</p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说(由字节码中是否跟随有invokespecial指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样<strong>一个真正可用的对象才算完全创建</strong>出来。</p>
</li>
</ol>
<h4 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_内存布局"></p>
<p>小结：图示</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%9B%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_图示对象的内存布局"></p>
<h4 id="3、对象的访存定位"><a href="#3、对象的访存定位" class="headerlink" title="3、对象的访存定位"></a>3、对象的访存定位</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="第10章_对象访问定位"></p>
<p>图示：JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p>
<p><img src="/2021/04/19/JVM/image-20210424190106896.png" alt="image-20210424190106896"></p>
<h5 id="1、句柄访问"><a href="#1、句柄访问" class="headerlink" title="1、句柄访问"></a>1、句柄访问</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式1：句柄访问"></p>
<p>好处：reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍)时只会改变句柄中实<br>例数据指针即可，reference本身不需要被修改。</p>
<h5 id="2、直接指针（HotSpot采用）"><a href="#2、直接指针（HotSpot采用）" class="headerlink" title="2、直接指针（HotSpot采用）"></a>2、直接指针（HotSpot采用）</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式2：使用直接指针访问"></p>
<hr>
<h3 id="11、直接内存-Direct-Memory"><a href="#11、直接内存-Direct-Memory" class="headerlink" title="11、直接内存(Direct Memory)"></a>11、直接内存(Direct Memory)</h3><h4 id="1、直接内存概述"><a href="#1、直接内存概述" class="headerlink" title="1、直接内存概述"></a>1、直接内存概述</h4><ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li><strong>直接内存是在Java堆外</strong>的、<strong>直接向系统申请的内存区间</strong>。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常，<strong>访问直接内存的速度会优于Java堆。即读写性能高。</strong><ul>
<li>因此出于性能考虑，<strong>读写频繁的场合可能会考虑使用直接内存</strong>。</li>
<li><strong>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</strong></li>
</ul>
</li>
</ul>
<h4 id="2、IO-VS-NIO"><a href="#2、IO-VS-NIO" class="headerlink" title="2、IO VS NIO"></a>2、IO VS NIO</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IO</th>
<th align="center">NIO (New IO / Non-Blocking IO：非阻塞IO)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现</td>
<td align="center">byte[] / char[]</td>
<td align="center">Buffer（缓存区）</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">Stream（流）</td>
<td align="center">Channel（管道）</td>
</tr>
</tbody></table>
<h4 id="3、直接缓存区（IO）-VS-非直接缓存区（NIO）"><a href="#3、直接缓存区（IO）-VS-非直接缓存区（NIO）" class="headerlink" title="3、直接缓存区（IO） VS 非直接缓存区（NIO）"></a>3、直接缓存区（IO） VS 非直接缓存区（NIO）</h4><p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。</p>
<p>使用IO，见下图。这<strong>里需要两份内存存储重复数据，效率低</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225618054.png" alt="image-20210424225618054"></p>
<p>使用NIO时，如下图。</p>
<p><strong>操作系统划出的直接缓存区可以被java代码直接访问，只有一份。 NIO适合对大文件的读写操作</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225837934.png" alt="image-20210424225837934"></p>
<h4 id="4、直接内存的OOM异常"><a href="#4、直接内存的OOM异常" class="headerlink" title="4、直接内存的OOM异常"></a>4、直接内存的OOM异常</h4><ul>
<li><p><strong>直接内存也可能导致OutOfMemoryError异常</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231245461.png" alt="image-20210424231245461"></p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是<strong>系统内存是有限</strong>的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>缺点</p>
<ul>
<li><strong>分配回收成本较高</strong></li>
<li><strong>不受JVM内存回收管理</strong></li>
</ul>
</li>
<li><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置</p>
</li>
<li><p>如果不指定，<strong>默认与堆的最大值-Xmx参数值一致</strong></p>
</li>
</ul>
<p>简单理解：</p>
<p><strong>java process memory = java heap + native memory</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231440926.png" alt="image-20210424231440926"></p>
<hr>
<h3 id="12、执行引擎"><a href="#12、执行引擎" class="headerlink" title="12、执行引擎"></a>12、执行引擎</h3><h4 id="1、执行引擎概述"><a href="#1、执行引擎概述" class="headerlink" title="1、执行引擎概述"></a>1、执行引擎概述</h4><h5 id="1、执行引擎的作用"><a href="#1、执行引擎的作用" class="headerlink" title="1、执行引擎的作用"></a>1、执行引擎的作用</h5><ul>
<li>执行引擎是Java虛拟机<strong>核心</strong>的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此<strong>可以不受物理条件制约地定制指令集与执行引擎的结构体系</strong>，能够<strong>执行那些不被硬件直接支持的指令集格式</strong>。</li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令</strong>才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ul>
<h5 id="2、执行引擎的工作过程"><a href="#2、执行引擎的工作过程" class="headerlink" title="2、执行引擎的工作过程"></a>2、执行引擎的工作过程</h5><ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令<strong>完全依赖于PC寄存器</strong>。</li>
<li>每当执行完一项指令操作后，PC寄存器就会<strong>更新下一条需要被执行的指令地址</strong>。</li>
<li>当前方法在执行的过程中，<strong>执行引擎</strong>有可能会<strong>通过</strong>存储在局部变量表中的<strong>对象引用准确定位</strong>到存储在Java堆区中的<strong>对象实例信息</strong>，以及<strong>通过对象头中的元数据指针定位到目标对象的类型信息</strong>。</li>
</ul>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：<strong>输入的是字节码二进制流</strong>，处理过程是<strong>字节码解析执行的等效过程</strong>，<strong>输出的是执行结果</strong>。</p>
<h4 id="2、Java代码编译和执行过程"><a href="#2、Java代码编译和执行过程" class="headerlink" title="2、Java代码编译和执行过程"></a>2、Java代码编译和执行过程</h4><p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005150269.png" alt="image-20210425005150269"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005213179.png" alt="image-20210425005213179"></p>
<p>问题1：什么是解释器( Interpreter)，什么是JIT编译器? </p>
<ul>
<li>解释器：当Java虛拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT (Just In Time Compiler) 编译器：就是虚拟机将<strong>源代码直接编译成和本地机器平台相关的机器语言</strong>。</li>
<li>解释器：边逐行翻译边运行</li>
<li>编译器：一起编译好再执行</li>
</ul>
<p>问题2：为什么说Java是半编译半解释型语言?</p>
<ul>
<li><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
</li>
<li><p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来</strong>进行。</p>
</li>
<li><p>经过编译器编译之后可以在方法区中进行缓存（热点代码）</p>
<p><img src="/2021/04/19/JVM/image-20210425005819291.png" alt="image-20210425005819291"></p>
</li>
</ul>
<h4 id="3、机器码、指令、汇编语言"><a href="#3、机器码、指令、汇编语言" class="headerlink" title="3、机器码、指令、汇编语言"></a>3、机器码、指令、汇编语言</h4><h5 id="1、理解执行引擎"><a href="#1、理解执行引擎" class="headerlink" title="1、理解执行引擎"></a>1、理解执行引擎</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg" alt="第12章_理解执行引擎"></p>
<h5 id="2、机器码"><a href="#2、机器码" class="headerlink" title="2、机器码"></a>2、机器码</h5><ul>
<li>各种用二进制编码方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，<strong>执行速度最快</strong>。</li>
<li>机器指令与CPU紧密相关，所以<strong>不同种类的CPU所对应的机器指令也就不同</strong>。</li>
</ul>
<h5 id="3、指令与指令集"><a href="#3、指令与指令集" class="headerlink" title="3、指令与指令集"></a>3、指令与指令集</h5><ul>
<li>指令<ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的0和1序列，简化成对应的指令(一般为英文简写，如mov,inc等)，可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比如mov)，对应的机器码也可能不同。</li>
</ul>
</li>
<li>指令集<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、汇编语言"><a href="#4、汇编语言" class="headerlink" title="4、汇编语言"></a>4、汇编语言</h5><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<strong>助记符</strong>(Mnemonics)代替<strong>机器指令的操作码</strong>，用<strong>地址符号</strong>(Symbol) 或<strong>标号</strong>(Label)代替<strong>指令或操作数的地址</strong>。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用<strong>汇编语言编写的程序还必须翻译成机器指令码</strong>，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h5 id="5、高级语言"><a href="#5、高级语言" class="headerlink" title="5、高级语言"></a>5、高级语言</h5><ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<strong>更接近人的语言</strong>。</li>
<li>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做<strong>解释程序</strong>或<strong>编译程序</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-1619284091715.jpg" alt="第12章_机器语言、汇编、高级语言"></p>
<h5 id="6、字节码"><a href="#6、字节码" class="headerlink" title="6、字节码"></a>6、字节码</h5><ul>
<li>字节码是一种**中间状态(中间码)的二进制代码(文件)**，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。（<strong>实现跨平台</strong>）</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<h5 id="7、C-C-源程序执行过程"><a href="#7、C-C-源程序执行过程" class="headerlink" title="7、C/C++源程序执行过程"></a>7、C/C++源程序执行过程</h5><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<ul>
<li><strong>编译过程</strong>：是读取源程序(字符流)，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li>
<li><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210425020914156.png" alt="image-20210425020914156"></p>
<h4 id="4、解释器"><a href="#4、解释器" class="headerlink" title="4、解释器"></a>4、解释器</h4><h5 id="1、解释器概述"><a href="#1、解释器概述" class="headerlink" title="1、解释器概述"></a>1、解释器概述</h5><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p>为什么需要字节码文件作为中间过渡，而不是采用将java源文件直接编译成对应的不同操作系统的机器指令的方式（此方式也可以实现跨平台）？</p>
<p>字节码文件是<strong>为了提高编译器的效率</strong>，同时也是Java虚拟机被称为<strong>跨语言的平台</strong>的基础。</p>
<p><img src="/2021/04/19/JVM/image-20210425021622259.png" alt="image-20210425021622259"></p>
<h5 id="2、解释器的工作机制（或工作任务）"><a href="#2、解释器的工作机制（或工作任务）" class="headerlink" title="2、解释器的工作机制（或工作任务）"></a>2、解释器的工作机制（或工作任务）</h5><ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
<h5 id="3、解释器分类"><a href="#3、解释器分类" class="headerlink" title="3、解释器分类"></a>3、解释器分类</h5><p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<ul>
<li>字节码解释器在执行时通过<strong>纯软件代码模拟字节码的执行</strong>，效率非常低下。</li>
<li>模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由<strong>Interpreter模块</strong>和<strong>Code模块</strong>构成。<ul>
<li>Interpreter模块：实现了解释器的<strong>核心功能</strong></li>
<li>Code模块：用于<strong>管理</strong>HotSpot VM在运行时生成的<strong>本地机器指令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、解释器现状"><a href="#4、解释器现状" class="headerlink" title="4、解释器现状"></a>4、解释器现状</h5><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些<br>C/C++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作<strong>即时编译</strong>的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h4 id="5、JIT编译器"><a href="#5、JIT编译器" class="headerlink" title="5、JIT编译器"></a>5、JIT编译器</h4><h5 id="1、Java代码的执行分类"><a href="#1、Java代码的执行分类" class="headerlink" title="1、Java代码的执行分类"></a>1、Java代码的执行分类</h5><ol>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行(直接编译成机器码)。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT, Just In Time）将方法编译成机器码后再执行</p>
<p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
</li>
</ol>
<ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用<strong>解释器与即时编译器并存</strong>的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代<br>码的时间和直接解释执行代码的时间。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一 较高下的地步。</li>
</ul>
<h5 id="2、为什么需要解释器？"><a href="#2、为什么需要解释器？" class="headerlink" title="2、为什么需要解释器？"></a>2、为什么需要解释器？</h5><p>有些开发人员会感觉到诧异，既然HotSpot VM中 已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢?比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确：</p>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>总结成一句话：<strong>解释器的响应速度快，执行速度慢；而编译器的响应速度慢，执行速度快。</strong></p>
<p>所以：</p>
<p>尽管JRockit VM中程序的执行性能会非常高效，但<strong>程序在启动时必然需要花费更长的时间来进行编译</strong>。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率</strong>。</p>
<p>同时，<strong>解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”</strong>。</p>
<h5 id="3、HotSpot-JVM-的执行方式"><a href="#3、HotSpot-JVM-的执行方式" class="headerlink" title="3、HotSpot JVM 的执行方式"></a>3、HotSpot JVM 的执行方式</h5><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且<strong>随着程序运行时间的推移，即时编译器逐渐发挥作用</strong>，根据<strong>热点探测功能</strong>，将<strong>有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</strong>。</p>
<p>相关案例：</p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态可以承受的负载要大于冷机状态</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>热机状态：已经启动很长时间；冷机状态：刚刚启动</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机,此故障说明了JIT的存在。——阿里团队</p>
<p><img src="/2021/04/19/JVM/image-20210425024022961.png" alt="image-20210425024022961"></p>
<h5 id="4、JIT即时编译器"><a href="#4、JIT即时编译器" class="headerlink" title="4、JIT即时编译器"></a>4、JIT即时编译器</h5><h6 id="1、概念解释"><a href="#1、概念解释" class="headerlink" title="1、概念解释"></a>1、概念解释</h6><ul>
<li>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器(其实叫“ 编译器的前端”更准确一些)把. java文件转变成.class文件的过程；</li>
<li>也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器 (AOT编译器，Ahead Of Time Compiler) 直接把.java文件编译成本地机器代码的过程。</li>
</ul>
<p>相关的编译器：</p>
<ul>
<li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器( ECJ)</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器</li>
<li>AOT编译器：GNU Compiler for the Java (GCJ)、Excelsior JET。</li>
</ul>
<h6 id="2、是否选择使用编译器"><a href="#2、是否选择使用编译器" class="headerlink" title="2、是否选择使用编译器"></a>2、是否选择使用编译器</h6><p>热点代码及探测方式</p>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被<strong>调用执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<h6 id="3、热点代码及探测方式"><a href="#3、热点代码及探测方式" class="headerlink" title="3、热点代码及探测方式"></a>3、热点代码及探测方式</h6><ul>
<li><p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过<strong>JIT编译器编译为本地机器指令</strong>。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为<strong>OSR (On Stack Replacement)编译</strong>。</p>
</li>
<li><p>一个方法究竟<strong>要被调用多少次</strong>，或者<strong>一个循环体究竟需要执行多少次</strong>循环才可以达到这个标准?</p>
<p>必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</p>
</li>
<li><p><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</p>
</li>
<li><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>(Invocation Counter)和<strong>回边计数器</strong>(BackEdge Counter) 。</p>
<ul>
<li><strong>方法调用计数器用于统计方法的调用次数</strong></li>
<li><strong>回边计数器则用于统计循环体执行的循环次数</strong></li>
</ul>
</li>
</ul>
<h6 id="4、方法调用计数器"><a href="#4、方法调用计数器" class="headerlink" title="4、方法调用计数器"></a>4、方法调用计数器</h6><ul>
<li><p>这个计数器就用于<strong>统计方法被调用的次数</strong>，它的默认阈值<strong>在Client模式下是1500次</strong>，<strong>在Server 模式下是10000 次</strong>。超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>这个阈值可以通过虛拟机参数<code>-XX:CompileThreshold</code>来人为设定。</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
</li>
<li><p>方法调用计数器的工作流程图：</p>
<p><img src="/2021/04/19/JVM/image-20210425024857559.png" alt="image-20210425024857559"></p>
<p>简化版本：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_方法调用计数器"></p>
</li>
<li><p>热度衰减</p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过<strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为<strong>方法调用计数器热度的衰减</strong>(Counter Decay) ，而这段时间就称为此方法统计的<strong>半衰周期</strong>(Counter Half Life Time) 。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用<code>-XX:CounterHalfLifeTime</code> 参数设置半衰周期的时间，单位是秒。</li>
</ul>
</li>
</ul>
<h6 id="5、回边计数器"><a href="#5、回边计数器" class="headerlink" title="5、回边计数器"></a>5、回边计数器</h6><ul>
<li><p>它的作用是统计一个方法中<strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边” (Back Edge) 。显然，建立回边计数器统计的目的就是为了<strong>触发OSR编译</strong>。</p>
</li>
<li><p>回边计数器的执行流程图：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_回边计数器"></p>
</li>
</ul>
<h6 id="6、HotSpot-VM可以设置程序执行方式"><a href="#6、HotSpot-VM可以设置程序执行方式" class="headerlink" title="6、HotSpot VM可以设置程序执行方式"></a>6、HotSpot VM可以设置程序执行方式</h6><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用解释器执行</strong>，还是<strong>完全采用即时编译器执行</strong>。如下所示：</p>
<ul>
<li><p><code>-Xint</code>：完全采用解释器模式执行程序；</p>
</li>
<li><p><code>-Xcomp</code>： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</p>
</li>
<li><p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。（默认）</p>
<p><img src="/2021/04/19/JVM/image-20210425031931789.png" alt="image-20210425031931789"></p>
</li>
</ul>
<h6 id="7、HotSpot-VM中JIT分类"><a href="#7、HotSpot-VM中JIT分类" class="headerlink" title="7、HotSpot VM中JIT分类"></a>7、HotSpot VM中JIT分类</h6><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为<strong>C1编译器</strong>和<strong>C2编译器</strong>。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><p><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p>
<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，<strong>耗时短</strong>。以达到更快的编译速度。</li>
</ul>
</li>
<li><p><code>-server</code>：指定Java虚拟机运行在Server模式下，并使用C2编译器。（对于84位的操作系统默认就是Srver模式，不能修改）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官方</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425030403484.png" alt="image-20210425030403484"></p>
<p><img src="/2021/04/19/JVM/image-20210425030645445.png" alt="image-20210425030645445"></p>
<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<p><strong>分层编译(Tiered Compilation)策略</strong>：程序解释执行(不开启性能监控)可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p><strong>C1和C2编译器不同的优化策略：</strong></p>
<ul>
<li>在不同的编译器上有不同的优化策略，C1骗译器上主要有<strong>方法内联</strong>，<strong>去虚拟化</strong>、<strong>冗余消除</strong>。<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<p>总结:</p>
<ul>
<li>一般来讲，<strong>JIT编译出来的机器码性能比解释器高</strong>。</li>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h6 id="8、最后补充"><a href="#8、最后补充" class="headerlink" title="8、最后补充"></a>8、最后补充</h6><ul>
<li>关于C1与C2：<ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器：<strong>Graal编译器</strong>。</li>
<li>编译效果短短几年时间就追评了C2编译器。未来可期。</li>
<li>目前，带着“实验状态”标签，需要使用开关参数去激活，才可以使用。<ul>
<li><code>-XX: +UnlockExperimentalVMOptions</code> </li>
<li><code>-XX: +UseJVMCICompiler</code></li>
</ul>
</li>
</ul>
</li>
<li>关于AOT编译器：（AOT VS JIT）<ul>
<li>jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)</li>
<li>Java 9引入了实验性AOT编译工具<strong>jaotc</strong>。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在<strong>程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在<strong>程序运行之前</strong>，便将字节码转换为机器码的过程。<ul>
<li>.java -&gt; .class -(jaotc)-&gt; .so(机器指令)</li>
</ul>
</li>
<li>最大好处：Java虛拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>缺点:<ul>
<li>破坏了java“一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。</li>
<li><strong>降低了Java链接过程的动态性</strong>，加载的代码在编译期就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="13、String-Table"><a href="#13、String-Table" class="headerlink" title="13、String Table"></a>13、String Table</h3><h4 id="1、String的基本特性"><a href="#1、String的基本特性" class="headerlink" title="1、String的基本特性"></a>1、String的基本特性</h4><ul>
<li><p>String：字符串，使用一对<code>&quot;&quot;</code>引起来表示。</p>
<ul>
<li><pre><code class="java">// 字面量的方式
String str = &quot;Hello&quot;;
// new的方式
String string = new String(&quot;Hi&quot;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- String声明为final的，**不可被继承**</span><br><span class="line"></span><br><span class="line">- String实现了Serializable接口：表示字符串是**支持序列化**的</span><br><span class="line"></span><br><span class="line">- String实现了Comparable接口：表示String可以**比较大小**</span><br><span class="line"></span><br><span class="line">- String在JDK8及以前内部定义了final char[] value用于存储字符串数据。**JDK9时改为byte[]**</span><br><span class="line"></span><br><span class="line">  - [官方](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;254</span><br><span class="line">    )：</span><br><span class="line"></span><br><span class="line">    ![image-20210425194526787](JVM&#x2F;image-20210425194526787.png)</span><br><span class="line"></span><br><span class="line">    ![image-20210425201622470](JVM&#x2F;image-20210425201622470.png)</span><br><span class="line"></span><br><span class="line">- String：代表不可变的字符序列。简称：不可变性</span><br><span class="line"></span><br><span class="line">  - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"></span><br><span class="line">- 通过字面量的方式（区别与new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span><br><span class="line"></span><br><span class="line">- 字符串常量池中是不会存储相同内容的字符串的</span><br><span class="line"></span><br><span class="line">  - String的String Pool时一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长。而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</span><br><span class="line">  - 使用&#96;-XX: StringTableSize&#96;可设置StringTable的长度</span><br><span class="line">  - 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多的就会导致效率下降很快。StringTableSize设置没有要求</span><br><span class="line">  - 在JDK7中，StringTable的长度默认值是60013，StringTableSize设置没有要求</span><br><span class="line">  - 在JDK8开始，设置StringTable的长度的话，1009是可设置的最小值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、String的内存分配</span><br><span class="line"></span><br><span class="line">- 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</span><br><span class="line"></span><br><span class="line">- 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，**String类型的常量池比较特殊。它的主要使用方法有两种**：</span><br><span class="line"></span><br><span class="line">  - 直接使用双引号&#96;&quot;&quot;&#96;声明出来的String对象会直接存储在常量池中。</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String info &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>如果不是用双引号<code>&quot;&quot;</code>声明的String对象，可以使用String提供的intern()方法。</p>
</li>
</ul>
</li>
<li><p><strong>Java6及以前，字符串常量池存放在永久代</strong>。</p>
</li>
<li><p>Java7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong>。</p>
<ul>
<li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
</li>
<li><p>字符串常量池概念原本使用比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()。</p>
</li>
<li><p>Java8元空间，字符串常量池在堆</p>
<p><img src="/2021/04/19/JVM/image-20210425213811970.png" alt="image-20210425213811970"></p>
</li>
</ul>
</li>
<li><p>为什么StringTable要调整？</p>
<ul>
<li>permSize默认比较小</li>
<li>永久代垃圾回收的频率低</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes">官网</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425214013347.png" alt="image-20210425214013347"></p>
</li>
</ul>
<h4 id="3、String的基本操作"><a href="#3、String的基本操作" class="headerlink" title="3、String的基本操作"></a>3、String的基本操作</h4><p>Java语言规范里要求<strong>完全相同的字符串字面量</strong>，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且<strong>必须是指向同一个String类实例</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425215451317.png" alt="image-20210425215451317"></p>
<p>A string is created in line 7.it goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.</p>
<h4 id="4、字符串拼接操作"><a href="#4、字符串拼接操作" class="headerlink" title="4、字符串拼接操作"></a>4、字符串拼接操作</h4><ol>
<li>常量与插入的拼接结果在常量池，原理是<strong>编译期优化</strong></li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆（非字符串常量池）中。变量拼接原理是<strong>StringBuilder</strong>（底层新建了一个StringBuilder对象进行字符串拼接）</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li>
</ol>
<p>相关案例：</p>
<p>总结：</p>
<ul>
<li><p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>
</li>
<li><p>intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</p>
</li>
<li><p>如下的s1 + s2 的执行细节：(变量s是我临时定义的）</p>
<ul>
<li><p>StringBuilder s = new StringBuilder();</p>
</li>
<li><p>s.append(“a”)</p>
</li>
<li><p>s.append(“b”)</p>
</li>
<li><p>s.toString()  –&gt; 约等于 new String(“ab”)</p>
<p>StringBuilder的toString()方法的new里面放的是char数组，不会在常量池创建对，而new String(“ab”)这里放的是字面量，会先在常量池创对象</p>
</li>
</ul>
<p>补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</p>
</li>
<li><p>字符串拼接操作不一定使用的是StringBuilder!</p>
<ul>
<li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</li>
</ul>
</li>
<li><p>针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</p>
<p>final修饰的变量一旦赋值后就不能再次赋值，所以可以做编译期优化，但是如果使用final String s = new String(“a”)；则不会做编译期优化，必须运行时才能确定。</p>
</li>
<li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p>
<ul>
<li><p>详情：</p>
<ul>
<li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li>
<li>使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</li>
<li>使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</li>
</ul>
</li>
<li><p>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</p>
<p>StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</p>
</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">           使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span></span><br><span class="line"><span class="comment">               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425221328973.png" alt="image-20210425221328973"></p>
<p><img src="/2021/04/19/JVM/image-20210425221607026.png" alt="image-20210425221607026"></p>
<p><img src="/2021/04/19/JVM/image-20210425221622886.png" alt="image-20210425221622886"></p>
<p><img src="/2021/04/19/JVM/image-20210425221651006.png" alt="image-20210425221651006"></p>
<p>StringBuilder执行拼接操作：</p>
<ul>
<li>好处：从始至终就创建了一个stringBuilder对象去执行append操作</li>
<li>改进空间：<ul>
<li>可以使用StringBuilder的带参数的构造器，指定大小</li>
<li>如果调用默认构造器，初始容量16，进行大量存储操作时，会导致频繁扩容(数组大小是不可变的,所以得新建数组，然后进行数组间的copy，中间也会产生垃级对象，耗时耗力。</li>
</ul>
</li>
</ul>
<h4 id="5、intern-的使用"><a href="#5、intern-的使用" class="headerlink" title="5、intern()的使用"></a>5、intern()的使用</h4><h5 id="1、Java-lang-String-intern-的相关解释"><a href="#1、Java-lang-String-intern-的相关解释" class="headerlink" title="1、Java.lang.String.intern()的相关解释"></a>1、Java.lang.String.intern()的相关解释</h5><p><img src="/2021/04/19/JVM/image-20210426012219855.png" alt="image-20210426012219855"></p>
<h5 id="2、intern-的使用"><a href="#2、intern-的使用" class="headerlink" title="2、intern()的使用"></a>2、intern()的使用</h5><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<ul>
<li><p>比如：</p>
<ul>
<li><pre><code class="java">String myInfo = new String(&quot;I love atguigu&quot;).intern();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    (&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() &#x3D;&#x3D; &quot;abc&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool)。</p>
</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426020658942.png" alt="image-20210426020658942"></p>
<ul>
<li>如何保证变量s指向的是字符串常量池中的数据呢？<ul>
<li>有两种方式：<ul>
<li>方式一： String s = “shkstart”;//字面量定义的方式</li>
<li>方式二： 调用intern()<ul>
<li><pre><code>    String s = new String(&quot;shkstart&quot;).intern();</code></pre>
</li>
<li><pre><code>    String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢"><a href="#3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢" class="headerlink" title="3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?"></a>3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str = new String(&quot;ab&quot;);</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目： new String(“ab”) 会创建几个对象?</p>
<ul>
<li>new String(“ab”)会创建几个对象？看字节码，就知道是两个。<ul>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
</ul>
</li>
</ul>
<p>拓展: new String(“a”) + new String (“b”)呢?</p>
<ul>
<li>看字节码，知道是五个对象<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2： new String(“a”)</li>
<li>对象3： 常量池中的”a”</li>
<li>对象4： new String(“b”)</li>
<li>对象5： 常量池中的”b”</li>
</ul>
</li>
<li>深入剖析： StringBuilder的toString():<ul>
<li>对象6 ：new String(“ab”)</li>
</ul>
</li>
<li>强调一下，toString()的调用（底层用的是char[]数组创建的字符串），在字符串常量池中，没有生成”ab”</li>
</ul>
<h5 id="4、intern-的使用-jdk6-vs-jdk7-8"><a href="#4、intern-的使用-jdk6-vs-jdk7-8" class="headerlink" title="4、intern()的使用: jdk6 vs jdk7/8"></a>4、intern()的使用: jdk6 vs jdk7/8</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">                                            <span class="comment">//         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于s3 == s4在JDK6 与 JDK7/8中答案不同的解析：</p>
<ul>
<li><p>JDK6：在JDK6中，字符串常量池是放在永久代中</p>
<ul>
<li><p>执行到String s3 = new String(“1”) + new String(“1”);的时候，程序在堆空间创建了一片空间用来存放字符串”11”，局部变量s3里存放着字符串”11”在堆空间当中的地址。</p>
<p>注意：此时的字符串常量池中并不存在字符串”11”（底层调用了StringBuilder的toString()方法，其中的new String使用char[]数组的方式创建了字符串”11”）</p>
</li>
<li><p>执行到s3.intern();的时候，intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。然而字符串常量池当中并不存在字符串”11”。所以，程序在字符串常量池中生成”11”对象。</p>
</li>
<li><p>执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址）</p>
</li>
<li><p>由于变量s3的引用是堆当中字符串对象”11”的地址，而变量s4的引用是字符串常量池中字符串”11”的地址。两者并不相等。</p>
</li>
</ul>
</li>
<li><p>JDK7/8：在JDK7/8中，字符串常量池放在堆中</p>
<ul>
<li>执行String s3 = new String(“1”) + new String(“1”);与上面描述的一样</li>
<li>执行到s3.intern();的时候，由于字符串常量池是存放在堆空间当中，而字符串”11”对象也在堆空间，所以intern()方法在字符串常量池中创建字符串”11”的时候，直接将堆空间中的字符串”11”的地址存放进了字符串常量池的字符串”11”对象当中，即字符串常量池中存放的是堆空间中字符串”11”的引用。即变量s3的引用也指向了字符串常量池的字符串”11”</li>
<li>代码执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址），然而字符串常量池中的字符串”11”存放的是堆空间的字符串”11”的地址。即：变量s4的引用也指向了堆空间在的字符串”11”的地址</li>
<li>这样一来堆空间与字符串常量池存放的字符串”11”为同一个对象。因此变量s3与变量s4指向的都是同一个地址，使用两者相等。</li>
</ul>
</li>
</ul>
<p>JDK6的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022637283.png" alt="image-20210426022637283"></p>
<p>JDK7的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022851422.png" alt="image-20210426022851422"></p>
<p>对上面案例在进行扩展：</p>
<p>代码：将 String s4 = “11”; 与 String s5 = s3.intern(); 执行顺序进行互换，并使用s5接收返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringIntern.java中练习的拓展：</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">        String s5 = s3.intern();<span class="comment">//intern方法会从字符串常量池中查询当前字符串是否存在，若存在就会返回该字符串的引用(地址)</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、总结String的intern-方法的使用"><a href="#5、总结String的intern-方法的使用" class="headerlink" title="5、总结String的intern()方法的使用"></a>5、总结String的intern()方法的使用</h5><ul>
<li>jdk1. 6中,将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，会把<strong>此对象复制一份</strong>(<strong>新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的对象地址</li>
</ul>
</li>
<li>Jdk1.7起，将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，则会<strong>把对象的引用地址复制一份</strong>(<strong>没有新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的引用地址</li>
</ul>
</li>
</ul>
<h5 id="6、关于intern-方法的两道练习"><a href="#6、关于intern-方法的两道练习" class="headerlink" title="6、关于intern()方法的两道练习"></a>6、关于intern()方法的两道练习</h5><h6 id="1、练习1"><a href="#1、练习1" class="headerlink" title="1、练习1:"></a>1、练习1:</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String x = &quot;ab&quot;;</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032250932.png" alt="image-20210426032250932"></p>
<p>放开 String x = “ab”; 注释之后的图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032752667.png" alt="image-20210426032752667"></p>
<h6 id="2、练习2"><a href="#2、练习2" class="headerlink" title="2、练习2"></a>2、练习2</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池和堆空间中都会生成&quot;ab&quot;，不同对象。s1指向的是堆空间当中的字符串&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，在堆空间中会生成字符串&quot;abc&quot;，但不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//在jdk7：false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、使用intern-测试执行效率：空间角度的使用上"><a href="#7、使用intern-测试执行效率：空间角度的使用上" class="headerlink" title="7、使用intern()测试执行效率：空间角度的使用上"></a>7、使用intern()测试执行效率：空间角度的使用上</h5><p>两种方式创建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length]));</span><br><span class="line"></span><br><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure>

<p>结论：对于程序中<strong>大量存在的字符串</strong>，尤其其中存在很多<strong>重复</strong>字符串时，<strong>使用intern()可以节省内存空间</strong>。</p>
<p>应用场景：</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储:北京市、海淀区等信息。这时候如果字符串都调用intern()方法，就会明显降低内存的大小。</p>
<h4 id="6、StringTable的垃圾回收"><a href="#6、StringTable的垃圾回收" class="headerlink" title="6、StringTable的垃圾回收"></a>6、StringTable的垃圾回收</h4><p>使用new String()的方式和使用new String().intern()的方式创建字符串都会在堆与字符串常量池创建字符串对象，但是为什么在存在大量重复的字符串的时候使用intern()会更节省内存空间呢？ =》 答案：StringTable存在垃圾回收。</p>
<ul>
<li>使用new String()的方式创建字符串不仅仅会在字符串常量池当中创建字符串对象（不重复），还会在堆空间当中创建大量的字符串对象（存在重复），这些堆空间的字符串对象都有一个变量的引用指向，GC不会进行垃圾回收。</li>
<li>使用new String().intern()的方式创建字符串虽然也会在堆空间和字符串常量池创建字符串对象，但是局部变量的指向的是字符串常量池的字符串对象，堆空间的字符串对象虽然也被创建了，但是没有变量的引用指向，会被GC回收。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426115438284.png" alt="image-20210426115438284"></p>
<h4 id="7、G1的String去重操作"><a href="#7、G1的String去重操作" class="headerlink" title="7、G1的String去重操作"></a>7、G1的String去重操作</h4><p><a target="_blank" rel="noopener" href="http://openjdk.java.netjeps/192">官网</a></p>
<ul>
<li>背景：对许多Java应用(有大的也有小的)做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：string1.equals(string2)=true。<strong>堆上存在重复的String对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
<li>实现<ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li>
<li>如果是，把这个对象的一个引用插入到<strong>队列</strong>中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个<strong>hashtable来记录所有的被String对象使用的不重复的char数组</strong>。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，<strong>char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了</strong>。</li>
</ul>
</li>
<li>命令行选项<ul>
<li>UseStringDeduplication(bool)：开启String去重，<strong>默认是不开启的，需要手动开启</strong>。</li>
<li>PrintStringDeduplicationStatistics(bool)：打印详细的去重统计信息</li>
<li>StringDeduplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14、垃圾回收概述"><a href="#14、垃圾回收概述" class="headerlink" title="14、垃圾回收概述"></a>14、垃圾回收概述</h3><ul>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>哪些内存需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<strong>极大地提高了开发效率</strong>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li>
</ul>
<h4 id="1、什么是垃圾"><a href="#1、什么是垃圾" class="headerlink" title="1、什么是垃圾"></a>1、什么是垃圾</h4><ul>
<li>什么是垃圾( Garbage) 呢<ul>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文: An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
</ul>
</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出</strong>。</li>
<li>内存溢出：存在引用指向不再被使用的对象，导致该对象无法被回收。比如匿名内部类存在指向外部类的引用等等。</li>
</ul>
<h4 id="2、为什么需要GC"><a href="#2、为什么需要GC" class="headerlink" title="2、为什么需要GC"></a>2、为什么需要GC</h4><ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行。</strong>而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
<h4 id="3、早期的垃圾回收"><a href="#3、早期的垃圾回收" class="headerlink" title="3、早期的垃圾回收"></a>3、早期的垃圾回收</h4><ul>
<li><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代<br>码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;Register(kDestroy) != NO_ERROR)</span><br><span class="line">	<span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式可以<strong>灵活控制内存释放的时间</strong>，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回<br>收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，<strong>垃圾对象所耗内存可能持续上升</strong>，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>在有了垃圾回收机制后，，上述代码块极有可能变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p>
</li>
</ul>
<h4 id="4、java垃圾回收机制"><a href="#4、java垃圾回收机制" class="headerlink" title="4、java垃圾回收机制"></a>4、java垃圾回收机制</h4><ul>
<li><p>自动内存管理无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄漏问题让你头疼不已。</li>
</ul>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<strong>更专心地专注于业务开发</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">oracle官网关于垃圾回收的介绍</a></p>
</li>
<li><p>对于Java开发人员而言自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</p>
</li>
<li><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地<strong>根据错误异常日志定位问题和解决问题</strong>。</p>
</li>
<li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术**实施必要的<code>监控</code>和<code>调节</code>**。</p>
</li>
<li><p>垃圾回收的区域：**<code>堆</code>(Heap)与<code>方法区</code>(Method Area)**</p>
<p><img src="/2021/04/19/JVM/image-20210426180331460.png" alt="image-20210426180331460"></p>
</li>
<li><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p>
<ul>
<li>其中，**<code>Java堆</code>是垃圾收集器的工作重点**。</li>
</ul>
</li>
<li><p>从次数上讲：</p>
<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不动方法区（Perm区或元空间）</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="15、垃圾回收相关算法"><a href="#15、垃圾回收相关算法" class="headerlink" title="15、垃圾回收相关算法"></a>15、垃圾回收相关算法</h3><ul>
<li>判断对象存活<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当<strong>一个对象已经不再被任何的存活对象继续引用</strong>时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：**<code>引用计数算法</code><strong>和</strong><code>可达性分析算法</code>**。</li>
</ul>
</li>
<li>回收垃圾<ul>
<li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是<strong>执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</strong>。</li>
<li>目前在JVM中比较常见的三种垃圾收集算法是：**<code>标记一清除算法(Mark-Sweep)</code><strong>、</strong><code>复制算法(Copying)</code><strong>、</strong><code>标记-压缩算法(Mark-Compact)</code>**。</li>
</ul>
</li>
</ul>
<h4 id="1、标记阶段：引用计数算法"><a href="#1、标记阶段：引用计数算法" class="headerlink" title="1、标记阶段：引用计数算法"></a>1、标记阶段：引用计数算法</h4><h5 id="1、引用计数算法概述"><a href="#1、引用计数算法概述" class="headerlink" title="1、引用计数算法概述"></a>1、引用计数算法概述</h5><ul>
<li><strong>引用计数算法</strong>(Reference Counting)比较简单，对<strong>每个对象保存一个整型的引用计数器属性</strong>。<strong>用于记录对象被引用的情况</strong>。</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：<ul>
<li><strong>实现简单，垃圾对象便于辨识</strong>；</li>
<li><strong>判定效率高，回收没有延迟性</strong>。</li>
</ul>
</li>
<li>缺点:<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致<strong>在Java的垃圾回收器中没有使用这类算法</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、循环引用"><a href="#2、循环引用" class="headerlink" title="2、循环引用"></a>2、循环引用</h5><p><img src="/2021/04/19/JVM/image-20210426203337926.png" alt="image-20210426203337926"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动断开各自reference的引用</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？能 -&gt; java使用的不是引用计数算法</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426204015295.png" alt="image-20210426204015295"></p>
<h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用?<ul>
<li><strong>手动解除</strong>：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用<strong>弱引用weakref</strong>，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
<h4 id="2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集"><a href="#2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集" class="headerlink" title="2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)"></a>2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)</h4><ul>
<li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是<strong>Java、C#**选择的。这种类型的垃圾收集通常也叫作</strong>追踪性垃圾收集**(Tracing GarbageCollection)。</p>
</li>
<li><p>所谓”GC Roots”根集合就是<strong>一组必须活跃的引用</strong>。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合(GC Roots) 为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)</li>
<li>如果<strong>目标对象没有任何引用链相连，则是不可达的</strong>，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
<li><p>图示</p>
<p><img src="/2021/04/19/JVM/image-20210426210515944.png" alt="image-20210426210515944"></p>
</li>
<li><p>在Java语言中，GC Roots包括以下几类元素：</p>
<ul>
<li><strong>虚拟机栈中引用的对象</strong><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><strong>本地方法栈内JNI (通常说的本地方法)引用的对象</strong></li>
<li>方法区中<strong>类静态属性引用的对象</strong><ul>
<li>比如: Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中<strong>常量引用的对象</strong><ul>
<li>比如：<strong>字符串常量池(String Table)里的引用</strong></li>
</ul>
</li>
<li><strong>所有被同步锁synchronized持有的对象</strong></li>
<li>Java虚拟机内部的引用。<ul>
<li><strong>基本数据类型对应的Class对象</strong>，<strong>一些常驻的异常对象</strong>(如:NullPointerException、OutOfMemoryError) ，<strong>系统类加载器</strong>。</li>
</ul>
</li>
<li><strong>反映java虛拟机内部情况的JMXBean</strong>、<strong>JVMTI中注册的回调</strong>、<strong>本地代码缓存</strong>等。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426210824260.png" alt="image-20210426210824260"></p>
</li>
<li><p>除了这些固定的GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和<strong>局部回收(Partial GC)</strong></p>
<ul>
<li>如果<strong>只针对Java堆中的某一块区域进行垃圾回收</strong>(比如：<strong>典型的只针对新生代</strong>)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的<strong>对象完全有可能被其他区域的对象所引用</strong>，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li><p>小技巧：</p>
<ul>
<li>由于<strong>Root采用栈方式存放变量和指针</strong>，所以<strong>如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</strong>。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个<strong>能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须”<code>Stop The World</code>“的一个重要原因。<ul>
<li>即使是号称(几乎)不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、对象的finalization机制"><a href="#3、对象的finalization机制" class="headerlink" title="3、对象的finalization机制"></a>3、对象的finalization机制</h4><ul>
<li>Java语言提供了对象终止(finalization)机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：<strong>垃圾回收此对象之前，总会先调用这个对象的finalize()方法</strong>。</li>
<li>finalize()方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中<strong>进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接</strong>等。</li>
<li><strong>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用</strong>。理由包括下面三点：<ul>
<li>在finalize() 时<strong>可能会导致对象复活</strong>。</li>
<li>finalize() 方法的<strong>执行时间是没有保障的，它完全由GC线程决定</strong>，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li><strong>一个糟糕的finalize()会严重影响GC的性能</strong>。</li>
</ul>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</li>
<li>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。</li>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件（finalize()方法）下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li><strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li>
</ul>
</li>
<li>以上3种状态中，是由于finalize()方法的存在进行的区分。<strong>只有在对象不可触及时才可以被回收</strong>。</li>
<li>判定一个对象objA是否可回收，至少要经历两次标记过程，具体过程：<ul>
<li><strong>如果对象objA到GC Roots没有引用链，则进行第一次标记</strong>。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ul>
<li>如果<strong>对象objA没有重写finalize()方法</strong>，或者<strong>finalize()方法已经被虚拟机调用过</strong>，则虚拟机视为“没有必要执行”，<strong>objA被判定为不可触及</strong>的。</li>
<li>如果<strong>对象objA重写了finalize()方法，且还未执行过</strong>，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个<strong>虚拟机自动创建的、<code>低优先级</code>的Finalizer线程</strong>触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong>。如果<strong>objA在finalize()方法中与引用链上的任何一个对象建立了联系</strong>，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成<strong>不可触及</strong>的状态，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、MAT与JProfiler的GC-Roots溯源"><a href="#4、MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4、MAT与JProfiler的GC Roots溯源"></a>4、MAT与JProfiler的GC Roots溯源</h4><h5 id="1、MAT概述"><a href="#1、MAT概述" class="headerlink" title="1、MAT概述"></a>1、MAT概述</h5><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
<p>大家可以在<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/">官网</a>下载并使用MAT。</p>
<h5 id="2、获取dump文件"><a href="#2、获取dump文件" class="headerlink" title="2、获取dump文件"></a>2、获取dump文件</h5><ol>
<li><p>命令行使用jmap</p>
<p><img src="/2021/04/19/JVM/image-20210426214539114.png" alt="image-20210426214539114"></p>
</li>
<li><p>使用JVisualVM导出</p>
<ul>
<li>捕获的heap dump文件是一个临时文件，关闭JVisua1VM后自动删除，若要保留，需要将其另存为文件。</li>
<li>可通过以下方法捕获heap dump：<ul>
<li>在左侧”Application”(应用程序)子窗口中右击相应的应用程序，选择Heap Dump(堆Dump)。</li>
<li>在Monitor (监视)子标签页中点击Heap Dump (堆Dump)按钮。</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的Application (应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择save as (另存为)即可将heap dump保存到本地。</li>
</ul>
</li>
</ol>
<h5 id="3、使用MAT打开heap-dump文件-hprof"><a href="#3、使用MAT打开heap-dump文件-hprof" class="headerlink" title="3、使用MAT打开heap dump文件.hprof"></a>3、使用MAT打开heap dump文件.hprof</h5><ol>
<li><p>File -&gt; Open File -&gt; 找到对应的.hprof文件导入</p>
</li>
<li><p>导入后图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426220319212.png" alt="image-20210426220319212"></p>
</li>
<li><p>在MAT中查看GC Roots的方法</p>
<p><img src="/2021/04/19/JVM/image-20210426220439764.png" alt="image-20210426220439764"></p>
</li>
<li><p>GC Roots的相关展示：详情可查看<a target="_blank" rel="noopener" href="https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/concepts/gcroots.html">官网</a></p>
<p><img src="/2021/04/19/JVM/image-20210426221159953.png" alt="image-20210426221159953"></p>
</li>
</ol>
<h5 id="4、使用Profiler进行GC-Roots溯源"><a href="#4、使用Profiler进行GC-Roots溯源" class="headerlink" title="4、使用Profiler进行GC Roots溯源"></a>4、使用Profiler进行GC Roots溯源</h5><ol>
<li><p>Live memory -&gt; All Objects -&gt; View -&gt; Mark Current Values (查看当前对象的个数)（光标变绿）</p>
<p><img src="/2021/04/19/JVM/image-20210426223157917.png" alt="image-20210426223157917"></p>
<p><img src="/2021/04/19/JVM/image-20210426223406880.png" alt="image-20210426223406880"></p>
</li>
<li><p>选择其中一个占内存较多的类 -&gt; Show Selection In Heap Walker -&gt; References(查看当前类的相关引用)</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426223532525.png" alt="image-20210426223532525"></p>
<p><img src="/2021/04/19/JVM/image-20210426223639192.png" alt="image-20210426223639192"></p>
</li>
<li><p>查看哪个对象在哪里被关联（用来解决内存泄漏问题：查看内存泄漏的相关对象在哪里被引用）</p>
<p><img src="/2021/04/19/JVM/image-20210426224059101.png" alt="image-20210426224059101"></p>
<p><img src="/2021/04/19/JVM/image-20210426224309986.png" alt="image-20210426224309986"></p>
</li>
</ol>
<h5 id="5、使用Profiler分析OOM"><a href="#5、使用Profiler分析OOM" class="headerlink" title="5、使用Profiler分析OOM"></a>5、使用Profiler分析OOM</h5><ol>
<li><p>可以在代码中使用参数：<code>-XX: +HeapDumpOnOutOfMemoryError</code>，当程序出现OOM的时候在当前目录下自动生成Heap Dump文件</p>
</li>
<li><p>Heap Walker -&gt; Current Object Set -&gt; Biggest Objects查看是否存在占用内存的超大对象</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426224832591.png" alt="image-20210426224832591"></p>
</li>
<li><p>在Thread Dump处查看哪个线程的哪个位置出现了OOM</p>
<p><img src="/2021/04/19/JVM/image-20210426225204897.png" alt="image-20210426225204897"></p>
</li>
</ol>
<h4 id="5、清除阶段：标记-清除算法"><a href="#5、清除阶段：标记-清除算法" class="headerlink" title="5、清除阶段：标记-清除算法"></a>5、清除阶段：标记-清除算法</h4><ul>
<li><p>背景：</p>
<ul>
<li>标记一清除算法( Mark-Sweep )是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</li>
</ul>
</li>
<li><p>执行过程：</p>
<p>当<strong>堆中的有效内存空间(available memory)被耗尽</strong>的时候，就会<strong>停止整个程序</strong>(也被称为stop the world) ，然后进行两项工作，第一项则是<strong>标记</strong>，第二项则是<strong>清除</strong>。</p>
<ul>
<li>标记：Collector<strong>从引用根节点开始遍历，标记<code>所有被引用的对象</code>**。一般是</strong>在对象的Header中记录为<code>可达对象</code>**。</li>
<li>清除：Collector对<strong>堆内存从头到尾进行线性的遍历</strong>，如果发现<strong>某个对象在其Header中没有标记为可达对象</strong>，则将其<strong>回收</strong>。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-清除算法"></p>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>效率不算高</strong></li>
<li>在<strong>进行GC</strong>的时候，需要<strong>停止整个应用程序</strong>，导致<strong>用户体验差</strong></li>
<li>这种方式清理出来的<strong>空闲内存是不连续的</strong>，<strong>产生内存碎片</strong>。</li>
<li>需要<strong>维护一个空闲列表</strong></li>
</ul>
</li>
<li><p>注意：何为清除(<strong>透明覆盖</strong>)</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是<strong>把需要清除的对象地址保存在空闲的地址列表里</strong>。</li>
<li>下次<strong>有新对象需要加载</strong>时，<strong>判断垃圾的位置空间</strong>是否够，如果够，就存放。</li>
</ul>
</li>
</ul>
<h4 id="6、清除阶段：复制算法"><a href="#6、清除阶段：复制算法" class="headerlink" title="6、清除阶段：复制算法"></a>6、清除阶段：复制算法</h4><ul>
<li><p>背景：</p>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，”使用双存储区的Lisp语言垃圾收集器CALISP Garbage Collector Algorithm Using Serial Secondary Storage)”M.L.Minsky在该论文中描述的算法被人们称为复制(Copying) 算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
</li>
<li><p>核心思想：</p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的<strong>存活对象复制</strong>到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="第14章_复制算法"></p>
</li>
<li><p>优点：</p>
<ul>
<li>没有标记和清除的过程，<strong>实现简单，运行高效</strong></li>
<li>复制过去以后<strong>保证空间的连续性，不会出现”碎片”问题</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>需要两倍的内存空间</strong></li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
</li>
<li><p>特别的：</p>
<ul>
<li>如果系统中的<strong>垃圾对象很多</strong>，复制算法不会很理想。复制算法需要<strong>复制的存活对象数量要求不要太多</strong>，或者说<strong>非常少</strong>才行。</li>
<li>即<strong>特别适合垃圾对象很多，存活对象很少</strong>的场景；例如：Young区的Survivor0和Survivor1区</li>
</ul>
</li>
<li><p>应用场景：</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99%的内存空间。</p>
<p>回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="/2021/04/19/JVM/image-20210427010211524.png" alt="image-20210427010211524"></p>
</li>
</ul>
<h4 id="7、清除阶段：标记-压缩算法"><a href="#7、清除阶段：标记-压缩算法" class="headerlink" title="7、清除阶段：标记-压缩算法"></a>7、清除阶段：标记-压缩算法</h4><ul>
<li><p>背景：</p>
<ul>
<li><strong>复制算法的高效性是建立在存活对象少、垃圾对象多的前提</strong>下的。这种情况在新生代经常发生，但是在<strong>老年代</strong>，更常见的情况是<strong>大部分对象都是存活对象</strong>。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法</strong>。</li>
<li>标记-清除算法的确可以应用在老年代中，但是该算法不仅<strong>执行效率低下</strong>，而且在<strong>执行完内存回收后还会产生内存碎片</strong>，所以JVM的设计者需要在此基础之上进行改进。标记-压缩(Mark一Compact) 算法由此诞生。</li>
<li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
</li>
<li><p>执行过程：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按<strong>顺序</strong>排放。</li>
<li>之后，清理边界外所有的空间。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-压缩算法"></p>
</li>
<li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩(Mark- Sweep- Compact)算法</strong>。</p>
</li>
<li><p>二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法</strong>，<strong>标记-压缩是移动式的</strong>。<strong>是否移动回收后的存活对象</strong>是一项优缺点并存的风险决策。</p>
<ul>
<li>风险：<strong>所有引用到存活对象的引用都需要修改</strong></li>
</ul>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要<strong>给新对象分配内存时，JVM只需要持有一个内存的起始地址</strong>即可，这比维护一个空闲列表显然少了许多开销。</p>
</li>
<li><p>指针碰撞：</p>
<ul>
<li>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，<strong>彼此之间维系着一个记录下一次分配起始点的标记指针</strong>，当为新对象分配内存时，只需要通过<strong>修改指针的偏移量将新对象分配在第一个空闲内存位置</strong>上，这种分配方式就叫做指针碰撞(Bump the Pointer) 。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><strong>消除了</strong>标记-清除算法当中<strong>内存区域分散的缺点</strong>，我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可</strong>。</li>
<li><strong>消除了</strong>复制算法当中，<strong>内存减半的高额代价</strong>。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>从效率上来说，<strong>标记-整理算法要低于复制算法</strong>。</li>
<li>移动对象的同时，如果<strong>对象被其他对象引用，则还需要调整引用的地址</strong>。</li>
<li>移动过程中，需要全程暂停用户应用程序。即: <strong>STW</strong></li>
</ul>
</li>
</ul>
<h4 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h4><p>对比三种清除算法</p>
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不会堆积碎片）</td>
<td>通常需要活对象的两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>再分配对象空间使用</td>
<td>空闲列表</td>
<td>指针碰撞</td>
<td>指针碰撞</td>
</tr>
</tbody></table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整<br>理内存的阶段。</p>
<h4 id="9、分代收集算法"><a href="#9、分代收集算法" class="headerlink" title="9、分代收集算法"></a>9、分代收集算法</h4><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Session对象、线程、Socket连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String对象</strong>， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的GC都是采用分代收集( Generational Collecting) 算法执行垃圾回收的</strong>。</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代(Young Gen)<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，<strong>回收频繁</strong>。</li>
<li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而<strong>复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</strong>。</li>
</ul>
</li>
<li>老年代(Tenured Gen)<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，<strong>回收不及年轻代频繁</strong>。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是<strong>由标记-清除或者是标记-清除与标记-整理的混合实现</strong>。<ul>
<li>Mark阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
<li>Sweep阶段的<strong>开销与所管理区域的大小成正比</strong>。</li>
<li>Compact阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以HotSpot中的<strong>CMS回收器</strong>为例，CMS是<strong>基于Mark- Sweep实现</strong>的，对于对象的回收效率很高。而对于碎片问题，CMS采用<strong>基于Mark-Compact算法的Serial Old回收器作为补偿措施</strong>：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用<strong>Serial Old执行Full GC以达到对老年代内存的整理</strong>。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="10、增量收集算法、分区算法"><a href="#10、增量收集算法、分区算法" class="headerlink" title="10、增量收集算法、分区算法"></a>10、增量收集算法、分区算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World(SWT)状态</strong>下，应用程序所有的线程都会挂起，暂停切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<strong>严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集( Incremental Collecting) 算法的诞生。</p>
<p><strong>基本思想：</strong></p>
<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以<strong>让垃圾收集线程和应用程序线程交替执行</strong>。<strong>每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。（<strong>并发思想</strong>）</li>
<li>总的来说，<strong>增量收集算法的基础仍是传统的标记-清除和复制算法</strong>。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能<strong>减少系统的停顿时间</strong>。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的<strong>总体成本上升</strong>，造成<strong>系统吞吐量的下降</strong>。</li>
</ul>
<p><strong>分区算法</strong>：</p>
<ul>
<li><p>一般来说，<strong>在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长</strong>。</p>
</li>
<li><p>为了更好地<strong>控制GC产生的停顿时间</strong>，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
</li>
<li><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。</p>
</li>
<li><p>每一个小区间都独立使用，独立回收。这种算法的好处是<strong>可以控制一次回收多少个小区间</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427023448226.png" alt="image-20210427023448226"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.jpg" alt="第14章_分区算法"></p>
</li>
</ul>
<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<hr>
<h3 id="16、垃圾回收相关概念"><a href="#16、垃圾回收相关概念" class="headerlink" title="16、垃圾回收相关概念"></a>16、垃圾回收相关概念</h3><h4 id="1、System-gc-的理解"><a href="#1、System-gc-的理解" class="headerlink" title="1、System.gc()的理解"></a>1、System.gc()的理解</h4><ul>
<li>在目录情况下，通过System.gc()或者runtime.getRuntime().gc()的调用，<strong>会显式触发Full GC</strong>，<strong>同时对老年代和新时代进行回收</strong>，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>
<li>JVM实现者可以通过System.gc()调用来觉得JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</li>
</ul>
<p>System.gc()提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc，但是调用System.runFinalization()方法可以强制调用使用引用的对象的finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样</span></span><br><span class="line">        System.runFinalization();<span class="comment">//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.gc()的相关案例：</p>
<p><img src="/2021/04/19/JVM/image-20210427112323264.png" alt="image-20210427112323264"></p>
<p>问题：调用System.gc()无法保证对垃圾收集器的调用，为什么上述案例中，每次调用都会有垃圾回收信息输出?是进行了GC吗?</p>
<h4 id="2、内存溢出-OOM-与内存泄漏-Memory-Leak"><a href="#2、内存溢出-OOM-与内存泄漏-Memory-Leak" class="headerlink" title="2、内存溢出(OOM)与内存泄漏(Memory Leak)"></a>2、内存溢出(OOM)与内存泄漏(Memory Leak)</h4><h5 id="1、内存溢出（OOM）"><a href="#1、内存溢出（OOM）" class="headerlink" title="1、内存溢出（OOM）"></a>1、内存溢出（OOM）</h5><ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
</li>
<li><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</p>
</li>
<li><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存供应用程序继续使用。</p>
</li>
<li><p>javadoc中对OutOfMemoryError的解释是：<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
</li>
<li><p>首先说没有空闲内存的情况:说明Java虛拟机的堆内存不够。原因有二：</p>
<ol>
<li><p><strong>Java虚拟机的堆内存设置不够</strong>。</p>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以<strong>通过参数-Xms、-Xmx来调整</strong>。</p>
</li>
<li><p><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</strong></p>
<p>对于老版本的Oracle JDK， 因为永久代的大小是有限的，并且JVM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型)非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和<strong>永久代</strong>相关：”java.lang.OutOfMemoryError: PermGen space”。</p>
<p>随着<strong>元数据区</strong>的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM的异常信息则变成了：”java.lang.OutOfMemoryError: Metaspace”。 直接内存不足，也会导致OOM。</p>
</li>
</ol>
</li>
<li><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong>等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h5 id="2、内存泄漏（Memory-Leak）"><a href="#2、内存泄漏（Memory-Leak）" class="headerlink" title="2、内存泄漏（Memory Leak）"></a>2、内存泄漏（Memory Leak）</h5><ul>
<li><p>也称作”存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
</li>
<li><p>但实际情况很多时候一些不太好的实践 (或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做**宽泛意义上的”内存泄漏”**。</p>
</li>
<li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p>
</li>
<li><p>注意，这里的存储空间并不是指物理内存，而是指<strong>虚拟内存大小</strong>，这个虚拟内存大小<strong>取决于磁盘交换区设定的大小</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427230217504.png" alt="image-20210427230217504"></p>
</li>
<li><p>举例：</p>
<ol>
<li><p>单例模式：</p>
<p><strong>单例的生命周期和应用程序是一样长</strong>的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
</li>
<li><p>一些<strong>提供close的资源未关闭</strong>导致内存泄漏：</p>
<p>数据库连接(dataSourse . getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3、Stop-The-World"><a href="#3、Stop-The-World" class="headerlink" title="3、Stop The World"></a>3、Stop The World</h4><ul>
<li>Stop-The-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。<ul>
<li><strong>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</strong>。<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，<strong>所有的GC都有STW这个事件</strong>。</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li>
<li>STW是JVM在<strong>后台自动发起和自动完成的</strong>。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li>
<li><strong>开发中不要用System.gc()；会导致Stop-the-world的发生</strong>。</li>
</ul>
<h4 id="4、垃圾回收的并行与并发"><a href="#4、垃圾回收的并行与并发" class="headerlink" title="4、垃圾回收的并行与并发"></a>4、垃圾回收的并行与并发</h4><h5 id="1、并发（Concurrent）"><a href="#1、并发（Concurrent）" class="headerlink" title="1、并发（Concurrent）"></a>1、并发（Concurrent）</h5><ul>
<li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在<strong>同一个处理器</strong>上运行。</li>
<li>并发不是真正意义上的”同时进行”，只是CPU把一个时间段分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，主要时间间隔处理得当，即可让用户感觉是多个应用程序在同时运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231222179.png" alt="image-20210427231222179"></p>
<h5 id="2、并行（Parallel）"><a href="#2、并行（Parallel）" class="headerlink" title="2、并行（Parallel）"></a>2、并行（Parallel）</h5><ul>
<li>当系统有<strong>一个以上CPU</strong>时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程<strong>互不抢占CPU资源</strong>，可以<strong>同时进行</strong>，我们称之为并行（Parallel）。</li>
<li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</li>
<li>适合<strong>科学计算，后台处理等弱交互场景</strong></li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231302158.png" alt="image-20210427231302158"></p>
<h5 id="3、并行-VS-并发"><a href="#3、并行-VS-并发" class="headerlink" title="3、并行 VS 并发"></a>3、并行 VS 并发</h5><p>二者对比：</p>
<ul>
<li><strong>并发</strong>，指的是<strong>多个事情，在同一时间段内同时发生了</strong>。</li>
<li><strong>并行</strong>，指的是<strong>多个事情，在同一时间点上同时发生了</strong>。</li>
</ul>
<ul>
<li><strong>并发</strong>的多个任务之间是<strong>互相抢占资源</strong>的。</li>
<li><strong>并行</strong>的多个任务之间是<strong>不互相抢占资源</strong>的。</li>
</ul>
<ul>
<li>只有在<strong>多CPU或者一个CPU多核</strong>的情况中，才会发生<strong>并行</strong>。</li>
<li>否则，<strong>看似同时发生的事情，其实都是并发执行的</strong>。</li>
</ul>
<h5 id="4、垃圾回收的并发与并行"><a href="#4、垃圾回收的并发与并行" class="headerlink" title="4、垃圾回收的并发与并行"></a>4、垃圾回收的并发与并行</h5><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li><p>并行(Parallel)：指<strong>多条垃圾收集线程并行工作</strong>，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<ul>
<li>如并行的垃圾回收器：ParNew、 Parallel Scavenge、 Parallel Old;</li>
</ul>
</li>
<li><p>串行(Serial)</p>
<ul>
<li>相较于并行的概念，<strong>单线程执行</strong>。</li>
<li><strong>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</strong></li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231437839.png" alt="image-20210427231437839"></p>
</li>
<li><p>并发(Concurrent)：指<strong>用户线程与垃圾收集线程同时执行</strong>(但不一定是并行的，可能会交替执行)，<strong>垃圾回收线程在执行时不会停顿用户程序的运行</strong>。</p>
<ul>
<li><strong>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</strong>；</li>
<li>如: CMS、G1</li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231919364.png" alt="image-20210427231919364"></p>
</li>
</ul>
<h4 id="5、安全点与安全区域"><a href="#5、安全点与安全区域" class="headerlink" title="5、安全点与安全区域"></a>5、安全点与安全区域</h4><h5 id="1、安全点（Safepoint）"><a href="#1、安全点（Safepoint）" class="headerlink" title="1、安全点（Safepoint）"></a>1、安全点（Safepoint）</h5><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为”安全点(Safepoint)”</p>
<p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长</strong>，<strong>如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p>
<p>比如：选择些执行时间较长的指令作为Safe Point，如<strong>方法调用</strong>、<strong>循环跳转</strong>和<strong>异常跳转</strong>等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</p>
<ul>
<li><p><strong>抢先式中断</strong>：(目前没有虚拟机采用了)</p>
<p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
</li>
<li><p><strong>主动式中断</strong>：</p>
<p><strong>设置一个中断标志</strong>，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</li>
</ul>
<h5 id="2、安全区域"><a href="#2、安全区域" class="headerlink" title="2、安全区域"></a>2、安全区域</h5><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?</p>
<p>例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应JVM 的中断请求，”走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把 Safe Region 看做是被扩展了的Safepoint。 </p>
<p>实际执行时：</p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，<strong>JVM会忽略标识为Safe Region状态的线程</strong>;</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了则继续运行，否则<strong>线程必须等待直到收到可以安全离开Safe Region的信号为止</strong>;</li>
</ol>
<h4 id="6、在谈引用"><a href="#6、在谈引用" class="headerlink" title="6、在谈引用"></a>6、在谈引用</h4><p>我们希望能描述这样一类对象：当<strong>内存空间还足够</strong>时，则能<strong>保留在内存</strong>中；如果<strong>内存空间在进行垃圾收集后还是很紧张</strong>，则可以<strong>抛弃</strong>这些对象。</p>
<p>[既<strong>偏门</strong>又<strong>非常高频</strong>的面试题]<code>强引用、软引用、弱引用、虚引用有什么区别?</code> <code>具体使用场景是什么?</code></p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用(StrongReference)</code>、<code>软引用(Soft Reference)</code> 、<code>弱引用(Weak Reference)</code>和<code>虚引用(Phantom Reference)</code> 4种，<strong>这4种引用强度依次逐渐减弱</strong>。（强软弱虚）</p>
<p>除<strong>强引用</strong>外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="/2021/04/19/JVM/image-20210427233208635.png" alt="image-20210427233208635"></p>
<p>Reference子类中只有<strong>终结器引用是包内可见</strong>的，<strong>其他3种引用类型均为public</strong>，可以在应用程序中直接使用</p>
<ul>
<li><strong><code>强引用(StrongReference)</code>**：最传统的“引用”的定义，是指</strong>在程序代码之中普遍存在的引用赋值<strong>，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，</strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象<strong>。（</strong>不回收**）</li>
<li><strong><code>软引用(SoftReference)</code>**：</strong>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常<strong>。（</strong>内存不足即回收**）</li>
<li><strong><code>弱引用(WeakReference)</code>**：</strong>被弱引用关联的对象只能生存到下一次垃圾收集之前<strong>。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。（</strong>发现即回收**）</li>
<li><strong><code>虚引用(PhantomReference)</code>**：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是</strong>能在这个对象被收集器回收时收到一个系统通知<strong>。（</strong>对象回收的跟踪**）</li>
</ul>
<h4 id="7、再谈引用：强引用Strong-Reference（不回收）"><a href="#7、再谈引用：强引用Strong-Reference（不回收）" class="headerlink" title="7、再谈引用：强引用Strong Reference（不回收）"></a>7、再谈引用：强引用Strong Reference（不回收）</h4><p>在Java程序中，最常见的引用类型是强引用(<strong>普通系统99%以上都是强引用</strong>)，也就是我们最常见的普通对象引用，也是<strong>默认的引用类型</strong>。</p>
<p>当在Java语言中<strong>使用new操作符创建一个新的对象</strong>， 并<strong>将其赋值给一个变量</strong>的时候， 这个变量就成为指向该对象的一个强引用。</p>
<p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
<p>强引用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用</p>
<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093616812.png" alt="image-20210428093616812"></p>
<p>此时，如果再运行一个赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>

<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093737403.png" alt="image-20210428093737403"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以<strong>直接访问目标对象</strong>。</li>
<li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong>。</li>
<li>强引用<strong>可能导致内存泄漏</strong>。</li>
</ul>
<h4 id="8、再谈引用：软引用Soft-Reference（内存不足即回收）"><a href="#8、再谈引用：软引用Soft-Reference（内存不足即回收）" class="headerlink" title="8、再谈引用：软引用Soft Reference（内存不足即回收）"></a>8、再谈引用：软引用Soft Reference（内存不足即回收）</h4><p>软引用是用来描述一些<strong>还有用</strong>，但<strong>非必需</strong>的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现<strong>内存敏感的缓存</strong>。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。实例：<strong>Mybatis的一些内部类中就使用了软引用</strong>。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue) 。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在java doc中，软引用是这样描述的：</p>
<blockquote>
<p>虚拟机在抛出 OutOfMemoryError 之前会<strong>保证所有的软引用对象已被清除</strong>。此外，没有任何约束保证软引用将在某个特定的时间点被清除，或者确定一组不同的软引用对象被清除的顺序。不过，虚拟机的具体实现会倾向于<strong>不清除最近创建或最近使用过的软引用</strong>。</p>
</blockquote>
<p>软引用在我们的日常开发中使用的场景很多，比如商城中商品的信息。某个商品可能会被多人访问，此时我们可以把该商品的信息使用软引用保存。当系统内存足够时，可以实现高速查找，当系统内存不足又会被回收，避免<code>OOM</code>的风险。</p>
<p>注意：</p>
<p>尽管软引用会在OOM之前被清理，但是，<strong>这并不表示Full GC会清理软引用对象</strong>。在经过Full GC后我们的软引用对象都放入了old区，由于Full GC的存在，程序大多数情况下并不会OOM。<strong>由于软引用对象占据了老年代的空间，Full GC将执行的更为频繁</strong>。所以还是建议使用弱引用。</p>
<p>当然，我们可以通过参数：<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>来设置当Full GC时回收软引用。其中参数值为Full GC保留的 SoftReference 数量，参数值越大，GC 后保留的软引用对象就越多。设置这个参数值为0时，Full GC就会回收我们的软引用对象了。</p>
<p>在JDK 1.2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>



<h4 id="9、再谈引用：弱引用Weak-Reference（发现即回收）"><a href="#9、再谈引用：弱引用Weak-Reference（发现即回收）" class="headerlink" title="9、再谈引用：弱引用Weak Reference（发现即回收）"></a>9、再谈引用：弱引用Weak Reference（发现即回收）</h4><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong>。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，<strong>通过这个队列可以跟踪对象的回收情况</strong>。</p>
<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>实例：</p>
<ul>
<li>三级缓存（内存(弱引用) -&gt; 本地 -&gt; 网络）</li>
<li><code>ThreadLocal</code>的内部实现就是一个<code>ThreadLocalMap</code>,该<code>map</code>的<code>Entry</code>的<code>key</code>为<code>ThreadLocal</code>本身，<code>value</code>为我们向<code>ThreadLocal</code>对象<code>set</code>的值，其中的<code>key</code>就是弱引用对象</li>
<li>集合<code>WeakHashMap</code>，都是使用了弱引用实现的</li>
</ul>
<p>在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，<strong>当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收</strong>。<strong>弱引用对象更容易、更快被GC回收</strong>。</p>
<p><strong>面试题：你开发中使用过WeakHashMap吗?</strong></p>
<h4 id="10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）"><a href="#10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）" class="headerlink" title="10、再谈引用：虚引用Phantom Reference（对象回收跟踪）"></a>10、再谈引用：虚引用Phantom Reference（对象回收跟踪）</h4><p>也称为“<strong>幽灵引用</strong>”或者“<strong>幻影引用</strong>”，是<strong>所有引用类型中最弱的一个</strong>。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它<strong>不能单独使用</strong>，也<strong>无法通过虚引用来获取被引用的对象</strong>。当试图通过虚引用的get()方法取得对象时，<strong>总是null</strong>。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p><strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以<strong>通知应用程序对象的回收情况</strong>。</p>
<p><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</strong>。</p>
<p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue( );</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>对象回收跟踪的代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程，用来跟踪对象的回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11、再谈引用：终结器引用Final-reference"><a href="#11、再谈引用：终结器引用Final-reference" class="headerlink" title="11、再谈引用：终结器引用Final reference"></a>11、再谈引用：终结器引用Final reference</h4><ul>
<li>它用以<strong>实现对象的finalize()方法</strong>，也可以称为<strong>终结器引用</strong>。</li>
<li>无需手动编码，其<strong>内部配合引用队列</strong>使用。</li>
<li>在GC时，终结器引用入队。由<strong>Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象</strong>。</li>
</ul>
<hr>
<h3 id="17、垃圾回收器"><a href="#17、垃圾回收器" class="headerlink" title="17、垃圾回收器"></a>17、垃圾回收器</h3><h4 id="1、GC分类与性能指标"><a href="#1、GC分类与性能指标" class="headerlink" title="1、GC分类与性能指标"></a>1、GC分类与性能指标</h4><h5 id="1、垃圾回收器概述"><a href="#1、垃圾回收器概述" class="headerlink" title="1、垃圾回收器概述"></a>1、垃圾回收器概述</h5><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<h5 id="2、垃圾回收器分类"><a href="#2、垃圾回收器分类" class="headerlink" title="2、垃圾回收器分类"></a>2、垃圾回收器分类</h5><h6 id="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"><a href="#1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器" class="headerlink" title="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"></a>1、按<strong>线程数</strong>分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></h6><p><img src="/2021/04/19/JVM/image-20210428111017627.png" alt="image-20210428111017627"></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的<code>Client模式</code>下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。</li>
</ul>
<h6 id="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"><a href="#2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器" class="headerlink" title="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"></a>2、按照<strong>工作模式</strong>分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong></h6><ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210428111338892.png" alt="image-20210428111338892"></p>
<h6 id="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"><a href="#3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器" class="headerlink" title="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"></a>3、按<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong></h6><ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
<h6 id="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"><a href="#4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器" class="headerlink" title="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"></a>4、按<strong>工作的内存区间</strong>分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong></h6><h5 id="3、评估GC的性能指标"><a href="#3、评估GC的性能指标" class="headerlink" title="3、评估GC的性能指标"></a>3、评估GC的性能指标</h5><ul>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>
<li>(总运行时间:程序的运行时间十内存回收的时间)</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用：Java堆区所占的内存大小。</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>关于吞吐量、暂停时间与内存占用：</p>
<ul>
<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ul>
<h6 id="1、吞吐量（throughput）"><a href="#1、吞吐量（throughput）" class="headerlink" title="1、吞吐量（throughput）"></a>1、吞吐量（throughput）</h6><ul>
<li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间)</p>
<ul>
<li>比如:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/2021/04/19/JVM/image-20210428111925067.png" alt="image-20210428111925067"></p>
</li>
</ul>
<h6 id="2、暂停时间（pause-time）"><a href="#2、暂停时间（pause-time）" class="headerlink" title="2、暂停时间（pause time）"></a>2、暂停时间（pause time）</h6><ul>
<li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li><p>暂停时间优先，意味着尽可能让单次STW的时间最短: 0.1 + 0.1 + 0.1 + 0.1+0.1=0.5</p>
<p><img src="/2021/04/19/JVM/image-20210428112108819.png" alt="image-20210428112108819"></p>
</li>
</ul>
<h6 id="3、吞吐量-VS-暂停时间"><a href="#3、吞吐量-VS-暂停时间" class="headerlink" title="3、吞吐量 VS 暂停时间"></a>3、吞吐量 VS 暂停时间</h6><ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</strong>。因此，具有低的较大暂停时间是非常重要的，特别是<strong>对于一个交互式应用程序</strong>。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。<ul>
<li>因为如果选择以<strong>吞吐量优先</strong>，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会<strong>导致GC需要更长的暂停时间来执行内存回收</strong>。</li>
<li>相反的，如果选择以<strong>低延迟优先为原则</strong>，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又引起了<strong>年轻代内存的缩减和导致程序吞吐量的下降</strong>。</li>
</ul>
</li>
<li>在设计(或使用) GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间)，或尝试找到一个二者的折衷。</li>
<li>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong>。</li>
</ul>
<h4 id="2、不同的垃圾回收器概述"><a href="#2、不同的垃圾回收器概述" class="headerlink" title="2、不同的垃圾回收器概述"></a>2、不同的垃圾回收器概述</h4><h5 id="1、垃圾回收器发展史"><a href="#1、垃圾回收器发展史" class="headerlink" title="1、垃圾回收器发展史"></a>1、垃圾回收器发展史</h5><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection, 对应的产品我们称为Garbage Collector（GC）。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>—–分水岭——</li>
<li>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为”No-Op (无操作) “回收器。同时引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC (Experimental)。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ul>
<h5 id="2、七款经典的垃圾收集器"><a href="#2、七款经典的垃圾收集器" class="headerlink" title="2、七款经典的垃圾收集器"></a>2、七款<strong>经典</strong>的垃圾收集器</h5><ul>
<li>串行回收器: Serial、Serial Old</li>
<li>并行回收器: ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发回收器: CMS、G1</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429023423991.png" alt="image-20210429023423991"></p>
<p><strong>七款经典收集器与垃圾分代之间的关系</strong></p>
<ul>
<li>新生代收集器: Serial、ParNew、Parallel Scavenge;</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS;</li>
<li>整堆收集器：G1;</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429024547757.png" alt="image-20210429024547757"></p>
<p><strong>垃圾收集器的组合关系</strong>：</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<p>为什么要有很多收集器，一个不够吗?</p>
<p>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是<strong>对具体应用最合适的收集器</strong>。</p>
<p><strong>如何查看默认的垃圾收集器</strong>：</p>
<ul>
<li><code>XX:+PrintCommandLineFlags</code>：查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数进程ID</code></li>
</ul>
<h4 id="3、Serial回收器：串行回收"><a href="#3、Serial回收器：串行回收" class="headerlink" title="3、Serial回收器：串行回收"></a>3、Serial回收器：串行回收</h4><ul>
<li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1. 3之前回收新生代唯一的选择。</p>
</li>
<li><p>Serial收集器作为HotSpot中<strong>Client模式下的默认新生代垃圾收集器</strong>。</p>
</li>
<li><p>Serial收集器采用<strong>复制算法</strong>、<strong>串行回收</strong>和**”Stop-the-World”机制**的方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于<strong>执行老年代垃圾收集</strong>的Serial Old收集器。<strong>Serial Old收集器同样也采用了串行回收和”Stop the World”机制， 只不过内存回收算法使用的是标记-压缩算法</strong>。</p>
<ul>
<li>Serial Old是运行在<strong>Client模式下默认的老年代的垃圾回收器</strong></li>
<li>Serial Old在Server模式下主要有两个用途：<ul>
<li><strong>与新生代的Parallel Scavenge配合使用</strong></li>
<li><strong>作为老年代CMS收集器的后备垃圾收集方案</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束(Stop The World) 。</p>
<p><img src="/2021/04/19/JVM/image-20210429085028563.png" alt="image-20210429085028563"></p>
</li>
<li><p>优势：<strong>简单而高效</strong>(与其他收集器的单线程比)，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在Client模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li><p>在<strong>用户的桌面应用场景</strong>中，可用内存一般不大(几十MB至一两百MB)，可以在较短时间内完成垃圾收集(几十ms至一百多ms) , 只要不频繁发生，使用串行回收器是可以接受的。</p>
</li>
<li><p>在HotSpot虚拟机中，使用<code>-XX: +UseSerialGC</code>参数可以<strong>指定年轻代和老年代都使用串行收集器</strong>。</p>
<ul>
<li>等价于新生代用Serial GC， 且老年代用Serial Old GC</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
</li>
</ul>
<h4 id="4、ParNew回收器：并行回收"><a href="#4、ParNew回收器：并行回收" class="headerlink" title="4、ParNew回收器：并行回收"></a>4、ParNew回收器：并行回收</h4><ul>
<li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是<strong>Serial收集器的多线程版本</strong>。</p>
<ul>
<li>Par是Parallel的缩写，New：只能处理的是<strong>新生代</strong></li>
</ul>
</li>
<li><p>ParNew收集器除了采用<strong>并行回收的方式执行内存回收</strong>外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop-the-World”机制</strong>。</p>
</li>
<li><p>ParNew是很多JVM运行<strong>在Server模式下新生代的默认垃圾收集器</strong>。</p>
</li>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。 (CPU并行需要切换线程，串行可以省去切换线程的资源)</p>
<p><img src="/2021/04/19/JVM/image-20210429085347499.png" alt="image-20210429085347499"></p>
</li>
<li><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效?</p>
<ul>
<li>ParNew<br>收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地<br>做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li><p>因为除Serial外，目前<strong>只有ParNew GC能与CMS收集器配合工作</strong></p>
</li>
<li><p>在程序中，开发人员可以通过选项”<code>-XX: +UseParNewGC</code>“手动指定使用ParNew收集器执行内存回收任务。它表示<strong>年轻代使用</strong>并行收集器，<strong>不影</strong><br><strong>响老年代</strong>。</p>
</li>
<li><p><code>-XX: ParallelGCThreads</code><strong>限制线程数量，默认开启和CPU数据相同的线程数</strong>。(一般不超过CPU的数据)</p>
</li>
</ul>
<h4 id="5、Parallel回收器：吞吐量优先"><a href="#5、Parallel回收器：吞吐量优先" class="headerlink" title="5、Parallel回收器：吞吐量优先"></a>5、Parallel回收器：吞吐量优先</h4><ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>复制算法</strong>、<strong>并行回收</strong>和**”Stop the World”机制**。</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举?</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达至一个<strong>可控制的吞吐量(Throughput)**，它也被称为</strong>吞吐量优先的垃圾收集器**。</li>
<li><strong>自适应调节策略</strong>也是Parallel Scavenge 与ParNew一个重要区别。</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在<strong>服务器环境中</strong>使用。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了<strong>用于执行老年代垃圾收集</strong>的Parallel Old收集器，用来<strong>代替老年代的Serial Old收集器</strong>。</p>
</li>
<li><p>Parallel Old收集器采用了<strong>标记-压缩算法</strong>，但同样也是<strong>基于并行回收</strong>和**”Stop-the-World”机制**。</p>
</li>
<li><p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</p>
</li>
<li><p>在Java8中，<strong>默认是此垃圾收集器</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210429090344976.png" alt="image-20210429090344976"></p>
</li>
<li><p>参数配置：</p>
<ul>
<li><code>-XX: +UseParallelGC</code>：<strong>手动指定年轻代使用Parallel并行收集器执行内存回收任务</strong>。</li>
<li><code>-XX: +UseParallelOldGC</code>：<strong>手动指定老年代都是使用并行回收收集器</strong>。<ul>
<li>分别适用于新生代和老年代。<strong>默认jdk8是开启的</strong>。</li>
<li>上面两个参数，<strong>默认开启一个，另一个也会被开启。 (互相激活)</strong></li>
</ul>
</li>
<li><code>-XX: parallelGCThreads</code>：<strong>设置年轻代并行收集器的线程数</strong>。一般地，<strong>最好与CPU数量相等</strong>，以避免<strong>过多的线程数影响垃圾收集性能</strong>。<ul>
<li>在默认情况下，当CPU数量小于8个， ParallelGCThreads的值等于CPU数量。</li>
<li>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5 * CPU_Count] / 8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPaulseMillis</code>：<strong>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒</strong>。<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li><strong>该参数使用需谨慎</strong>。</li>
</ul>
</li>
<li><code>-XX: GCTimeRatio</code>：<strong>垃圾收集时间占总时间的比例</strong>(= 1 / (N + 1))。用于<strong>衡量吞吐量的大小</strong>。</li>
<li>取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。</li>
<li><strong>与前一个-XX :MaxGCPauseMillis参数有一定矛盾性</strong>。暂停时间越长，Radio参数就容易超过设定的比例。</li>
<li><code>-XX: +UseAdaptiveSizePolilcy</code>：设置Parallel Scavenge收集器<strong>具有自适应调节策略</strong><ul>
<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCT imeRatio)和停顿时间<br>(MaxGCPauseMills)，让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6、CMS回收器：低延迟"><a href="#6、CMS回收器：低延迟" class="headerlink" title="6、CMS回收器：低延迟"></a>6、CMS回收器：低延迟</h4><ul>
<li><p>在JDK 1.5时期，HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent -Mark -Sweep)收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
</li>
<li><p>CMS收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><strong>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</strong>，以给用户带来较好的体验。</li>
<li>CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li><p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会**”Stop-the-world”**</p>
</li>
<li><p>不幸的是，<strong>CMS作为老年代的收集器</strong>，却<strong>无法与</strong>JDK 1.4.0中已经存在的<strong>新生代收集器Parallel Scavenge 配合工作</strong>，所以在JDK 1.5中<strong>使用CMS来收集老年代</strong>的时候，<strong>新生代只能选择ParNew或者Serial收集器中的一个</strong>。在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
</li>
<li><p>CMS的工作原理：</p>
<p><img src="/2021/04/19/JVM/image-20210429095659541.png" alt="image-20210429095659541"></p>
</li>
<li><p>CMS整个过程比之前的收集器要复杂，整个过程分为<strong>4个主要阶段</strong>，即<strong>初始标记阶段</strong>、<strong>并发标记阶段</strong>、<strong>重新标记阶段</strong>和<strong>并发清除阶段</strong>。</p>
<ul>
<li>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li>
<li>并发标记(Concurrent-Mark)阶段：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起<strong>并发运行</strong>。</li>
<li>重新标记(Remark) 阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除(Concurrent-Sweep) 阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时<strong>并发的</strong>。</li>
</ul>
</li>
<li><p>尽管CMS收集器采用的是<strong>并发回收(非独占式)**，但是在其</strong>初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p>
</li>
<li><p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</p>
</li>
<li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以<strong>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当<strong>堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”<strong>Concurrent Mode Failure</strong>“失败，这时虛拟机将启动<strong>后备预案:临时启用Serial Old收集器</strong>来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<strong>产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择<strong>空闲列表(Free List) 执行内存分配</strong>。</p>
</li>
<li><p>既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢?</p>
<ul>
<li>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?</li>
<li>要保证用户线程能继续执行，前提的<strong>它运行的资源不受影响</strong>嘛。Mark Compact更适合“Stop the World”这种场景下使用</li>
</ul>
</li>
<li><p>CMS的优点：</p>
<ul>
<li><strong>并发收集</strong></li>
<li><strong>低延迟</strong></li>
</ul>
</li>
<li><p>CMS的弊端：</p>
<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现”<strong>Concurrent Mode Failure</strong>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ol>
</li>
<li><p>CMS收集器可以设置的参数：</p>
<ul>
<li><code>-XX: +UseConcMarkSweepGC</code>：<strong>手动指定使用CMS收集器执行内存回收任务</strong>。<ul>
<li>开启该参数后会自动将<code>-XX: +UseParNewGC</code>打开。 即：<strong>ParNew (Young区用) +CMS (Old区用) + Serial Old的组合。</strong></li>
</ul>
</li>
<li><code>-XX:CMSlnitiatingOccupancyFraction</code>：<strong>设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</strong>。<ul>
<li><strong>JDK5及以前版本的默认值为<code>68</code>**，即当</strong>老年代的空间<strong>使用率达到68%时，会执行一次CMS回收。</strong>JDK6及 以上版本默认值为92%**</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><code>-XX: +UseCMSCompactAtFullCollection</code>：<strong>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生</strong>。不过由于内存压缩整理过程无法并发执行，所带来的问题就是<strong>停顿时间变得更长</strong>了。</li>
<li><code>-XX: CMSFullGCsBeforeCompaction</code>：<strong>设置在执行多少次Full GC后对内存空间进行压缩整理</strong>。</li>
<li><code>-XX:Parallel CMSThreads</code>：<strong>设置CMS的线程数量</strong>。</li>
<li>CMS默认启动的线程数是<code>(ParallelGCThreads+3) / 4</code>，<strong>ParallelGCThreads是年轻代并行收集器的线程数</strong>。当CPU资源比较紧张时，受到CMs收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢?</li>
<li>请记住以下口令：<ul>
<li>如果你想要<strong>最小化地使用内存和并行开销</strong>，请选<strong>Serial GC</strong>;</li>
<li>如果你想要<strong>最大化应用程序的吞吐量</strong>，请选<strong>Parallel GC</strong>;</li>
<li>如果你想要<strong>最小化GC的中断或停顿时间</strong>，请选<strong>CMS GC</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK后续版本中CMS的变化</p>
<ul>
<li><p>JDK9新特性：<strong>CMS被标记为Deprecate了(JEP291)</strong></p>
<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，<strong>提示CMS未来将会被废弃</strong>。</li>
</ul>
</li>
<li><p>JDK14新特性：<strong>删除CMS垃圾回收器(JEP363)</strong></p>
<ul>
<li><p>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX: +UseConcMarkSweepGC</code>的话，<strong>JVM不会报错，只是给出一个warning信息，但是不会exit</strong>。<strong>JVM会自动回退以默认GC方式启动JVM</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC;support was removed in 14. 0 and the VM will continue execution using the default collector.</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7、G1回收器：区域化分代式"><a href="#7、G1回收器：区域化分代式" class="headerlink" title="7、G1回收器：区域化分代式"></a>7、G1回收器：区域化分代式</h4><h5 id="1、两个问题"><a href="#1、两个问题" class="headerlink" title="1、两个问题"></a>1、两个问题</h5><p>问题1：既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First (G1)GC?</p>
<ul>
<li>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 (Garbage-First) 垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间(pause time) ，同时兼顾良好的吞吐量。</li>
<li><strong>官方给G1设定的目标是<code>在延迟可控的情况下获得尽可能高的吞吐量</code>，所以才担当起”全功能收集器”的重任与期望。</strong></li>
</ul>
<p>问题2：为什么名字叫做Garbage First (G1) 呢?</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region) (物理上不连续的)。使用不同的Region来表示Eden、 幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</strong>。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间(Region) ，所以我们给G1一个名字：<strong>垃圾优先(Garbage First)</strong> 。</li>
</ul>
<h5 id="2、G1概述"><a href="#2、G1概述" class="headerlink" title="2、G1概述"></a>2、G1概述</h5><p>G1 (Garbage-First)是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以<strong>极高概率满足GC停顿时间</strong>的同时，还<strong>兼具高吞吐量</strong>的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，是<strong>JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为“<strong>全功能的垃圾收集器</strong>”。</p>
<p>与此同时，CMS已经在JDK 9中被标记为废弃(deprecated) 。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX: +UseG1GC</code>来启用。</p>
<h5 id="3、G1的特点（优势）与缺点"><a href="#3、G1的特点（优势）与缺点" class="headerlink" title="3、G1的特点（优势）与缺点"></a>3、G1的特点（优势）与缺点</h5><p>与其他GC收集器相比，G1使用了全新的<strong>分区算法</strong>，其特点有如下四点：</p>
<ul>
<li><p><strong>并行与并发</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，<strong>不会出现在整个回收阶段发生完全阻塞应用程序的情况</strong></li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li><p>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p><strong>将堆空间分为若千个区域(Region) ,这些区域中包含了逻辑上的年轻代和老年代</strong>。</p>
</li>
<li><p>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
<p><img src="/2021/04/19/JVM/image-20210429235305962.png" alt="image-20210429235305962"></p>
</li>
</ul>
</li>
<li><p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记-压缩(Mark-Compact )算法</strong>，两种算法都可以<strong>避免内存碎片</strong>。这种特性<strong>有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。尤其是当<strong>Java堆非常大的时候，G1的优势更加明显</strong>。</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型</strong>(即：软实时soft real-time)</p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。(其中吞吐量 = M-N / M)</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，<strong>每次根据允许的收集</strong><br><strong>时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<p>G1收集器的缺点：</p>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是<strong>为了垃圾收集产生的内存占用(Footprint) 还是程序运行时的额外执行负载(Overload)</strong> 都要比CMS要高。</li>
<li>从经验上来说，在<strong>小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势</strong>。<strong>平衡点在6-8GB之间</strong>。</li>
</ul>
<h5 id="4、G1回收器的参数设置"><a href="#4、G1回收器的参数设置" class="headerlink" title="4、G1回收器的参数设置"></a>4、G1回收器的参数设置</h5><ul>
<li><strong><code>-XX: +UseG1GC</code>**：</strong>手动指定使用G1收集器执行内存回收任务**。</li>
<li><strong><code>-XX: G1HeapRegionSize</code>**：</strong>设置每个Region的大小**。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/ 2000。</li>
<li><strong><code>-XX: MaxGCPauseMillis</code>**：</strong>设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms**</li>
<li><code>-XX: ParallelGCThread</code>：<strong>设置STW时GC线程数的值。最多设置为8</strong></li>
<li><code>-XX: ConcGCThreads</code>：<strong>设置并发标记的线程数</strong>。将n设置为<strong>并行垃圾回收线数(ParallelGCThreads)的1/4左右</strong>。</li>
<li><code>-XX: InitiatingHeapoccupancyPercent</code>：<strong>设置触发并发GC周期的Java堆占用率阈值</strong>。超过此值，就触发GC。<strong>默值是45</strong>。堆空间已用占比达到45%，老年代才会并发标记</li>
</ul>
<h5 id="5、G1回收器的常见操作步骤"><a href="#5、G1回收器的常见操作步骤" class="headerlink" title="5、G1回收器的常见操作步骤"></a>5、G1回收器的常见操作步骤</h5><ul>
<li>G1的设计原则就是<strong>简化JVM性能调优</strong>，开发人员只需要简单的三步即可完成调优：<ol>
<li>第一步：<strong>开启G1垃圾收集器</strong></li>
<li>第二步：<strong>设置堆的最大内存</strong></li>
<li>第三步：<strong>设置最大的停顿时间</strong></li>
</ol>
</li>
<li>G1中提供了三种垃圾回收模式：<strong>YoungGC、 Mixed GC和Full GC，在不同的条件下被触发</strong>。</li>
</ul>
<h5 id="6、G1回收器的适用场景"><a href="#6、G1回收器的适用场景" class="headerlink" title="6、G1回收器的适用场景"></a>6、G1回收器的适用场景</h5><ul>
<li><strong>面向服务端应用</strong>，针对具有<strong>大内存、多处理器</strong>的机器。(在普通大小的堆里表现并不惊喜)</li>
<li>最主要的应用是<strong>需要低GC延迟，并具有大堆的应用程序</strong>提供解决方案；</li>
<li>如：在堆大小<strong>约6GB或更大</strong>时，<strong>可预测的暂停时间可以低于0.5秒</strong>；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ol>
<li><strong>超过50%的Java堆被活动数据占用</strong>；</li>
<li><strong>对象分配频率或年代提升频率变化很大</strong>；</li>
<li><strong>GC停顿时间过长</strong>(长于0.5至1秒)</li>
</ol>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用<strong>应用线程承担后台运行的GC工作</strong>，即<strong>当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</strong>。</li>
</ul>
<h5 id="7、分区Region：化整为零"><a href="#7、分区Region：化整为零" class="headerlink" title="7、分区Region：化整为零"></a>7、分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB<br>之间，且为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB, 32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的Region大小相同，且在JVM生命周期内</strong><br><strong>不会被改变</strong>。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实</strong><br><strong>现逻辑上的连续</strong>。</p>
<ul>
<li><strong>如果设置了Region数量，那么Region大小就不是固定的，但是大小肯定是2的幂次方，并且在1-32M之间</strong>；</li>
<li><strong>如果设置了Region大小，那么Region数量就不是固定的，但是肯定是2048附近</strong>；</li>
</ul>
<p>Region只能是Eden、Survivor、 Humongous中的一种，但是它的身份不是固定的，谁来占用那么这个Region就是谁的</p>
<p><img src="/2021/04/19/JVM/image-20210430001836775.png" alt="image-20210430001836775"></p>
<ul>
<li>一个region有可能属于Eden，Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做<strong>Humongous内存区域</strong>，如图中的H块。主要用于<strong>存储大对象</strong>，如果<strong>超过0.5个region，就放到H</strong>。region是可以连续分配的，小于0.5的就用两个连续的region分配</li>
<li>object that is more than half a region size is considered a “Humongous object” ：大于区域大小一半的对象都被视为“巨大对象”</li>
</ul>
<p>设置Humongous的原因：</p>
<p>对于<strong>堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个<strong>Humongous区，它用来专门存放大对象</strong>。如果<strong>一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到<strong>连续的H区</strong>，有时候不得不<strong>启动Full GC</strong>。G1的<strong>大多数行为都把H区作为老年代的一部分来看待</strong>。</p>
<p>关于指针碰撞与空闲列表：</p>
<ul>
<li><p>Bump：单个Region使用指针碰撞的方式来放数据上面allocated是已经使用的内存空间，top就是指针的位置，unallocate是没有使用的内存空间</p>
<ul>
<li>Bump-the-pointer，即：指针碰撞</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210430002300492.png" alt="image-20210430002300492"></p>
</li>
<li><p>TLAB：虽然存在分区Region，但是依然有线程独有的TLAB空间，这样可以保证多个线程对对象修改可以并行操作</p>
<ul>
<li>TLAB，即：空闲列表</li>
</ul>
</li>
</ul>
<h5 id="8、G1回收器垃圾回收过程"><a href="#8、G1回收器垃圾回收过程" class="headerlink" title="8、G1回收器垃圾回收过程"></a>8、G1回收器垃圾回收过程</h5><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程(Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
<li>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</li>
</ul>
<p>顺时针，Young GC -&gt; Young GC +Concurrent Marking -&gt; Mixed GC顺序，进行垃圾回收。</p>
<p><img src="/2021/04/19/JVM/image-20210429185519798.png" alt="image-20210429185519798"></p>
<ul>
<li>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</strong>。</li>
<li>当堆内存使用达到一定值(<strong>默认45%</strong>)时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，<strong>这个老年代Region是和年轻代一起被回收的</strong>。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45号%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ul>
<p><strong>G1回收器垃圾回收过程：Remembered Set</strong></p>
<ul>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代?</p>
<ul>
<li>这样的话会降低Minor GC的效率；</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li><strong>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</strong>：<ul>
<li>每个Region都有一个对应的Remembered Set；</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier 暂时中断操作；</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象)；</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<ul>
<li>卡表是记忆集的一种具体实现方式。 见《深入理解Java虚拟机》</li>
</ul>
</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏；</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210430003324501.png" alt="image-20210430003324501"></p>
</li>
<li><p>上面提到的Remebered Set就是上述Reset，上面提到的Reference类型就是引用类型，其中Reset的作用是记录当前Region中哪些对象被外部引用指向，比如OId区中的对象会指向Eden区的对象，然后当我们要回收某个Region的时候，直接遍历遍历当前Region中的所有对象就可以了，然后针对性的去找到那些指向当前对象的其他对象，最终发现当前对象是否是根可达的，如果不是，那就应该被删除，其实之前的垃圾回收器都涉及到这个问题，当进行Minor GC的时候，通过GC Roots查找的时候还需要遍历Old区的对象，毕竟Old区对象也可能会指向Eden区对象，但是G1通过Rset避免了全堆的扫描，当引用类型数据写操作时，先暂时中断，然后判断当前引用类型数据是否被其他对象所指向，如果不被指向，那就直接放在Region中就可以了；如果被其他对象指向，那么还要判断这个对象是在当前要插入的Region中，还是在其他Region中;如果在其他Region中，那就需要使用CardTable把当前引用类型数据的指向信息放在Rset中，也就是形成上面的虚线连线，如果在当前Region中，那就不需要指向了，毕竟到时候我们会进行遍历查找根可达对象，那肯定会找到的，所以这种情况也是直接放在Region中就可以了。</p>
</li>
</ul>
<h5 id="9、G1回收过程一：年轻代GC"><a href="#9、G1回收过程一：年轻代GC" class="headerlink" title="9、G1回收过程一：年轻代GC"></a>9、G1回收过程一：年轻代GC</h5><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p><strong>年轻代垃圾回收只会回收Eden区和Survivor区</strong>。</p>
<p>首先G1停止应用程序的执行(Stop-The-World)，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="/2021/04/19/JVM/image-20210430003008242.png" alt="image-20210430003008242"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><p>第一阶段，<strong>扫描根</strong>。可以体现Rset作用：<strong>避免全堆扫描</strong></p>
<ul>
<li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li><p>第二阶段，<strong>更新RSet</strong>。 作用：<strong>保证Rset中的数据准确性</strong></p>
<ul>
<li><p>处理dirty card queue中的card，更新RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</strong>。</p>
</li>
<li><p>对dirty card queue (脏卡表队列)的解释：</p>
<ul>
<li>对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。<ul>
<li>其中object.field=object中的第一个object代表老年代中的对象，而第二个object代表Eden区中的对象</li>
</ul>
</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢?<ul>
<li>这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
</li>
</ul>
</li>
<li><p>脏卡表队列作用：</p>
<p>Reset更新需要线程同步，所以开销会很大，因此不能实时更新，因此我们需要把引用对象被其他对象引用的关系放在一个脏卡表队列中，当年轻代回收的时候会进行STW，所以我们也正好把脏卡表队列中的值更新到Rset中，这样不仅没有涉及到开销问题，还可以保证Rset中的数据是准确的。</p>
</li>
</ul>
</li>
<li><p>第三阶段，<strong>处理RSet</strong>。作用：<strong>根可达性遍历的一部分</strong></p>
<ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p>第四阶段，<strong>复制对象</strong>。说明：<strong>新生代使用复制算法</strong></p>
<ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p>第五阶段，<strong>处理引用</strong>。空Eden：<strong>Eden变成空的，那它就变成了无主Region，因此会被记录到空链表中，等待下一次被分配</strong></p>
<ul>
<li>处理Soft，Weak，Phantom， Final， JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
<li>以上回收的都是强引用对象，下面回收软引用对象 (不足回收)、弱引用对象(发现回收)、虚引用对象</li>
</ul>
</li>
</ol>
<h5 id="10、G1回收过程二：并发标记过程"><a href="#10、G1回收过程二：并发标记过程" class="headerlink" title="10、G1回收过程二：并发标记过程"></a>10、G1回收过程二：并发标记过程</h5><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。<strong>这个阶段是STW的，并且会触发一次年轻代GC</strong>。</li>
<li><strong>根区域扫描(Root Region Scanning)**：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。</strong>主要扫描哪些老年代对象是可达的**，毕竟我们进行Young GC的时候会移动Survivor区，移动之后就找不到哪些老年代对象是可达的了</li>
<li><strong>并发标记(Concurrent Marking)**：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，</strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**（实时回收）。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>**再次标记(Remark)**：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning (SATB)。<ul>
<li>原因：并发标记不准确</li>
</ul>
</li>
<li><strong>独占清理(cleanup ,STW)**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。</strong>是STW的<strong>。</strong>其实是一个统计计算过程，不会涉及垃圾清理**<ul>
<li><strong>这个阶段并不会实际上去做垃圾的收集</strong></li>
</ul>
</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。<ul>
<li>并发清理阶段任务：<strong>如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收</strong>。</li>
</ul>
</li>
</ol>
<h5 id="11、G1回收过程三：混合回收"><a href="#11、G1回收过程三：混合回收" class="headerlink" title="11、G1回收过程三：混合回收"></a>11、G1回收过程三：混合回收</h5><p>当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。 这里需要注意：是<strong>一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<strong>Mixed GC并不是Full GC</strong>。 </p>
<p><img src="/2021/04/19/JVM/image-20210429194133565.png" alt="image-20210429194133565"></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</li>
<li>混合回收的回收集(Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收</strong>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。<strong>如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。垃圾占比越多， 回收优先级越高</strong>；如果垃圾不足Region空间的65%，那么将不会进行回收。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。如果垃圾不足Region内存的10%，那么将不会对该老年代Region进行回收，综合上面的来看，只要垃圾占整个老年代Region的比例大于65%，才会对该Region进行回收</li>
</ul>
<h5 id="12、G1回收可选的过程四：Full-GC"><a href="#12、G1回收可选的过程四：Full-GC" class="headerlink" title="12、G1回收可选的过程四：Full GC"></a>12、G1回收可选的过程四：Full GC</h5><ul>
<li><p>G1的初衷就是要避免Fu1l GC的出现。但是如果上述方式不能正常工作，G1会<strong>停止应用程序的执行</strong>(Stop- The-World)，使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
</li>
<li><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?</p>
<ul>
<li>比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
</ul>
</li>
<li><p>导致G1Full GC的原因可能有三个:</p>
<ol>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象；</li>
</ol>
<ul>
<li>解决：加大堆空间</li>
</ul>
<ol start="2">
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<ul>
<li>解决：调小触发并发GC周期的Java堆占用阈值(默认是45%， 在前面参数页有)</li>
</ul>
<ol start="3">
<li>最大GC暂停时间太短，导致在规定的时间间隔内无法完成垃圾回收，也会导致Full GC</li>
</ol>
<ul>
<li>解决：加大最大GC停顿时间</li>
</ul>
</li>
</ul>
<h5 id="13、G1回收过程：补充"><a href="#13、G1回收过程：补充" class="headerlink" title="13、G1回收过程：补充"></a>13、G1回收过程：补充</h5><p>从Oracle官方透露出来的信息可获知，回收阶段( Evacuation)其实本也有想过设计成<strong>与用户程序一起并发执行</strong>，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而<strong>选择把这个特性放到了G1之后出现的低延迟垃圾收集器(即ZGC)中</strong>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h5 id="14、G1回收器优化建议"><a href="#14、G1回收器优化建议" class="headerlink" title="14、G1回收器优化建议"></a>14、G1回收器优化建议</h5><ul>
<li>年轻代大小<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标<ul>
<li>原因：年轻代GC是并行独占式的，所以最好让垃圾回收器自己去调节</li>
</ul>
</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
<li>说明：暂停时间和吞吐量是此消彼长的，所以不要把暂停时间设置的太严格，不然因为这个原因引起Full GC也不太好</li>
</ul>
</li>
</ul>
<h4 id="8、垃圾回收总结"><a href="#8、垃圾回收总结" class="headerlink" title="8、垃圾回收总结"></a>8、垃圾回收总结</h4><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B/S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记-压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段：Serial =&gt; Parallel (并行) =&gt; CMS (并发) =&gt; G1 =&gt; ZGC</p>
<p><strong>怎么选择垃圾回收器?</strong></p>
<ul>
<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>
<li>怎么选择垃圾收集器?<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果<strong>内存小于100M</strong>， 使用<strong>串行收集器</strong></li>
<li>如果是<strong>单核、单机程序，并且没有停顿时间</strong>的要求，<strong>串行收集器</strong></li>
<li>如果是<strong>多CPU</strong>、需要<strong>高吞吐量</strong>、<strong>允许停顿时间超过1秒</strong>，选择<strong>并行</strong>或者<strong>JVM自己选择</strong>.</li>
<li>如果是<strong>多CPU</strong>、<strong>追求低停顿时间</strong>，需<strong>快速响应</strong>(比如延迟不能超过1秒，如互联网应用)，使用并发收集器官方推荐<strong>G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li>
<li>最后需要明确一个观点：<ol>
<li>没有最好的收集器，更没有万能的收集器；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
</li>
</ol>
</li>
<li>面试：<ul>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：<ul>
<li>垃圾收集的算法有哪些?</li>
<li>如何判断一个对象是否可以回收?</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</li>
</ul>
</li>
</ul>
<h4 id="9、GC日志分析"><a href="#9、GC日志分析" class="headerlink" title="9、GC日志分析"></a>9、GC日志分析</h4><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p>
<ul>
<li><p>内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX: +PrintGC</code>：输出Gc日志。类似: -verbose :gc</li>
<li><code>-XX: +PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX: +PrintGCTimeStamjps</code>：输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX: +PrintGCDateStamps</code>：输出GC的时间戳(以日期的形式，如2013-05-04T21 :53:59.234+0800)</li>
<li><code>-XX: + PrintHeapAtGC</code> ：在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc: ../logs/gc.log</code>：日志文件的输出路径</li>
</ul>
</li>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个只会显示总的GC堆的变化， 如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K)，0.0084018secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K (228352K)，0.0184066 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K) ，0.0619261secs ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li>GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代， 老年代。</li>
<li>Allocation Failure: GC发生的原因。</li>
<li>80832K -&gt; 19298K：堆在GC前的大小和GC后的大小。</li>
<li>228840k：现在的堆大小。</li>
<li>0.0084018 secs：GC持续的时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc -XX: +PrintGCDetails</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)[PSYoungGen: 70640K-&gt;10116K(141312K)] 80541K-&gt;20017K (227328K)，0.0172573secs]</span><br><span class="line">[Times: user=0.03 sys=0.00， real=0.02 secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 98859K-&gt;8154K(142336K) ] 108760K-&gt;21261K (228352K)，0.0151573 secs]</span><br><span class="line">[Times: user=0.00 sys=0.01, real=0.02 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 8154K-&gt;0K(142336K) ] [ParOldGen: 13107K-&gt;16809K(62464K)] 21261K -&gt; 16809K (204800K),</span><br><span class="line">[Metaspace: 20599K-&gt;20599K (1067008K)]，0.0639732 secs]</span><br><span class="line">[Times: user=0.14 sys=0.00， real=0.06 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析:</p>
<ul>
<li>GC，Full FC：同样是GC的类型</li>
<li>Allocation Failure：GC原因</li>
<li>PSYoungGen：使用了Parallel Scavenge并 行垃圾收集器的新生代Gc前后大小的变化</li>
<li>ParoldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</li>
<li>Metaspace：元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代</li>
<li>XXX secs：指GC花费的时间</li>
<li>Times: user: 指的是垃圾收集器花费的所有CPU时间，sys: 花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX: +PrintGCDetails -XX: +PrintGCTimeStamps -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-09-24T22:15:24.518+0800:3.287: [GC(Allocation Failure) [ PSYoungGen: 136162K-&gt;5113K (136192K) ] 141425K-&gt;17632K (222208K)，0.0248249 secs] [Times: user=0. 05 sys=0.00，real=0.03 secs]</span><br><span class="line">2019-09-24T22:15:25.559+0800:4.329: [GC (Metadata GC Threshold)[ PSYoungGen:97578K-&gt;10068K(274944K) ] 110096K-&gt;22658K (360960K)，0.0094071 secs] [Times: user=0. 00 sys=0.00，real=0.01 secs]</span><br><span class="line">2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [ PSYoungGen:10068K-&gt;0K(274944K) ] [ParOldGen: 12590K-&gt;13564K (56320K) ] 22658K-&gt;13564K (331264K) ,</span><br><span class="line">[Metaspace: 20590K-&gt;20590K(1067008K)]， 0.0494875 secs]</span><br><span class="line">[Times: user=0.17 sys=0.02，real=0.05 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：带上了日期和时间</p>
</li>
</ul>
<ul>
<li>日志补充说明：<ul>
<li>“ [GC”和” [Full GC” 说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是” [DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成” [ParNew”，意思是”Parallel New Generation”</li>
<li>使用Parallel Scavenge收集器在新生代的名字是” [PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage- first heap”</li>
<li>Allocation Failure：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li>[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K- &gt; 704K (9216K)中<ul>
<li>括号内：GC回收前年轻代大小，回收后大小，( 年轻代总大小)</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，( 年轻代和老年代总大小)</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys 内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间</li>
</ul>
</li>
</ul>
<p>GC日志分析</p>
<p><img src="/2021/04/19/JVM/image-20210430011457790.png" alt="image-20210430011457790"></p>
<p>Minor GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430011551243.png" alt="image-20210430011551243"></p>
<p>Full GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430012224983.png" alt="image-20210430012224983"></p>
<p>如果想把GC日志存到文件的话，是下面这个参数：</p>
<ul>
<li>Xloggc: ./path/to/gc. log</li>
</ul>
<p>GC日志分析工具：</p>
<ul>
<li>可以用一些工具去分析这些gc日志。</li>
<li>常用的日志分析工具有：<strong>GCViewer</strong>、<strong>GCEasy</strong>、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</li>
</ul>
<h4 id="10、垃圾回收器的新发展"><a href="#10、垃圾回收器的新发展" class="headerlink" title="10、垃圾回收器的新发展"></a>10、垃圾回收器的新发展</h4><h5 id="1、垃圾回收器的发展"><a href="#1、垃圾回收器的发展" class="headerlink" title="1、垃圾回收器的发展"></a>1、垃圾回收器的发展</h5><p>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、 Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p>
<p>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在<strong>Serverless等新的应用场景 下，Serial GC找到了新的舞台</strong>。</p>
<p>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p>
<h5 id="2、JDK11的新特性"><a href="#2、JDK11的新特性" class="headerlink" title="2、JDK11的新特性"></a>2、JDK11的新特性</h5><p><img src="/2021/04/19/JVM/image-20210429231614446.png" alt="image-20210429231614446"></p>
<h5 id="3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性"><a href="#3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性" class="headerlink" title="3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)"></a>3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)</h5><ul>
<li><p>现在G1回收器已成为默认回收器好几年了。</p>
</li>
<li><p>我们还看到了引入了两个新的收集器：</p>
<ul>
<li>ZGC( JDK11出现)</li>
<li>Shenandoah(Open JDK12)</li>
<li>主打特点：<strong>低停顿时间</strong></li>
</ul>
</li>
<li><p><strong>Shenandoah，无疑是众多GC中最孤独的一个</strong>。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<strong>旨在针对JVM上的内存回收实现低停顿的需求</strong>。在2014年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat研发Shenandoah团队对外宣称，<strong>Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="/2021/04/19/JVM/image-20210430015133115.png" alt="image-20210430015133115"></p>
</li>
<li><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降王</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
<li>Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前Java12新特性视频里有过介绍。</li>
</ul>
</li>
</ul>
<p>[Java12新特性地址]<br><a target="_blank" rel="noopener" href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a><br>或<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p>
<h5 id="4、令人震惊、革命性的ZGC（JDK14新特性）"><a href="#4、令人震惊、革命性的ZGC（JDK14新特性）" class="headerlink" title="4、令人震惊、革命性的ZGC（JDK14新特性）"></a>4、令人震惊、革命性的ZGC（JDK14新特性）</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">官网地址</a></p>
<ul>
<li><p>ZGC与Shenandoah目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</strong>。</p>
</li>
<li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，(暂时)不设分代的，使用了<code>读屏障</code>、<code>染色指针</code>和<code>内存多重映射</code>等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标的一款垃圾收集器</strong>。</p>
</li>
<li><p>ZGC的工作过程可以分为4个阶段：</p>
<ul>
<li><strong>并发标记</strong></li>
<li><strong>并发预备重分配</strong></li>
<li><strong>并发重分配</strong></li>
<li><strong>并发重映射</strong>等。</li>
</ul>
</li>
<li><p>ZGC几乎在所有地方并发执行的，除了<strong>初始标记的是STW</strong>（10ms以内）的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
</li>
<li><p>测试数据：</p>
<p><img src="/2021/04/19/JVM/image-20210430015758548.png" alt="image-20210430015758548"></p>
<p>低延迟：</p>
<p><img src="/2021/04/19/JVM/image-20210430015925777.png" alt="image-20210430015925777"></p>
</li>
<li><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、958停顿、99%停顿、99. 98停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在10毫秒以内。</p>
</li>
<li><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。</p>
</li>
<li><p><strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器</strong>。</p>
</li>
<li><p>JEP 364: ZGC应用在macOS上</p>
</li>
<li><p>JEP 365: ZGC应用在Windows</p>
<ul>
<li>JDK14之前，ZGC仅Linux才支持。</li>
<li> 尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOs.上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</li>
<li>现在mac或windows.上也能使用zGc了，示例如下：<br>**-XX: +Unloc kExperimentalVMOptions -XX: +UseZGC**</li>
</ul>
</li>
<li><p>其它垃圾回收器: AIiGC</p>
<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆 (LargeHeap)应用场景。指定场景下的对比：</p>
<p><img src="/2021/04/19/JVM/image-20210429233231323.png" alt="image-20210429233231323"></p>
</li>
<li><p>当然，其他厂商也提供了各种独具一格的GC实现， 例如比较有名的低延迟GC：<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail">Zing</a>，有兴趣可以参考提供的链接。</p>
</li>
</ul>
<hr>
<h3 id="18、垃圾回收的相关大厂面试题"><a href="#18、垃圾回收的相关大厂面试题" class="headerlink" title="18、垃圾回收的相关大厂面试题"></a>18、垃圾回收的相关大厂面试题</h3><ul>
<li>蚂蚁金服:<ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1</li>
<li>一面: JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li>
<li>一面: G1回收器讲下回收过程</li>
<li>GC是什么?为什么要有GC?</li>
<li>一面: GC的两种判定方法? CMS收集器与G1收集器的特点。</li>
</ul>
</li>
<li>百度:<ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: jvm GC原理，JVM怎么回收内存</li>
<li>一面: CMS特点，垃圾回收算法有哪些?各自的优缺点，他们共同的缺点是什么?</li>
</ul>
</li>
<li>滴滴:<ul>
<li>一面: java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
</li>
<li>京东:<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</li>
<li>垃圾回收算法的实现原理。</li>
</ul>
</li>
<li>阿里:<ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收?</li>
<li>如何选择合适的垃圾收集算法?</li>
<li>JVM有哪三种垃圾回收器?</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣?</li>
<li>system.gc() 和 runtime.gc() 会做什么事情?</li>
<li>一面: Java GC机制? GC Roots有哪些?</li>
<li>二面: Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次。</li>
</ul>
</li>
</ul>
<h3 id="0、其他"><a href="#0、其他" class="headerlink" title="0、其他"></a>0、其他</h3><h4 id="1、label"><a href="#1、label" class="headerlink" title="1、label"></a>1、label</h4><p>官方：</p>
<p>Refactor the code to remove this label and the need for it.</p>
<p>label标签，不属于关键字，类似于c的goto（很少用），用于标记跳转。底层就是goto语句，尽量不要用</p>
<h4 id="2、怎么学习Java的不同版本的新特性"><a href="#2、怎么学习Java的不同版本的新特性" class="headerlink" title="2、怎么学习Java的不同版本的新特性"></a>2、怎么学习Java的不同版本的新特性</h4><p>Java不同版本的新特性：</p>
<ol>
<li>语法层面：Lambda表达式、switch表达式、 自动装箱、自动拆箱、enum关键字、 &lt;&gt;泛式等等</li>
<li>API层面：Stream API、新的日期时间、Optional、 String、 集合框架</li>
<li>底层优化：JVM的优化，GC的变化、元空间、静态域、字符串常量池等</li>
</ol>
<h2 id="中篇：字节码与类的加载器"><a href="#中篇：字节码与类的加载器" class="headerlink" title="中篇：字节码与类的加载器"></a>中篇：字节码与类的加载器</h2><h3 id="1、class文件结构"><a href="#1、class文件结构" class="headerlink" title="1、class文件结构"></a>1、class文件结构</h3><h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、字节码文件的跨平台性"><a href="#1、字节码文件的跨平台性" class="headerlink" title="1、字节码文件的跨平台性"></a>1、字节码文件的跨平台性</h5><ol>
<li><p>Java语言: 跨平台的语言(write once ，run anywhere</p>
<ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译</li>
<li>这个优势不再那么吸引人了。Python、 PHP、 Perl、 Ruby、 Lisp等有强大的解释器。</li>
<li>跨平台似乎已经快成为一门语言必选的特性。</li>
</ul>
</li>
<li><p>Java虚拟机：跨语言的平台</p>
<ul>
<li><p><strong>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联</strong>。</p>
</li>
<li><p>无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。</p>
</li>
<li><p>可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
</li>
<li><p>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">官方文档</a></p>
</li>
</ul>
</li>
<li><p>想要让一个Java程序正确地运行在JVM中， Java源码就必须要被编译为符合JVM规范的字节码。</p>
<ul>
<li><p><strong>前端编译器的主要任务</strong>就是<strong>负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件</strong>。</p>
</li>
<li><p><strong>javac</strong>一种能够将Java源码编译为字节码的<strong>前端编译器</strong>。</p>
</li>
<li><p>javac编译器在<strong>将Java源码编译为个有效的字节码文件过程中经历了4个步骤，分别是词法解析、语法解析、语义解析以及生成字节码。</strong></p>
<p><img src="/2021/04/19/JVM/image-20210504004503138.png" alt="image-20210504004503138"></p>
</li>
</ul>
</li>
<li><p>Oracle的JDK软件包括两部分内容：</p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实现Java虛拟机的运行时环境</li>
</ul>
</li>
</ol>
<h5 id="2、Java的前端编译器"><a href="#2、Java的前端编译器" class="headerlink" title="2、Java的前端编译器"></a>2、Java的前端编译器</h5><h6 id="1、关于前端编译器与后台编译器在程序编译过程中的作用"><a href="#1、关于前端编译器与后台编译器在程序编译过程中的作用" class="headerlink" title="1、关于前端编译器与后台编译器在程序编译过程中的作用"></a>1、关于前端编译器与后台编译器在程序编译过程中的作用</h6><p><img src="/2021/04/19/JVM/image-20210504005333757.png" alt="image-20210504005333757"></p>
<h6 id="2、前端编译器vs后端编译器"><a href="#2、前端编译器vs后端编译器" class="headerlink" title="2、前端编译器vs后端编译器"></a>2、前端编译器vs后端编译器</h6><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的<strong>javac编译器</strong>。javac是一种能够<strong>将Java源码编译为字节码的前端编译器</strong>。</p>
<p>HotSpotVM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在Java的前端编译器领域，除了javac之外， 还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ (Eclipse Compiler for Java )编译器。和<strong>Javac的全量式编译</strong>不同，<strong>ECI是一种增量式编译器</strong>。</p>
<ul>
<li>在Eclipse中，当开发人员编写完代码后，使用“Ctrl+S”快捷键时，ECI编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此<strong>ECI的编译效率会比javac更加迅速和高效</strong>，当然编译质量和javac相比大致还是一样的。</li>
<li>ECI不仅是Eclipse的默认内置前端编译器，在<strong>Tomcat中同样也是使用ECJ编译器来编译jsp文件</strong>。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA使用javac 编译器。(还可以自己设置为AspectJ编译器 ajc)</li>
</ul>
<p><strong>前端编译器并不会直接涉及编译优化</strong>等方面的技术，而是将这些具体<strong>优化细节移交给HotSpot的JIT编译器负责</strong>。</p>
<p>复习: AOT(静态提前编译器，Ahead of Time Compiler)</p>
<h5 id="3、透过字节码指令看代码细节"><a href="#3、透过字节码指令看代码细节" class="headerlink" title="3、透过字节码指令看代码细节"></a>3、透过字节码指令看代码细节</h5><p>BAT面试题：</p>
<ol>
<li>类文件结构有几个部分?</li>
<li>知道字节码吗?字节码都有哪些? Integer x = 5;int y = 5;比较x == y都经过哪些步骤?</li>
</ol>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2、虚拟机的基石：class文件"><a href="#2、虚拟机的基石：class文件" class="headerlink" title="2、虚拟机的基石：class文件"></a>2、虚拟机的基石：class文件</h4><ul>
<li><p>字节码文件里是什么?</p>
<p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。</p>
</li>
<li><p>什么是字节码指令(byte code)?<br>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：</p>
<p><img src="/2021/04/19/JVM/image-20210504010005360.png" alt="image-20210504010005360"></p>
</li>
<li><p>如何解读供虚拟机解释执行的二进制字节码?</p>
<ol>
<li>方式一：一个一个二进制的看。这里用到的是Notepad++,需要安装一个HEX-Editor插件，或者使用Binary Viewer</li>
<li>方式二：使用javap指令：jdk 自带的反解析工具</li>
<li>方式三：使用IDEA插件：jclasslib或jclasslib bytecode viewer客户端工具。(可视化更好)</li>
</ol>
</li>
</ul>
<h4 id="3、class文件结构"><a href="#3、class文件结构" class="headerlink" title="3、class文件结构"></a>3、class文件结构</h4><h4 id="4、-使用javap指令解析Class文件"><a href="#4、-使用javap指令解析Class文件" class="headerlink" title="4、    使用javap指令解析Class文件"></a>4、    使用javap指令解析Class文件</h4><h3 id="2、字节码指令集与解析举例"><a href="#2、字节码指令集与解析举例" class="headerlink" title="2、字节码指令集与解析举例"></a>2、字节码指令集与解析举例</h3><h3 id="3、类的加载过程详解"><a href="#3、类的加载过程详解" class="headerlink" title="3、类的加载过程详解"></a>3、类的加载过程详解</h3><h3 id="4、再谈类的加载器"><a href="#4、再谈类的加载器" class="headerlink" title="4、再谈类的加载器"></a>4、再谈类的加载器</h3><p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/su20145104009/article/details/83095871">Java引用类型：强引用，软引用，弱引用，虚引用</a></p>
<p>相关网站：</p>
<p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数查找</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/VUE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/VUE/" class="post-title-link" itemprop="url">Vue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-19 03:10:19 / 修改时间：03:31:53" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">前端学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue官网</a></p>
<h2 id="一、邂逅Vuejs"><a href="#一、邂逅Vuejs" class="headerlink" title="一、邂逅Vuejs"></a>一、邂逅Vuejs</h2><h3 id="1、遇见Vuejs"><a href="#1、遇见Vuejs" class="headerlink" title="1、遇见Vuejs"></a>1、遇见Vuejs</h3><h4 id="1、认识Vuejs"><a href="#1、认识Vuejs" class="headerlink" title="1、认识Vuejs"></a>1、认识Vuejs</h4><ul>
<li><p>Vue (读Vue (读音 /vjuː/，类似于 <strong>view</strong>)音 /vjuː/，类似于 <strong>view</strong>)</p>
</li>
<li><p>Vue是一个渐进式的框架，渐进式的框架：</p>
<ul>
<li>渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</li>
<li>如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</li>
</ul>
</li>
<li><p>与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</li>
</ul>
<h4 id="2、Vue的特点和Web开发中常见的高级功能"><a href="#2、Vue的特点和Web开发中常见的高级功能" class="headerlink" title="2、Vue的特点和Web开发中常见的高级功能"></a>2、Vue的特点和Web开发中常见的高级功能</h4><ul>
<li>解耦视图和数据</li>
<li>可复用的组件</li>
<li>前端路由技术</li>
<li>状态管理</li>
<li>虚拟DOM</li>
</ul>
<h3 id="2、安装Vuejs"><a href="#2、安装Vuejs" class="headerlink" title="2、安装Vuejs"></a>2、安装Vuejs</h3><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html">安装</a></p>
<h4 id="1、方式一：下载和引入"><a href="#1、方式一：下载和引入" class="headerlink" title="1、方式一：下载和引入"></a>1、方式一：下载和引入</h4><p>在<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">官网</a>上直接下载vue.js文件引入到项目（本地）中，其中有<a target="_blank" rel="noopener" href="https://vuejs.org/js/vue.js">开发环境</a>与<a target="_blank" rel="noopener" href="https://vuejs.org/js/vue.min.js">生产环境</a>。</p>
<p>注意：</p>
<p>在下载时不能直接点击，直接点击的话你将看到vue.js的源码。应该右键选中<code>从链接另存文件</code>。</p>
<p><img src="/2021/04/19/VUE/01.png" alt="image-20210320014752045"></p>
<p>其中</p>
<ul>
<li><p>开发环境用在开发的时候，其中的代码包含了有帮助的命令行警告，方便程序员查看源代码，但相对的文件比较大。</p>
</li>
<li><p>生产环境用在发布产品的时候，其中的代码都是经过压缩的，优化了尺寸和速度，文件也比较小，方便用户下载，但代码的可读性极差。</p>
</li>
</ul>
<p>一句话总结：开发环境面向的是程序员，生产环境面向的是用户。</p>
<h4 id="2、方式二：直接CDN引入"><a href="#2、方式二：直接CDN引入" class="headerlink" title="2、方式二：直接CDN引入"></a>2、方式二：直接CDN引入</h4><p>你可以在你的项目中直接CDN（外部）引入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、方式三：NPM安装"><a href="#3、方式三：NPM安装" class="headerlink" title="3、方式三：NPM安装"></a>3、方式三：NPM安装</h4><p>在用 Vue 构建大型应用时推荐使用 NPM 安装[<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html#footnote-1">1]</a>。NPM 能很好地和诸如 <a target="_blank" rel="noopener" href="https://webpack.js.org/">webpack</a> 或 <a target="_blank" rel="noopener" href="http://browserify.org/">Browserify</a> 模块打包器配合使用。同时 Vue 也提供配套工具来开发<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最新稳定版</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install vue</span></span><br></pre></td></tr></table></figure>

<h3 id="3、第一个Vuejs程序"><a href="#3、第一个Vuejs程序" class="headerlink" title="3、第一个Vuejs程序"></a>3、第一个Vuejs程序</h3><p><img src="/2021/04/19/VUE/02.png" alt="image-20210320015424885"></p>
<h4 id="1、代码的执行"><a href="#1、代码的执行" class="headerlink" title="1、代码的执行"></a>1、代码的执行</h4><ol>
<li>阅读JavaScript代码，程序发现创建了一个Vue对象；</li>
<li>创建Vue对象的时候，传入了一些options：{}<ul>
<li>{}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上；</li>
<li>{}中包含了data属性：该属性中通常会存储一些数据：<ul>
<li>这些数据可以是我们直接定义出来的，比如像上面代码这样</li>
<li>也可能是来自网络，从服务器加载的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2、浏览器执行代码的流程"><a href="#2、浏览器执行代码的流程" class="headerlink" title="2、浏览器执行代码的流程"></a>2、浏览器执行代码的流程</h4><ol>
<li>执行到10~13行代码显然出对应的HTML；</li>
<li>执行第16行代码创建Vue实例，并且对原HTML进行解析和修改</li>
</ol>
<h4 id="3、响应式"><a href="#3、响应式" class="headerlink" title="3、响应式"></a>3、响应式</h4><p>Vue代码是可以实现响应式的。在浏览器里进入开发者模式<code>F12</code>中的<code>console</code>。在里面修改代码可以实现浏览器的内容也随着修改而响应着改变。</p>
<p><img src="/2021/04/19/VUE/03.png" alt="image-20210320020223661"></p>
<h3 id="4、Vue与JavaScript-（两种编程范式）"><a href="#4、Vue与JavaScript-（两种编程范式）" class="headerlink" title="4、Vue与JavaScript （两种编程范式）"></a>4、Vue与JavaScript （两种编程范式）</h3><ul>
<li><p>命令式编程（JavaScript ）</p>
<p>命令式编程的主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。</p>
<p>优点：数据和界面完全分离，不需要js创建页面元素等操作</p>
</li>
</ul>
<ul>
<li><p>声明式编程（Vuejs）</p>
<p>声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。</p>
<p>优点：当数据发生改变时界面自动发生改变（响应式）</p>
</li>
</ul>
<h3 id="5、Vue的MVVM"><a href="#5、Vue的MVVM" class="headerlink" title="5、Vue的MVVM"></a>5、Vue的MVVM</h3><h4 id="1、是什么MVVM"><a href="#1、是什么MVVM" class="headerlink" title="1、是什么MVVM"></a>1、是什么MVVM</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM">维基百科官方解释</a>：</p>
<p><strong>MVVM</strong>（<strong>Model–view–viewmodel</strong>）是一种软件<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a>。</p>
<p>MVVM有助于将<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">图形用户界面</a>的开发与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91">业务逻辑</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF">后端</a>逻辑（<em>数据模型</em>）的开发<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">分离</a>开来，这是通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">置标语言</a>或GUI代码实现的。MVVM的<em>视图模型</em>是一个值转换器，[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM#cite_note-MVVM-eliminates-valueconverters-1">1]</a> 这意味着视图模型负责从模型中暴露（转换）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">数据对象</a>，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM#cite_note-MVVM-eliminates-valueconverters-1">1]</a> 视图模型可以实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a>，组织对视图所支持的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E4%BE%8B">用例</a>集的后端逻辑的访问。</p>
<p><img src="/2021/04/19/VUE/184.png" alt="image-20210402232753389"></p>
<h4 id="2、Vue的MVVM"><a href="#2、Vue的MVVM" class="headerlink" title="2、Vue的MVVM"></a>2、Vue的MVVM</h4><p><img src="/2021/04/19/VUE/04.png" alt="image-20210320022023488"></p>
<ul>
<li>View层：<ul>
<li>视图层</li>
<li>在前端开发中，通常就是DOM层</li>
<li>主要的作用是给用户展示各种信息</li>
</ul>
</li>
<li>Model层：<ul>
<li>数据层</li>
<li>数据可能是我们固定的死数据，但更多的是来自我们服务器，从网络上请求下来的数据</li>
</ul>
</li>
<li>VueModel层：<ul>
<li>视图模型层</li>
<li>视图模型层是View和Model沟通的桥梁</li>
<li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li>
<li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data</li>
</ul>
</li>
</ul>
<h4 id="3、计数器的MVVM示例"><a href="#3、计数器的MVVM示例" class="headerlink" title="3、计数器的MVVM示例"></a>3、计数器的MVVM示例</h4><p>计数器：点击 <code>+</code> 计数器+1，点击 <code>-</code>  计数器 -1</p>
<p>在Vue对象中</p>
<ul>
<li>新属性：methods。该属性用于在Vue对象中定义方法。</li>
<li>新的指令：@click, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法(方法通常是methods中定义的方法)</li>
</ul>
<p><img src="/2021/04/19/VUE/05.png" alt="image-20210320022244195"></p>
<p><img src="/2021/04/19/VUE/06.png" alt="image-20210320022417139"></p>
<p>计数器中就有严格的MVVM思想：</p>
<ul>
<li>View依然是我们的DOM</li>
<li>Model就是我们我们抽离出来的obj</li>
<li>ViewModel就是我们创建的Vue对象实例</li>
</ul>
<p><img src="/2021/04/19/VUE/07.png" alt="01-计数器的MVVM"></p>
<p>它们之间如何工作呢？</p>
<ol>
<li>首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。</li>
<li>其次ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。</li>
</ol>
<p>有了Vue帮助我们完成VueModel层的任务，在后续的开发，我们就可以专注于数据的处理，以及DOM的编写工作了。</p>
<h3 id="6、创建Vue实例传入的options"><a href="#6、创建Vue实例传入的options" class="headerlink" title="6、创建Vue实例传入的options"></a>6、创建Vue实例传入的options</h3><p>在创建Vue实例的时候，传入了一个对象options。那么，这个options中可以包含哪些选项呢？<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">详细解析</a></p>
<ul>
<li><p>el：</p>
<p>传入类型：string | HTMLElement</p>
<p>作用：决定之后Vue实例会管理哪一个DOM，挂载要管理的元素</p>
<p>限制：只在用 <code>new</code> 创建实例时生效</p>
</li>
<li><p>data：</p>
<p>类型：Object | Function （组件当中data必须是一个函数）</p>
<p>作用：Vue实例对应的数据对象</p>
<p>限制：组件的定义只接受 <code>function</code></p>
</li>
<li><p>methods：</p>
<p>类型：{ [key: string]: Function }</p>
<p>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</p>
</li>
<li><p>components：</p>
<p>类型：<code>Object</code></p>
<p>详细：包含 Vue 实例可用组件的哈希表。</p>
</li>
<li><p>computed：</p>
<p>类型：<code>&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;</code></p>
<p>详细：</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p>
</li>
<li><p>生命周期函数：</p>
<p>所有的生命周期钩子<code>hook</code>自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。（粗体表示常用）</p>
<ul>
<li><p>beforeCreate：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
</li>
<li><p><strong>created</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>
</li>
<li><p>beforeMount：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>mounted</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></p>
</li>
<li><p>beforeUpdate：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
</li>
<li><p>updated：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p>
<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></p>
</li>
<li><p><strong>activated</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>deactivated：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>beforeDestroy：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>destroyed：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>errorCaptured：</p>
<blockquote>
<p>2.5.0+ 新增(<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#errorCaptured">具体查看</a>)</p>
</blockquote>
<p>类型：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
<p>详细：</p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7、Vue的生命周期"><a href="#7、Vue的生命周期" class="headerlink" title="7、Vue的生命周期"></a>7、Vue的生命周期</h3><p>以下图来自<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html">官网</a></p>
<p><img src="/2021/04/19/VUE/08.png" alt="Vue 实例生命周期"></p>
<img src="/2021/04/19/VUE/09.png" alt="image-20210320025609038" style="zoom: 200%;">

<p>简化：</p>
<p><img src="/2021/04/19/VUE/10.png" alt="image-20210320025717195"></p>
<h3 id="8、ES6补充"><a href="#8、ES6补充" class="headerlink" title="8、ES6补充"></a>8、ES6补充</h3><h4 id="1、let-var"><a href="#1、let-var" class="headerlink" title="1、let/var"></a>1、let/var</h4><p>事实上var的设计可以看成JavaScript语言设计上的错误. 但是这种错误多半不能修复和移除, 以为需要向后兼容。于是，大概十年前，Brendan Eich就决定修复这个问题, 于是他添加了一个新的关键字: let。</p>
<p>我们可以将let看成更完美的var</p>
<h5 id="1、块级作用域"><a href="#1、块级作用域" class="headerlink" title="1、块级作用域"></a>1、<strong>块级作用域</strong></h5><ul>
<li>JS中使用var来声明一个变量时, 变量的作用域主要是和函数的定义有关</li>
<li>针对于其他块定义来说是没有作用域的，比如if/for等，这在我们开发中往往会引起一些问题。</li>
</ul>
<p>我们可以通过ES6与ES5的不同来显示<strong>块级作用域</strong>的作用：</p>
<ul>
<li><p>ES5中的var是没有块级作用域的(if/for)，var只有在function中才有块级作用域。</p>
<p>ES5之前因为if和for都没有块级作用域的概念，所以在很多时候，我们都必须借助于function的作用域来解决应用外面变量的问题。</p>
</li>
<li><p>ES6中的let是由块级作用的(if/for)</p>
</li>
</ul>
<h5 id="2、没有块级作用域引起的问题"><a href="#2、没有块级作用域引起的问题" class="headerlink" title="2、没有块级作用域引起的问题"></a>2、没有块级作用域引起的问题</h5><p>for的块级：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line"> for (var i=0; i<span class="tag">&lt;<span class="name">btns.length;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">     <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">       <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">i</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">     &#125;)</span></span><br><span class="line"><span class="tag"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>效果：无论点击哪个按钮，日志打印的都是<code>第5个按钮被点击</code></p>
<p><img src="/2021/04/19/VUE/19.png" alt="image-20210320220031829"></p>
<p>说明：由于var没有块级作用域，被var定义的<code>i</code>会随着<code>i++</code>的改变而改变。function里面的<code>i</code>受到for循环的<code>i++</code>的影响，被改变成了<code>5</code>，所以输出的都是<code>第5个按钮被点击</code></p>
<h5 id="3、解决方法："><a href="#3、解决方法：" class="headerlink" title="3、解决方法："></a>3、解决方法：</h5><ol>
<li><p>用闭包可以解决问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">  for (var i=0; i<span class="tag">&lt;<span class="name">btns.length;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    (<span class="attr">function</span> (<span class="attr">num</span>) &#123; // <span class="attr">0</span></span></span><br><span class="line"><span class="tag">      <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">num</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">      &#125;)</span></span><br><span class="line"><span class="tag">    &#125;)(<span class="attr">i</span>)</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>为什么闭包可以解决问题：函数是一个作用域。</p>
</li>
<li><p>用ES6的let</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const btns = document.getElementsByTagName(&#x27;button&#x27;)</span><br><span class="line">for (let i = 0; i <span class="tag">&lt; <span class="attr">btns.length</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">i</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">  &#125;)</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2、const"><a href="#2、const" class="headerlink" title="2、const"></a>2、const</h3><ul>
<li>在很多语言中已经存在, 比如C/C++中, 主要的作用是将某个变量修饰为常量。</li>
<li>在JavaScript中也是如此, 使用const修饰的标识符为常量, 不可以再次赋值。</li>
</ul>
<p>什么时候使用：</p>
<p>当我们修饰的标识符<strong>不会被再次赋值</strong>时, 就可以使用const来<strong>保证数据的安全性</strong>。</p>
<p><strong>建议:</strong></p>
<p><strong>在ES6开发中,优先使用const, 只有需要改变某一个标识符的时候才使用let。</strong></p>
<p>使用const时要注意的点（以下代码为错误展示）：</p>
<ul>
<li><p>一旦给const修饰的标识符被赋值之后, 不能修改</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &#x27;why&#x27;;</span><br><span class="line">name = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用const定义标识符,必须进行赋值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    name: &#39;why&#39;,</span><br><span class="line">    age: 18,</span><br><span class="line">    height: 1.88</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; const修饰的标识符被赋值之后, 不能修改</span><br><span class="line">  &#x2F;&#x2F; obj &#x3D; &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 但是可以改变对象内部的属性</span><br><span class="line">  obj.name &#x3D; &#39;kobe&#39;;</span><br><span class="line">  obj.age &#x3D; 40;</span><br><span class="line">  obj.height &#x3D; 1.87;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、对象增强写法"><a href="#3、对象增强写法" class="headerlink" title="3、对象增强写法"></a>3、<strong>对象增强写法</strong></h3><p>ES6中，对<strong>对象字面量</strong>进行了很多增强。</p>
<p>属性初始化简写和方法的简写：</p>
<ul>
<li><p>属性初始化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age,</span><br><span class="line">  height: height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  height,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的简写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  run: function () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  eat: function () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ES6的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="二、Vue基础语法"><a href="#二、Vue基础语法" class="headerlink" title="二、Vue基础语法"></a>二、Vue基础语法</h2><h3 id="1、语法糖"><a href="#1、语法糖" class="headerlink" title="1、语法糖"></a>1、语法糖</h3><p>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>语法糖对程序员来说是友好的，但对机器本身却不怎么好。语法糖越甜，编译成的二进制也就越麻烦，出错的时候也会带来更多的麻烦。程序员要做的不是尽力避免错误，而是聚焦在快速发现并改正错误。真正以快速方式轻易解决错误，“快速的失败”远胜过“预防错误”。</p>
<p>Vue中常用的语法糖：</p>
<ul>
<li><code>v-bind</code>：<code>:</code></li>
<li><code>v-on</code>：<code>@</code></li>
<li><code>v-once</code>：<code>.once</code></li>
</ul>
<h3 id="2、插值语法"><a href="#2、插值语法" class="headerlink" title="2、插值语法"></a>2、插值语法</h3><h4 id="1、mustache语法"><a href="#1、mustache语法" class="headerlink" title="1、mustache语法"></a>1、mustache语法</h4><p>Mustache（胡子/胡须）是一款「logic-less（轻逻辑）」的前端模板引擎，它原本是基于 javascript 实现的，但是因为轻量易用，所以经过拓展目前支持更多的平台，如 java，.NET，PHP，C++ 等。Mustache 主要用于在表现和数据相分离的前端技术架构中，根据数据生成特定的动态内容，这些内容在网页中指的是HTML结构，而在小程序中则是WXML结构。在前后端分离的技术架构下面，前端模板引擎是一种可以被考虑的技术选型，随着重型框架（AngularJS、ReactJS、Vue）的流行，前端的模板技术已经成为了某种形式上的标配，Mustache 的价值在于其稳定和经典</p>
<p>主页：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://mustache.github.io/mustache.5.html">https://mustache.github.io/mustache.5.html</a></p>
<p>项目主页：<a target="_blank" rel="noopener" href="http://mustache.github.io/">http://mustache.github.io/</a></p>
<p>Handlebars：基于 Mustache 的模板引擎：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://handlebarsjs.com/">http://handlebarsjs.com/</a></p>
<p>对于Vue简单来说："{{}}"（双大括号）不仅仅可以直接写变量,也可以写简单的表达式

更多的Mustache功能参考：https://www.jianshu.com/p/7f1cecdc27e1

我们可以像下面这样来使用，并且数据是响应式的：

![image-20210320030738172](VUE/11.png)

#### 2、v-once

在某些情况下，我们可能不希望界面随意的跟随改变，这个时候，我们就可以使用一个Vue的指令：v-once

v-once：

- 该指令后面不需要跟任何表达式(比如v-for后面是由跟表达式的)
- p该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。

代码：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

效果：

![image-20210320032116662](VUE/12.png)

#### 3、v-html

某些情况下，我们从服务器请求到的数据本身就是一个HTML代码。如果我们直接通过"{{}}"来输出，会将HTML代码也一起输出。但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。这个时候，我们就可以使用一个Vue的指令：v-html</p>
<p>v-html：</p>
<ul>
<li>该指令后面往往会跟上一个string类型</li>
<li>会将string的html解析出来并且进行渲染</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">      url: &#x27;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<h4 id="4、v-text（不常用）"><a href="#4、v-text（不常用）" class="headerlink" title="4、v-text（不常用）"></a><img src="/2021/04/19/VUE/13.png" alt="image-20210320032430169">4、v-text（不常用）</h4><p>nv-text作用和Mustache比较相似：都是用于将数据显示在界面中</p>
<p>nv-text</p>
<ul>
<li>通常情况下，接受一个string类型</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;, 李银河!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span>, 李银河!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/04/19/VUE/14.png" alt="image-20210320032749380"></p>
<h4 id="5、v-pre"><a href="#5、v-pre" class="headerlink" title="5、v-pre"></a>5、v-pre</h4><p>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</p>
<p>比如下面的代码：</p>
<ul>
<li>第一个h2元素中的内容会被编译解析出来对应的内容</li>
<li>第二个h2元素中会直接显示</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/04/19/VUE/15.png" alt="image-20210320032946332"></p>
<h4 id="6、v-cloak"><a href="#6、v-cloak" class="headerlink" title="6、v-cloak"></a>6、v-cloak</h4><p>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签（加载过慢）。</p>
<p>v-cloak</p>
<ul>
<li>存在期限：在vue解析之前存在，在vue解析之后消失。</li>
<li>该指令后面不需要跟任何表达式</li>
</ul>
<p>cloak：斗篷（起遮挡作用）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在vue解析之前, div中有一个属性v-cloak</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在vue解析之后, div中没有一个属性v-cloak</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>在没加v-cloak之前，浏览器先显示，过1s后显示“你好啊”</li>
<li>在加了v-cloak之后，浏览器先显示空白，过1s后显示“你好啊”</li>
</ul>
<h3 id="3、绑定属性（v-bind）"><a href="#3、绑定属性（v-bind）" class="headerlink" title="3、绑定属性（v-bind）"></a>3、绑定属性（v-bind）</h3><h4 id="1、v-bind基础"><a href="#1、v-bind基础" class="headerlink" title="1、v-bind基础"></a>1、v-bind基础</h4><p>前面的插值指令主要作用是将值插入到我们<strong>模板的内容</strong>当中。但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。</p>
<ul>
<li>比如动态绑定a元素中网站的链接href</li>
<li>比如动态绑定img元素的src属性</li>
<li>动态绑定一些类、样式</li>
</ul>
<p>v-bind指令：</p>
<ul>
<li>作用：绑定一个或多个属性值，或者向另一个组件传递props值</li>
<li>缩写：<code>:</code></li>
<li>预期：any (with argument) | Object (without argument)</li>
<li>参数：attrOrProp (optional)</li>
</ul>
<p>通过Vue实例中的data绑定元素的src和href：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;img src=&quot;&#123;&#123;imgURL&#125;&#125;&quot; alt=&quot;&quot;&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 正确的做法: 使用v-bind指令 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;aHref&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--语法糖的写法--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;aHref&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      imgURL: <span class="string">&#x27;https://vuejs.org/images/log.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      aHref: <span class="string">&#x27;https://vuejs.org&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、v-bind绑定class"><a href="#2、v-bind绑定class" class="headerlink" title="2、v-bind绑定class"></a>2、v-bind绑定class</h4><p>很多时候，我们希望动态的来切换class：</p>
<ul>
<li>当数据为某个状态时，字体显示红色。</li>
<li>当数据另一个状态时，字体显示黑色。</li>
</ul>
<h5 id="1、绑定方式：对象语法"><a href="#1、绑定方式：对象语法" class="headerlink" title="1、绑定方式：对象语法"></a>1、绑定方式：对象语法</h5><p>对象语法的含义是:class后面跟的是一个对象。</p>
<p>语法：v-bind:class=’{类名: boolean,类名: boolean}’</p>
<p>eg：v-bind:class=”{类名1: true, 类名2: boolean}</p>
<p>对象语法有下面这些用法：</p>
<ul>
<li><p>直接通过{}绑定一个类：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过判断，传入多个值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的类同时存在，并不冲突</p>
<p>注：如果isActive和isLine都为true，那么会有title/active/line三个class</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果过于复杂，可以放在一个methods或者<code>computed</code>中</p>
<p>注：classes是一个<code>计算属性</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isActive: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      isLine: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      classes: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">active</span>: <span class="built_in">this</span>.isActive, <span class="attr">line</span>: <span class="built_in">this</span>.isLine&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、绑定方式：数组语法"><a href="#2、绑定方式：数组语法" class="headerlink" title="2、绑定方式：数组语法"></a>2、绑定方式：数组语法</h5><p>数组语法的含义是:class后面跟的是一个数组。</p>
<p>数组语法有下面这些用法：</p>
<ul>
<li><p>直接通过{}绑定一个类：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;,&#x27;line&#x27;]&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的类同时存在，并不冲突</p>
<p>注：会有title/active/line三个class</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">“[‘active’,</span> &#x27;<span class="attr">line</span>&#x27;]&quot;&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果过于复杂，可以放在一个methods或者computed中</p>
<p>注：classes是一个<code>计算属性</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      active: <span class="string">&#x27;aaaaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      line: <span class="string">&#x27;bbbbbbb&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getClasses: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> [<span class="built_in">this</span>.active, <span class="built_in">this</span>.line]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、v-bind绑定style"><a href="#3、v-bind绑定style" class="headerlink" title="3、v-bind绑定style"></a>3、v-bind绑定style</h4><p>我们可以利用v-bind:style来绑定一些CSS内联样式。</p>
<p>在写CSS属性名的时候，比如font-size</p>
<ul>
<li>我们可以使用驼峰式 (camelCase) fontSize </li>
<li>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</li>
</ul>
<h5 id="1、绑定方式：对象语法-1"><a href="#1、绑定方式：对象语法-1" class="headerlink" title="1、绑定方式：对象语法"></a>1、绑定方式：对象语法</h5><p>style后面跟的是一个对象类型</p>
<ul>
<li>对象的key是<code>CSS属性名称</code></li>
<li>对象的value是具体赋的值，值可以来自于data中的属性</li>
<li>如果过于复杂，可以放在一个methods或者<code>computed</code>中</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span> &#123;</span></span><br><span class="line">      font-size: 50px;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2 :style=&quot;&#123;key(属性名): value(属性值)&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--&#x27;50px&#x27;必须加上单引号, 否则是当做一个变量去解析--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: &#x27;50px&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--finalSize当成一个变量使用--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2 :style=&quot;&#123;fontSize: finalSize&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: finalSize + &#x27;px&#x27;, backgroundColor: finalColor&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;getStyles()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line">      finalSize: 100,</span><br><span class="line"><span class="javascript">      finalColor: <span class="string">&#x27;red&#x27;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getStyles: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">fontSize</span>: <span class="built_in">this</span>.finalSize + <span class="string">&#x27;px&#x27;</span>, <span class="attr">backgroundColor</span>: <span class="built_in">this</span>.finalColor&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、绑定方式：数组语法-1"><a href="#2、绑定方式：数组语法-1" class="headerlink" title="2、绑定方式：数组语法"></a>2、绑定方式：数组语法</h5><p>style后面跟的是一个数组类型</p>
<ul>
<li>多个值以<code>,</code>分割即可</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyle, baseStyle1]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      baseStyle: &#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">      baseStyle1: &#123;<span class="attr">fontSize</span>: <span class="string">&#x27;100px&#x27;</span>&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、计算属性（computed）"><a href="#4、计算属性（computed）" class="headerlink" title="4、计算属性（computed）"></a>4、计算属性（computed）</h3><h4 id="1、是什么计算属性"><a href="#1、是什么计算属性" class="headerlink" title="1、是什么计算属性"></a>1、是什么计算属性</h4><p>在模板中可以直接通过插值语法显示一些data中的数据。但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示：</p>
<ul>
<li><p>比如我们有firstName和lastName两个变量，我们需要显示完整的名称：</p>
<ul>
<li> </li>
<li>undefined undefined
</li>
</ul>
</li>
<li><p>但是如果多个地方都需要显示完整的名称，我们就需要写多个</p>
 。代码臃肿

</li>
</ul>
<p>我们可以将上面的代码换成计算属性：写在实例Vue的computed选项中的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Lebron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;James&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// computed: 计算属性()</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、计算属性："><a href="#2、计算属性：" class="headerlink" title="2、计算属性："></a>2、计算属性：</h4><ul>
<li><p>解决代码臃肿</p>
</li>
<li><p>可以进行一些更加复杂的操作</p>
<p><img src="/2021/04/19/VUE/16.png" alt="image-20210320150614370"></p>
</li>
<li><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p>
</li>
</ul>
<h4 id="3、计算属性的setter和getter"><a href="#3、计算属性的setter和getter" class="headerlink" title="3、计算属性的setter和getter"></a>3、计算属性的setter和getter</h4><p>每个计算属性都包含一个getter和一个setter</p>
<ul>
<li><p>在上面的例子中，我们只是使用getter来读取。</p>
</li>
<li><p>在某些情况下，你也可以提供一个setter方法（不常用）。</p>
<p>由于一般我们不希望有人能任意修改我们的计算属性的值，所以一般省略setter方法。而计算属性的getter就能简写成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 简写前（如果有setter方法）：</span><br><span class="line">computed: &#123;</span><br><span class="line">	  fullName: &#123;</span><br><span class="line">		get() &#123;</span><br><span class="line">		  console.log(&#x27;---调用了fullName的get&#x27;);</span><br><span class="line">		  return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;,</span><br><span class="line">		set(newValue) &#123;</span><br><span class="line">		  console.log(&#x27;---调用了fullName的get&#x27;);</span><br><span class="line">		  const names = newValue.split(&#x27; &#x27;);</span><br><span class="line">		  this.firstName = names[0];</span><br><span class="line">		  this.lastName = names[1];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写后：</span><br><span class="line">computed: &#123;</span><br><span class="line">      fullName: function () &#123;</span><br><span class="line">        return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、methods与computed"><a href="#4、methods与computed" class="headerlink" title="4、methods与computed"></a>4、methods与computed</h4><p>methods和computed看起来都可以实现我们的功能，那么为什么还要多一个计算属性这个东西呢？</p>
<p>原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1.直接拼接: 语法过于繁琐--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--2.通过定义methods--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--3.通过computed--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// angular -&gt; google</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// TypeScript(microsoft) -&gt; ts(类型检测)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// flow(facebook) -&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;getFullName&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;fullName&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>当使用computed时：由于有缓存，浏览器只执行了一次。</p>
<p><img src="/2021/04/19/VUE/17.png" alt="image-20210320153300912"></p>
</li>
<li><p>当使用methods时：没有缓存，浏览器执行多次，加重了浏览器的负担。</p>
<p><img src="/2021/04/19/VUE/18.png" alt="image-20210320153616146"></p>
</li>
</ul>
<h3 id="5、事件监听（v-on）"><a href="#5、事件监听（v-on）" class="headerlink" title="5、事件监听（v-on）"></a>5、事件监听（v-on）</h3><p>在前端开发中，我们需要经常和用于交互。</p>
<p>这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等</p>
<p>在Vue中如何监听事件呢？使用v-on指令</p>
<p>v-on：</p>
<ul>
<li><strong>作用</strong>：绑定事件监听器</li>
<li><strong>缩写</strong>（语法糖）：@</li>
<li><strong>预期</strong>：Function | Inline Statement | Object</li>
<li><strong>参数</strong>：event</li>
</ul>
<h4 id="1、v-on基础"><a href="#1、v-on基础" class="headerlink" title="1、v-on基础"></a>1、v-on基础</h4><ul>
<li><p>一般v-on后面加上<code>:</code>，然后加上<code>动作</code>如点击（click）、拖拽、键盘事件（keyup/keydown）等等。</p>
</li>
<li><p>若v-on监听的事件简单，可以在v-on后面直接实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若v-on监听的事件复杂，就需要将事件的实现抽取成一个方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      increment() &#123;</span><br><span class="line">        this.counter++</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、v-on参数"><a href="#2、v-on参数" class="headerlink" title="2、v-on参数"></a>2、v-on参数</h4><p>当通过methods中定义方法，以供@click调用时，需要<strong>注意参数问题</strong>：</p>
<ul>
<li><p>如果该方法不需要额外参数，那么方法后的()可以不添加。</p>
<p>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.事件调用的方法没有参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.1函数后添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.1函数后不添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn1Click() &#123;</span><br><span class="line">        console.log(&quot;btn1Click&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, 这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.1函数后没添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.2函数需要参数,()里传入参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;button @click=&quot;btn2Click(123)&quot;&gt;按钮2&lt;/button&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.3如果函数需要参数,但是没有传入, 那么函数的形参为undefined--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;button @click=&quot;btn2Click()&quot;&gt;按钮2&lt;/button&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn2Click(event) &#123;</span><br><span class="line">        console.log(&#x27;--------&#x27;, event);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1的效果：</p>
<p><img src="/2021/04/19/VUE/20.png" alt="image-20210320232959026"></p>
<p>2.3的效果：</p>
<p><img src="/2021/04/19/VUE/21.png" alt="image-20210320233429354"></p>
</li>
<li><p>如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.1在调用函数时, 如何手动的获取到浏览器参数的event对象: $event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;abc&#x27;, $event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.2在调用函数时，若event没有加$，那么浏览器将默认将event当成一个变量，若event在app实例里没有定义的话，浏览器会找不到该变量而报错并且返回undefined--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;abc&#x27;, event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.3在调用函数时，若函数没传入参数，那么浏览器将默认将浏览器参数的event放入第一个参数中，又因为第二个参数没有传值，浏览器会将其变为undefined--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn3Click(abc, event) &#123;</span><br><span class="line">        console.log(&#x27;++++++++&#x27;, abc, event);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.1的效果：</p>
<p><img src="/2021/04/19/VUE/22.png" alt="image-20210320234009069"></p>
<p>3.2的效果：</p>
<p><img src="/2021/04/19/VUE/23.png" alt="image-20210320235528249"></p>
<p>3.3的效果：</p>
<p><img src="/2021/04/19/VUE/24.png" alt="image-20210320235715797"></p>
</li>
</ul>
<h4 id="3、v-on修饰符"><a href="#3、v-on修饰符" class="headerlink" title="3、v-on修饰符"></a>3、v-on修饰符</h4><p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。Vue提供了修饰符来帮助我们方便的处理一些事件：</p>
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li>
<li>.native - 监听组件根元素的原生事件。</li>
<li>.once - 只触发一次回调。</li>
</ul>
<p><img src="/2021/04/19/VUE/25.png" alt="image-20210321000423484"></p>
<p>更多修饰符参考<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">官网的事件修饰符</a>，以下来自官网。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6、条件判断"><a href="#6、条件判断" class="headerlink" title="6、条件判断"></a>6、条件判断</h3><h4 id="1、v-if、v-else-if、v-else"><a href="#1、v-if、v-else-if、v-else" class="headerlink" title="1、v-if、v-else-if、v-else"></a>1、v-if、v-else-if、v-else</h4><ul>
<li><p>这三个指令与JavaScript的条件语句if、else、else if类似。</p>
</li>
<li><p>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件。</p>
</li>
</ul>
<p>简单的案例演示：</p>
<p><img src="/2021/04/19/VUE/26.png" alt="image-20210321004504280"></p>
<p><img src="/2021/04/19/VUE/27.png" alt="image-20210321005848254"></p>
<p>v-if的原理：</p>
<ul>
<li><p>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。</p>
</li>
<li><p>也就是根本没有不会有对应的标签出现在DOM中。</p>
</li>
</ul>
<h4 id="2、一个简单的小案例（用户登陆方式切换）"><a href="#2、一个简单的小案例（用户登陆方式切换）" class="headerlink" title="2、一个简单的小案例（用户登陆方式切换）"></a>2、一个简单的小案例（用户登陆方式切换）</h4><p>用户再登录时，可以切换使用用户账号登录还是邮箱地址登录。类似如下情景：</p>
<p><img src="/2021/04/19/VUE/28.png" alt="image-20210321013857218"></p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isUser = !isUser&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isUser: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h5><p>以上案例会有一个小问题：如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。</p>
<p>为什么呢？按道理讲，我们在一个input输入的内容（value），在切换到另外一个input元素后应该消失，因为在另一个input元素中，我们并没有输入内容。</p>
<h5 id="2、问题解答"><a href="#2、问题解答" class="headerlink" title="2、问题解答"></a>2、问题解答</h5><ul>
<li>这是因为Vue在进行渲染时，不会直接渲染在浏览器上面，Vue会在其之间构建一个虚拟NOM，Vue会先渲染在虚拟DOM上面，然后在渲染在浏览器上。而出于性能考虑，当出现两个只存在一个（if -else）的时候，会尽可能的复用已经存在的元素，而不是重新创建新的元素。</li>
<li>在上面的案例中，Vue内部会发现原来（if）的input元素不再使用，直接作为else中的input来使用了。此时并不会重新构建一个input，并且改变的只有与之前input不同的内容（如for、id、placeholder等等），所以文本里面的内容不会改变。</li>
</ul>
<h5 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h5><p>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key</p>
<p>并且需要我们保证key的值不同。（若key的值相同的话还是会继承文本内容）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、v-show"><a href="#3、v-show" class="headerlink" title="3、v-show"></a>3、<strong>v-show</strong></h4><p>v-show的用法和v-if非常相似，也用于决定一个元素是否渲染</p>
<p><strong>v-if和v-show对比：</strong></p>
<ul>
<li>v-if: 当条件为false时, 包含v-if指令的元素, 根本就不会存在dom中</li>
<li>v-show: 当条件为false时, v-show只是给我们的元素添加一个行内样式: display: none</li>
</ul>
<p>v-if和v-show都可以决定一个元素是否渲染，<strong>开发中如何选择</strong>呢：</p>
<ul>
<li>当需要在显示与隐藏之间切换很频繁时，使用v-show</li>
<li>当只有一次切换时，通过使用v-if</li>
</ul>
<h3 id="7、循环遍历（v-for）"><a href="#7、循环遍历（v-for）" class="headerlink" title="7、循环遍历（v-for）"></a>7、循环遍历（v-for）</h3><h4 id="1、v-for遍历数组"><a href="#1、v-for遍历数组" class="headerlink" title="1、v-for遍历数组"></a>1、v-for遍历数组</h4><p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成</p>
<ul>
<li><p>v-for的语法类似于JavaScript中的for循环。</p>
</li>
<li><p>格式如下：item in items的形式。</p>
</li>
<li><p>如果在遍历的过程中不需要使用索引值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在遍历的过程中，我们需要拿到元素在数组中的索引值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in names&quot;</span>&gt;</span></span><br><span class="line">      // 使遍历从1开始</span><br><span class="line">      &#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、v-for遍历对象"><a href="#2、v-for遍历对象" class="headerlink" title="2、v-for遍历对象"></a>2、v-for遍历对象</h4><p>当有一对象需要我们对其里面的数据进行渲染时，我们就可以使用v-for来完成</p>
<ul>
<li><p>在遍历对象的过程中, 如果只是获取一个值, 那么获取到的是value</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in info&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why</li>
<li>18</li>
<li>1.88</li>
</ul>
</li>
<li><p>获取key和value 格式: (value, key)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why-name</li>
<li>18-age</li>
<li>1.88-height</li>
</ul>
</li>
<li><p>获取key和value和index 格式: (value, key, index)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why-name-1</li>
<li>18-age-2</li>
<li>1.88-height-3</li>
</ul>
</li>
</ul>
<h4 id="3、v-for的组件的key属性"><a href="#3、v-for的组件的key属性" class="headerlink" title="3、v-for的组件的key属性"></a>3、v-for的组件的key属性</h4><p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。</p>
<p>为什么需要这个key属性呢？</p>
<ul>
<li><p>这个其实和Vue的虚拟DOM的Diff算法有关系</p>
</li>
<li><p>我们借用<a href="https://link.zhihu.com/?target=https://calendar.perfplanet.com/2013/diff/">React’s</a><a href="https://link.zhihu.com/?target=https://calendar.perfplanet.com/2013/diff/"> diff algorithm</a>中的一张图来简单说明一下：</p>
<p><img src="/2021/04/19/VUE/29.png" alt="image-20210321153710582"></p>
</li>
<li><p>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点</p>
<ul>
<li>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的</li>
<li>即把C更新成F，D更新成C，E更新成D，最后再插入E</li>
</ul>
</li>
<li><p>这样做会使程序的执行效率变低，所以可以用<code>key</code>这个属性来给每个节点做一个唯一标识</p>
<ul>
<li>Diff算法就可以正确的识别此节点</li>
<li>找到正确的位置区插入新的节点</li>
</ul>
</li>
<li><p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
</li>
</ul>
<h4 id="4、检测数组更新（响应式）"><a href="#4、检测数组更新（响应式）" class="headerlink" title="4、检测数组更新（响应式）"></a>4、检测数组更新（响应式）</h4><p>因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。</p>
<p>Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新：</p>
<ul>
<li><p>push()：在数组末尾添加一个或多个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.push(&#x27;aaa&#x27;)</span><br><span class="line">this.letters.push(&#x27;aaaa&#x27;, &#x27;bbbb&#x27;, &#x27;cccc&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()：删除数组中的最后一个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.pop();</span><br></pre></td></tr></table></figure>
</li>
<li><p>shift()：删除数组中的第一个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.shift();</span><br></pre></td></tr></table></figure>
</li>
<li><p>unshift()：在数组最前面添加一个或多个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.unshift()</span><br><span class="line">this.letters.unshift(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice(start,index,…items)：删除元素/插入元素/替换元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素)</span><br><span class="line">this.letters.splice(1, 3)</span><br><span class="line">this.letters.splice(1)</span><br><span class="line"></span><br><span class="line">// 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素</span><br><span class="line">this.letters.splice(1, 3, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line">// 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素</span><br><span class="line">this.letters.splice(1, 0, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>sort()：对数组进行排序。（参数可以添加排序的规则的方法）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.sort()</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.reverse()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：通过<code>索引值</code>修改数组中的元素不能做到响应式</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters[0] = &#x27;bbbbbb&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时可以通过splice方法或Vue的set方法的方式来修改以达到响应式的目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// splice方法</span><br><span class="line">this.letters.splice(0, 1, &#x27;bbbbbb&#x27;)</span><br><span class="line"></span><br><span class="line">// Vue的set(要修改的对象, 索引值, 修改后的值)</span><br><span class="line">Vue.set(this.letters, 0, &#x27;bbbbbb&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="5、作业：（v-for-v-bind-v-on-当前索引方法的应用）"><a href="#5、作业：（v-for-v-bind-v-on-当前索引方法的应用）" class="headerlink" title="5、作业：（v-for + v-bind + v-on + 当前索引方法的应用）"></a>5、作业：（v-for + v-bind + v-on + 当前索引方法的应用）</h4><p>需求：有一电影列表，点击哪一部影片，哪一部影片就表现为红色。</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>homework<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.active</span>&#123;</span></span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(movie,index) in movies&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">&quot;&#123;active: currentIndex === index&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">click</span>=<span class="string">&quot;isClick(index)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;index&#125;&#125;.&#123;&#123;movie&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      movies: [<span class="string">&#x27;海贼王&#x27;</span>,<span class="string">&#x27;火影忍者&#x27;</span>,<span class="string">&#x27;进击的巨人&#x27;</span>,<span class="string">&#x27;妖精的尾巴&#x27;</span>],</span></span><br><span class="line">      currentIndex: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      isClick: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.currentIndex = index</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6、高阶函数filter-map-reduce"><a href="#6、高阶函数filter-map-reduce" class="headerlink" title="6、高阶函数filter|map|reduce"></a>6、高阶函数filter|map|reduce</h4><h5 id="1、filter：过滤作用"><a href="#1、filter：过滤作用" class="headerlink" title="1、filter：过滤作用"></a>1、filter：过滤作用</h5><p>filter函数的参数是一个回调函数，返回值为一个数组：</p>
<ul>
<li>回调函数的参数为循环遍历的值n</li>
<li>回调函数有一个要求: 必须返回一个boolean值<ul>
<li>true: 当返回true时, 函数内部会自动将这次回调的n加入到新的数组中</li>
<li>false：当返回false时, 函数内部会过滤掉这次的n</li>
</ul>
</li>
</ul>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const nums = [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">// newNums = [10,20,40,50]</span><br><span class="line">let newNums = nums.filter(function (n) &#123;</span><br><span class="line">  return n <span class="tag">&lt; <span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="2、map：映射作用"><a href="#2、map：映射作用" class="headerlink" title="2、map：映射作用"></a>2、map：映射作用</h5><p>map函数的参数是一个回调函数，返回值为一个数组：</p>
<ul>
<li>回调函数的参数为循环遍历的值n</li>
<li>可以在回调函数内对数组的值进行操作，map会帮操作完的值映射到一个新的数组</li>
</ul>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// newNums = [10,20,40,50]</span><br><span class="line">// new2Nums = [20,40,80,100]</span><br><span class="line">let new2Nums = newNums.map(function (n) &#123; // 20</span><br><span class="line">  return n * 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、reduce：作用对数组中所有的内容进行汇总"><a href="#3、reduce：作用对数组中所有的内容进行汇总" class="headerlink" title="3、reduce：作用对数组中所有的内容进行汇总"></a>3、reduce：作用对数组中所有的内容进行汇总</h5><p>map函数的参数是一个回调函数，和一个初始值</p>
<ul>
<li>回调函数有两个参数（previousValue，start）<ul>
<li>previousValue：数组当前值的前一个值</li>
<li>start：数组当前值</li>
</ul>
</li>
<li>初始值为数组一开始值（第一个元素，index=0）的前一个值</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// new2Nums = [20,40,80,100]</span><br><span class="line">// total = 240</span><br><span class="line">let total = new2Nums.reduce(function (preValue, n) &#123;</span><br><span class="line">  return preValue + n</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>

<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><p>需求：筛选出数组nums里所有小于100的值，然后就值乘以2再相加。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const nums = [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">let total = nums.filter(function (n) &#123;</span><br><span class="line">  return n <span class="tag">&lt; <span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#125;)<span class="attr">.map</span>(<span class="attr">function</span> (<span class="attr">n</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">return</span> <span class="attr">n</span> * <span class="attr">2</span></span></span><br><span class="line"><span class="tag">&#125;)<span class="attr">.reduce</span>(<span class="attr">function</span> (<span class="attr">prevValue</span>, <span class="attr">n</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">return</span> <span class="attr">prevValue</span> + <span class="attr">n</span></span></span><br><span class="line"><span class="tag">&#125;, <span class="attr">0</span>)</span></span><br></pre></td></tr></table></figure>

<p>以上三个高阶函数的回调函数都可以用箭头函数表示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let total = nums.filter(n =&gt; n <span class="tag">&lt; <span class="attr">100</span>)<span class="attr">.map</span>(<span class="attr">n</span> =&gt;</span> n * 2).reduce((pre, n) =&gt; pre + n)</span><br></pre></td></tr></table></figure>

<h3 id="8、表单绑定（v-mode）"><a href="#8、表单绑定（v-mode）" class="headerlink" title="8、表单绑定（v-mode）"></a>8、表单绑定（v-mode）</h3><h4 id="1、v-mode基础"><a href="#1、v-mode基础" class="headerlink" title="1、v-mode基础"></a>1、v-mode基础</h4><p>表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。</p>
<p>Vue中使用v-model指令来实现表单元素和数据的双向绑定。</p>
<p>案例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/VUE/30.png" alt="image-20210321210459660"></p>
<p>案例的解析：</p>
<p>当我们在输入框输入内容时，因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。所以，通过v-model实现了双向的绑定。</p>
<p>当然，我们也可以将v-model用于textarea元素。</p>
<h4 id="2、v-mode的原理"><a href="#2、v-mode的原理" class="headerlink" title="2、v-mode的原理"></a>2、v-mode的原理</h4><p>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</p>
<ul>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同与--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;valueChange&quot;</span>&gt;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">      valueChange(event) &#123;</span><br><span class="line">        this.message = event.target.value;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--也等同与--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、v-mode：radio"><a href="#3、v-mode：radio" class="headerlink" title="3、v-mode：radio"></a>3、v-mode：radio</h4><p>当存在多个单选框时，v-mode可用于将单选框的值和与之对应变量进行双向绑定。</p>
<p>其中一个label与一个input组合，label里面的for与input里面的id一一对应，实现用户点击文字就可以选中对应的单选框。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的性别是: &#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      sex: <span class="string">&#x27;女&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、v-mode：checkbox"><a href="#4、v-mode：checkbox" class="headerlink" title="4、v-mode：checkbox"></a>4、v-mode：checkbox</h4><p>checkbox复选框分为两种情况：单个勾选框和多个勾选框</p>
<ul>
<li><p>单个勾选框：</p>
<ul>
<li><p>v-model即为布尔值</p>
</li>
<li><p>此时input的value并不影响v-model的值</p>
</li>
<li><p>常用于让用户点击<code>同意协议</code>后才能点击<code>下一步</code>的业务场景</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;licence&quot;</span>&gt;</span>--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;licence&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的是: &#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isAgree: <span class="literal">false</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多个复选框</p>
<ul>
<li><p>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组</p>
</li>
<li><p>当选中某一个时，就会将input的value添加到数组中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;足球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>足球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好是: &#123;&#123;hobbies&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--label中的:for与input的:id对应--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in originHobbies&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      hobbies: [],</span><br><span class="line"><span class="javascript">      originHobbies: [<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>, <span class="string">&#x27;台球&#x27;</span>, <span class="string">&#x27;高尔夫球&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="5、v-mode：select"><a href="#5、v-mode：select" class="headerlink" title="5、v-mode：select"></a>5、v-mode：select</h4><p>select也分单选和多选两种情况：</p>
<ul>
<li><p>单选：只能选中一个值：</p>
<ul>
<li><p>v-model绑定的是一个值</p>
</li>
<li><p>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是: &#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 默认香蕉</span></span></span><br><span class="line"><span class="javascript">      fruit: <span class="string">&#x27;香蕉&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多选：可以选中多个值（属性加上multiple）：</p>
<ul>
<li><p>v-model绑定的是一个数组</p>
</li>
<li><p>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是: &#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      fruits: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="6、值绑定"><a href="#6、值绑定" class="headerlink" title="6、值绑定"></a>6、值绑定</h4><p>动态的给value赋值而已。我们前面的value中的值，都是在定义input的时候直接给定的（写死），但是真实开发中，这些input的值可能是从网络获取或定义在data中的。所以我们可以通过v-bind:value动态的给value绑定值（其实就是v-bind在input中的应用）</p>
<h4 id="7、修饰符"><a href="#7、修饰符" class="headerlink" title="7、修饰符"></a>7、修饰符</h4><h5 id="1、lazy修饰符"><a href="#1、lazy修饰符" class="headerlink" title="1、lazy修饰符"></a>1、lazy修饰符</h5><p>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</p>
<p>lazy修饰符可以让数据在失去焦点或者回车时才会更新。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>聚焦时：</li>
</ul>
<p><img src="/2021/04/19/VUE/31.png" alt="image-20210321214116893"></p>
<ul>
<li>失焦时：</li>
</ul>
<p><img src="/2021/04/19/VUE/32.png" alt="image-20210321214156460"></p>
<h5 id="2、number修饰符"><a href="#2、number修饰符" class="headerlink" title="2、number修饰符"></a>2、number修饰符</h5><p>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</p>
<p>number修饰符可以让在输入框中输入的内容自动转成数字类型</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      age: 18</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>没加number：</p>
<p><img src="/2021/04/19/VUE/33.png" alt="image-20210321214845631"></p>
</li>
<li><p>加上number：</p>
<p><img src="/2021/04/19/VUE/34.png" alt="image-20210321214942404"></p>
</li>
</ul>
<h4 id="3、trim修饰符"><a href="#3、trim修饰符" class="headerlink" title="3、trim修饰符"></a>3、trim修饰符</h4><p>如果输入的内容首尾有很多空格，通常我们希望将其去除，trim修饰符可以过滤内容左右两边的空格（浏览器会格式化显示时帮忙去掉多余的空格，但在代码里空格依旧存在，trim修饰符可以过滤内容左右两边的空格）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您输入的名字:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>没加trim：</p>
<p><img src="/2021/04/19/VUE/36.png" alt="image-20210321215801147"></p>
</li>
<li><p>加上trim</p>
<p><img src="/2021/04/19/VUE/35.png" alt="image-20210321215539094"></p>
</li>
</ul>
<h2 id="三、组件化开发"><a href="#三、组件化开发" class="headerlink" title="三、组件化开发"></a>三、组件化开发</h2><h3 id="1、什么是组件化"><a href="#1、什么是组件化" class="headerlink" title="1、什么是组件化"></a>1、什么是组件化</h3><p>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。</p>
<p>如图：</p>
<ul>
<li>我们将一个完整的页面分成很多个组件。</li>
<li>每个组件都用于实现页面的一个功能块。</li>
<li>而每一个组件又可以进行细分。</li>
</ul>
<p><img src="/2021/04/19/VUE/37.png" alt="image-20210321224044742"></p>
<h3 id="2、Vue组件化思想"><a href="#2、Vue组件化思想" class="headerlink" title="2、Vue组件化思想"></a>2、Vue组件化思想</h3><p>组件化是Vue.js中的重要思想。它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。任何的应用都会被抽象成一颗组件树。</p>
<p><img src="/2021/04/19/VUE/38.png" alt="image-20210321224237074"></p>
<p>组件化思想的应用：</p>
<ul>
<li>有了组件化的思想，我们在之后的开发中就要充分的利用它。</li>
<li>尽可能的将页面拆分成一个个小的、可复用的组件。</li>
<li>这样让我们的代码更加方便组织和管理，并且扩展性也更强。</li>
</ul>
<p>注意：每一个组件都有独属于自己的data、<code>methods</code>、<code>computed</code>、<code>components</code>、<code>template</code>等等。其中<code>app</code>可以看成所有组件的<strong>根组件（root）。</strong>但要注意，app也只能调用自己的<code>儿子</code>组件，不能去跨辈调用<code>孙子</code>组件。</p>
<h3 id="3、注册组件"><a href="#3、注册组件" class="headerlink" title="3、注册组件"></a>3、注册组件</h3><p>组件的使用分成三个步骤：</p>
<ol>
<li>创建组件构造器</li>
<li>注册组件</li>
<li>使用组件：组件只能在注册过的实例里使用，否则Vue因没有进行管理不会加载组件。</li>
</ol>
<p>注意：字符串的表达除了有<code>&#39;&#39;</code>（单引号）、<code>&quot;&quot;</code>（双引号）以外，还有<code>``</code>（尖引号）。尖引号可以实现字符串的跨行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--3.使用组件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以下没有在app实例里使用，Vue没有进行管理不会加载组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.创建组件构造器对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template: `</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组件标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件中的一个段落内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.注册组件</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 参数1：组件的名称，参数2：组件构造器对象的名称</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h4><ol>
<li><p>Vue.extend()：</p>
<ol>
<li>调用Vue.extend()创建的是一个组件构造器；</li>
<li>通常在创建组件构造器时，传入template代表我们自定义组件的模板；</li>
<li>该模板就是在使用到组件的地方，要显示的HTML代码；</li>
<li>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础</li>
</ol>
</li>
<li><p>Vue.component()：</p>
<ol>
<li>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称；</li>
<li>所以需要传递两个参数：<ol>
<li>注册组件的标签名</li>
<li>组件构造器</li>
</ol>
</li>
</ol>
</li>
<li><p>组件必须挂载在某个Vue实例下，否则它不会生效：</p>
<ol>
<li><p>我们来看下面我使用了三次<my-cpn></my-cpn></p>
</li>
<li><p>而第三次其实并没有生效：</p>
<p><img src="/2021/04/19/VUE/39.png" alt="image-20210322023308247"></p>
</li>
</ol>
</li>
</ol>
<h3 id="4、全局组件和局部组件"><a href="#4、全局组件和局部组件" class="headerlink" title="4、全局组件和局部组件"></a>4、全局组件和局部组件</h3><p>当我们通过<strong>调用Vue.component()注册组件</strong>时，组件的注册是<strong>全局的</strong>。</p>
<p><strong>这意味着该组件可以在任意Vue示例下使用。</strong></p>
<p><img src="/2021/04/19/VUE/40.png" alt="image-20210322023704676"></p>
<p>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p>
<p><img src="/2021/04/19/VUE/41.png" alt="image-20210322023725407"></p>
<h3 id="5、父组件和子组件"><a href="#5、父组件和子组件" class="headerlink" title="5、父组件和子组件"></a>5、父组件和子组件</h3><p>在前面我们看到了组件树：组件和组件之间存在层级关系。而其中一种非常重要的关系就是父子组件的关系</p>
<p>我们来看通过代码如何组成的这种层级关系：</p>
<p><img src="/2021/04/19/VUE/42.png" alt="image-20210322024427807"></p>
<p>父子组件错误用法：以子标签的形式在Vue实例中使用</p>
<ul>
<li>因为当子组件注册到父组件的components时，Vue会编译好父组件的模块</li>
<li>该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）</li>
<li><child-cpn></child-cpn>是只能在父组件中被识别的。</li>
<li>类似这种用法，<child-cpn></child-cpn>是会被浏览器忽略的。</li>
</ul>
<h3 id="6、注册组件语法糖"><a href="#6、注册组件语法糖" class="headerlink" title="6、注册组件语法糖"></a>6、注册组件语法糖</h3><p>在上面注册组件的方式，可能会有些繁琐。Vue为了简化这个过程，提供了注册的语法糖。</p>
<p>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p>
<p>语法糖注册全局组件和局部组件：</p>
<ul>
<li><p>全局组件的语法糖：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line">    template: `</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>局部组件的语法糖：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 注册局部组件的语法糖</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      <span class="string">&#x27;cpn2&#x27;</span>: &#123;</span></span><br><span class="line">        template: `</span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">   		 `</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7、模板的分离写法"><a href="#7、模板的分离写法" class="headerlink" title="7、模板的分离写法"></a>7、模板的分离写法</h3><p>以上代码虽然通过语法糖简化了Vue组件的注册过程，但还有一个地方的写法比较麻烦，就是template模块写法。如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。</p>
<p>Vue提供了两种方案来定义HTML模块内容：</p>
<ul>
<li><p>使用<script>标签：添加类型：text/x-template；用id的值来建立组件与模板之间的关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--script标签, 注意:类型必须是text/x-template--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span>--&gt;</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 注册一个全局组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<template>标签：用id的值来建立组件与模板之间的关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--template标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 注册一个全局组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：组件模板必须要有一个根。</strong>可以是<div></div></p>
</li>
</ul>
<h3 id="8、组件的数据存放"><a href="#8、组件的数据存放" class="headerlink" title="8、组件的数据存放"></a>8、组件的数据存放</h3><h4 id="1、组件可以访问Vue实例数据吗？"><a href="#1、组件可以访问Vue实例数据吗？" class="headerlink" title="1、组件可以访问Vue实例数据吗？"></a>1、组件可以访问Vue实例数据吗？</h4><p>组件是一个单独功能模块的封装：这个模块有属于自己的HTML模板，也应该有属性自己的数据data。</p>
<p>组件中的数据是保存在哪里呢？顶层的Vue实例中吗？我们先来测试一下，组件中能不能直接访问Vue实例中的data。</p>
<p><img src="VUE/43.png" alt="image-20210322131356074"></p>
<p>我们发现不能访问，而且即使可以访问，<strong>如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿</strong>。</p>
<p><strong>结论：Vue组件应该有自己保存数据的地方。</strong></p>
<h4 id="2、组件自己的数据存放"><a href="#2、组件自己的数据存放" class="headerlink" title="2、组件自己的数据存放"></a>2、组件自己的数据存放</h4><p>组件对象也有一个data属性(也可以有methods等属性)</p>
<ul>
<li><p>只是这个data属性<strong>必须是一个函数</strong></p>
</li>
<li><p>而且这个函数<strong>返回一个对象，对象内部保存着数据</strong></p>
<p><img src="VUE/45.png" alt="image-20210322132158055"></p>
</li>
</ul>
<p>为什么data属性在组件中一定要是一个函数？</p>
<ul>
<li><p>首先，如果不是一个函数，Vue直接就会报错（直接原因Vue不允许）</p>
</li>
<li><p>其次，原因是在于Vue让每个组件对象<strong>都返回一个新的实例</strong>（存储地址不同），因为如果是同一个对象的，组件在多次使用后会相互影响。</p>
</li>
<li><p>组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的</p>
</li>
<li><p>data返回一个实例所以每个counter都存在自己的实例的堆里面，如果直接返回一个data对象那么3个都共用一个堆会一起改变。</p>
<p><img src="VUE/46.png" alt="image-20210322132442881"></p>
</li>
</ul>
<h3 id="9、父子组件的通信"><a href="#9、父子组件的通信" class="headerlink" title="9、父子组件的通信"></a>9、父子组件的通信</h3><p>因为子组件是不能引用父组件或者Vue实例的数据的。但是，在开发中，往往一些数据确实需要从上层传递到下层：</p>
<ul>
<li>比如在一个页面中，我们从服务器请求到了很多的数据。</li>
<li>其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</li>
<li>这个时候，并不会让子组件再次发送一个网络请求，而是直接让**大组件(父组件)将数据传递给小组件(子组件)**。</li>
</ul>
<p>那么父子组件间如何通信呢？Vue官方提到</p>
<ul>
<li>通过props向子组件传递数据</li>
<li>通过事件向父组件发送消息</li>
</ul>
<p><img src="VUE/47.png" alt="image-20210322183204442"></p>
<h4 id="1、父级向子级传递数据"><a href="#1、父级向子级传递数据" class="headerlink" title="1、父级向子级传递数据"></a>1、父级向子级传递数据</h4><p>在组件中，使用选项props来声明需要从父级接收到的数据。</p>
<p>props写在子组件中，使用子组件时使用props的属性，对应属性的值填父组件的变量，即可通过props中的属性获取父组件的变量值。</p>
<p>父组件模板通过<code>:</code>也就是<code>v-on:</code>来绑定父组件向子组件传递的数据的名称。</p>
<p>props的值有两种方式：</p>
<ul>
<li><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p>
</li>
<li><p>方式二：对象，对象可以设置：</p>
<ul>
<li><p>传递时的类型：type，type既可以是基本数据类型，也可以是数组，或者自定义的一些对象。若props有可能的好几种，也可以写成数组的形式。[String,Arrary]</p>
</li>
<li><p>默认值：default，给props提供一些默认值。</p>
<p>注意：但props的类型为数组或对象时，不能直接设置默认值，而是必须从一个工厂函数中获取。</p>
</li>
<li><p>必传值：required，required是一个Boolean值。表示传过来的是否一定需要传入props</p>
</li>
<li><p>验证：validator，为一个函数，其参数为一个值，传入值必须与设置字符串其中之一匹配。返回值是一个Boolean值：true则匹配成功，false则匹配失败。</p>
</li>
</ul>
</li>
<li><p>其中当需要对<strong>props进行类型等验证时</strong>，就需要对象写法了。验证支持的数据类型（其中<code>null</code>可以匹配所有类型）：</p>
<ul>
<li><p>String</p>
</li>
<li><p>Number</p>
</li>
<li><p>Boolean</p>
</li>
<li><p>Array</p>
</li>
<li><p>Object</p>
</li>
<li><p>Date</p>
</li>
<li><p>Function</p>
</li>
<li><p>Symbol</p>
</li>
<li><p>当我们有自定义构造函数时，验证也支持自定义的类型</p>
<p><img src="VUE/48.png" alt="image-20210322192825268"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cmessage</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:cmovies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in cmovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;cmessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 父传子: props</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 方式一：字符串数组，数组中的字符串就是传递时的名称</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;],</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">    <span class="comment">// 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。</span></span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 1.类型限制</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// cmovies: Array,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// cmessage: String,</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 2.提供一些默认值, 以及必传值</span></span></span><br><span class="line">      cmessage: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">&#x27;aaaaaaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        required: <span class="literal">true</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 类型是对象或者数组时, 默认值必须是一个函数</span></span></span><br><span class="line">      cmovies: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">default</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> []</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      movies: [<span class="string">&#x27;海王&#x27;</span>, <span class="string">&#x27;海贼王&#x27;</span>, <span class="string">&#x27;海尔兄弟&#x27;</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、子级向父级传递数据"><a href="#2、子级向父级传递数据" class="headerlink" title="2、子级向父级传递数据"></a>2、子级向父级传递数据</h4><p>我们需要使用<strong>自定义事件</strong>来完成子级向父级的数据传递。<code>@</code>(v-on)不仅仅可以用于监听DOM事件，也可以用于监听组件间的自定义事件。所有可以用<code>@</code> + <code>$emit()</code>自定义事件来完成子级向父级的数据传递。</p>
<p>自定义事件的流程：</p>
<ul>
<li>在子组件中，通过$emit()来触发事件。<ul>
<li>参数一：自定义事件的标签（注意不要用驼峰）</li>
<li>参数二：事件的对象</li>
</ul>
</li>
<li>在父组件中，通过v-on来监听子组件事件。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">item-click</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;btnClick(item)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        categories: [</span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;热门推荐&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机数码&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ccc&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家用家电&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ddd&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑办公&#x27;</span>&#125;,</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// $emit发射事件: 自定义事件</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 参数一：自定义事件的标签（注意不要用驼峰）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 参数二：事件的对象</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">cpnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;cpnClick&#x27;</span>, item);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、标签驼峰问题"><a href="#3、标签驼峰问题" class="headerlink" title="3、标签驼峰问题"></a>3、标签驼峰问题</h4><p>在html的自定义标签的时候，最好不要用驼峰的写法，其实不是Vue不支持驼峰。而是在HTML属性不支持大写，即浏览器会将cInfo会自动解析成cinfo。由于浏览器解析后的标签名与代码的标签名对不上，会导致渲染失败。若需要分隔单词的时候，不要写成驼峰，而是推荐写成 “<strong><code>小写单词</code> + <code>-</code> + <code>小写单词</code></strong>“ 的方式。如：childMyMessage -&gt; child-my-message</p>
<h4 id="4、案例（父传子、子传父、在之间实现功能、数据流）"><a href="#4、案例（父传子、子传父、在之间实现功能、数据流）" class="headerlink" title="4、案例（父传子、子传父、在之间实现功能、数据流）"></a>4、案例（父传子、子传父、在之间实现功能、数据流）</h4><p>需求以及注意的点：</p>
<ol>
<li><p>父为app，子为cpn。</p>
</li>
<li><p>父组件里面有两个值1/0，父组件通过props向子组件传递这两个值</p>
</li>
<li><p>在子组件的两个值对应添加相应的输入框input，并将各自input与值用<code>v-mode</code>进行双向绑定。希望在改变输入框的值的时候，双向绑定到子组件的值，去修改子组件的值。</p>
<p>存在的问题：由于子组件的值是由父组件的值传递过来的，但你去修改子组件的值时会同时影响改变父组件的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span> <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="VUE/49.png" alt="image-20210322222858177"></p>
<p>注意：虽然以上代码实现了功能（改变子组件的值，但同时改变了父组件的值），但是浏览器却报错：避免直接改变属性，因为每当父组件重新渲染时，该值将被覆盖。所以应当让父组件来将其进行重写。</p>
<p>相反，它让我们使用基于属性值的data或computed去改变绑定的值。</p>
<p>其实：Vue建议我们最好不要通过修改子组件的值，从而去修改父组件的值。这样会引起很多问题。</p>
<ul>
<li>可以这样理解：父亲传过来的参数，我既使不满意但我也不能改变，于是自己搞个数据默认值为父亲传过来的参数，这样既可以改变数值，又没有改变父亲的参数。</li>
<li>从父组件传过来的值放在props绑定的组件变量里，而组件变量的值deepcopy了一份到data里，v-model绑定的是data数据，不影响props。</li>
</ul>
<p>修改的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        dnumber1: this.number1,</span><br><span class="line">        dnumber2: this.number2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/50.png" alt="image-20210322235953981"></p>
</li>
<li><p>将子组件改变的值重新传回父组件。（也就是调试改变props里的值）。</p>
<ol>
<li><p>将v-mode转换为用v-on与v-bind来表示。v-bind绑定value,v-on监听输入事件，并将其抽离成一个方法。</p>
</li>
<li><p>并在那方法里实现$emit()方法来与父组件传递数据。</p>
</li>
<li><p>$emit()方法传入自定义事件num1change()和子组件data里的值</p>
</li>
<li><p>在父组件的methods里实现自定义事件num1change()，用来修改父组件data里的值，因为父组件的data里的值被修改，父组件向子组件传递的props里的值也被改变。</p>
</li>
<li><p>向浏览器进行渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span> = <span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span> = <span class="string">&quot;num2change&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number1&quot; v-model=&quot;dnumber1&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num1Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number2&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num2Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = value</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num1Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.将input中的value赋值到dnumber中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2.为了让父组件可以修改值, 发出一个事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1)</span></span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num2Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="VUE/51.png" alt="image-20210323011007374"></p>
</li>
<li><p>注意：以上报错是因为传入的数据默认为字符串（String）类型，二代码里的值的类型是Number类型。两者类型不同而报错。可以将浏览器传来的value进行类型转换就行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">      num1change(value) &#123;</span><br><span class="line">        this.num1 = parseFloat(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      num2change(value) &#123;</span><br><span class="line">        this.num2 = parseFloat(value)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/52.png" alt="image-20210323012409525"></p>
</li>
</ol>
</li>
<li><p>在下面的值为上面的值的100倍，在上面的值为下面的值的1/100倍.</p>
<p>实现：在numxInput函数里添加业务需求就行</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          num1Input(event) &#123;</span><br><span class="line">            // 1.将input中的value赋值到dnumber中</span><br><span class="line">            this.dnumber1 = event.target.value;</span><br><span class="line">            // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1);</span><br><span class="line">            // 3.同时修饰dnumber2的值</span><br><span class="line">            this.dnumber2 = this.dnumber1 * 100</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line">          num2Input(event) &#123;</span><br><span class="line">            this.dnumber2 = event.target.value;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">            this.dnumber1 = this.dnumber2 / 100</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/53.png" alt="image-20210323013317559"></p>
<p>出现问题：</p>
<p>当上面值修改时，下面只有data里的值变成了上面值的100倍，而props里的值并没有改变。</p>
<p>解决方法：</p>
<p>在实现业务修改data的值后，再把data里的值通过自定义事件的方式（$erim）传递给父组件，父组件改变后在去改变子组件props里的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          num1Input(event) &#123;</span><br><span class="line">            // 1.将input中的value赋值到dnumber中</span><br><span class="line">            this.dnumber1 = event.target.value;</span><br><span class="line">            // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1);</span><br><span class="line">            // 3.同时修饰dnumber2的值</span><br><span class="line">            this.dnumber2 = this.dnumber1 * 100;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2Input(event) &#123;</span><br><span class="line">            this.dnumber2 = event.target.value;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">            this.dnumber1 = this.dnumber2 / 100;</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1)</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/54.png" alt="image-20210323014120094"></p>
</li>
</ol>
<p>以上程序完整代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span> = <span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span> = <span class="string">&quot;num2change&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number1&quot; v-model=&quot;dnumber1&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num1Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number2&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num2Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num1Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.将input中的value赋值到dnumber中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2.为了让父组件可以修改值, 发出一个事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3.同时修饰dnumber2的值</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = <span class="built_in">this</span>.dnumber1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num2Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = <span class="built_in">this</span>.dnumber2 / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将以上代码执行流程总结成一张图如下：</p>
<p><img src="VUE/58.png"></p>
<p>我们也可以用watch属性 + v-mode来实现以上需求：</p>
<p>watch属性：里面可以写一些函数用来监听组件内某一属性的改变。</p>
<p>里面函数的参数：</p>
<ul>
<li>newValue（常用）：变化的新值</li>
<li>oldValue（不常用）：变化前的值</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span>=<span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span>=<span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span>=<span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span>=<span class="string">&quot;num2change&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props:&#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data:&#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props:&#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data:&#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">dnumber1</span>(<span class="params">newValue</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = newValue * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;num1change&#x27;</span>, newValue);</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">dnumber2</span>(<span class="params">newValue</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.number1 = newValue / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;num2change&#x27;</span>, newValue);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10、父子组件的访问"><a href="#10、父子组件的访问" class="headerlink" title="10、父子组件的访问"></a>10、父子组件的访问</h3><p>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。</p>
<ul>
<li>父组件访问子组件：使用<code>$children</code>或<code>$refs</code></li>
<li>子组件访问父组件：使用<code>$parent</code>或<code>$root</code></li>
</ul>
<h4 id="1、父组件直接访问子组件"><a href="#1、父组件直接访问子组件" class="headerlink" title="1、父组件直接访问子组件"></a>1、父组件直接访问子组件</h4><h5 id="1、-children（不常用）"><a href="#1、-children（不常用）" class="headerlink" title="1、$children（不常用）"></a>1、$children（不常用）</h5><p>this.$children是一个数组类型，它包含所有子组件对象。我们可以通过一个遍历，取出所有子组件的数值data、方法methods、计算属性computed等等。<img src="VUE/55.png" alt="image-20210323014719042"></p>
<p>$children的缺陷：</p>
<ul>
<li>通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。</li>
<li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化（其他组件的插入删除等等）。</li>
<li>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</li>
</ul>
<h5 id="2、-refs（常用）"><a href="#2、-refs（常用）" class="headerlink" title="2、$refs（常用）"></a>2、$refs（常用）</h5><p>$refs的使用：</p>
<ul>
<li><code>$refs</code>和<code>ref</code>指令通常是一起使用的。</li>
<li>首先，我们<strong>通过ref给某一个子组件绑定一个特定的ID</strong>。</li>
<li>其次，通过<code>this.$refs.ID</code>就可以访问到该组件了。</li>
</ul>
<p><img src="VUE/56.png" alt="image-20210323015200643"></p>
<h4 id="2、子组件访问父组件"><a href="#2、子组件访问父组件" class="headerlink" title="2、子组件访问父组件"></a>2、子组件访问父组件</h4><h5 id="1、-parent（不常用）"><a href="#1、-parent（不常用）" class="headerlink" title="1、$parent（不常用）"></a>1、$parent（不常用）</h5><p>注意事项：</p>
<ul>
<li>尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。</li>
<li>子组件应该尽量避免直接访问父组件的数据，因为这样<strong>耦合度太高</strong>了。</li>
<li><strong>如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题</strong>。</li>
<li>另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。</li>
</ul>
<p><img src="VUE/57.png" alt="image-20210323015429354"></p>
<h5 id="2、-root（不常用）"><a href="#2、-root（不常用）" class="headerlink" title="2、$root（不常用）"></a>2、$root（不常用）</h5><p>我们可以通过$root访问到根组件，也就是app。但实际上我们在开发过程中也很少用这个$root.因为在root组件里什么都没有，非常简单。它只有一些非常重要的东西，比如：路由、Vuex。所以我们一般不访问根组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.$root.message);</span><br></pre></td></tr></table></figure>

<h3 id="11、插槽slot"><a href="#11、插槽slot" class="headerlink" title="11、插槽slot"></a>11、插槽slot</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>组件的插槽：</p>
<ul>
<li>组件的插槽也是为了让我们封装的组件<strong>更加具有扩展性</strong>。</li>
<li>让使用者可以决定组件内部的一些内容到底展示什么。</li>
</ul>
<p>组件插槽的例子：移动网站中的导航栏。</p>
<p>移动开发中，几乎每个页面都有导航栏。导航栏我们必然会封装成一个插件，比如nav-bar组件。一旦有了这个组件，我们就可以在多个页面中复用了。但是每个页面的导航栏是不一样，它们也很多<strong>区别</strong>，但是也有很多<strong>共性</strong>。</p>
<ul>
<li>如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装（<strong>共性</strong>）。</li>
<li>如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字等等，每一个组件又不一样（<strong>区别</strong>）。</li>
</ul>
<p>那么该如何封装合适呢？抽取共性，保留不同</p>
<ul>
<li>最好的封装方式就是将<strong>共性抽取到组件中</strong>，将<strong>区别暴露为插槽（slot）</strong>。</li>
<li>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。</li>
<li>是搜索框，还是文字，还是菜单。由调用者自己来决定。</li>
</ul>
<h4 id="2、slot的基本使用"><a href="#2、slot的基本使用" class="headerlink" title="2、slot的基本使用"></a>2、slot的基本使用</h4><ul>
<li><p>在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。</p>
</li>
<li><p>该插槽插入什么内容取决于父组件如何使用。</p>
</li>
<li><p>我们也可以为插槽设置默认值，当父组件没有使用该插槽的时候，插槽显示的就是默认值。</p>
<p>插槽的默认值 <slot>button</slot></p>
</li>
<li><p>如果父组件有多个值, 同时放入到组件的插槽进行替换时, 这多个值会一起作为替换元素。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--插槽显示默认值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插槽显示父组件修改的样式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>呵呵呵<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--插槽显示父组件的多个值，多个值一起作为插槽的替换元素--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>呵呵呵<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插槽显示默认值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件, 哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、具名插槽（多个插槽）"><a href="#2、具名插槽（多个插槽）" class="headerlink" title="2、具名插槽（多个插槽）"></a>2、具名插槽（多个插槽）</h4><p>当子组件的功能复杂时，子组件的插槽可能并非是一个。</p>
<ul>
<li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li>
<li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li>
<li>这个时候，我们就需要给插槽起一个名字。这就是具名插槽。</li>
</ul>
<p>那么如何使用具名插槽呢？</p>
<ul>
<li><p>只要在子组件的template中给slot元素一个name属性即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;myslot&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在父组件使用子组件插槽的时候用slot属性并赋予将要操作的插槽的name即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;mysolt&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、编译作用域"><a href="#3、编译作用域" class="headerlink" title="3、编译作用域"></a>3、编译作用域</h4><p>官方给出了一条准则：</p>
<ul>
<li><strong>父组件模板的所有东西都会在父级作用域内编译；</strong></li>
<li><strong>子组件模板的所有东西都会在子级作用域内编译。</strong></li>
</ul>
<p>即：在父组件模板使用的数据内容来自于父组件自己本身，而不会从自己绑定的子组件里面拿数据内容。在子组件模板里面使用的数据内容与来自子组件本身，不会从自己的父组件里面拿数据内容。</p>
<p>示例：</p>
<p><img src="VUE/59.png" alt="image-20210323220612323"></p>
<p>以上的代码是否最终是可以渲染出来的：</p>
<ul>
<li><my-cpn v-show="isShow"></my-cpn>中，我们使用了isShow属性。</li>
<li>isShow属性包含在组件中，也包含在Vue实例中。</li>
</ul>
<p>答案：最终可以渲染出来，也就是使用的是Vue实例的属性。</p>
<ul>
<li>我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，<strong>整个组件的使用过程是相当于在父组件</strong>（父组件模板）中出现的。</li>
<li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li>
<li>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</li>
</ul>
<h4 id="4、作用域插槽"><a href="#4、作用域插槽" class="headerlink" title="4、作用域插槽"></a>4、作用域插槽</h4><p>有时，父组件使用插槽的时候需要用到子组件里面的内容，又因为父子组件都有自己的编译作用域。父组件不能拿到子组件的内容。所以才出现了作用域插槽。</p>
<p>有一句话总结：父组件替换插槽的标签，但是内容由子组件来提供。</p>
<p>使用作用域插槽：</p>
<p>父组件：</p>
<ul>
<li><p>在父组件使用子组件<cpn></p>
</li>
<li><p>在<cpn>里面使用<template>标签，在<template>里有一个属性：</p>
<ul>
<li><p>v-solt：作用域插槽，格式：</p>
<p><strong>v-slot :+ 插槽名称 + = + 组件内部绑定作用域值的映射。</strong></p>
</li>
</ul>
<p>注意：在<cpn>里不是一定要使用<template>标签。在Vue2.6版本以后就可以使用其他标签了，如<div>、<span>等等，但是为了兼容Vue2.6以前的版本，我们一般会使用<template></p>
</li>
<li><p>然后在<template>里面完成自己的业务</p>
</li>
</ul>
<p>子组件：</p>
<ul>
<li><p>在子组件模板里使用<slot>插槽，里面有几个属性：</p>
<ul>
<li><p>name：实现具名插槽</p>
</li>
<li><p>v-bind(<code>:</code>)：与子组件的值进行绑定。</p>
<p>如：:user=”user”  :message=”message”  :data=”data”</p>
</li>
</ul>
</li>
<li><p>在子组件内部要定义好在子组件模板插槽里与之绑定的数据。</p>
</li>
</ul>
<p>通过以上父子组件两步设置就可以完成：父组件使用子组件的插槽时可以拿到子组件的数据内容。</p>
<p>需求：</p>
<ul>
<li>子组件中包括一组数据，比如：pLanguages: [‘JavaScript’, ‘Python’, ‘Swift’, ‘Go’, ‘C++’]</li>
<li>需要在多个界面进行展示：<ul>
<li>某些界面是以列表形式展示的</li>
<li>某些界面要用<code>-</code>进行分隔</li>
<li>某些界面要用<code>*</code>进行分隔</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:cpn</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; - &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:cpn</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;cpn&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            pLanguages: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>, <span class="string">&#x27;Swift&#x27;</span>]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/60.png" alt="image-20210324003729089"></p>
<h2 id="四、前端模块化"><a href="#四、前端模块化" class="headerlink" title="四、前端模块化"></a>四、前端模块化</h2><h3 id="1、为什么需要模块化"><a href="#1、为什么需要模块化" class="headerlink" title="1、为什么需要模块化"></a>1、为什么需要模块化</h3><p>在网页开发的早期，js制作作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的，可以直接将代码写在<script>标签中。</p>
<p>但随着ajax异步请求的出现，慢慢形成了前后端的分离：</p>
<ul>
<li><p>客户端需要完成的事情越来越多，代码量也是与日俱增。</p>
</li>
<li><p>为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护</p>
</li>
<li><p>但是这种维护方式，依然不能避免一些灾难性的问题：</p>
<ul>
<li><p>全局变量同名问题</p>
<p><img src="VUE/61.png" alt="image-20210324102745837"></p>
</li>
<li><p>对js文件的依赖顺序几乎是强制性的(对js文件导入的顺序不同，所得到的结果也是不同的)</p>
</li>
<li><p>但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较同时的事情。</p>
</li>
<li><p>而且即使你弄清楚顺序了，也不能避免上面出现的这种尴尬问题的发生。</p>
</li>
</ul>
</li>
</ul>
<p>随着重名问题的出现，也随之出现了解决方法：</p>
<p>使用<strong>匿名函数</strong>来解决方面的重名问题（闭包）。因为函数是有自己的作用域的。重名的变量或者方法都只有在对应的函数里面才有效。将一个个重名的全局变量变成一个个局部变量。</p>
<p><img src="VUE/62.png" alt="image-20210324103304290"></p>
<p>但随之而来又出现了新的问题：程序的代码复用性大大的下降。因为定义的变量都是局部变量，只有在自己匿名函数的内部使用，不能在其他js文件里引用。</p>
<p>所以，模块化思想就出现了。我们可以使用一个模块作为出口，将我们需要的局部变量与方法暴露出来。外部的js文件就可以通过这个模块去调用匿名函数里面的变量与方法。</p>
<p>那么怎么是匿名函数模块化呢？</p>
<p>匿名函数：</p>
<ul>
<li>在匿名函数内部，定义一个对象；</li>
<li>给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)；</li>
<li>最后将这个对象返回，并且在外面使用了一个MoudleA接受。</li>
</ul>
<p>调用方（某js文件）：</p>
<ul>
<li>只需要使用属于自己模块的属性和方法即可</li>
</ul>
<p><img src="VUE/63.png" alt="image-20210324104648346"></p>
<p>这就是模块最基础的封装。但前端模块化开发到今天，已经有了很多既有的规范，以及对应的实现方案。常见的模块化规范：</p>
<ul>
<li>CommonJS：在Nodejs里使用（了解）</li>
<li>ES6的Modules（主要学习）</li>
<li>AMD</li>
<li>CMD</li>
</ul>
<h3 id="2、CommonJS"><a href="#2、CommonJS" class="headerlink" title="2、CommonJS"></a>2、CommonJS</h3><p>CommonJS模块化有两个核心：导出和导入</p>
<p>CommonJS的导出：</p>
<p><img src="VUE/64.png" alt="image-20210324105207224"></p>
<p>CommonJS的导入：</p>
<p><img src="VUE/65.png" alt="image-20210324105241377"></p>
<h3 id="3、ES6的Modules"><a href="#3、ES6的Modules" class="headerlink" title="3、ES6的Modules"></a>3、ES6的Modules</h3><h4 id="1、ES6的Modules的导出：export"><a href="#1、ES6的Modules的导出：export" class="headerlink" title="1、ES6的Modules的导出：export"></a>1、ES6的Modules的导出：export</h4><h5 id="1、export导出变量"><a href="#1、export导出变量" class="headerlink" title="1、export导出变量"></a>1、export导出变量</h5><ul>
<li><p>导出方式一：先定义好变量，在将需要导出的变量一起导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先定义好变量，在将需要导出的变量一起导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  flag, message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式二：在定义变量的同时导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.在定义变量的同时导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> num1 = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> height = <span class="number">1.88</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、export导出函数或者类"><a href="#2、export导出函数或者类" class="headerlink" title="2、export导出函数或者类"></a>2、export导出函数或者类</h5><ul>
<li><p>导出方式三：导出函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式四：导出类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3、export-default"><a href="#3、export-default" class="headerlink" title="3、export default"></a>3、export default</h5><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名。这个时候就可以使用export default。</p>
<p><strong>需要注意</strong>：<strong>export default在同一个模块中，不允许同时存在多个。</strong></p>
<ul>
<li><p>导出方式五：export default为一个变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;北京市&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> address</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式六：export default为一个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">argument</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、ES6的Modules的导入：import"><a href="#2、ES6的Modules的导入：import" class="headerlink" title="2、ES6的Modules的导入：import"></a>2、ES6的Modules的导入：import</h4><p>我们使用**<code>export</code><strong>指令导出了模块对外提供的接口，下面我们就可以通过</strong><code>import</code>**命令来加载对应的这个模块了。</p>
<p>关于import的使用：</p>
<ol>
<li><p>首先，我们需要在HTML代码中<strong>引入两个js文件</strong>，并且<strong>类型需要设置为module</strong>。</p>
<p><img src="VUE/67.png" alt="image-20210324111327722"></p>
</li>
<li><p>import指令用于导入模块中的内容。以下为导入的几种形式（对应上面的方式一到六）：</p>
<ol>
<li><p>导入的{}中定义的变量（对应方式一）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;flag, message&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小明是天才, 哈哈哈&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接导入export定义的变量（对应方式二）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;num1, height&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export的function（对应方式三）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mul&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">30</span>, <span class="number">50</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export的class（对应方式四）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mul, Person&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export default中的内容（变量）（对应方式五）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(addr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export default中的内容（方法）（对应方式六）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line">todo(<span class="string">&#x27;你好啊&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>统一全部导入：</p>
<p>我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦</p>
<p>通过<code>*</code>可以导入模块中所有的export变量</p>
<p>但是通常情况下我们需要给<code>*</code>用<code>as</code><strong>起一个别名</strong>，方便后续的使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123;flag, num, num1, height, Person, mul, sum&#125; from &quot;./aaa.js&quot;;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">&#x27;./aaa.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(aaa.flag);</span><br><span class="line"><span class="built_in">console</span>.log(aaa.height);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="五、webpack"><a href="#五、webpack" class="headerlink" title="五、webpack"></a>五、webpack</h2><h3 id="1、什么是webpack？"><a href="#1、什么是webpack？" class="headerlink" title="1、什么是webpack？"></a>1、什么是webpack？</h3><p>官方解释：</p>
<ul>
<li>At its core, <strong>webpack</strong> is a <em>static module bundler</em> for modern JavaScript applications. </li>
<li>从本质上来讲，webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</li>
</ul>
<p><img src="VUE/68.png" alt="image-20210325215829591"></p>
<p>我们从两个点来解释上面这句话：<strong>模块</strong> 和 <strong>打包</strong></p>
<ul>
<li><p>模块：</p>
<p>前端模块化的必要性之前已经提及，而且也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</p>
<p>但在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</p>
<p>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。而且不仅仅是JavaScript文件，我们的CSS、图片、json文件，以及一些less、scss、stylus文件等等在webpack中都可以被当做模块来使用。</p>
</li>
<li><p>打包：</p>
<p>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。</p>
<p>webpack的打包就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</p>
<p>也就是说，开发的时候你可以使用AMD、CMD、CommonJS、ES6等模块化方案进行编码开发，发布到浏览器的时候可以通过webpack打包成一个浏览器能够识别的（如ES5）代码文件。然后再将这个代码文件部署到服务器。</p>
<p>但是打包的操作似乎<code>grunt</code>/<code>gulp</code>/<code>rollup</code>(Vue的源码就是用rollup构建的)也可以帮助我们完成。为什么要用webpack呢？</p>
</li>
</ul>
<h3 id="2、webpack和grunt-gulp的对比"><a href="#2、webpack和grunt-gulp的对比" class="headerlink" title="2、webpack和grunt/gulp的对比"></a>2、webpack和grunt/gulp的对比</h3><h4 id="1、grunt-gulp"><a href="#1、grunt-gulp" class="headerlink" title="1、grunt/gulp"></a>1、grunt/gulp</h4><p><strong>grunt/gulp的核心是Task（任务）</strong></p>
<p>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）。之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。所以grunt/gulp也被称为<strong>前端自动化任务管理工具</strong>。</p>
<p>一个gulp的task：</p>
<ul>
<li>下面的task就是将src下面的所有js文件转成ES5的语法。</li>
<li>并且最终输出到dist文件夹中。</li>
</ul>
<p><img src="VUE/69.png" alt="image-20210325221756978"></p>
<p>什么时候用grunt/gulp？什么时候用webpack？</p>
<ul>
<li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li>
<li>只需要进行简单的合并、压缩，就使用grunt/gulp即可。</li>
<li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li>
</ul>
<h4 id="2、grunt-gulp和webpack有什么不同呢？"><a href="#2、grunt-gulp和webpack有什么不同呢？" class="headerlink" title="2、grunt/gulp和webpack有什么不同呢？"></a>2、grunt/gulp和webpack有什么不同呢？</h4><ul>
<li>grunt/gulp更加强调的是<strong>前端流程的自动化</strong>，模块化不是它的核心。</li>
<li>webpack更加强调<strong>模块化开发管理</strong>，而文件压缩合并、预处理等功能，是他附带的功能。</li>
</ul>
<h3 id="3、webpack的安装"><a href="#3、webpack的安装" class="headerlink" title="3、webpack的安装"></a>3、webpack的安装</h3><ol>
<li><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm</p>
<p>查看自己的node版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>查看自己的npm版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>webpack和node和npm的关系：</p>
<p><img src="VUE/77.png" alt="webpack和node和npm的关系"></p>
</li>
<li><p>全局安装webpack（<strong>全局的webpack</strong>）（少用）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// -g进行全局安装（默认安装最新版本）</span><br><span class="line">npm install webpack -g</span><br><span class="line"></span><br><span class="line">// 也可以通过@+版本号进行具体版本的安装</span><br><span class="line">npm install webpack@3.6.0 -g </span><br></pre></td></tr></table></figure>

<p><strong>局部安装webpack</strong>（常用）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd 对应目录</span><br><span class="line">// 可以通过@+版本号安装该模块需要的webpack版本</span><br><span class="line">// --save-dev`是开发时依赖，项目打包后不需要继续使用的</span><br><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>

<p>为什么全局安装后，还需要局部安装呢？</p>
<ul>
<li>全局安装：在终端直接执行webpack命令，使用的全局安装的webpack</li>
<li>局部安装：当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack。</li>
</ul>
<p>开发时依赖与运行时依赖（<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json">npm的5种依赖种类</a>）</p>
<ul>
<li><p>开发时依赖（package.json中的devDependencies）：</p>
<p>开发中所使用的的依赖，<strong>线上生产环境上并不需要他们</strong>，npm官方文档将它定义为开发中所使用的外部的测试或者文档框架。目的是为了减少在安装依赖时node_modules的体积，提升安装依赖的速度，节省线上及其的硬盘资源以及部署上线的时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install/i xxx -D/--save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行时依赖（package.json中的dependencies）：</p>
<p>这是npm最基本的依赖，写在一个简单的对象中，将依赖程序包映射到版本范围。比较常用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install/i xxx@version -S/--save</span><br></pre></td></tr></table></figure>

<p>如果不指定版本号version，则默认安装最新版本</p>
</li>
</ul>
</li>
</ol>
<h3 id="4、使用webpack进行开发"><a href="#4、使用webpack进行开发" class="headerlink" title="4、使用webpack进行开发"></a>4、使用webpack进行开发</h3><h4 id="1、webpack基础"><a href="#1、webpack基础" class="headerlink" title="1、webpack基础"></a>1、webpack基础</h4><ol>
<li><p>我们创建如下文件和文件夹：</p>
<ul>
<li><p>index.html：浏览器打开展示的首页html</p>
</li>
<li><p>dist文件夹：用于存放之后打包的文件</p>
</li>
<li><p>src文件夹：用于存放我们写的源文件</p>
</li>
<li><p>js文件夹：用于存放我们写的js文件</p>
<ul>
<li><p>main.js：项目的入口文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用commonjs的模块化规范进行导入</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtils.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范进行导入</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, age, height&#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br></pre></td></tr></table></figure>
</li>
<li><p>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS进行导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>info.js：定义了一些属性，可以在其他地方引用，并且使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ES6的模块化的规范进行导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>package.json：通过npm init生成的，npm包管理的文件（下面会提）</p>
</li>
</ul>
</li>
<li><p>现在的js文件中使用了模块化的方式进行开发，但是他们并不可以直接使用。</p>
<ul>
<li>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码</li>
<li>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理</li>
</ul>
</li>
<li><p>所以我们应使用webpack工具，对多个js文件进行打包。</p>
<ul>
<li>webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。</li>
<li>另外，如果在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了。</li>
<li>而且，在打包的时候也不用将所有的js文件进行打包，只选择有导入其他模块（js文件）的主js文件（main.js）进行打包即可。因为webpack会自动处理模块间的依赖，它会根据依赖找到相关联的js文件，然后webpack会将主js文件（main.js）与之相关联的文件一起打包。如以上代码只需打包main.js文件即可。</li>
</ul>
</li>
<li><p>在终端进到项目的目录，使用webpack的指令进行打包（webpack 3.6.0版本）。将src下的main.js打包到dist下的bundle.js文件（自动生成）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/bundle.js</span><br></pre></td></tr></table></figure>

<p><img src="VUE/70.png" alt="image-20210325233912009"></p>
</li>
<li><p>打包后会在dist文件下，生成一个bundle.js文件</p>
<ul>
<li><p>文件内容有些复杂，这里暂时先不看，后续再进行分析</p>
</li>
<li><p>bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可</p>
<p><img src="VUE/71.png" alt="image-20210325234101665"></p>
</li>
</ul>
</li>
<li><p>bundle.js：核心方法：__webpack_require__（用来就将ES6解析成ES5）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">installedModules[moduleId]</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> 			i: moduleId,</span><br><span class="line"><span class="comment">/******/</span> 			l: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> 		modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.m = modules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.c = installedModules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// define getter function for harmony exports</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">!__webpack_require__.o(<span class="built_in">exports</span>, name)</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line"><span class="comment">/******/</span> 				configurable: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 				enumerable: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">/******/</span> 				get: getter</span><br><span class="line"><span class="comment">/******/</span> 			&#125;);</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line"><span class="comment">/******/</span> 		__webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> getter;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// __webpack_public_path__</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> ([</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__info__ = __webpack_require__(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1.使用commonjs的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = __webpack_require__(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;c&quot;</span> <span class="comment">/* name */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;a&quot;</span> <span class="comment">/* age */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;b&quot;</span> <span class="comment">/* height */</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;c&quot;</span>] = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;a&quot;</span>] = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;b&quot;</span>] = height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> ]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<p><img src="VUE/72.png" alt="image-20210325234538965"></p>
</li>
</ol>
<h4 id="2、webpack的配置"><a href="#2、webpack的配置" class="headerlink" title="2、webpack的配置"></a>2、webpack的配置</h4><p>如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？</p>
<p>当然可以，就是创建一个**<code>webpack.config.js</code>**文件。文件名字不能修改。在里面设置路径、出口与入口。</p>
<ul>
<li>入口：项目打包的文件</li>
<li>出口：项目要打包到哪里</li>
<li>路径：用来确定出口的位置。注意路径必须是绝对路径，但是又不能写死，所以需要我们动态获取路径。通过Nodejs的<code>path</code>模块进行路径的动态获取。</li>
</ul>
<p>如何获取Nodejs的<code>path</code>模块？安装步骤：</p>
<ol>
<li><p>在终端输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>当项目需要使用到Nodejs的东西的时候，就需要我们初始化npm。</p>
<p>npm初始化过程：</p>
<ul>
<li>package name：给包起一个名称（排除中文与一些特殊符号）</li>
<li>version：版本号</li>
<li>description：描述（可不填）</li>
<li>entry point：index.js（在webpack用不上）</li>
<li>test command：测试命令</li>
<li>git repository：git仓库</li>
<li>keywords：密码</li>
<li>author：作者</li>
<li>license：协议（如果为开源就需要设置）</li>
</ul>
<p>一旦初始化就会生成一个**<code>package.json</code>**的文件：任何一个项目，如果想单独依赖Nodejs环境的话，一般情况下，都需要一个package.json文件。这个文件是用来告知当前项目的一些信息的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;meetwebpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.6.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些命令：</p>
<ul>
<li>npm install：若项目有依赖一些模块的话，他会根据你在package.json里所有的依赖，帮助我们在当前文件夹下安装一些东西。</li>
</ul>
</li>
<li><p>然后在**<code>webpack.config.js</code>**文件里的路径处使用path的resolve函数。</p>
<p>resolve函数：用于对两个路径进行拼接</p>
<p>而绝对路径的拼接还需要一个全局变量：__dirname：保存当前文件所在的路径。</p>
</li>
</ol>
<p><strong>webpack.config.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以直接使用<code>webpack</code>对项目进行打包。</p>
<p>但是当项目越来越复杂的时候，即不止一个webpack.config.js，还存在production.comfig.js等等文件的时候。执行webpack的时候，还得加上具体的js文件。这是还可以通过将webpack命令统一映射到一个命令上，如<code>npm run build</code>。那么怎么设置映射呢？</p>
<p>在package.json里对scripts（脚本）设置自己的执行脚本：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<ol>
<li>首先，会寻找本地的node_modules/.bin路径中对应的命令</li>
<li>如果没有找到，会去全局的环境变量中寻找。<ul>
<li>在这里全局的环境变量指的是当时我们安装的全局webpack。</li>
<li>而本地的node_modules/.bin路径指的是我们在当前项目安装的局部webpack。</li>
<li>上文有提：<code>webpack</code>命令执行的全局的webpack，因为它是在终端命令的；而npm run build命令执行的是局部的webpack，因为它是根据scripts的脚本执行的，找的是本地的webpack。<strong>而在大项目中，每个子项目往往依赖特定的webpack版本，很少去使用全局的webpack，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题</strong>。（反正全局的webpack的版本太高而出现bug）<strong>所以通常一个项目，都有自己局部的webpack</strong>。而我们也要使用局部webpack的方式**<code>node_modules/.bin/webpack</code>**进行局部打包。但是我们可以通过映射的方式简化命令，这也是我们要设置映射，使用 npm run bulid 而不使用webpack的一大原因。</li>
</ul>
</li>
</ol>
<h3 id="5、webpack其他文件的转化（Loader）"><a href="#5、webpack其他文件的转化（Loader）" class="headerlink" title="5、webpack其他文件的转化（Loader）"></a>5、webpack其他文件的转化（Loader）</h3><p>webpack用来做什么呢？</p>
<ul>
<li>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</li>
<li>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</li>
<li>对于webpack本身的能力来说，对于这些转化是不支持的。</li>
<li>所以，就需要给webpack扩展对应的loader。</li>
<li>loader是webpack中一个非常核心的概念</li>
</ul>
<p>loader使用过程：</p>
<ol>
<li>通过npm安装需要使用的loader</li>
<li>在webpack.config.js中的module关键字下进行配置</li>
</ol>
<p>大部分loader我们都可以在<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/">webpack的官网</a>中找到，并且学习对应的用法。</p>
<h4 id="1、CSS文件"><a href="#1、CSS文件" class="headerlink" title="1、CSS文件"></a>1、CSS文件</h4><p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。在src目录中，创建一个css文件，在该文件夹下写我们css的一些代码。</p>
<p>但是这个时候，我们写的.css文件中的样式并不会生效：</p>
<ul>
<li>我们压根就没有引用它</li>
<li>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件</li>
</ul>
<p>所以需要我们在入口js文件里引用需要的css文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖css文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>重新打包，会出现如下错误：</p>
<p><img src="VUE/73.png" alt="image-20210326013352060"></p>
<p>这个错误告诉我们：加载normal.css文件必须有对应的loader。</p>
<p>在<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/">webpack的官方</a>中，我们可以找到如下关于样式的loader使用方法：</p>
<p><img src="VUE/75.png" alt="image-20210326013640249"></p>
<ul>
<li><p>按照官方先安装css-loader</p>
</li>
<li><p>按照官方配置webpack.config.js文件（暂时不配置style-loader看情况）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 正则表达式 \.对.进行转义，$为结束标志</span></span><br><span class="line">        <span class="comment">// 匹配.css文件</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [ <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>重新打包项目，运行index.html，你会发现样式并没有生效。原因：</p>
<ul>
<li>css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中</li>
<li>这个时候，我们还需要一个style-loader帮助我们处理。</li>
</ul>
<p>安装style-loader：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>

<p>在webpack.config.js配置：</p>
<p><strong>注意：style-loader需要放在css-loader的前面。</strong>（官网也是这么配置的）</p>
<p>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</p>
<p>答案：这次<strong>因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的</strong>。否则打包报错：</p>
<p><img src="VUE/76.png" alt="image-20210326015106671"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、less文件"><a href="#2、less文件" class="headerlink" title="2、less文件"></a>2、less文件</h4><p>如果我们希望在项目中使用less、scss、stylus来写样式，与css一样，webpack并不可以帮助我们处理。需要我们添加对应的loader。（以less为例，scss与stylus一样）</p>
<p>先创建一个less文件，依然放在css文件夹中。在less文件夹里编写我们的less代码。并在main.js里面依赖less文件，然后对项目进行打包（报错）：</p>
<p><img src="VUE/78.png" alt="image-20210326015525314"></p>
<p>继续在官方中查找，我们会找到less-loader相关的使用说明</p>
<p><img src="VUE/79.png" alt="image-20210326015729535"></p>
<ol>
<li><p>首先，还是需要安装对应的loader</p>
<p>注意：我们这里还安装了less，因为webpack会使用<strong>less对less文件进行编译解析</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，修改对应的配置文件webpack.config.js</p>
<p>添加一个rules选项，用于处理.less文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3、图片文件处理"><a href="#3、图片文件处理" class="headerlink" title="3、图片文件处理"></a>3、图片文件处理</h4><h5 id="1、url-loader与file-loader"><a href="#1、url-loader与file-loader" class="headerlink" title="1、url-loader与file-loader"></a>1、url-loader与file-loader</h5><ol>
<li><p>首先，我们在项目中加入两张图片：</p>
<ul>
<li>一张较小的图片test.jpg(小于13kb)，一张较大的图片timg.jpeg(大于13kb)</li>
<li>待会儿我们会针对这两张图片进行不同的处理</li>
</ul>
</li>
<li><p>将这两张图片放在src文件夹下的img文件夹里</p>
</li>
<li><p>先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/*background-color: red;*/</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/test.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们现在直接打包，会出现如下问题</p>
<p><img src="VUE/80.png" alt="image-20210326021448341"></p>
</li>
<li><p>图片处理，我们使用url-loader来处理（在webpack5之后有改变，<a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/asset-modules/">详情</a>）</p>
</li>
<li><p>依然先安装url-loader</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。</p>
<ul>
<li><p>而仔细观察，你会发现背景图是通过base64显示出来的</p>
<p><img src="VUE/81.png" alt="image-20210326022233777"></p>
</li>
<li><p>OK，这就是limit属性的作用，当图片小于13kb时，对图片进行base64编码</p>
</li>
</ul>
</li>
<li><p>那么问题来了，如果大于13kb呢？我们将background的图片改成test02.jpg</p>
<ul>
<li><p>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<p><img src="VUE/82.png" alt="image-20210326022436695"></p>
</li>
</ul>
</li>
<li><p>所以，我们需要安装file-loader</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>将项目重新打包，运行index.html，发现图片并未显示出来，控制台报404错误。</p>
</li>
</ol>
<p><img src="VUE/83.png"></p>
<p>原因：</p>
<ul>
<li><p>因为之前使用url-loader加载图片时是通过base64进行的，不需要单独一个文件来存储。</p>
</li>
<li><p>而现在使用的file-loader加载图片是将其看成一个完整的图片，就需要对它进行打包到dist文件夹里面，并对其进行重新命名（以哈希方式，防止重复）。</p>
</li>
<li><p>以后发布时连同bundle.js一起发布到服务器。所以打开dist文件夹下多了一个图片文件：</p>
<p><img src="VUE/84.png" alt="image-20210326024243736"></p>
</li>
<li><p>当浏览器加载图片的时候加载的是dist里打包的hash的图片文件，而不是我们开发时用的src/img下的图片。</p>
</li>
<li><p>控制台报404找不到浏览器需要加载的图片是因为浏览器是在index.html当前路径下查找图片的：</p>
<p><img src="VUE/85.png" alt="image-20210326024731783"></p>
</li>
<li><p>而我们的图片是在dist文件夹下面的，所以需要我们把路径改成dist/32f5576… .jpg</p>
</li>
<li><p>但我们不能改变css里面的代码，不能把它写死，应该让他在使用路径自动加上dist这个文件夹，所以我们需要对webpack.config.js的output属性进行修改，添加一个publicPath属性：值为<code>&#39;dist/&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    publicPath: <span class="string">&#x27;dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>设置以后，以后只要用到url的时候，就会在url前面添加dist/</p>
</li>
</ul>
<p>将项目重新打包，运行index.html。发现图片加载成功。</p>
<p><strong>注意：开发时我们可以使用这种方式，但在之后，我们项目发布服务器的时候是要将index.html文件打包进dist文件夹里面的，此时图片就在index.html的当前路径下，不需要在路径前面添加dist/，所以当项目发布的时候需要将publicPath属性删除。</strong></p>
<h5 id="2、修改dist图片文件名称"><a href="#2、修改dist图片文件名称" class="headerlink" title="2、修改dist图片文件名称"></a>2、<strong>修改dist图片文件名称</strong></h5><p>我们发现webpack自动帮助我们在dist文件夹里生成一个非常长的名字的图片。</p>
<ul>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹img中，跟上<strong>图片原来的名称</strong>，同时也要防止重复，所以也需要进行<strong>hash</strong>方式（其中ext是为了保存后缀名 ext = extension）：img/name.hash:8.ext</li>
</ul>
<p>所以，我们可以在options中添加上如下选项：</p>
<ul>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名</li>
</ul>
<p>对webpack.config.js进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">              name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>注意：**name、hash、ext要用中括号<code>[]</code>**，webpack会把<code>[]</code>里的值当成一个变量</p>
<ul>
<li>如果有些中括号<code>[]</code>,webpack在读取配置的时候会根据原有变量对应的值对<code>[]</code>里的内容进行替换</li>
<li>如果没有中括号<code>[]</code>,webpack会将其统一命名成name.png</li>
</ul>
<p>将项目进行打包后，发现配置成功：</p>
<p><img src="VUE/86.png" alt="image-20210326031643907"></p>
<h4 id="4、ES6语法处理（babel）"><a href="#4、ES6语法处理（babel）" class="headerlink" title="4、ES6语法处理（babel）"></a>4、ES6语法处理（babel）</h4><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p>
<p>如果希望将ES6的语法转成ES5，那么就需要使用babel。而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>配置webpack.config.js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// exclude: 排除</span></span><br><span class="line">        <span class="comment">// include: 包含</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、webpack配置vue"><a href="#6、webpack配置vue" class="headerlink" title="6、webpack配置vue"></a>6、webpack配置vue</h3><p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。所以，需要我们在我们的webpack环境中集成Vuejs。</p>
<p>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p><strong>注意：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</strong></p>
<p>在main.js引入vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在index.html里挂载app：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包运行index.html，控制台报错：</p>
<p><img src="VUE/87.png" alt="image-20210326033342069"></p>
<p>原因：</p>
<ul>
<li><p>Vue在构建最终的发布版本的时候，它构建了两类版本：</p>
<ul>
<li><p>runtime-only：</p>
<p>代码中不允许有任何template（app算vue实例的template），因为该版本内没有包含对template编译解析的代码（only只包含运行，不包含编译）。</p>
</li>
<li><p>runtime-compiler：</p>
<p>代码中允许有template，因为该版本中有compiler可以用于编译template</p>
</li>
</ul>
</li>
</ul>
<p>解决方法：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A">Vue不同版本构建</a></p>
<p>修改webpack的配置，添加如下内容即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/88.png" alt="image-20210326034650420"></p>
<h3 id="7、Vue的正确格式（el与template区别）"><a href="#7、Vue的正确格式（el与template区别）" class="headerlink" title="7、Vue的正确格式（el与template区别）"></a>7、Vue的正确格式（el与template区别）</h3><p>正常运行之后，我们来考虑另外一个问题：</p>
<ul>
<li>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</li>
<li>如果我们后面自定义了组件，也必须修改index.html来使用组件</li>
<li>但是html模板在之后的开发中，我并不希望手动的来频繁修改。</li>
</ul>
<p>SPA（single page web application）:单页面复用。只有一个index.html。多页面我们也可以通过单页面实现（通过路由跳转vue-router（前端路由））。所以一般我们不改index.html里的东西，只用于挂载vue实例和导入主js文件（到时候插件帮我们将index.html导入到dist文件夹的是会自动生成，不需要我们手动写）。</p>
<ol>
<li><p>修改index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js了删除Vue实例前面的变量app，将之前写在index.html里面的vue实例的模板通过template搬到Vue实例中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>el与template的区别</strong>：</p>
<ul>
<li>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等</li>
<li>而如果Vue实例中同时指定了template，那么<strong>template模板的内容会替换掉挂载的对应el的模板</strong>。</li>
<li>这样做的好处：之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可。</li>
</ul>
<p>但是，书写template模块非常麻烦臃肿怎么办呢？</p>
<p>最终会将template模板中的内容进行抽离，会分成三部分书写：template、script、style，结构变得非常清晰</p>
</li>
<li><p>将vue实例的内容抽取成一个组件，在vue实例中使用抽取的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将抽取出去的App组件当成一个对象，在src下创建一个vue文件夹，在该文件夹下创建app.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main.js进行导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/app&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是存在一个问题：app.js里模板与js代码没有分离。</p>
<p>解决方法：在src/vue文件夹下创建App.vue文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;App&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#39;Hello Webpack&#39;,</span><br><span class="line">        name: &#39;coderwhy&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在main.js里引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import App from &#x27;./vue/app&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打包运行报错：没有对应的loader。</p>
</li>
<li><p>安装vue-loader和vue-template-compiler</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但依旧存在问题：缺少插件。在vue-loader14开始，如果要使用vue-loader，还必须另外给它配置个插件。</p>
<p>解决方法：降低版本，在package.json里进行修改</p>
<p>其中：<code>^</code>大于等于，表示在13 &lt; vue-loader &lt; 14在这中间安装一个版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;vue-loader&quot;: &quot;^13.0.0&quot;,</span><br></pre></td></tr></table></figure>

<p>在终端执行命令<code>npm install</code>重新安装</p>
</li>
<li><p>在vue编写其他组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是cpn组件的标题&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是cpn组件的内容, 哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Cpn&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &#39;CPN组件的name&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue里使用Cpn.vue组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;Cpn&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Cpn from &#39;.&#x2F;Cpn.vue&#39;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;App&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#39;Hello Webpack&#39;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若你在导入Cpn.vue的时候想要省略掉.vue的话，就需要修改webpack.config.js文件：在resolve里添加属性extensions，值为要省略的扩展名。如[‘.js’, ‘.css’, ‘.vue’]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在App.vue里引入的时候就能省略扩展名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Cpn from &#39;.&#x2F;Cpn&#39;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="8、插件（plugin）"><a href="#8、插件（plugin）" class="headerlink" title="8、插件（plugin）"></a>8、插件（plugin）</h3><h4 id="1、插件（plugin）是什么"><a href="#1、插件（plugin）是什么" class="headerlink" title="1、插件（plugin）是什么"></a>1、插件（plugin）是什么</h4><ul>
<li>通常是用于对某个现有的架构进行扩展</li>
<li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等</li>
</ul>
<h4 id="2、loader和plugin区别"><a href="#2、loader和plugin区别" class="headerlink" title="2、loader和plugin区别"></a>2、loader和plugin区别</h4><ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器和加载器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器</li>
</ul>
<h4 id="3、plugin的使用过程"><a href="#3、plugin的使用过程" class="headerlink" title="3、plugin的使用过程"></a>3、plugin的使用过程</h4><ol>
<li>通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li>
<li>在webpack.config.js中的plugins中配置插件</li>
</ol>
<h4 id="4、webpack的常用插件"><a href="#4、webpack的常用插件" class="headerlink" title="4、webpack的常用插件"></a>4、webpack的常用插件</h4><h5 id="1、添加版权的Plugin（BannerPlugin）"><a href="#1、添加版权的Plugin（BannerPlugin）" class="headerlink" title="1、添加版权的Plugin（BannerPlugin）"></a>1、添加版权的Plugin（BannerPlugin）</h5><p>BannerPlugin可以为打包的文件添加版权声明，属于webpack自带的插件</p>
<p>可以按照下面的方式来修改webpack.config.js的文件：</p>
<p><img src="VUE/89.png" alt="image-20210326140918356"></p>
<p>重新打包程序：查看bundle.js文件的头部，看到如下信息:</p>
<p><img src="VUE/90.png" alt="image-20210326141001962"></p>
<h5 id="2、打包html的plugin（HtmlWebpackPlugin）"><a href="#2、打包html的plugin（HtmlWebpackPlugin）" class="headerlink" title="2、打包html的plugin（HtmlWebpackPlugin）"></a>2、打包html的plugin（HtmlWebpackPlugin）</h5><p>目前，我们的index.html文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件。</p>
<p>HtmlWebpackPlugin插件可以为我们做这些事情：</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<ul>
<li>这里的template表示根据什么模板来生成index.html</li>
<li>另外，我们需要删除之前在output中添加的publicPath属性</li>
<li>否则插入的script标签中的src可能会有问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h5 id="3、js压缩的Plugin（uglifyjs-webpack-plugin）"><a href="#3、js压缩的Plugin（uglifyjs-webpack-plugin）" class="headerlink" title="3、js压缩的Plugin（uglifyjs-webpack-plugin）"></a>3、js压缩的Plugin（uglifyjs-webpack-plugin）</h5><p>在项目发布之前，我们必然需要对js等文件进行压缩处理，这里，我们就对打包的js文件进行压缩。我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js文件，使用插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>注意：<code>uglifyjs-webpack-plugin丑化插件</code>会将js代码进行压缩处理，删除多余的注释、空行与空格，并将出现的变量使用简单的字母进行替换。也就是说，也会删除我们之前由<code>添加版权的插件BannerPlugin</code>生成的注释版权信息。</p>
<p>解决方法：由于在配置文件中，plugins为一个数组，只要将<code>uglifyjs-webpack-plugin丑化插件</code>放在<code>添加版权的插件BannerPlugin</code>前面，让<code>uglifyjs-webpack-plugin丑化插件</code>先执行，在执行<code>添加版权的插件BannerPlugin</code>。就可以实现在丑化的js文件中添加版本信息。</p>
<h5 id="4、搭建本地服务器"><a href="#4、搭建本地服务器" class="headerlink" title="4、搭建本地服务器"></a>4、搭建本地服务器</h5><p>我们在开发的时候，如果要一次次经过重建项目的方式去查看代码效果，这将给我们的开发带来很大麻烦，开发效率也很低。webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，每次点击保存的时候就可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。等我们将代码修改完成后在将代码进行构建。</p>
<p>express框架的在Vue本地服务器的粗略理解：</p>
<p>express服务于某个文件夹，实时的监听该文件夹里面的代码有没有发生改动，一旦发生改变，它就会对这些改变的代码重新进行编译。重新编译的话一开始并不会生成最终的文件，而是会将其生成一些新的我们要编译的东西，但并没有将其存入磁盘里面，而是存进内存之中，方便开发人员进行测试。当真正进行发布的时候在存储进磁盘里面。</p>
<p>一句话总结：由于系统访问内存的速度要远远快于访问磁盘的速度。而express就相当于一个中间件，我们开发过程的编译生成的代码先通过express存储进内存，方便测试。发布的时候再有express将其存储进磁盘。</p>
<p>本地开发服务器它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@2.9.3</span><br></pre></td></tr></table></figure>

<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</p>
<ul>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</li>
<li>inline：页面实时刷新</li>
<li>port：端口号（默认8080）</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ul>
<p>webpack.config.js文件配置修改如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">  inline: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以再package.json配置另外一个scripts：–open参数表示直接打开浏览器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="5、开发与发布配置文件的分离"><a href="#5、开发与发布配置文件的分离" class="headerlink" title="5、开发与发布配置文件的分离"></a>5、开发与发布配置文件的分离</h4><p>在webpack.config.js配置文件中，我们进行了很多的配置，有些配置是在开发时才需要使用（如：本地服务器的配置），而生产环境下需要将其移除；有些配置是在发布的时候才需要使用（如：js丑化插件），而开发环境不需要使用（js丑化后不利于开发人员调试）。而我们在生产到发布的进行转换时，每次都需要删除开发时注释，在去添加生产时注释。如果项目代码量大的话，这也是一种灾难。</p>
<p>解决方法：</p>
<p>对webpack.config.js配置文件中的配置进行分离，将其中<code>公共的配置（base.config.js）</code>抽离出来，再将剩余配置分成<code>开发时配置（dev.config.js）</code>与<code>生产时配置（prod.config.js）</code>。我们在开发的时候就使用base.config.js + dev.config.js，发布的时候就使用base.config.js + prod.config.js。</p>
<p>实现步骤：</p>
<ol>
<li><p>在项目根目录新建文件夹build，在build文件夹里新建base.config.js、dev.config.js、prod.config.js三个js配置文件。</p>
<ul>
<li><p>base.config.js：一些公共的配置，开发时和生产时都需要使用到的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      app: <span class="string">&#x27;./src/main.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// publicPath: &#x27;dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">              name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// exclude: 排除</span></span><br><span class="line">        <span class="comment">// include: 包含</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dev.config.js：开发时需要的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prod.config.js：生产时需要的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对当前配置文件进行合并，安装合并插件webpack-merge，来帮助我们对配置文件进行合并：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-merge@4.1.5 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在dev.config.js与prod.config.js配置文件里对webpack-merge插件进行导入使用</p>
<p>dev.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>prod.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改package.json文件里的脚本（scripts）：指定运行时的配置文件。否则打包时会报找不到webpack.config.js配置文件的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config ./build/prod.config.js&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是存在问题：项目打包并没有打包在dist文件夹中，而是打包在了build下新建的一个dist文件夹里</p>
<p>原因：在base.config.js配置文件里，我们配置的绝对路径是当前文件的dist文件夹：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br></pre></td></tr></table></figure>

<p>而base.config.js配置文件是在build文件夹里，所以他会在build文件夹中新建dist文件夹存放打包的东西。所以主要是修改绝对路径的值就行了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="六、Vue-cli脚手架"><a href="#六、Vue-cli脚手架" class="headerlink" title="六、Vue-cli脚手架"></a>六、Vue-cli脚手架</h2><h3 id="1、什么是脚手架"><a href="#1、什么是脚手架" class="headerlink" title="1、什么是脚手架"></a>1、什么是脚手架</h3><p>如果你在开发大型项目, 那么你需要, 并且必然需要使用Vue CLI。</p>
<ul>
<li>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情</li>
<li>如果每个项目都要手动完成这些工作，那无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情</li>
</ul>
<p>CLI是什么意思？</p>
<ul>
<li>CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架</li>
<li>Vue CLI是一个官方发布 vue.js 项目脚手架</li>
<li>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置</li>
</ul>
<h3 id="2、使用Vue-cli的前提"><a href="#2、使用Vue-cli的前提" class="headerlink" title="2、使用Vue-cli的前提"></a>2、使用Vue-cli的前提</h3><ol>
<li><p>Nodejs</p>
<p><a target="_blank" rel="noopener" href="http://nodejs.cn/download/">安装NodeJS</a></p>
<p><strong>检测安装的版本</strong>：</p>
<ul>
<li><p>默认情况下自动安装Node和NPM</p>
</li>
<li><p>Vue CLI 4.x 需要 <a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a><a target="_blank" rel="noopener" href="https://nodejs.org/"> </a> v8.9 或更高版本 (推荐 v10 以上)。（官方推荐）</p>
</li>
</ul>
<p>什么是NPM：</p>
<ul>
<li>NPM的全称是Node Package Manager</li>
<li>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。</li>
<li>后续我们会经常使用NPM来安装一些开发过程中依赖包.</li>
</ul>
</li>
<li><p>webpack</p>
<p>Vue.js官方脚手架工具就使用了webpack模板</p>
<ul>
<li>对所有的资源会压缩等优化操作</li>
<li>它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效。</li>
</ul>
</li>
</ol>
<h3 id="3、安装Vue-cli"><a href="#3、安装Vue-cli" class="headerlink" title="3、安装Vue-cli"></a>3、安装Vue-cli</h3><p>安装Vue脚手架：默认下载最新版本（Vue-cli4）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/cli -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>若想要安装Vue-cli3版本的，只需要在@vue/cli后面加上@版本号就行了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/cli@3.0.4 -g</span><br></pre></td></tr></table></figure>

<p>其实，Vue-cli3与Vue-cli4之间只有一些微小的差别，具体查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/migrating-from-v3/#vue-cli-plugin-unit-jest">官网</a></li>
<li><a target="_blank" rel="noopener" href="http://t.zoukankan.com/Super-scarlett-p-12495902.html">相关blog</a></li>
</ul>
<p>关于旧版本（Vue-cli1.x或2.x）</p>
<blockquote>
<p>Vue CLI 的包名称由 <code>vue-cli</code> 改成了 <code>@vue/cli</code>。 如果你已经全局安装了旧版本的 <code>vue-cli</code> (1.x 或 2.x)，你需要先通过 <code>npm uninstall vue-cli -g</code> 或 <code>yarn global remove vue-cli</code> 卸载它。</p>
</blockquote>
<p>安装之后，你就可以用这个命令来验证它是否安装成功以及检查其版本是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<p><img src="VUE/91.png" alt="image-20210326200446984"></p>
<p>注意：上面安装的是Vue CLI4的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。如果你在Vue-cli3.x/4.x环境下仍然需要使用旧版本Vue-cli2.x的模板，你可以全局安装一个桥接工具：（之后就可以按照Vue CLI2的方式初始化项目）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="meta">#</span><span class="bash"> `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<p><img src="VUE/92.png" alt="image-20210326200544804"></p>
<p>Vue CLI2.x与Vue CLI3.x/4.x怎么初始化项目：</p>
<ul>
<li><p>Vue CLI2初始化项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue CLI3初始化项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4、Vue-CLI2项目详解"><a href="#4、Vue-CLI2项目详解" class="headerlink" title="4、Vue CLI2项目详解"></a>4、Vue CLI2项目详解</h3><h4 id="1、Vue-CLI2项目的创建"><a href="#1、Vue-CLI2项目的创建" class="headerlink" title="1、Vue CLI2项目的创建"></a>1、Vue CLI2项目的创建</h4><p>在终端输入<code>vue init webpack 项目名称</code>来初始化Vue CLI2项目：</p>
<ol>
<li><p>Project name：项目名称。括号里面是默认值，即直接回车就默认使用括号里面的内容，但不能包含大写字母。我们使用<code>vue init webpack 项目名称</code>命令使用的<code>项目名称</code>并不是项目的真正名称，而是会根据<code>项目名称</code>创建一个文件夹。项目的名称可以在这里进行命名。（默认就是<code>项目名称</code>）</p>
</li>
<li><p>Project description：项目描述。（默认：A Vue.js project）</p>
</li>
<li><p>Author：作者。（会默认从.gitconfig(C:\Users\Admin.gitconfig)在读取信息）</p>
</li>
<li><p>Vue build：Vue项目构建的方式：</p>
<ul>
<li><p>Runtime + Compiler：推荐大多数用户使用（暂时使用，以后会用Runtime-only的）</p>
</li>
<li><p>Runtime-only：常用</p>
<p>原因：</p>
<ul>
<li>Runtime-only打包后的程序比Runtime + Compiler小</li>
<li>Runtime-only的运行效率更高</li>
</ul>
<p><img src="VUE/94.png" alt="image-20210326202702064"></p>
</li>
</ul>
</li>
<li><p>Install vue-router：是否安装vue路由</p>
</li>
<li><p>Use ESLint to lint your code：是否使用ESLint 检测代码规范</p>
<p>若选择了y，则它会让你选择一种代码规范：</p>
<ul>
<li>Standard：标准规范</li>
<li>Airbnb：爱彼迎。（民宿）</li>
<li>none：不选择，自己配置</li>
</ul>
<p>就算开启，之后也可以在config/index.js中将<code>useEslint</code>的值从true改成false进行关闭。</p>
<p><img src="VUE/95.png" alt="image-20210326203148480"></p>
</li>
<li><p>Set up uint tests：单元测试</p>
</li>
<li><p>Set e2e(end to end 端到端测试) tests with NightWatch</p>
</li>
<li><p>Should we run <code>npm install</code> for you after the project has been create? </p>
</li>
</ol>
<p><img src="VUE/93.png" alt="image-20210326201123763"></p>
<h4 id="2、Vue-cli2项目的目录结构详解"><a href="#2、Vue-cli2项目的目录结构详解" class="headerlink" title="2、Vue-cli2项目的目录结构详解"></a>2、Vue-cli2项目的目录结构详解</h4><p>项目创建完成之后，vue-cli2会帮我们生成一些文件：</p>
<p>我们怎么看一个项目：</p>
<ol>
<li><p>先看package.json，里面有运行的一些脚本scripts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>npm run dev</strong>：本地服务器。执行的指令为<code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code></p>
</li>
<li><p><strong>npm run start</strong>：所有项目的默认开始命令。实际上执行的是<code>npm run dev</code>。（如上）</p>
</li>
<li><p><strong>npm run lint</strong>：执行一些约束</p>
</li>
<li><p><strong>npm run build</strong>：打包项目。实际执行的是<code>node build/build.js</code>命令。</p>
<p>关于node指令：</p>
<p>node为js提供了运行环境，可以直接执行js文件，不需要借助html文件去访问浏览器。</p>
<p>nodejs本身是用C++开发的，里面的核心为：<code>V8引擎</code>（Google开发的，用C++写的）。</p>
<ul>
<li>一般js代码的执行过程是：js -&gt;字节码（class）-&gt;浏览器。（慢）</li>
<li>V8引擎（可以直接跳过字节码，直接把js编译成二进制代码）：js-&gt;二进制代码-&gt;浏览器（快）</li>
</ul>
<p>node的V8引擎为js代码的执行做了一个底层支撑。</p>
</li>
</ul>
</li>
<li><p><strong>构建项目</strong>：由于执行打包命令<strong>npm run build</strong>，执行的是<code>node build/build.js</code>命令。所以再去看build/build.js</p>
<ol>
<li>rm：通过执行rm命令删除之前打包生成的dist文件夹</li>
<li>webpack：通过webpackConfig执行相关配置</li>
<li>webpackConfig：const webpackConfig = require(‘./webpack.prod.conf’)</li>
</ol>
</li>
<li><p>查看build/webpack.prod.conf</p>
<p>merge(baseWebpackConfig,{})</p>
</li>
<li><p>再查看baseWebpackConfig</p>
<p>里面抽取了很多东西（有很多之前讲过的插件）</p>
<p><img src="VUE/99.png" alt="image-20210327013437402"></p>
</li>
<li><p><strong>开发项目</strong>：由于执行本地服务器命令<strong>npm run dev</strong>,执行的指令为<code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code></p>
</li>
<li><p>查看build/webpack.dev.conf.js</p>
<p>merge(baseWebpackConfig,{})</p>
</li>
<li><p>build文件夹中的其他配置都是为前面的配置服务的</p>
</li>
<li><p>在看看config中的配置：</p>
<p>index.js中主要是配置了两个模块：dev、build</p>
<ul>
<li><p>dev配置都是定义了一些变量：</p>
<ul>
<li><p>host: ‘localhost’</p>
</li>
<li><p>port: 8080</p>
</li>
<li><p>autoOpenBrowser: false</p>
<p>……</p>
</li>
</ul>
</li>
<li><p>build配置的是一些index.html的模板路径，资源等等</p>
</li>
</ul>
<p><img src="VUE/98.png" alt="image-20210327013206531"></p>
</li>
<li><p>**<code>node_modules</code>**：放置项目依赖的包</p>
</li>
<li><p>**<code>src</code>**：进行开发的地方</p>
</li>
<li><p>**<code>static</code>**：存放静态资源的地方。到时候打包的时候，Vue-cli会将static文件里的内容原封不动的复制到dist文件夹中。若你把一些图片资源放到src/assets中，Vue-cli会根据你图片的大小与url-loader中<code>limit</code>里的数值进行比对，并将图片重新命名后放入dist。</p>
<p>其中有一个文件：.gitkeep：如果不管该文件夹是否为空，Vue-cli打包的时候都会将其打包上传到服务器。</p>
</li>
<li><p>**<code>.babelrc</code>**：ES代码相关转化配置</p>
<p>其中”browsers”: [“&gt; 1%”, “last 2 versions”, “not ie &lt;= 8”]：</p>
<ul>
<li>“&gt; 1%”：市场份额大于1%</li>
<li>“last 2 versions”：最后的两个版本</li>
<li>“not ie &lt;= 8”：不支持低于IE8版本</li>
</ul>
</li>
<li><p>**<code>.editorconfig</code>**：代码规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br></pre></td></tr></table></figure>

<p>root = true：根据root进行查找文件。Vue-cli在查找.editorconfig文件的时候，只有在root = true的时候才会开始解析。</p>
<p>end_of_line = lf：换行。值<code>lf</code>不同操作系统可能不同，具体网上查看即可</p>
<p>insert_final_newline = true：文件结尾是否空出一行</p>
<p>trim_trailing_whitespace = true：清除掉多余无效的空格</p>
</li>
<li><p>**<code>.eslintignore</code>**：忽略eslint规范的文件夹配置。</p>
</li>
<li><p>**<code>.gitignore</code>**：Git查看忽略的文件夹配置</p>
</li>
<li><p>**<code>.eslintrc.js</code>**：eslint代码检测的配置的js文件</p>
</li>
<li><p>**<code>.postcssrc.js</code>**：在进行css转化的时候配置的js文件</p>
</li>
<li><p>**<code>index.html</code>**：dist文件夹中index.html的模板</p>
</li>
<li><p>package.json与package-lock.json：</p>
<p>在package.json中的插件与依赖存在许多版本，但大部分都不是安装对应版本的依赖（一般会大于设定值），安装的依赖由两个符号决定：</p>
<ul>
<li><code>^</code>开头：改变的是最后一个数值。如<code>^4.15.0</code>，他就只会安装4.15.0到4.15.9之间的依赖</li>
<li><code>~</code>开头：改变的可以是最后两个值。如<code>~4.15.0</code>，它就会安装在4版本内大于4.15.0版本的其它版本，如4.20.7版本。但绝对不会安装到5.xx.x的版本。</li>
</ul>
<p>而package-lock.json就是对应package.json中设定的版本号与实际安装的版本之间的映射关系的js配置文件。</p>
<p>一句话：package.json为依赖安装的大概版本，package-lock.json为依赖安装的实际版本。</p>
</li>
<li><p>README.md：书写项目相关文档</p>
</li>
</ol>
<p><img src="VUE/96.png" alt="image-20210326203911636"></p>
<h3 id="5、Runtime-Compiler和Runtime-only的区别"><a href="#5、Runtime-Compiler和Runtime-only的区别" class="headerlink" title="5、Runtime-Compiler和Runtime-only的区别"></a>5、Runtime-Compiler和Runtime-only的区别</h3><h4 id="1、代码区别"><a href="#1、代码区别" class="headerlink" title="1、代码区别"></a>1、代码区别</h4><p>他们的区别只在一个文件里面：main.js</p>
<ul>
<li><p>Runtime-Compiler的main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">	components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app的使用步骤：</p>
<ol>
<li>先导入</li>
<li>然后在components里进行注册</li>
<li>最后在template里使用</li>
</ol>
</li>
<li><p>Runtime-only的main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(App);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// render: h =&gt; h(App)</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(App)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app的使用步骤：</p>
<ol>
<li>先导入</li>
<li>使用render进行渲染</li>
</ol>
<p>注意：Runtime-only并不是完全没有template标签，在App.vue里面存在template标签。但是不妨碍代码的执行。因为App.vue里面的template标签在使用之前已经进行渲染了。</p>
</li>
</ul>
<p>  Vue.config.productionTip = false：发布产品的时候（npm run build）会给你一些提示信息；但我在开发的时候（npm run dev）不需要这些提示信息。所以默认为false。但项目真正需要构建build的时候可以改为true。</p>
<h4 id="2、Vue程序的运行过程中的区别"><a href="#2、Vue程序的运行过程中的区别" class="headerlink" title="2、Vue程序的运行过程中的区别"></a>2、Vue程序的运行过程中的区别</h4><p>Vue程序的运行过程：</p>
<p><img src="VUE/97.png" alt="image-20210327001054379"></p>
<ul>
<li><p>对于Runtime-Compiler：template -(解析)-&gt; ast-(编译) -&gt; render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）</p>
</li>
<li><p>对于Runtime-only：render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）</p>
<p>所以，对于Runtime-only有Runtime-Compiler不具备的优势：</p>
<ol>
<li>性能更高 </li>
<li>代码量更少（没有Compiler编译template标签的那部分代码）（6KB左右）</li>
</ol>
</li>
</ul>
<h4 id="3、Runtime-only的实现"><a href="#3、Runtime-only的实现" class="headerlink" title="3、Runtime-only的实现"></a>3、Runtime-only的实现</h4><h5 id="1、对于Runtime-only的render的解析："><a href="#1、对于Runtime-only的render的解析：" class="headerlink" title="1、对于Runtime-only的render的解析："></a>1、对于Runtime-only的render的解析：</h5><p>内部有一个函数<code>h</code>，其实h就是createElement。其中的内容是用来替换app模板里的内容。</p>
<p>函数createElement的用法：</p>
<ol>
<li><p>普通用法: createElement(‘标签’, {标签的属性}, [ ‘内容’ ])：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,&#123;<span class="attr">class</span>: <span class="string">&#x27;box&#x27;</span>&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现：<h2 class="box">Hello World<h2/>代替了<div id="app"></div></p>
</li>
<li><p>普通用法的扩展：既然内容部分是一个数组，那么就可以在里面继续嵌套标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,</span><br><span class="line">      &#123;<span class="attr">class</span>: <span class="string">&#x27;box&#x27;</span>&#125;,</span><br><span class="line">      [<span class="string">&#x27;Hello World&#x27;</span>, createElement(<span class="string">&#x27;button&#x27;</span>, [<span class="string">&#x27;按钮&#x27;</span>])])</span><br></pre></td></tr></table></figure>

<p>运行发现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">	&quot;Hello World&quot;</span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传入组件对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;我是组件message&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createElement(cpn)</span><br></pre></td></tr></table></figure>

<p>运行发现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是组件message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有上可得我们可以将App组件传入createElement函数，得到的结果就是Runtime-only的main.js中的写法：只是将createElement换成h。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function (h) &#123;</span><br><span class="line">    return h(App)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2、对Runtime-only的App-vue中的template标签的解惑"><a href="#2、对Runtime-only的App-vue中的template标签的解惑" class="headerlink" title="2、对Runtime-only的App.vue中的template标签的解惑"></a>2、对Runtime-only的App.vue中的template标签的解惑</h5><p>Runtime-only的Vue程序的运行过程：render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）。并没有对标签template进行编译解析。那怎么解决Runtime-only的App.vue中的template标签呢？</p>
<p>解答：Runtime-only的App.vue中的template标签并不需要经历template -(解析)-&gt; ast-(编译) -&gt; render的过程，因为在App.vue中的template标签最终被编译出来的就是一个普通的对象，而在这个普通的对象里面，已经将template全部渲染成render函数了。即我们最终用到的App这个对象里面是没有template标签的。所以我们并不需要使用Runtime-Compiler对App进行编译解析了，因为App里面已经没有template标签了。只需要使用我们的Runtime-only进行打包就行了。</p>
<p>那么.vue文件中的template是由谁处理的了?</p>
<p>是由vue-template-compiler对它进行解析处理的</p>
<h3 id="6、Vue-cli3-4（以下以Vue-cli3为例，Vue-cli4差别不大）"><a href="#6、Vue-cli3-4（以下以Vue-cli3为例，Vue-cli4差别不大）" class="headerlink" title="6、Vue-cli3/4（以下以Vue-cli3为例，Vue-cli4差别不大）"></a>6、Vue-cli3/4（以下以Vue-cli3为例，Vue-cli4差别不大）</h3><h4 id="1、nvue-cli-3-与-2-版本有很大区别："><a href="#1、nvue-cli-3-与-2-版本有很大区别：" class="headerlink" title="1、nvue-cli 3 与 2 版本有很大区别："></a>1、nvue-cli 3 与 2 版本有很大区别：</h4><ul>
<li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li>
<li>vue-cli 3 的设计原则是“0配置”，移除了根目录下的的配置文件，build和config等目录</li>
<li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li>
<li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</li>
</ul>
<h4 id="2、Vue-CLI3项目详解（Vue-CLI4在创建过程只是多了版本选择）"><a href="#2、Vue-CLI3项目详解（Vue-CLI4在创建过程只是多了版本选择）" class="headerlink" title="2、Vue CLI3项目详解（Vue CLI4在创建过程只是多了版本选择）"></a>2、Vue CLI3项目详解（Vue CLI4在创建过程只是多了版本选择）</h4><h5 id="1、Vue-CLI3项目的创建"><a href="#1、Vue-CLI3项目的创建" class="headerlink" title="1、Vue CLI3项目的创建"></a>1、Vue CLI3项目的创建</h5><p>在终端输入：<code>vue create my-project</code>进行Vue CLI3的项目创建。</p>
<p>创建步骤：</p>
<ol>
<li><p>Please pick a prset：选择配置方式</p>
<ol>
<li>default（bable，eslint）：默认配置</li>
<li>Manually select feature：手动选择特性</li>
<li>若你之前有保存过你的一些特性，可以在这里选择。</li>
</ol>
</li>
<li><p>Check the feature needed for your project：若上一步选择Manually select feature，则这一步会让你选择需要加入的特性。空格选中或反选，回车确定。一些特性说明：</p>
<ul>
<li>TypeScript：相当于ES的超级（有点像java）</li>
<li>Progressive Web App （PWA）Support：先进的web app。里面增加了很多功能：<ul>
<li>可以进行大量的缓存</li>
<li>拥有推送通知的功能</li>
</ul>
</li>
</ul>
</li>
<li><p>Where do you prefer placing config for Babel,PostCSS,ESLint,etc.?</p>
<p>选择对应的配置的生成位置，有两个选择：</p>
<ul>
<li>In dedicated config files：单独生成一个对应的配置文件</li>
<li>In package.json：生成在package.json文件中</li>
</ul>
</li>
<li><p>Save this as a preset for future projects?是否将刚才自己选择的配置保存下来。</p>
</li>
<li><p>Save preset as :若选择保存下来，则会让你设置保存的名称。这样在创建其他项目的时候，第1步就能选择你保存的配置。</p>
<p>如何删除自己保存的配置：</p>
<p>在.vuerc(C:\Users\Admin.vuerc)文件里进行删除</p>
</li>
<li><p>Pick the package manager to use when installing dependencies：在安装依赖的时候选择使用哪个包管理工具，两个选择：</p>
<ul>
<li>Use Yarn</li>
<li>Use NPM</li>
</ul>
</li>
</ol>
<p><img src="VUE/100.png" alt="image-20210327022546764"></p>
<p>Vue-cli3在创建项目时会在当前目录下创建.git文件。它会默认将代码放进git仓库进行管理。</p>
<h5 id="2、Vue-cli3项目的目录结构详解"><a href="#2、Vue-cli3项目的目录结构详解" class="headerlink" title="2、Vue-cli3项目的目录结构详解"></a>2、Vue-cli3项目的目录结构详解</h5><p>项目创建完成之后，vue-cli3会帮我们生成一些文件：</p>
<ul>
<li>**<code>node_modules</code>**：放置项目依赖的包</li>
<li>**<code>public</code>**：相当于之前的static。存放静态资源的地方。到时候打包的时候，Vue-cli会将public文件里的内容原封不动的复制到dist文件夹中。里面存放两个文件：<ul>
<li>favicon.ico：Vue的小图标</li>
<li>index.html</li>
</ul>
</li>
<li>**<code>src</code>**：进行开发的地方</li>
<li>**<code>.browserslistrc</code>**：浏览器相关的配置</li>
<li>**<code>.gitignore</code>**：Git查看忽略的文件夹配置</li>
<li>**<code>babel.config.js</code>**：babel的相关配置</li>
<li>package.json与package-lock.json</li>
<li>**<code>postcss.config.js</code>**：在进行css转化的时候配置的js文件，用来配置转化一些特殊的CSS文件</li>
<li>README.md：书写项目相关文档</li>
</ul>
<p><img src="VUE/101.png" alt="image-20210327025419742"></p>
<p>运行Vue-cli3：npm run serve</p>
<p>查看package.json中的scripts属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>main.js文件：</p>
<ul>
<li><p>Vue-cli3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span>=&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其实使用el: ‘#app’挂载app的时候，其底层还是使用了mount方法，只是多了个判断。所以这里是使用了mount方法代替el挂载App。</p>
</li>
<li><p>Vue-cli4：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、Vue-cli3配置文件的查看与修改"><a href="#3、Vue-cli3配置文件的查看与修改" class="headerlink" title="3、Vue-cli3配置文件的查看与修改"></a>3、Vue-cli3配置文件的查看与修改</h4><p>vue-cli 3 的设计原则是“0配置”，移除了根目录下的配置文件，build和config等目录。但是配置并不是说消失了，因为要用到webpack，配置是必须的。所以vue-cli 3只是将配置隐藏起来了。那么我们该怎么查看与修改隐藏的配置文件呢？有三种方法：</p>
<ul>
<li><p>通过命令<code>vue ui</code>打开vue-cli 3为我们提供的ui图形界面，端口默认为8000（查看与修改）</p>
<p><img src="VUE/111.png" alt="image-20210327150713404"></p>
<ul>
<li><p>仪表盘：</p>
<p><img src="VUE/104.png" alt="image-20210327144223290"></p>
</li>
<li><p>插件：</p>
<p><img src="VUE/105.png" alt="image-20210327144450855"></p>
</li>
<li><p>依赖</p>
<p><img src="VUE/106.png" alt="image-20210327144610556"></p>
</li>
<li><p>配置</p>
<p><img src="VUE/107.png" alt="image-20210327145616237"></p>
<p><img src="VUE/108.png" alt="image-20210327145738257"></p>
</li>
<li><p>任务：</p>
<p><img src="VUE/109.png" alt="image-20210327150018316"></p>
</li>
</ul>
</li>
<li><p>在项目文件的根目录下有node_modules@vue\cli-service\lib\Service.js（查看）</p>
<p><img src="VUE/112.png" alt="image-20210327151311282"></p>
<p><img src="VUE/110.png" alt="image-20210327150122955"></p>
</li>
<li><p>在项目的根目录下创建文件：<code>vue.config.js</code>（固定）进行自定义配置。如果我们对默认的配置不满意的话，可以在该文件下写我们的配置，最终项目打包时会将<code>vue.config.js</code>里编写的配置与项目隐藏的配置合并一起作为项目的总配置。（修改）</p>
<p><img src="VUE/113.png" alt="image-20210327151516954"></p>
</li>
</ul>
<h2 id="七、箭头函数"><a href="#七、箭头函数" class="headerlink" title="七、箭头函数"></a>七、箭头函数</h2><h3 id="1、箭头函数的基本使用"><a href="#1、箭头函数的基本使用" class="headerlink" title="1、箭头函数的基本使用"></a>1、箭头函数的基本使用</h3><p>箭头函数: 也是一种定义函数的方式</p>
<p>定义函数的方式：</p>
<ul>
<li><p>function：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aaa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量中定义函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">bbb</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6中的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2、箭头函数的参数与返回值"><a href="#2、箭头函数的参数与返回值" class="headerlink" title="2、箭头函数的参数与返回值"></a>2、箭头函数的参数与返回值</h3><p>箭头函数最基础的写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、箭头函数的参数"><a href="#1、箭头函数的参数" class="headerlink" title="1、箭头函数的参数"></a>1、箭头函数的参数</h4><h5 id="1、没参数"><a href="#1、没参数" class="headerlink" title="1、没参数"></a>1、没参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、有两个参数"><a href="#2、有两个参数" class="headerlink" title="2、有两个参数"></a>2、有两个参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、只有一个参数（括号可删除）"><a href="#3、只有一个参数（括号可删除）" class="headerlink" title="3、只有一个参数（括号可删除）"></a>3、只有一个参数（括号可删除）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、箭头函数的返回值"><a href="#2、箭头函数的返回值" class="headerlink" title="2、箭头函数的返回值"></a>2、箭头函数的返回值</h4><h5 id="1、函数代码块中有多行代码时"><a href="#1、函数代码块中有多行代码时" class="headerlink" title="1、函数代码块中有多行代码时"></a>1、函数代码块中有多行代码时</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打印Hello World</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.打印Hello Vuejs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Vuejs&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、函数代码块中只有一行代码（大括号与return可以省略）"><a href="#2、函数代码块中只有一行代码（大括号与return可以省略）" class="headerlink" title="2、函数代码块中只有一行代码（大括号与return可以省略）"></a>2、函数代码块中只有一行代码（大括号与return可以省略）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 * num2</span><br></pre></td></tr></table></figure>

<p>当函数没有返回值，返回undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello Demo</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> demo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Demo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3、什么时候使用箭头函数"><a href="#3、什么时候使用箭头函数" class="headerlink" title="3、什么时候使用箭头函数"></a>3、什么时候使用箭头函数</h3><p>箭头函数一般使用在<strong>作为函数参数</strong>传入一个函数时</p>
<h3 id="4、this的使用"><a href="#4、this的使用" class="headerlink" title="4、this的使用"></a>4、this的使用</h3><ul>
<li>以function函数的形式调用时，this永远都是window </li>
<li>以箭头函数的形式调用时，this就是调用方法的那个对象</li>
</ul>
<p>这是因为两者的执行方式不同：</p>
<ul>
<li>function函数是执行了call函数，在call函数中将window作为第一个参数传入，使用this就是window</li>
<li>箭头函数是向外层作用域中, 一层层查找this, 直到有this的定义。</li>
</ul>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">aaa</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 通过function函数方式</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 1window</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 2window</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">	 <span class="comment">// 通过箭头函数方式</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 3window</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 4obj</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>1、3好理解，都是通过function函数，this都是window</li>
<li>2是找到上一层，发现是通过function函数方式，箭头函数指向外层的this，外层this是function的this 指向window</li>
<li>4也是找到上一层，上一层还是个箭头函数，就继续往上找，找到了aaa( )</li>
</ul>
<p>总结：function函数的this是由调用者决定，而箭头函数是直接看代码就能知道this是谁，嵌套的话，只要遇到一个function，就由function的this作为最终this。</p>
<h2 id="八、Vue-router路由"><a href="#八、Vue-router路由" class="headerlink" title="八、Vue-router路由"></a>八、Vue-router路由</h2><h3 id="1、认识路由"><a href="#1、认识路由" class="headerlink" title="1、认识路由"></a>1、认识路由</h3><p>路由是一个网络工程里面的术语</p>
<p><strong>路由</strong>（<strong>routing</strong>）就是通过互联的网络把信息从源地址传输到目的地址的活动.     — 维基百科</p>
<p>生活中的路由器是做什么的? 路由和转送</p>
<ul>
<li><p>路由是决定数据包从<strong>来源</strong>到<strong>目的地</strong>的路径</p>
</li>
<li><p>转送将<strong>输入端</strong>的数据转移到合适的<strong>输出端</strong></p>
</li>
<li><p>路由器的工作原理：</p>
<p><img src="VUE/115.png" alt="image-20210327171111712"></p>
</li>
</ul>
<p>路由中有一个非常重要的概念叫路由表。路由表本质上就是一个<strong>映射表</strong>, 决定了数据包的指向。</p>
<h3 id="2、网页开发的发展过程"><a href="#2、网页开发的发展过程" class="headerlink" title="2、网页开发的发展过程"></a>2、网页开发的发展过程</h3><h4 id="1、后端路由阶段"><a href="#1、后端路由阶段" class="headerlink" title="1、后端路由阶段"></a>1、<strong>后端路由阶段</strong></h4><p>早期的网站开发整个HTML页面是由服务器来渲染的。<strong>服务器直接生产渲染好对应的HTML页面</strong>, 返回给客户端进行展示。（jsp + servelet ）（jsp = java server page）</p>
<p>但是, 一个网站, 这么多页面服务器如何处理呢?</p>
<ul>
<li>一个页面有自己对应的网址, 也就是URL</li>
<li>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理。</li>
<li>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端。</li>
<li>这就完成了一个IO操作。</li>
</ul>
<p>上面的这种操作, 就是<strong>后端路由</strong>：</p>
<ul>
<li>当我们页面中需要请求不同的<strong>路径</strong>内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿。</li>
<li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利SEO的优化。</li>
</ul>
<p>后端路由的缺点:</p>
<ul>
<li>一种情况是整个页面的模块由后端人员来编写和维护的。</li>
<li>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码。</li>
<li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情。</li>
</ul>
<p><img src="VUE/116.png" alt="01-后端路由阶段"></p>
<h4 id="2、前后端分离阶段"><a href="#2、前后端分离阶段" class="headerlink" title="2、前后端分离阶段"></a>2、前后端分离阶段</h4><p>随着Ajax的出现, 有了前后端分离的开发模式：</p>
<ul>
<li>后端只提供API接口来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中。</li>
<li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上。</li>
<li>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可。</li>
<li>目前很多的网站依然采用这种模式开发。</li>
</ul>
<p><img src="VUE/117.png" alt="02-前端后端分离阶段"></p>
<h4 id="3、单页面复应用（SPA）阶段"><a href="#3、单页面复应用（SPA）阶段" class="headerlink" title="3、单页面复应用（SPA）阶段"></a>3、<strong>单页面复应用（SPA）阶段</strong></h4><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由，也就是前端来维护一套路由规则</p>
<p>上面的这种操作, 就是<strong>前端路由</strong>，前端路由的核心是什么呢？</p>
<ul>
<li>改变URL，但是页面不进行整体的刷新，即不用向服务器请求任何资源。</li>
</ul>
<p><img src="VUE/118.png" alt="03-SPA页面页面的阶段"></p>
<p>前端路由中url和组件的关系：</p>
<p><img src="VUE/119.png" alt="04-前端路由中url和组件的关系"></p>
<p><strong>总结</strong>：（前端路由与后端路由、前端渲染与后端渲染）</p>
<ul>
<li><strong>前端路由与后端路由的区别：看是谁在管理url与页面组件的映射关系</strong>。由前端管理就是前端路由，由后台管理就是后端路由。</li>
<li><strong>前端渲染与后端渲染的区别：看是谁在进行页面的开发渲染。</strong>即上面第一阶段后端路由阶段就是由后台开发渲染页面，称为后端渲染。而第二第三阶段都是由前端开发渲染页面，称为前端渲染。</li>
</ul>
<h3 id="3、前端路由的规则"><a href="#3、前端路由的规则" class="headerlink" title="3、前端路由的规则"></a>3、前端路由的规则</h3><p>怎么实现改变URL，但是页面不进行整体的刷新</p>
<p>有两种方法：URL的hash 与 HTML5的history模式</p>
<ul>
<li><p>URL的hash</p>
<p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性。</p>
<p>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p>
<p><img src="VUE/120.png" alt="image-20210327194500087"></p>
</li>
<li><p>HTML5的history模式。history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面：</p>
<p><strong>pushState</strong>、<strong>back/forward</strong>、<strong>replaceState</strong>、<strong>go</strong></p>
<ul>
<li><p><strong>pushState</strong>：类似于栈结构，可以实现页面的前进与后退。（实际上每使用一次pushState,都会生成一个新页面代替掉当前页面，浏览器会缓存当前页面的前后页面，可以实现前进与后退）</p>
<ul>
<li>参数1：data数据</li>
<li>参数2：title标题</li>
<li>参数3：url路径</li>
</ul>
<p><img src="VUE/121.png" alt="image-20210327195727256"></p>
</li>
<li><p><strong>back()/forward()**：back()往后，forward()向前（在</strong>pushState**可以使用这两个方法）</p>
<p><img src="VUE/122.png" alt="image-20210327200723241"></p>
<p><img src="VUE/125.png" alt="image-20210327202012268"></p>
</li>
<li><p><strong>replaceState</strong>：修改当前页面。（单一页面，并不存在前进后退。即back()/forward()方法不能使用）</p>
<ul>
<li>参数1：data数据</li>
<li>参数2：title标题</li>
<li>参数3：url路径</li>
</ul>
<p><img src="VUE/123.png" alt="image-20210327201422199"></p>
</li>
<li><p><strong>go</strong>：可以在当前页面指定跳转到前或后页面。参数为跳转的页面数。<code>-</code>表示后退，否则为前进，数值的大小为跳转的页面数。</p>
<p>不适用于replaceState。</p>
<ul>
<li>history.back() 等价于 history.go(-1)</li>
<li>history.forward() 则等价于 history.go(1)</li>
<li>这三个接口等同于浏览器界面的前进后退。</li>
</ul>
<p><img src="VUE/124.png" alt="image-20210327201802927"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4、vue-router"><a href="#4、vue-router" class="headerlink" title="4、vue-router"></a>4、vue-router</h3><h4 id="1、认识vue-router"><a href="#1、认识vue-router" class="headerlink" title="1、认识vue-router"></a>1、认识vue-router</h4><p>目前前端流行的三大框架, 都有自己的路由实现:</p>
<ul>
<li>Angular的ngRouter</li>
<li>React的ReactRouter</li>
<li>Vue的vue-router</li>
</ul>
<p>vue-router：</p>
<ul>
<li>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</li>
<li><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/">vue-router官网</a></li>
</ul>
<p>vue-router是基于路由和组件的</p>
<ul>
<li>路由用于设定访问路径, 将路径和组件映射起来.</li>
<li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li>
</ul>
<h4 id="2、安装与使用vue-router"><a href="#2、安装与使用vue-router" class="headerlink" title="2、安装与使用vue-router"></a>2、安装与使用vue-router</h4><p>因为我们已经学习了webpack, 后续开发中我们主要是通过<strong>工程化的方式</strong>进行开发的。所以在后续, 我们直接使用npm来安装路由即可。</p>
<p>步骤一: 安装vue-router</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure>

<p>步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能)</p>
<ul>
<li>第一步：导入路由对象，并且调用 Vue.use(VueRouter)</li>
<li>第二步：创建路由实例，并且传入路由映射配置</li>
<li>第三步：在Vue实例中挂载创建的路由实例</li>
</ul>
<p>使用vue-router的步骤:</p>
<ol>
<li><p>第一步: 创建路由对象VueRouter</p>
<ol>
<li>配置路由相关的信息</li>
<li>通过Vue.use(插件), 安装插件</li>
<li>创建VueRouter对象，配置路由和组件之间的应用关系</li>
<li>将router对象传入到Vue实例</li>
<li>到main.js中的Vue实例中挂载router对象</li>
</ol>
<p><img src="D:\blog\XGH-blog\source_posts\VUE\129.png" alt="image-20210328012024702"></p>
<p><img src="VUE/126.png" alt="image-20210328011844476"></p>
</li>
<li><p>第二步: 创建路由组件</p>
<p>在src/cpmponents文件夹下创建组件Home.vue与About.vue</p>
<p><img src="VUE/127.png" alt="image-20210328011915263"></p>
</li>
<li><p>第三步:配置路由映射: 组件和路径映射关系。在main.js中的routes。</p>
<p><img src="VUE/128.png" alt="image-20210328011939671"></p>
</li>
<li><p>第四步:使用路由: 通过<router-link>和<router-view>都是vue-router内定义过的全局组件</p>
<p><router-link>：用于建立与对应组件之间关系，最终会被渲染成<a>标签（页面效果）在App.vue的模板中使用</p>
<p><router-view>：用于占位，展示页面，该标签会根据当前的路径, 动态渲染出不同的组件。<router-view>用在哪里，组件对应模板就渲染在哪里。网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级。在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变。</p>
<p><img src="VUE/130.png" alt="image-20210328012112753"></p>
</li>
</ol>
<p>最终效果：</p>
<p><img src="VUE/131.png" alt="image-20210328012306928"></p>
<h4 id="3、细节处理"><a href="#3、细节处理" class="headerlink" title="3、细节处理"></a>3、细节处理</h4><h5 id="1、路由的默认值与修改为history模式"><a href="#1、路由的默认值与修改为history模式" class="headerlink" title="1、路由的默认值与修改为history模式"></a>1、路由的默认值与修改为history模式</h5><h6 id="1、路由的默认值"><a href="#1、路由的默认值" class="headerlink" title="1、路由的默认值"></a>1、路由的默认值</h6><p>我们这里还有一个不太好的实现:</p>
<ul>
<li>默认情况下, 进入网站的首页, 我们希望<router-view>渲染<strong>首页</strong>的内容。</li>
<li>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以。</li>
</ul>
<p>如何可以让一开始的<strong>路径</strong>就默认跳到到<strong>首页</strong>, 并且<router-view>渲染首页组件呢?</p>
<p>我只需要在router的index.js只修改，在配置路由和组件之间的应用关系时再配置一下重定向就可以了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>配置解析:</p>
<ul>
<li>我们在routes中又配置了一个映射。</li>
<li>path配置的是根路径: <code>/</code></li>
<li>redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了</li>
</ul>
<h6 id="2、修改为history模式"><a href="#2、修改为history模式" class="headerlink" title="2、修改为history模式"></a>2、修改为history模式</h6><p>我们前面说过改变路径的方式有两种:</p>
<ul>
<li>URL的hash</li>
<li>HTML5的history</li>
</ul>
<p><strong>默认情况下, 路径的改变使用的URL的hash。</strong>即路径后面会存在只有在hash模式才会出现的<code>#</code>，这其实是hash的锚点。</p>
<p>如果希望使用HTML5的history模式,可以在router的index.js里的router实例的属性进行如下配置即可:</p>
<p><img src="VUE/132.png" alt="image-20210328013637723"></p>
<p>效果：</p>
<p><img src="VUE/133.png" alt="image-20210328014008677"></p>
<h5 id="2、router-link补充"><a href="#2、router-link补充" class="headerlink" title="2、router-link补充"></a>2、router-link补充</h5><p>在前面的<router-link>中, 我们只是使用了一个属性: to, 用于指定跳转的路径。</p>
<p><router-link>中的属性：</p>
<ul>
<li><p>to：用于指定跳转的路径</p>
</li>
<li><p>tag: tag可以指定<router-link>之后渲染成什么组件（默认渲染成<a>）, 比如下面的代码会被渲染成一个<button>元素, 而不是<a></p>
</li>
<li><p>replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中。（默认为pushState）</p>
</li>
<li><p>active-class: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称。</p>
<ul>
<li><p>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类。</p>
</li>
<li><p>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可。</p>
<p><img src="VUE/134.png" alt="image-20210328014507832"></p>
</li>
<li><p>exact-active-class</p>
<ul>
<li>类似于active-class, 只是在精准匹配下才会出现的class。</li>
<li>后面看到嵌套路由时, 我们再看下这个属性。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home&quot;</span> tag=<span class="string">&quot;button&quot;</span> replace active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;active&quot;</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&quot;/about&quot;</span> tag=<span class="string">&quot;button&quot;</span> replace active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;active&quot;</span>&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若存在很多<router-link>标签，在每一个<router-link>标签内修改active-class的值将十分繁琐，所以有一个全局的配置，在router的index.js里的router实例的属性进行如下配置即可:</p>
<p>!<img src="VUE/136.png" alt="image-20210328015613180"></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、路由代码跳转"><a href="#3、路由代码跳转" class="headerlink" title="3、路由代码跳转"></a>3、路由代码跳转</h5><p>有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了：</p>
<p><img src="VUE/138.png" alt="138"></p>
<h5 id="4、动态路由"><a href="#4、动态路由" class="headerlink" title="4、动态路由"></a>4、动态路由</h5><p>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</p>
<ul>
<li>/user/aaaa或/user/bbbb</li>
<li>除了有前面的/user之外，后面还跟上了用户的ID</li>
</ul>
<p>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。</p>
<p>实现：路由有前面的/user之外，后面还<strong>动态</strong>跟上了用户的ID，并在页面展示用户的数据</p>
<ol>
<li><p>创建一个用户组件User.vue</p>
<p><img src="VUE/137.png" alt="image-20210328022521749"></p>
</li>
<li><p>在index.js中配置用户组件User.vue与路由之间的应用关系：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;../components/User&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routers = [</span><br><span class="line">    &#123;</span><br><span class="line">    	path: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    	component: User,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在App.vue进行动态渲染：</p>
<p>使用<router-link>方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过v-bind实现字符串拼接--&gt;</span><br><span class="line">&lt;!--如果直接拼接：to&#x3D;&quot;&#x2F;user&#x2F;+userId&quot;，它会将&#x2F;user&#x2F;+userId当成一个字符串--&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;user&#x2F;&#39;+userId&quot;&gt;用户&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-view&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &#39;App&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          userId: &#39;zhangsan&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用JavaScript代码的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;userClick&quot;&gt;用户&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &#39;App&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          userId: &#39;zhangsan&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        userClick() &#123;</span><br><span class="line">          this.$router.push(&#39;&#x2F;user&#x2F;&#39; + this.userId)</span><br><span class="line">    	&#125;</span><br><span class="line">  	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在User.vue进行模板编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是用户界面&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是用户的相关信息, 嘿嘿嘿&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;userId&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;!--也可以不使用计算属性，直接写--&gt;</span><br><span class="line">    &lt;!--&lt;h2&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;&#x2F;h2&gt;--&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;User&quot;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">          userId() &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意：这里的id要与index.js中的routers里路由的path的对应一致</span><br><span class="line">            return this.$route.params.id</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>效果：</p>
<p><img src="VUE/102.png" alt="image-20210328025647282"></p>
<h4 id="4、-route与-router的区别："><a href="#4、-route与-router的区别：" class="headerlink" title="4、$route与$router的区别："></a>4、$route与$router的区别：</h4><p><img src="VUE/114.png" alt="image-20210328030540747"></p>
<ul>
<li><p>$router：指的是路由器这一个整体。也就是我们在index.js中<code>const router = new VueRouter</code>的这个VueRouter对象，它里面包含routes[]路由数组里面有很多的路由，分别与组件对应。</p>
<p>其中图2通过修改路由器这一个整体的history模式去修改所有在该路由器下的路由的history模式。</p>
</li>
<li><p>$route：指的是当前活跃的路由。即当前使用页面对应的路由即为活跃路由。</p>
<p>其中图1通过当前活跃路由去获取的当前路由的参数数组中对应的参数。</p>
</li>
</ul>
<h4 id="5、路由的懒加载（使用时在加载）"><a href="#5、路由的懒加载（使用时在加载）" class="headerlink" title="5、路由的懒加载（使用时在加载）"></a>5、路由的懒加载（使用时在加载）</h4><h5 id="1、vue-router打包文件的解析"><a href="#1、vue-router打包文件的解析" class="headerlink" title="1、vue-router打包文件的解析"></a>1、vue-router打包文件的解析</h5><p>我们执行<code>npm run build</code>进行打包的时候，Vue-cli会在当前项目的目录下生成一个dist的文件夹。里面有css/js/img等文件夹和index.html文件。其中css文件夹里存放css.[hash].js，项目中关于css的部分打包在里面，img文件夹里面存放的是图片资源。还有一个js文件夹，里面有：</p>
<ul>
<li>app.[hash].js：当前应用程序开发的所有代码（业务代码）</li>
<li>manifest.[hash].js：为了打包的代码做底层支撑(导入导出)（Commonjs/ES6-&gt;ES5）</li>
<li>vendor.[hash].js：vendor（第三方/提供商）第三方vue/vue-router/axios/bs</li>
</ul>
<p><img src="VUE/74.png" alt="image-20210328142724755"></p>
<h5 id="2、对之前没用脚手架打包的bundle-js的粗略解析"><a href="#2、对之前没用脚手架打包的bundle-js的粗略解析" class="headerlink" title="2、对之前没用脚手架打包的bundle.js的粗略解析"></a>2、对之前没用脚手架打包的bundle.js的粗略解析</h5><p>之前的某个bundle.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">installedModules[moduleId]</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> 			i: moduleId,</span><br><span class="line"><span class="comment">/******/</span> 			l: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> 		modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.m = modules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.c = installedModules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// define getter function for harmony exports</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">!__webpack_require__.o(<span class="built_in">exports</span>, name)</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line"><span class="comment">/******/</span> 				configurable: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 				enumerable: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">/******/</span> 				get: getter</span><br><span class="line"><span class="comment">/******/</span> 			&#125;);</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line"><span class="comment">/******/</span> 		__webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> getter;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// __webpack_public_path__</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> ([</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__info__ = __webpack_require__(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1.使用commonjs的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = __webpack_require__(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;c&quot;</span> <span class="comment">/* name */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;a&quot;</span> <span class="comment">/* age */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;b&quot;</span> <span class="comment">/* height */</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;c&quot;</span>] = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;a&quot;</span>] = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;b&quot;</span>] = height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> ]);</span><br></pre></td></tr></table></figure>

<p>其实bundle.js中本质上是一个闭包函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)([])</span><br></pre></td></tr></table></figure>

<p>从后往前看：</p>
<ol>
<li><p><code>([])</code>中的内容其实是一个数组，存放的就是我们写的js代码。</p>
<p>即：我们写了main.js、mathUtil.js、info.js三个js文件，他们在<code>([])</code>中就按数组的方式存放：([main.js,mathUtil.js,info.js])。其中main.js为第0号元素。</p>
</li>
<li><p><code>(function(modules) &#123;&#125;)</code>这里对下面的js文件数组做底层支撑（commonjs/ES6-&gt;ES5、导入导出等等）。其中最重要的是<code>__webpack_require__()</code>方法。在<code>(function(modules) &#123;&#125;)</code>最后的返回<code>return __webpack_require__(__webpack_require__.s = 0)</code>作为入口。</p>
</li>
</ol>
<h5 id="3、vue-router的懒加载"><a href="#3、vue-router的懒加载" class="headerlink" title="3、vue-router的懒加载"></a>3、vue-router的懒加载</h5><p>官方给出了解释:</p>
<ul>
<li>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。</li>
<li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效</li>
</ul>
<p>通俗解释：</p>
<ul>
<li>首先, 我们知道路由中通常会定义很多不同的页面；</li>
<li>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件（app.[hash].js）中，因为app.[hash].js是当前应用程序开发的所有代码（业务代码）；</li>
<li>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大；</li>
<li>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况，这对用户是很不友好的；</li>
<li>如何避免这种情况呢? 使用路由懒加载就可以了。</li>
</ul>
<p>路由懒加载的作用：使用了在加载</p>
<ul>
<li>路由懒加载的主要作用就是<strong>将路由对应的组件打包成一个个的js代码块</strong>。</li>
<li>只有在这个路由被访问到的时候, 才加载对应的组件。</li>
</ul>
<p>路由懒加载的实现：</p>
<ul>
<li><p>方式一: 结合Vue的异步组件和Webpack的代码分析（早期使用，现已不常用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">require</span>.ensure([<span class="string">&#x27;../components/Home.vue&#x27;</span>], <span class="function">() =&gt;</span> &#123; resolve(<span class="built_in">require</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)) &#125;)&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二: AMD写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../components/About.vue&#x27;</span>], resolve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割（常用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>路由懒加载的实现的效果：</p>
<p><img src="VUE/139.png" alt="image-20210328143539544"></p>
<h4 id="6、路由的嵌套"><a href="#6、路由的嵌套" class="headerlink" title="6、路由的嵌套"></a>6、路由的嵌套</h4><p>嵌套路由是一个很常见的功能</p>
<ul>
<li>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容。</li>
<li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件。</li>
</ul>
<p>路径和组件的关系如下：</p>
<p><img src="VUE/140.png" alt="image-20210328145310299"></p>
<p>实现嵌套路由有两个步骤:</p>
<ul>
<li><p>创建对应的子组件HomeNews.vue和HomeMessage.vue, 并且在index.js引入并设置其中的路由映射中配置对应的子路由。在父路由里使用children属性，值是一个数组，在其中配置对应的子路由以及对应的子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HomeNews = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/HomeNews&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HomeMessage = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/HomeMessage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   path: &#x27;&#x27;,</span></span><br><span class="line">      <span class="comment">//   redirect: &#x27;news&#x27;</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">        component: HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">        component: HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>若在home主页中要设置默认页的可以在路由映射中配置对应的子路由中配置重定向redirect到想要的默认页。</p>
</li>
<li><p>在父组件Home.vue模板内部使用<router-link>进行相连与<router-view>标签进行占位。</p>
<p><strong>其中注意：<router-link>中to属性值的”/home/xxx”的第一个<code>/</code>不能省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是首页内容, 哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;新闻&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;消息&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7、参数传递"><a href="#7、参数传递" class="headerlink" title="7、参数传递"></a>7、参数传递</h4><p>为了演示传递参数, 我们这里再创建一个组件, 并且将其配置好</p>
<ol>
<li>第一步: 创建新的组件Profile.vue </li>
<li>第二步: 配置路由映射 </li>
<li>第三步: 添加跳转的<router-link></li>
</ol>
<p><img src="VUE/141.png" alt="image-20210328153143736"></p>
<h5 id="1、传递参数"><a href="#1、传递参数" class="headerlink" title="1、传递参数"></a>1、传递参数</h5><p><strong>传递参数主要有两种类型: params和query</strong></p>
<p><strong>params</strong>的类型（之前的动态路由）：</p>
<ul>
<li><p>配置路由格式：</p>
<p>/user/:id</p>
</li>
<li><p>传递的方式: 在path后面跟上对应的值：</p>
<p>:to=”‘/user/‘+userId”</p>
</li>
<li><p>传递后形成的路径：</p>
<p>在User.vue的模板template中</p>
</li>
</ul>
<p><strong>query</strong>的类型：</p>
<ul>
<li><p>配置路由格式： </p>
<p>path: ‘/profile’, 也就是普通配置</p>
</li>
<li><p>传递的方式： 对象中使用query的key作为传递方式：</p>
<p>使用<router-link>的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;path: &#39;&#x2F;profile&#39;, query: &#123;name: &#39;why&#39;, age: 18, height: 1.88&#125;&#125;档案&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<p>即在<code>:to</code>后面是一个对象，对象里面有两个属性path/query</p>
<ul>
<li>path：访问路由</li>
<li>query：查询参数，也是可以一个对象（里面存有多个数据）<ul>
<li>name: ‘why’</li>
<li>age: 18</li>
<li>height: 1.88</li>
</ul>
</li>
</ul>
<p>使用JavaScript代码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;profileClick&quot;&gt;档案&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   methods: &#123;</span><br><span class="line">        profileClick() &#123;</span><br><span class="line">          this.$router.push(&#123;</span><br><span class="line">            path: &#39;&#x2F;profile&#39;,</span><br><span class="line">            query: &#123;</span><br><span class="line">              name: &#39;kobe&#39;,</span><br><span class="line">              age: 19,</span><br><span class="line">              height: 1.87</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递后形成的路径: /profile?name=why&amp;age=18&amp;height=1.88</p>
<p>通过这种方式可以传递多个参数。</p>
<p><strong>注意：连点报错的在push的小括号后面加.catch(err =&gt;err)。</strong></p>
<p>例如：this.$router.replace(‘/home’).catch(err =&gt; {})</p>
</li>
</ul>
<h5 id="2、获取参数"><a href="#2、获取参数" class="headerlink" title="2、获取参数"></a>2、获取参数</h5><p><strong>获取参数通过$route对象获取的。</strong></p>
<p>在使用了 <code>vue-router</code> 的应用中，<strong>路由对象会被注入每个组件中</strong>，赋值为 <code>this.$route</code> ，并且当路由切换时，路由对象会被更新。</p>
<p>在profile.vue中的模板template中进行展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是Profile组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.age&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.height&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/143.png" alt="image-20210328172651274"></p>
<h5 id="3、-route和-router在参数传递过程中的区别："><a href="#3、-route和-router在参数传递过程中的区别：" class="headerlink" title="3、$route和$router在参数传递过程中的区别："></a>3、$route和$router在参数传递过程中的区别：</h5><ul>
<li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法；</li>
<li>$route为当前router跳转对象里面可以获取name、path、query、params等 。</li>
</ul>
<p><img src="VUE/144.png" alt="image-20210328172939825"></p>
<h5 id="4、所有的组件都继承自Vue类的原型"><a href="#4、所有的组件都继承自Vue类的原型" class="headerlink" title="4、所有的组件都继承自Vue类的原型"></a>4、<strong>所有的组件都继承自Vue类的原型</strong></h5><p>在main.js里定义的变量，在任何组件里都可以使用。</p>
<p>main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.name = <span class="string">&quot;coderwhy&quot;</span></span><br></pre></td></tr></table></figure>

<p>User.vue：在User.vue里并没有定义name，但可以使用Vue类中的name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    methods: &#123;</span><br><span class="line">          btnClick() &#123;</span><br><span class="line">            &#x2F;&#x2F; 所有的组件都继承自Vue类的原型</span><br><span class="line">            console.log(this.name);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这也是$route和$router的原理</p>
<ul>
<li><p>Vue.prototype.$router = return this.routerBoot.router</p>
<ul>
<li> this.routerBoot：Vue</li>
<li>router：Vue中的router</li>
</ul>
</li>
<li><p>Vue.prototype.$route = return this.routerBoot.route</p>
<p>this.routerBoot：Vue中的router</p>
<p>route：当前活跃路由</p>
</li>
</ul>
<h4 id="8、全局导航守卫"><a href="#8、全局导航守卫" class="headerlink" title="8、全局导航守卫"></a>8、全局导航守卫</h4><h5 id="1、beforeEach前置守卫-guard"><a href="#1、beforeEach前置守卫-guard" class="headerlink" title="1、beforeEach前置守卫(guard)"></a>1、beforeEach前置守卫(guard)</h5><p>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?</p>
<ul>
<li>网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变。（index.html）</li>
<li>但是我们可以通过生命周期函数+JavaScript来修改<title>的内容。 window.document.title = ‘新的标题’</li>
</ul>
<p>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</p>
<ul>
<li><p>普通的修改方式</p>
<ul>
<li><p>我们比较容易想到的修改标题的位置是<strong>每一个路由对应的组件.vue文件中</strong>。<strong>通过mounted/created声明周期函数, 执行对应的代码进行修改即可</strong>。</p>
<p>在每一个对应的组件.vue中添加对应的created钩子函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(&#39;home created&#39;);</span><br><span class="line">      document.title &#x3D; &#39;首页&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码)。</p>
</li>
</ul>
</li>
<li><p>导航守卫的方式：</p>
<p>什么是导航守卫?</p>
<ul>
<li>vue-router提供的导航守卫主要用来监<strong>听路由的进入和离开</strong>的。</li>
<li>vue-router提供了<strong>beforeEach前置守卫(guard)和afterEach后置钩子(hook)的函数</strong>, 它们会在<strong>路由即将改变前和改变后</strong>触发.</li>
</ul>
</li>
<li><p>实现：可以利用beforeEach前置守卫来完成标题的修改</p>
<ol>
<li><p>首先, 我们可以在路由当中定义一些标题, 可以利用meta(元数据)来定义；</p>
<p><img src="VUE/145.png" alt="image-20210328222421995"></p>
</li>
<li><p>其次, 利用beforeEach前置守卫(guard),来修改我们的标题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置守卫(guard)</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从from跳转到to</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>beforeEach前置守卫(guard)的三个参数：</p>
<ul>
<li>to: 即将要进入的目标的路由对象.</li>
<li>from: 当前导航即将要离开的路由对象.</li>
<li>next: 调用该方法后, 才能进入下一个钩子。</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li><p>上面的<code>document.title</code>为什么要写成<code>to.matched[0].meta.title</code>?不写成<code>to.meta.title</code>？</p>
<p>因为<code>to.meta.title</code>只能用于当前路由，即没有进行路由嵌套的当前路由。一旦有嵌套路由，那么<code>to.meta.title</code>将取不到值，为undefined，因为在嵌套路由，即当前路由是没有meta定义的，我们的mata只是定义在父路由（最基础的路由）那里。浏览器把嵌套路由的<code>meta</code>放在了<code>match[]数组</code>当中，在<strong>该数组中存放着当前路由的层级数组</strong>。而<code>match[]数组</code>的第0号元素就是当前路由的父路由，而对于没有嵌套的来源来说，自己就是自己的父路由。所有使用<code>to.matched[0].meta.title</code>就能取到每一个<code>meta</code>中的内容，无论路由有没有进行嵌套。</p>
<p><img src="VUE/146.png" alt="image-20210328225211032"></p>
</li>
<li><p><strong>在beforeEach方法里必须使用next函数</strong>。Vue-router默认实现了next方法，让网页可以进入下一步，但当我们调用beforeEach方法，vue-router就会使用我们在beforeEach方法里写的next函数，不会使用默认的那个。但如果我们没有写next函数（也就是在beforeEach方法中没有next函数），那么浏览器报错，不能渲染内容。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="2、如果是后置钩子-也就是afterEach-不需要主动调用next-函数"><a href="#2、如果是后置钩子-也就是afterEach-不需要主动调用next-函数" class="headerlink" title="2、如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数"></a>2、如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数</h5><p>afterEach后置钩子的参数只有afterEach(to,from)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置钩子(hook)</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;----&#x27;);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、路由独享的守卫与组件内的守卫"><a href="#3、路由独享的守卫与组件内的守卫" class="headerlink" title="3、路由独享的守卫与组件内的守卫"></a>3、路由独享的守卫与组件内的守卫</h5><p>上面我们使用的导航守卫, 被称之为<strong>全局守卫</strong>.</p>
<ul>
<li>路由独享的守卫。</li>
<li>组件内的守卫。</li>
</ul>
<p>查看<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">官网</a>进行学习</p>
<h4 id="9、keep-alive"><a href="#9、keep-alive" class="headerlink" title="9、keep-alive"></a>9、keep-alive</h4><h5 id="1、keep-alive实现页面缓存"><a href="#1、keep-alive实现页面缓存" class="headerlink" title="1、keep-alive实现页面缓存"></a>1、keep-alive实现页面缓存</h5><ul>
<li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li>
<li>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存。</li>
<li>在没有实现页面缓存的时候，每一次的页面跳转浏览器都会重新创建一个新的组件进行渲染。所以，页面缓存对于提高浏览器的性能是很有帮助的。</li>
</ul>
<p><img src="VUE/147.png" alt="image-20210328232633881"></p>
<p>需求：用户进入主页home的时候，默认显示新闻news页面。当用户点击主页home中的消息message页面后离开主页home，进入其他页面（如关于我们about）再回来主页home的时候，浏览器显示的是上次浏览的页面，也就是消息message页面（实现缓存）。</p>
<p>实现：（使用keep-alive加上组件内的守卫）</p>
<ol>
<li><p>直接在App.vue中的使用keep-alive将router-view包裹进来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>按道理来说浏览器已经实现的页面缓存了，实际上浏览器也实现了页面缓存（没有重新创建组件）。但是并没有实现我们想要的需求（浏览器显示的是上次浏览的页面），还是实现home的news页面。</p>
<p><img src="VUE/148.png" alt="image-20210329001711312"></p>
<p>为什么？</p>
<p>在浏览器处于其他页面的时候（如about页面）我们再点击主页home。浏览器实现to路由跳转，相当于在url传入了path=home，因为主页home会默认显示news页面，即在组件与路由匹配的时候进行了重定向redirect: ‘news’。所以在传入home的同时，浏览器重定向到了news页面。</p>
</li>
<li><p>修改重定向的方式，不使用组件与路由匹配的时候进行了重定向redirect: ‘news’，将对应的代码注释掉。在Home.vue中，在生命周期函数created中实现重定向。因为created是在组件被创建后的钩子函数，所以在Home组件被创建的时候进行重定向。又因为使用了keep-alive实现了页面缓存，从而实现浏览器显示的是上次浏览的页面这个需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      this.$router.push(this.path)</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>能实现首页home默认显示新闻news页面，但是不能实现重新进入主页home的时候显示的是上次浏览的页面。显示的是home主页，不是新闻news页面，也不是消息message页面。</p>
<p><img src="VUE/149.png" alt="image-20210329002247904"></p>
<p>原因（忽略了返回的home）：在其它页面进入主页home的时候，浏览器实现to路由跳转，相当于在url传入了path=home。但是主页home由keep-alive实现了页面缓存，Home组件不会被重新创建，也就是不会重复多次的调用created方法。组件没有销毁，所以只调用一次create方法，就是在主页创建的时候实现的重定向，之后并不会进行重定向。但传入home的时候没有重定向所以没有修改到home的news界面。</p>
</li>
<li><p>使用activated()与deactivated()函数：</p>
<ul>
<li>activated()：活跃时调用，当点击某个页面时，该页面进入活跃状态</li>
<li>deactivated()：非活跃时调用，离开某个页面时，该页面进入非活跃状态</li>
</ul>
<p>注释掉之前的created函数，使用activated()与deactivated()函数。在activated()实现重定向news，在deactivated()中实现在离开之前获取主页上次浏览的页面，如消息message主页。实现主页home默认显示新闻news页面，在离开的时候更新path的值，使重新回到主页home的时候，通过path的值重定向到上次浏览的页面，实现需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated() &#123;</span><br><span class="line">      this.$router.push(this.path);</span><br><span class="line">    &#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">        this path &#x3D; this.$route.push;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>能实现主页home默认显示新闻news页面，但是当离开首页home，就点不回去主页home了。。。</p>
<p><img src="VUE/151.png" alt="image-20210329005822319"></p>
<p>原因：因为this.$route.push获取的是当前活跃路由，并不是主页home，所以不能拿到离开的时候主页的path值。拿到的path是用户User页面。弄错了执行顺序。正确的执行顺序：activated()主页显示默认页news =&gt; 点击用户，执行deactivated()函数将path修改成/user/zhangsan =&gt; 点击主页home执行activated()函数重定向到/user/zhangsan =&gt; 再执行deactivated()函数将path修改成/user/zhangsan =&gt; …….一直重复。所以显示的一直是用户User页面，点不回去主页home。</p>
</li>
<li><p>使用组件内导航的beforeRouteLeave()函数实现在离开之前获取主页上次浏览的页面，如消息message主页。实现主页home默认显示新闻news页面，在离开的时候更新path的值，使重新回到主页home的时候，通过path的值重定向到上次浏览的页面，实现需求。</p>
<p><img src="VUE/152.png" alt="image-20210329010318911"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated() &#123;</span><br><span class="line">      this.$router.push(this.path);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">      console.log(this.$route.path);</span><br><span class="line">      this.path &#x3D; this.$route.path;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>实现需求。就是在第二种解决方法上使用beforeRouteLeave()去代替了deactivated()。因为deactivated()的route是用户User页面，而beforeRouteLeave()的route还是主页home。</p>
<p><img src="VUE/153.png" alt="image-20210329011235744"></p>
<p>总结如下：</p>
<ol>
<li>注释掉之前的默认页的重定向方式，采用activated()的方式进行默认页的重定向</li>
<li>使用组件内导航beforeRouteLeave记录离开时的状态，修改path的值方便下次重定向</li>
<li>使用keep-alive实现页面缓存</li>
</ol>
</li>
</ol>
<h5 id="2、activated-与deactivated-函数"><a href="#2、activated-与deactivated-函数" class="headerlink" title="2、activated()与deactivated()函数"></a>2、activated()与deactivated()函数</h5><p>activated()与deactivated()函数这两个函数只有在该组件被保持了状态使用了keep-alive时, 才是有效的。否则不能使用这两个函数。</p>
<h5 id="3、keep-alive的属性"><a href="#3、keep-alive的属性" class="headerlink" title="3、keep-alive的属性"></a>3、keep-alive的属性</h5><p>keep-alive有两个非常重要的属性：</p>
<ul>
<li>include - 字符串或正则表达，只有匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;</span><br><span class="line">  &lt;router-view&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：Profile,User中的逗号<code>,</code>后面不能加空格。（与正则表达式元素一样”\d{2,9}”）</strong></p>
<h2 id="九、Promise"><a href="#九、Promise" class="headerlink" title="九、Promise"></a>九、Promise</h2><h3 id="1、什么是promise"><a href="#1、什么是promise" class="headerlink" title="1、什么是promise"></a>1、什么是promise</h3><p>ES6中一个非常重要和好用的特性就是Promise。</p>
<p>Promis的作用：<strong>Promise是异步编程的一种解决方案。</strong></p>
<p>那什么时候我们会来处理异步事件呢？</p>
<ul>
<li>一种很常见的场景应该就是网络请求了。</li>
<li>我们封装一个网络请求的函数，因为<strong>不能立即拿到结果，需要等待网络请求</strong>，所以不能像简单的3+4=7一样将结果返回。</li>
<li>所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。当数据请求失败时提示错误信息。</li>
<li>如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦，但是当网络请求非常复杂时，就会出现回调地狱。</li>
</ul>
<p>什么是回调地狱？</p>
<p>我们来考虑下面的场景(有夸张的成分)，但在实际上也有可能出现以下情况：</p>
<ul>
<li><p>我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2；</p>
</li>
<li><p>我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3；</p>
</li>
<li><p>我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4；</p>
</li>
<li><p>发送网络请求url4，获取最终的数据data4。</p>
<p><img src="VUE/154.png" alt="image-20210329213713985"></p>
</li>
</ul>
<p>上面的代码存在的问题：</p>
<ul>
<li>正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。</li>
<li>但是，当中间每一次进行数据处理的代码都有多于100行的时候，这样的代码难看而且不容易维护，简直就是地狱。</li>
<li>我们更加期望的是一种更加优雅的方式来进行这种异步操作。</li>
</ul>
<p>所以可以通过Promise以一种非常优雅的方式来解决这个问题。</p>
<h3 id="2、promise的使用"><a href="#2、promise的使用" class="headerlink" title="2、promise的使用"></a>2、promise的使用</h3><h4 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h4><p>这里用一个定时器来模拟异步事件：</p>
<ul>
<li><p>假设下面的data是从网络上1秒后请求的数据</p>
</li>
<li><p>console.log就是我们的处理方式。</p>
</li>
<li><p>这是我们过去的处理方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">error</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 成功的时候调用resolve</span></span><br><span class="line">      <span class="comment">// resolve(&#x27;Hello World&#x27;)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 失败的时候调用reject</span></span><br><span class="line">      reject(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到请求数据，执行100行的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 100行的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>解析promise：</p>
<ul>
<li>new Promise很明显是创建一个Promise对象；</li>
<li>Promise传入两个参数函数((resolve, reject) =&gt; {})很明显就是一个函数，其中的参数resolve, reject<ul>
<li>resolve和reject函数只是一个标识，没有真正的函数体，你在newPromise中执行哪两个函数时会采用异步执行，也就先被挂载起来了。</li>
<li>在通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</li>
</ul>
</li>
<li>成功与失败：<ul>
<li>如果是<strong>成功</strong>的，那么通常我们会调用resolve(message)，这个时候，我们后续的<code>then</code>会被回调</li>
<li>如果是<strong>失败</strong>的，那么通常我们会调用reject(error)，这个时候，我们后续的<code>catch</code>会被回调</li>
</ul>
</li>
</ul>
<p>这就是Promise最基本的使用。那么，什么情况下会用到Promise?</p>
<ul>
<li>一般情况下是有异步操作时,使用Promise对这个异步操作进行封装。</li>
<li>通常将数据的网络请求部分代码放在(resolve, reject) =&gt; { 网络请求部分代码 }中，</li>
<li>将获取到网络请求的数据data后，对data进行数据处理的部分代码放在<code>then</code>当中，</li>
<li>将获取数据失败后的错误处理代码部分放在<code>catch</code>当中。</li>
</ul>
<p>执行过程：</p>
<ol>
<li>new Promise</li>
<li>构造函数(1.保存了一些状态信息 2.执行传入的函数)</li>
<li>在执行传入的回调函数时, 会传入两个参数, resolve, reject.本身又是函数</li>
<li>网路请求数据</li>
<li>获取数据成功进入then进行数据处理</li>
<li>获取数据失败进入catch进行错误处理</li>
</ol>
<h4 id="2、Promise链式调用"><a href="#2、Promise链式调用" class="headerlink" title="2、Promise链式调用"></a>2、Promise链式调用</h4><p>我们在看Promise的流程图时，发现无论在then还是catch中都可以返回一个Promise对象。所以，我们的代码其实是可以进行链式调用的：</p>
<p>我们可以直接通过Promise包装一下新的数据，将Promise对象返回了</p>
<ul>
<li>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数</li>
<li>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数</li>
</ul>
<p>需求：</p>
<ol>
<li>网络请求: aaa -&gt; 自己处理(10行)</li>
<li>处理: aaa111 -&gt; 自己处理(10行)</li>
<li>处理: aaa111222 -&gt; 自己处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次网络请求的代码</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次拿到结果的处理代码</span></span><br><span class="line">    <span class="comment">// 自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res + <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">      <span class="comment">// 过程中出现错误，直接执行catch，不会在执行以下的then</span></span><br><span class="line">      <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对结果进行第二次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第三次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>链式调用简写</strong>：</p>
<ul>
<li><p>如果我们希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Promise(resolve =&gt; resolve(结果))简写</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次网络请求的代码</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次拿到结果的处理代码</span></span><br><span class="line">    <span class="comment">// 自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res + <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对结果进行第二次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第三次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意下面的代码中，我讲return Promise.resovle(data)改成了return data</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略掉Promise.resolve</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> res + <span class="string">&#x27;111&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + <span class="string">&#x27;222&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果依然是一样的</p>
</li>
<li><p>Promise.reject(‘error message’)的另一种写法：都可以进入到catch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return Promise.reject(&#x27;error message&#x27;)</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;error message&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、Promise的all方法："><a href="#3、Promise的all方法：" class="headerlink" title="3、Promise的all方法："></a>3、Promise的all方法：</h4><p>当某个需求需要同时拿到两个或多个网络请求到的数据才能进行实现。为了分析那个网络请求先拿到数据（因为是同步的，所以不清楚哪个请求会先拿到。因为如果能够肯定网路请求2在网路请求1请求之后拿到数据的话，就可以将业务统一在网路请求1中实现。没必要进行下面的步骤。）这个时候如果使用之前jQuery + ajax的方式将变得很麻烦，但使用Promise的all方法将十分轻松的实现。</p>
<ul>
<li><p>使用jQuery + ajax的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网路请求一:</span></span><br><span class="line"><span class="keyword">let</span> isResult1 = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> isResult2 = <span class="literal">false</span></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;结果1&#x27;</span>);</span><br><span class="line">      isResult1 = <span class="literal">true</span></span><br><span class="line">      handleResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 网路请求二:</span></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;结果1&#x27;</span>);</span><br><span class="line">      isResult2 = <span class="literal">true</span></span><br><span class="line">      handleResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isResult1 &amp;&amp; isResult2) &#123;</span><br><span class="line">      <span class="comment">// 实现业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Promise的all方法的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="comment">// 网路请求一:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: <span class="string">&#x27;url1&#x27;</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 网路请求二:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个网路请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(results[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 第二个网路请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(results[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>Promise.all()的参数是一个<code>可迭代对象iterator</code>，也就是可遍历的，数组只是其中之一。</li>
<li>resolve(data)：中的data不只可以是一个数值，也可以是一个对象。</li>
</ul>
</li>
</ul>
<h3 id="3、Promise三种状态"><a href="#3、Promise三种状态" class="headerlink" title="3、Promise三种状态"></a>3、Promise三种状态</h3><p>当我们开发中有异步操作时, 就可以给异步操作包装一个Promise。异步操作之后会有三种状态：</p>
<p><img src="VUE/156.png" alt="image-20210329224000758"></p>
<ul>
<li>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li>
<li>fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li>
<li>reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</li>
</ul>
<h2 id="十、Vuex"><a href="#十、Vuex" class="headerlink" title="十、Vuex"></a>十、Vuex</h2><h3 id="1、什么是Vuex"><a href="#1、什么是Vuex" class="headerlink" title="1、什么是Vuex"></a>1、什么是Vuex</h3><p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">官方</a>解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p>
<ul>
<li>它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>Vuex 也集成到 Vue 的官方调试工具 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">devtools</a><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li>
</ul>
<p>是什么<strong>状态管理</strong>？</p>
<ul>
<li><strong>状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</li>
<li>其实，你可以简单的将其看成把<strong>需要多个组件共享的变量</strong>全部存储在一个单一对象里面。</li>
<li>然后，将这个单一对象放在顶层的Vue实例中，让其他组件可以使用。</li>
<li>那么，多个组件就可以共享这个对象中的所有变量属性了。</li>
</ul>
<p>如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？</p>
<ul>
<li>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是<strong>响应式</strong>。</li>
<li>如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。</li>
</ul>
<p><strong>总结：Vuex就是为了提供这样一个在多个组件间共享状态的插件，同时又具备响应式的特点。</strong></p>
<h3 id="2、需要管理的状态"><a href="#2、需要管理的状态" class="headerlink" title="2、需要管理的状态"></a>2、需要管理的状态</h3><p>有什么状态时需要我们在多个组件间共享的呢？</p>
<ul>
<li>如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</li>
<li>比如用户的<strong>登录状态（token）</strong>、用户名称、头像、地理位置信息等等。</li>
<li>比如商品的收藏、购物车中的物品等等。</li>
</ul>
<p>这些状态信息，都是在很多组件里需要使用到的，我们可以放在Vuex中，对它们进行保存和管理，而且它们还是响应式的。</p>
<h3 id="3、界面的状态管理"><a href="#3、界面的状态管理" class="headerlink" title="3、界面的状态管理"></a>3、界面的状态管理</h3><h4 id="1、单界面的状态管理"><a href="#1、单界面的状态管理" class="headerlink" title="1、单界面的状态管理"></a>1、单界面的状态管理</h4><p>要在单个组件中进行状态管理是一件非常简单的事情。具体看下图：</p>
<p>单界面状态管理的图示：</p>
<p><img src="VUE/157.png" alt="image-20210330013105126"></p>
<ul>
<li>State：就是我们的状态。（你姑且可以当做就是data中的属性变量）</li>
<li>View：视图层，可以针对State的变化，显示不同的信息。</li>
<li>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li>
</ul>
<p>单界面图解（从State开始）：</p>
<p>State就是我们的状态，也就是data中的属性 =&gt; 我们可以将State展示到浏览器上，也就是View层 =&gt; 在浏览器View上，我们可以经过一些Actions行为（如点击/滑动等等）去改变State属性的值 =&gt; 浏览器响应式的将改变后的State属性返回到State</p>
<p>案例：状态管理<code>个数counter</code></p>
<p><img src="VUE/155.png" alt="image-20210330133234214"></p>
<ul>
<li>counter需要某种方式被记录下来，也就是我们的State。</li>
<li>counter目前的值需要被显示在界面中，也就是我们的View部分。</li>
<li>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态State，也就是我们的Actions.</li>
</ul>
<h4 id="2、多界面状态管理"><a href="#2、多界面状态管理" class="headerlink" title="2、多界面状态管理"></a>2、多界面状态管理</h4><p>Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p>
<ul>
<li>多个视图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</li>
<li>不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</li>
<li>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的</li>
<li>状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</li>
<li>这个帮助我们管理的大管家就是Vuex。</li>
</ul>
<p><strong>全局单例模式（大管家）</strong></p>
<ul>
<li>我们现在要做的就是将共享的状态抽取出来，交给Vuex统一进行管理。</li>
<li>之后，你们每个试图，按照我<strong>规定好的</strong>规定，进行访问和修改等操作。</li>
<li>这就是Vuex背后的基本思想。</li>
</ul>
<p>多界面状态管理的图示：</p>
<p><img src="VUE/159.png" alt="image-20210330143646693"></p>
<p>图解：</p>
<ul>
<li>Mutations与Devtools：<ul>
<li>Vue开发的一个浏览器插件。安装在浏览器上，为后续的Vuex开发提供的插件。</li>
<li>作用：记录浏览器每次修改State的状态，让你清楚地跟踪到是哪一个组件修改了State，发生错误的时候也可以及时精准定位到出错的组件，对其代码进行修改。大大提高了开发效率。</li>
<li>但这个插件实现的前提是修改的数据有经过Mutations进入到State。所以官方不推荐将数据直接从Vue Component发回State，没经过Mutations，devtools就不能对State进行实时跟踪。</li>
<li>在Mutations里一般都是同步操作，如果需求中没有异步操作，也可以从Vue Component直接发送到Mutations。官方没有说这样做不可以</li>
<li>在没有使用Devtools时，由于每个组件都在使用State，使用很难跟踪到哪个组件对State进行修改。当某一个组件错误的修改了数据State，这个时候将很难进行查错。</li>
</ul>
</li>
<li>Actions与Mutations：<ul>
<li>在Actions中实现业务的异步操作，发送网络请求与后台API接口进行数据交互。</li>
<li>由于在Mutations中不能追踪到异步操作的State，所以将异步操作放在Actions当中进行处理。</li>
<li>经Actions处理过后变成同步操作在交由Mutations中的Devtools进行State追踪。</li>
<li>如果业务不需要进行异步操作，可以跳过Actions直接发送给Mutations进行追踪。</li>
</ul>
</li>
</ul>
<h3 id="4、Vuex的使用"><a href="#4、Vuex的使用" class="headerlink" title="4、Vuex的使用"></a>4、Vuex的使用</h3><p>案例：两个组件同时使用<code>属性count</code>，使用Vuex管理count</p>
<p>实现步骤：</p>
<ol>
<li><p>首先，我们需要在某个地方存放我们的Vuex代码：</p>
<p>这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件。</p>
</li>
<li><p>其次，我们让所有的Vue组件都可以使用这个store对象，</p>
<p>来到main.js文件，导入store对象，并且放在new Vue中，</p>
<p>这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了。</p>
</li>
<li><p>提取出一个公共的store对象，用于保存在多个组件中共享的状态</p>
</li>
<li><p>将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p>
</li>
<li><p>在其他组件中使用store对象中保存的状态即可</p>
<ul>
<li>通过this.$store.state.属性的方式来访问状态</li>
<li>通过this.$store.commit(‘mutation中方法’)来修改状态</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>我们通过提交mutation的方式，而非直接改变store.state.count。</li>
<li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li>
</ul>
</li>
</ol>
<p>代码：</p>
<ol>
<li><p>在src下建立<code>store</code>（仓库）文件夹，在里面创建index.js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">      count: <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">      <span class="comment">// 方法</span></span><br><span class="line">      <span class="function"><span class="title">incrememt</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          state.counr++</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">deincrememt</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          state.counr--</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>在main.js中挂载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在两个组件中使用Vuex管理的count：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在两个组件中使用Vuex的mutations去修改State的值：使用this.$store.commit(对应方法名)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	  addition() &#123;</span><br><span class="line">        this.$store.commit(INCREMENT)</span><br><span class="line">      &#125;,</span><br><span class="line">      subtraction() &#123;</span><br><span class="line">        this.$store.commit(&#39;decrement&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5、Vuex的五大属性"><a href="#5、Vuex的五大属性" class="headerlink" title="5、Vuex的五大属性"></a>5、Vuex的五大属性</h3><ul>
<li>State</li>
<li>Getters</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h4 id="1、State"><a href="#1、State" class="headerlink" title="1、State"></a>1、State</h4><h5 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h5><p>Vuex提出使用单一状态树, 什么是单一状态树呢？</p>
<p>英文名称是Single Source of Truth，也可以翻译成<strong>单一数据源</strong>。</p>
<p>来看一个生活中的例子。</p>
<ul>
<li>OK，我用一个生活中的例子做一个简单的类比。</li>
<li>我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</li>
<li>这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</li>
<li>这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。</li>
</ul>
<p>这个和我们在应用开发中比较类似：</p>
<ul>
<li>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。</li>
<li>所以Vuex也使用了单一状态树来管理应用层级的全部状态。</li>
<li>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</li>
</ul>
<h4 id="2、Getters"><a href="#2、Getters" class="headerlink" title="2、Getters"></a>2、Getters</h4><h5 id="1、Getters作为全局的computed"><a href="#1、Getters作为全局的computed" class="headerlink" title="1、Getters作为全局的computed"></a>1、Getters作为全局的computed</h5><p>我们需要从store中获取一些state变异后的状态。在单一界面中，我们是通过计算属性computed实现data的一些修改后的数据。然而在多界面中，我们通过Vuex进行管理。若仍使用单一界面的方法，用computed修改Store里State的值（$store.state.counter），则每一个需要用到State的组件都得使用computed，会增加很多冗余的代码。而使用Vuex的getters对State做统一的处理，让有需要的组件直接调用即可。</p>
<p>案例：获取学生年龄大于20的个数</p>
<p>Vuex的State：</p>
<p><img src="VUE/158.png" alt="image-20210330203308770"></p>
<ul>
<li><p>方式一：使用computed</p>
<p><img src="VUE/163.png" alt="image-20210330204204000"></p>
</li>
<li><p>方式二：使用getters</p>
<p><img src="VUE/164.png" alt="获取"></p>
</li>
</ul>
<h5 id="2、Getters作为参数和传递参数"><a href="#2、Getters作为参数和传递参数" class="headerlink" title="2、Getters作为参数和传递参数"></a>2、Getters作为参数和传递参数</h5><h6 id="1、将Getters作为参数，通过调用Getters的方法进行获取"><a href="#1、将Getters作为参数，通过调用Getters的方法进行获取" class="headerlink" title="1、将Getters作为参数，通过调用Getters的方法进行获取"></a>1、将Getters作为参数，通过调用Getters的方法进行获取</h6><p>如果我们已经通过getters获取了一个所有年龄大于20岁学生列表，那么怎么拿到学生列表的长度：</p>
<p><img src="VUE/162.png" alt="image-20210330203841286"></p>
<h6 id="2、Getters传递参数"><a href="#2、Getters传递参数" class="headerlink" title="2、Getters传递参数"></a>2、Getters传递参数</h6><p>getters默认是<strong>不能传递参数</strong>的, 如果希望传递参数, 那么只能<strong>让getters本身返回另一个函数</strong>。</p>
<p>比如上面的案例中,我们希望根据我们输入的age来获取年龄大于age的用户的信息（不写死）：</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他组件调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.moreAgeStu(12)&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3、Mutation"><a href="#3、Mutation" class="headerlink" title="3、Mutation"></a>3、Mutation</h4><h5 id="1、状态更新"><a href="#1、状态更新" class="headerlink" title="1、状态更新"></a>1、状态更新</h5><p>官方：Vuex的store状态的更新唯一方式：<strong>提交Mutation</strong></p>
<p>Mutation主要包括两部分：</p>
<ul>
<li>字符串的<strong>事件类型（type）</strong></li>
<li>一个<strong>回调函数（handler）</strong>,该回调函数的<strong>第一个参数就是state</strong></li>
</ul>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.counter--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>decrement：事件类型（type）</li>
<li>(state){}：回调函数（handler），第一个参数就是state。</li>
</ul>
<p>通过mutation更新：this.commit(“事件类型”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subtraction() &#123;</span><br><span class="line">  this.$store.commit(&#39;decrement&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、传递参数"><a href="#2、传递参数" class="headerlink" title="2、传递参数"></a>2、传递参数</h5><p>在通过mutation更新数据的时候, 有可能我们希望携带一些<strong>额外的参数</strong></p>
<p>参数被称为是mutation的载荷(Payload)，但需要记住：mutation的回调函数的第一个参数就是state，第二个才是载荷(Payload)。</p>
<h6 id="1、传递一个参数"><a href="#1、传递一个参数" class="headerlink" title="1、传递一个参数"></a>1、传递一个参数</h6><p><img src="VUE/165.png" alt="image-20210330232321987"></p>
<h6 id="2、传递多个参数（封装成一个对象）"><a href="#2、传递多个参数（封装成一个对象）" class="headerlink" title="2、传递多个参数（封装成一个对象）"></a>2、传递多个参数（封装成一个对象）</h6><ul>
<li>比如我们有很多参数需要传递。</li>
<li>这个时候, 我们通常会<strong>以对象的形式传递</strong>, 也就是<strong>payload是一个对象</strong>。</li>
<li>这个时候可以再<strong>从对象中取出相关的信息</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;<span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;alan&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>&#125;</span><br><span class="line"><span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addStudent&#x27;</span>, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、提交风格"><a href="#3、提交风格" class="headerlink" title="3、提交风格"></a>3、提交风格</h5><p>上面的通过<strong>commit</strong>进行提交是一种普通的方式。</p>
<p>Vue还提供了另外一种风格, 它是一个包含type属性的对象。</p>
<ul>
<li><p>特殊提交：因为变成了一个对象，里面除了count以外，还可以放入age等等，所以在Mutations的实现中需要使用payload.xxx的方式拿到xxx的值，否则直接拿到的xxx是一个payload对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 2.特殊的提交封装</span></span><br><span class="line">   <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">       type: <span class="string">&#x27;incrementCount&#x27;</span>,</span><br><span class="line">       count</span><br><span class="line">   &#125;)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mutation中的处理方式是<strong>将整个commit的对象作为payload使用</strong>, 所以代码没有改变, 依然如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrementCount(state, payload) &#123;</span><br><span class="line">    state.counter +&#x3D; payload.count</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4、响应规则（新版2-6-12以上不同，看总结）"><a href="#4、响应规则（新版2-6-12以上不同，看总结）" class="headerlink" title="4、响应规则（新版2.6.12以上不同，看总结）"></a>4、响应规则（新版2.6.12以上不同，看总结）</h5><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。</p>
<p>原理：（观察者模式：监听 -&gt; 发现变化 -&gt; 刷新页面）</p>
<ul>
<li><p>在我们创建好store对象时已经将state里的所有的属性，所有的对象放在vue的响应式系统里面了</p>
</li>
<li><p>之后vue都会观察着在state中每一个属性/对象的变化。</p>
</li>
<li><p>vue会为每个属性对象设定Dep，每一个属性对象对应着一个Dep，这个Dep可以监听属性对象的变化（观察者模式），而Dep对应着许多Watcher，Dep里有一个Watcher数组，里面就是所有与该属性数据绑定的地方。一旦属性数据发生变化，它会看一下（Watcher）有哪些地方会根据数据的变化去刷新页面的。</p>
<p><img src="VUE/166.png" alt="属性被添加到响应式系统中"></p>
</li>
</ul>
<p>但这就要求我们必须遵守一些Vuex对应的规则:</p>
<ol>
<li><strong>提前在store中初始化好所需的属性</strong>。</li>
<li>当给state中的对象添加/删除新属性时, 使用下面的方式：<ul>
<li>方式一: 使用Vue.set(obj, ‘newProp’, 123)</li>
<li>方式二: 用新对象给旧对象重新赋值</li>
</ul>
</li>
</ol>
<p>对应规则讲解：</p>
<ul>
<li><p>规则1：info:{name: ‘why’,age: 18}，给info添加属性height: 1.88</p>
<p><img src="VUE/167.png" alt="image-20210331001216170"></p>
<p><strong>提前在store中初始化好所需的属性</strong>。对已经创建store对象之后在进行初始化的属性并不会加入Vue的响应式系统里面。虽然声明了属性并成功赋值了，但没有响应。</p>
</li>
<li><p>规则2：若要实现在创建store对象之后添加或删除的属性，而且要实现响应式，怎么做？</p>
<p><img src="VUE/168.png" alt="image-20210331001552856"></p>
<p>删除也一样，如果在Mutations中使用delete方式<code>delete state.info.age</code>进行实现删除，并不会实现响应式。但如果使用Vue.delete<code>Vue.delete(state.info,&#39;age&#39;)</code>的话就可以实现响应式，给info赋值一个新的对象也是。</p>
</li>
</ul>
<p>总结：以上规则在旧版本是这样的，但在新版本2.12.6以上不一样了，区别：</p>
<ul>
<li>如果你在方法里面使用与响应式相关的东西（如修改响应式数据，Vue.set、Vue.delete等等），这个时候使用非响应式的方式修改属性数据是可以做到响应式的。</li>
<li>但是，如果你在方法里面没有使用与响应式相关的东西，直接就是一些非响应式的操作，那么就不能实现响应式。</li>
<li>新版本同时写了响应式和非响应式的操作，在使用响应式的基础上，非响应式的也显示了。但是单单写非响应式的操作并不能实现响应式。</li>
</ul>
<h5 id="5、Mutation常量类型"><a href="#5、Mutation常量类型" class="headerlink" title="5、Mutation常量类型"></a>5、Mutation常量类型</h5><p>我们来考虑下面的问题:</p>
<ul>
<li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)。</li>
<li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多。</li>
<li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况。</li>
</ul>
<p>如何避免上述的问题呢?</p>
<ul>
<li>在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代<strong>Mutation事件的类型</strong>。</li>
<li>我们可以将这些常量放在一个<strong>单独的文件</strong>中, 方便管理以及让整个app所有的事件类型一目了然。</li>
</ul>
<p>具体怎么实现?</p>
<ul>
<li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量。</li>
<li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称。</li>
</ul>
<p><img src="VUE/169.png" alt="image-20210331003230794"></p>
<p>官网：用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
<h5 id="6、同步函数"><a href="#6、同步函数" class="headerlink" title="6、同步函数"></a>6、同步函数</h5><p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法。</p>
<ul>
<li><p>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照。</p>
</li>
<li><p>比如我们之前的代码, 当执行更新时, devtools中会有如下信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">	state.info.name = <span class="string">&#x27;codewhy&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/172.png" alt="image-20210331004509394"></p>
</li>
<li><p>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成。即不能实现State跟踪。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">		state.info.name = <span class="string">&#x27;codewhy&#x27;</span></span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/173.png" alt="image-20210331004903309"></p>
</li>
</ul>
<p><strong>总结：通常情况下, 不要再mutation中进行异步的操作。</strong></p>
<h4 id="4、Actions"><a href="#4、Actions" class="headerlink" title="4、Actions"></a>4、Actions</h4><h5 id="1、基本定义"><a href="#1、基本定义" class="headerlink" title="1、基本定义"></a>1、基本定义</h5><p>我们强调, 不要再Mutation中进行异步操作。但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的。这个时候怎么处理呢?</p>
<p>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的。</p>
<p>Action的基本使用代码：</p>
<p>index.js：</p>
<p>注意：这里的commit是在使用Mutations当中的updateInfo方法进行数据更改。通过这个方法将数据经过Mutations，使Devtools可以跟踪到。因为Actions到Mutations中间就是commit。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line">          name: <span class="string">&#x27;koby&#x27;</span>,</span><br><span class="line">          age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">      <span class="comment">// context: 上下文</span></span><br><span class="line">	  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      	  context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">      	  <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">      	  payload.success()</span><br><span class="line">    	&#125;, <span class="number">1000</span>)</span><br><span class="line">  	  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<p>注意：在这里不能使用this.#store.commit，因为现在是使用Actions里的方法进行异步操作，如果在这里使用commit，相当于将数据直接从Actions发送到了State，没有经过Mutations。Devtools不能进行属性跟踪。也违反了：Vuex的store状态的更新唯一方式：<strong>提交Mutation</strong>。而通过多界面状态管理图也可以发现：Actions到Mutations是dispatch，不是commit。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, &#123;</span><br><span class="line">    	message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">    	success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context是什么?</p>
<ul>
<li>context是和store对象具有相同方法和属性的对象。</li>
<li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等。</li>
<li>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说。</li>
</ul>
<p>这样的代码是否多此一举呢?</p>
<ul>
<li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li>
<li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了。</li>
</ul>
<h5 id="2、Actions返回的Promise"><a href="#2、Actions返回的Promise" class="headerlink" title="2、Actions返回的Promise"></a>2、Actions返回的Promise</h5><p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作。而Actions又是让我们实现异步操作的地方，所以能不能在Actions中使用Promise进行异步操作呢？</p>
<p>在Actions中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject</p>
<p>修改上面代码：</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateInfo&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(payload);</span><br><span class="line">	   <span class="comment">// 在返回的时候还能携带信息</span></span><br><span class="line">        resolve(<span class="string">&#x27;1111111&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store</span><br><span class="line">      .dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, <span class="string">&#x27;我是携带的信息&#x27;</span>)</span><br><span class="line">          .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;里面完成了提交&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">          &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其实本质上就是链式调用：</p>
<ol>
<li>在组件中使用<code>aUpdateInfo</code>去Actions里调用aUpdateInfo实现异步操作，同时传过去一些参数（’我是携带的信息’）</li>
<li>由于组件用了aUpdateInfo，在Actions中调用aUpdateInfo方法实现一些异步操作，同时使用<code>updateInfo</code>去Mutations里调用updateInfo方法实现store状态的更新，并Devtools实现State跟踪，而且还使用了组件传递过来的参数。最后返回一个Promise对象，在异步操作成功的时候进行resolve()/reject()，告诉组件这次异步操作成功还是失败，还可以向组件传递一些参数。</li>
<li>组件在使用<code>aUpdateInfo</code>去Actions里实现的时候就在等待Actions中的异步操作是否成功。因为Actions返回一个Promise对象，在组件里执行dispatch成功后就表示这次异步操作已经成功了（因为dispatch失败的话就会报错）由于异步操作成功实现，resolve()会进入到组件的then()当中，组件在then当中就可以获取来自Actions的一些消息和参数并使用。</li>
</ol>
<h4 id="5、Module"><a href="#5、Module" class="headerlink" title="5、Module"></a>5、Module</h4><h5 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h5><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>
<ul>
<li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理。</li>
<li>当应用变得非常复杂时,store对象就有可能变得相当臃肿。</li>
<li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</li>
</ul>
<p>我们按照什么样的方式来组织模块呢? </p>
<p><img src="VUE/174.png" alt="image-20210331013941265"></p>
<h5 id="2、Module局部状态"><a href="#2、Module局部状态" class="headerlink" title="2、Module局部状态"></a>2、Module局部状态</h5><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写。</p>
<p>我们在moduleA中添加State、Mutations、Getters、Actions，然后在组件去使用store当中模块里的这四个核心：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateName</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateName&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>State：由于Vuex是单一状态树，用a定义在moduleA模块，最后会被转化为store的State中的一个a对象。</p>
<p><img src="VUE/175.png" alt="image-20210331020306951"></p>
<p>组件：a是store的state的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.state.a.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mutations：在模块里进行提交也是使用commit方法，但要注意：在模块的Mutations里定义的方法名不要与store当中Mutations里的方法重复。若是方法名重复的话，在组件进行commit提交的时候，不知道要提交给tore还是模块。</p>
<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;updateName&quot;&gt;修改名字&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">updateName() &#123;</span><br><span class="line">  this.$store.commit(&#39;updateName&#39;, &#39;lisi&#39;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>Getters：</p>
<ul>
<li>组件调用时不会理会这个fullname是来自哪里的，与之前一样调用就行。</li>
<li>当中模块当中要用到之前Getters获得到的值，就需要fullname2传入第二个参数getters，通过getters去获取之前定义的值。</li>
<li>当在模块中要使用store中state里的值，在fullname3当中传入第三个参数：rootState。可以通过rootState这个参数取到store当中state里的值。</li>
</ul>
<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname3&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Actions：在Actions里commit进行提交的时候使用的只能是模块里的Mutations中的方法，不能去使用store中Mutations当中的方法。同理store的Actions也是一样。</p>
<p>模块中的Actions的context：里面包含了很多东西：</p>
<ul>
<li><p>commit：提交到自身的Mutations</p>
</li>
<li><p>dispatch：分发到组件</p>
</li>
<li><p>getters：调用自身Getters的值</p>
</li>
<li><p>rootGetters：调用store中Getters的值</p>
</li>
<li><p>rootState：调用store中State的值</p>
<p>即在模块中使用comtext.rootState调用store里state的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(comtext.rootState.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>state：调用自身state的值</p>
</li>
</ul>
<p><img src="VUE/176.png" alt="image-20210331023258944"></p>
<p>Actions的另外一种写法：局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState</p>
<p><img src="VUE/177.png" alt="image-20210331024203961"></p>
<p>其实这就是对象的结构（ES6语法），也是对象的一种语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  height: <span class="number">1.88</span>,</span><br><span class="line">  address: <span class="string">&#x27;洛杉矶&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name, height, age&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<p>同理，数组也是可以解构的，但是并不常用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;why&#x27;</span>,<span class="string">&#x27;koby&#x27;</span>,<span class="string">&#x27;james&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name1,name2,name3&#125; = names</span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;asyncUpdateName&quot;&gt;异步修改名字&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">asyncUpdateName() &#123;</span><br><span class="line">  this.$store.dispatch(&#39;aUpdateName&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6、项目结构组织"><a href="#6、项目结构组织" class="headerlink" title="6、项目结构组织"></a>6、项目结构组织</h3><p>因为我有关于Vuex的使用都是在index.js当中，无论是Vuex的安装导出，还是Vuex的五大核心，特别是module模块里还可以使用四大核心。但我们的项目越来越大，越来越复杂的时候，我们的index.js就会变得十分臃肿。十分不利于我们进行查看与管理。当我们的Vuex帮助我们管理过多的内容时,我们可以将代码进行抽离</p>
<p>官方推荐：</p>
<ul>
<li>State：一般会放在index.js里面，可以在外面定义一个state变量，在store里引用。因为我们一般是希望在index.js当中可以一样看到Vuex管理的状态。（当然进行抽离也是可以的）</li>
<li>Getters/Mutations/Action：s新建成一个js文件，将在index.js里Getters/Mutations/Actions的那一部分抽离到对应的js文件当中。而在index.js里只需要导入后在store进行使用就行了。</li>
<li>Module：新建一个modules文件夹，把index.js当中定义的每一个module部分分别在modules文件夹当中建立对应的js文件。而在index.js中只需要导入后在store里的module进行对应模块的引用就行。</li>
</ul>
<p>抽离过后的index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&#x27;./mutations&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">&#x27;./modules/moduleA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  counter: <span class="number">1000</span>,</span><br><span class="line">  students: [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;curry&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line">    name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">    height: <span class="number">1.98</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line"></span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store独享</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>好的项目结构可以让我们的代码更加清晰：</p>
<p><img src="VUE/178.png" alt="image-20210331024637532"></p>
<h2 id="十一、网络请求模块aniox"><a href="#十一、网络请求模块aniox" class="headerlink" title="十一、网络请求模块aniox"></a>十一、网络请求模块aniox</h2><h3 id="1、网络模块的选择"><a href="#1、网络模块的选择" class="headerlink" title="1、网络模块的选择"></a>1、网络模块的选择</h3><p>Vue中发送网络请求有非常多的方式, 那么, 在开发中, 如何选择呢？</p>
<ol>
<li><p>选择一: 传统的Ajax是基于XMLHttpRequest(XHR)</p>
<p>为什么不用它呢?</p>
<ul>
<li>非常好解释, 配置和调用方式等非常混乱。</li>
<li>编码起来看起来就非常蛋疼。</li>
<li>所以真实开发中很少直接使用, 而是使用jQuery-Ajax。</li>
</ul>
</li>
<li><p>选择二: 在前面的学习中, 我们经常会使用jQuery-Ajax</p>
<p>相对于传统的Ajax非常好用。</p>
<p>为什么不选择它呢?</p>
<ul>
<li>首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了。</li>
<li>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?<ul>
<li>jQuery的代码1w+行。</li>
<li>Vue的代码才1w+行。</li>
</ul>
</li>
<li>完全没有必要为了用网络请求就引用这个重量级的框架</li>
</ul>
</li>
<li><p>选择三: 官方在Vue1.x的时候, 推出了Vue-resource。</p>
<p>Vue-resource的体积相对于jQuery小很多。</p>
<p>另外Vue-resource是官方推出的。</p>
<p>为什么不选择它呢?</p>
<ul>
<li>在Vue2.0退出后, Vue作者就在GitHub的Issues中说明了去掉vue-resource, 并且以后也不会再更新。</li>
<li>那么意味着以后vue-reource不再支持新的版本时, 也不会再继续更新和维护。</li>
<li>对以后的项目开发和维护都存在很大的隐患。</li>
</ul>
</li>
<li><p>选择四: 在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么不用它呢?</p>
<ul>
<li>axios有非常多的优点, 并且用起来也非常方便。</li>
</ul>
</li>
</ol>
<h3 id="2、跨域"><a href="#2、跨域" class="headerlink" title="2、跨域"></a>2、跨域</h3><h4 id="1、为什么会出现跨域问题？"><a href="#1、为什么会出现跨域问题？" class="headerlink" title="1、为什么会出现跨域问题？"></a>1、为什么会出现跨域问题？</h4><p>出于浏览器的<strong>同源策略</strong>限制。</p>
<p>同源策略（Sameoriginpolicy）是一种约定，它是<strong>浏览器最核心也最基本的安全功能</strong>，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>同源策略会<strong>阻止一个域的javascript脚本和另外一个域的内容进行交互</strong>。所谓同源（即指在同一个域）就是两个页面具有<strong>相同的<code>协议（protocol）</code>，<code>主机（host）</code>和<code>端口号（port）</code></strong></p>
<h4 id="2、什么是跨域？"><a href="#2、什么是跨域？" class="headerlink" title="2、什么是跨域？"></a>2、什么是跨域？</h4><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。</p>
<table>
<thead>
<tr>
<th>当前页面url</th>
<th>被请求页面url</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.test.com/index.html">http://www.test.com/index.html</a></td>
<td>否</td>
<td>同源（协议、域名、端口号相同）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="https://www.test.com/index.html">https://www.test.com/index.html</a></td>
<td>跨域</td>
<td>协议不同（http/https）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a></td>
<td>跨域</td>
<td>主域名不同（test/baidu）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://blog.test.com/">http://blog.test.com/</a></td>
<td>跨域</td>
<td>子域名不同（www/blog）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com:8080/">http://www.test.com:8080/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.test.com:7001/">http://www.test.com:7001/</a></td>
<td>跨域</td>
<td>端口号不同（8080/7001）</td>
</tr>
</tbody></table>
<h4 id="3、非同源限制"><a href="#3、非同源限制" class="headerlink" title="3、非同源限制"></a>3、非同源限制</h4><p>同源策略限制了一下行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 JS 对象无法获取</li>
<li>Ajax请求发送不出去</li>
</ul>
<h4 id="4、跨域解决方法"><a href="#4、跨域解决方法" class="headerlink" title="4、跨域解决方法"></a>4、跨域解决方法</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903521163182088">更多详情</a></p>
<h5 id="1、后台"><a href="#1、后台" class="headerlink" title="1、后台"></a>1、后台</h5><h6 id="1、使用nginx进行反向代理"><a href="#1、使用nginx进行反向代理" class="headerlink" title="1、使用nginx进行反向代理"></a>1、使用nginx进行反向代理</h6><p>既然跨域会产生问题，那么我们就不跨域不就完了嘛！！！</p>
<p><img src="VUE/180.png" alt="img"></p>
<p>首先我们用nginx作为代理服务器和用户交互，这样用户就只需要在80端口上进行交互就可以了，这样就避免了跨域问题，因为我们都是在80端口上进行交互的：</p>
<p>利用nginx作为反向代理的具体配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen      80; #监听80端口，可以改成其他端口</span><br><span class="line"></span><br><span class="line">        server_name  localhost; # 当前服务的域名</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://localhost:81;</span><br><span class="line"></span><br><span class="line">            proxy_redirect default;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location /apis &#123; #添加访问目录为/apis的代理配置</span><br><span class="line"></span><br><span class="line">rewrite  ^/apis/(.*)$ /$1 break;</span><br><span class="line"></span><br><span class="line">proxy_pass  http://localhost:82;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">#以下配置省略</span><br></pre></td></tr></table></figure>

<ol>
<li>当用户发送localhost:80/时会被nginx转发到<a href="http://localhost:81服务；">http://localhost:81服务；</a></li>
<li>当界面请求接口数据时，只要以/apis 为开头，就会被nginx转发到后端接口服务器上。</li>
</ol>
<p>总结：nginx实现跨域的原理，实际就是把web项目和后端接口项目放到一个域中，这样就不存在跨域问题，然后根据请求地址去请求不同服务器（真正干活的服务器）。</p>
<h5 id="2、前端"><a href="#2、前端" class="headerlink" title="2、前端"></a>2、前端</h5><h6 id="1、设置document-domain解决无法读取非同源网页的-Cookie问题"><a href="#1、设置document-domain解决无法读取非同源网页的-Cookie问题" class="headerlink" title="1、设置document.domain解决无法读取非同源网页的 Cookie问题"></a>1、设置document.domain解决无法读取非同源网页的 Cookie问题</h6><p>因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个页面都设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;test.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="2、跨文档通信-API：window-postMessage"><a href="#2、跨文档通信-API：window-postMessage" class="headerlink" title="2、跨文档通信 API：window.postMessage()"></a>2、跨文档通信 API：window.postMessage()</h6><p>调用postMessage方法实现父窗口<a target="_blank" rel="noopener" href="http://test1.com向子窗口http//test2.com%E5%8F%91%E6%B6%88%E6%81%AF%EF%BC%88%E5%AD%90%E7%AA%97%E5%8F%A3%E5%90%8C%E6%A0%B7%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AF%A5%E6%96%B9%E6%B3%95%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%BB%99%E7%88%B6%E7%AA%97%E5%8F%A3%EF%BC%89">http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）</a></p>
<p>它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="built_in">window</span>.open(<span class="string">&#x27;http://test2.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.postMessage(<span class="string">&#x27;Nice to meet you!&#x27;</span>, <span class="string">&#x27;http://test2.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>调用message事件，监听对方发送的消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 message 消息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.source); <span class="comment">// e.source 发送消息的窗口</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.origin); <span class="comment">// e.origin 消息发向的网址</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data);   <span class="comment">// e.data   发送的消息</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h6 id="3、JSONP"><a href="#3、JSONP" class="headerlink" title="3、JSONP"></a>3、JSONP</h6><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p>
<p>核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p>
<ol>
<li><p>原生实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://test.com/data.php?callback=dosomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span><br><span class="line"> </span><br><span class="line">// 处理服务器返回回调函数的数据</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 处理获得的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res.data)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://www.test.com:8080/login&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    dataType: <span class="string">&#x27;jsonp&#x27;</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">&quot;handleCallback&quot;</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.jsonp(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="4、CORS"><a href="#4、CORS" class="headerlink" title="4、CORS"></a>4、CORS</h6><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p>
<ol>
<li><p><strong>普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</strong></p>
</li>
<li><p><strong>带cookie跨域请求：前后端都需要进行设置</strong></p>
<p><strong>【前端设置】</strong></p>
<p>根据xhr.withCredentials字段判断是否带有cookie：</p>
<ol>
<li><p>原生ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   url: <span class="string">&#x27;http://www.test.com:8080/login&#x27;</span>,</span><br><span class="line">   type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">   data: &#123;&#125;,</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>vue-resource：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>axios：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>【服务端设置】</strong></p>
<p>服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<ol>
<li><p>Java后台：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#x27;/&#x27;</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://www.domain1.com&quot;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为&#x27;*&#x27;，必须指定具体的域名，否则浏览器会提示</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type,X-Requested-With&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nodejs后台</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHP后台：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache需要使用mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的<Directory>, <Location>, <Files>或<VirtualHost>的配置里加入以下内容即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set Access-Control-Allow-Origin *</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="3、JSONP的封装"><a href="#3、JSONP的封装" class="headerlink" title="3、JSONP的封装"></a>3、JSONP的封装</h3><h4 id="1、什么是JSONP"><a href="#1、什么是JSONP" class="headerlink" title="1、什么是JSONP"></a>1、什么是JSONP</h4><p>在前端开发中, 我们一种常见的网络请求方式就是JSONP：使用JSONP最主要的原因往往是为了解决跨域访问的问题。</p>
<p>JSONP的原理是什么呢?</p>
<ul>
<li>JSONP的核心在于通过<script>标签的src来帮助我们请求数据。</li>
<li>原因是我们的项目部署在domain1.com服务器上时, 是不能直接访问domain2.com服务器上的资料的。</li>
<li>这个时候, 我们利用<script>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行的过程中传入我们需要的json。</li>
<li>所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称。</li>
</ul>
<p><img src="VUE/171.png" alt="image-20210331231151444"></p>
<h4 id="2、JSONP的封装"><a href="#2、JSONP的封装" class="headerlink" title="2、JSONP的封装"></a>2、JSONP的封装</h4><p><img src="VUE/170.png" alt="image-20210331231233559"></p>
<h3 id="4、认识axios"><a href="#4、认识axios" class="headerlink" title="4、认识axios"></a>4、认识axios</h3><p>更多学习：<a target="_blank" rel="noopener" href="https://www.runoob.com/vue3/vue3-ajax-axios.html">菜鸟教程</a></p>
<h4 id="1、为什么选择axios"><a href="#1、为什么选择axios" class="headerlink" title="1、为什么选择axios?"></a>1、为什么选择axios?</h4><ul>
<li><p>作者推荐：</p>
<p><img src="VUE/161.png" alt="image-20210331231358415"></p>
</li>
<li><p>功能特点:</p>
<ul>
<li>在浏览器中发送 XMLHttpRequests 请求</li>
<li>在 node.js 中发送 http请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>….</li>
</ul>
</li>
</ul>
<h4 id="2、axios请求方式"><a href="#2、axios请求方式" class="headerlink" title="2、axios请求方式"></a>2、axios请求方式</h4><p>支持多种请求方式:</p>
<ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<p>演示：</p>
<ul>
<li><p>发送get请求演示：（使用 response.data 读取 JSON 数据）</p>
<p>没有参数传递：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;site in info&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; site.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      info: <span class="string">&#x27;Ajax 测试!!&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line"><span class="javascript">      .get(<span class="string">&#x27;https://www.runoob.com/try/ajax/json_demo.json&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="built_in">this</span>.info = response))</span></span><br><span class="line"><span class="javascript">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(error);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在 URL 上添加参数 ID=12345</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以通过 params 设置参数：</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送post请求演示：</p>
<p>没有传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      info: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_axios_post.php&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="built_in">this</span>.info = response))</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参数传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Fred&#x27;</span>,        <span class="comment">// 参数 firstName</span></span><br><span class="line">    lastName: <span class="string">&#x27;Flintstone&#x27;</span>    <span class="comment">// 参数 lastName</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>执行多个并发请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、axios的使用"><a href="#3、axios的使用" class="headerlink" title="3、axios的使用"></a>3、axios的使用</h4><p>除了上面两种方法，axios还可以直接传递相关配置来创建请求。</p>
<h5 id="1、发送axios-config-请求演示："><a href="#1、发送axios-config-请求演示：" class="headerlink" title="1、发送axios(config)请求演示："></a>1、发送axios(config)请求演示：</h5><p>可以通过向 axios <strong>传递相关配置</strong>来创建请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  GET 请求远程图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  responseType:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">axios(url[, config])</span><br><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line">axios(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2、请求方法的别名："><a href="#2、请求方法的别名：" class="headerlink" title="2、请求方法的别名："></a><strong>2、请求方法的别名</strong>：</h5><p>为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
<h5 id="3、并发："><a href="#3、并发：" class="headerlink" title="3、并发："></a><strong>3、并发：</strong></h5><p>有时候, 我们可能需求同时发送两个请求</p>
<ul>
<li><p>使用axios.all, 可以放入多个请求的数组.</p>
</li>
<li><p>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理并发请求的助手函数:</span></span><br><span class="line"><span class="comment">// axios.all(iterable)</span></span><br><span class="line"><span class="comment">// axios.spread(callback)</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h5 id="4、全局配置："><a href="#4、全局配置：" class="headerlink" title="4、全局配置："></a><strong>4、全局配置</strong>：</h5><p>在上面的示例中, 我们的BaseURL是固定的</p>
<ul>
<li>事实上, 在开发中可能很多参数都是固定的。</li>
<li>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用全局的axios和对应的配置在进行网络请求</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br><span class="line">axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</span><br></pre></td></tr></table></figure>

<p><strong>常见的配置选项</strong>：</p>
<p><img src="VUE/179.png" alt="image-20210401002517223"></p>
<h5 id="5、axios实例："><a href="#5、axios实例：" class="headerlink" title="5、axios实例："></a><strong>5、axios实例：</strong></h5><p>为什么要创建axios的实例呢?</p>
<ul>
<li>当我们从axios模块中导入对象时, 使用的实例是<strong>默认的实例</strong>。</li>
<li>当给该实例设置一些默认配置时, 这些配置就被固定下来了(<strong>全局配置</strong>)。</li>
<li>但当项目越来越大的时候，并发量会越来越大。一个服务器可能承受不了很大的请求量。这个时候可能会使用多个服务器去承载大量请求，即我们说的<code>分布式</code>。由于每一个服务器ip不一样，这个时候不会向客户端传递多个ip地址，往往会使用一个反向代理服务器nginx对每一服务器进行反向代理和负载均衡，并向客户端提供一个公共的ip。而每一客户端都是面向这个代理服务器。</li>
<li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等。</li>
<li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对应的axios的实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送网络请求</span></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送网络请求</span></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">10000</span>,</span><br><span class="line">  <span class="comment">// headers: &#123;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5、对网络请求进行模块封装（重要）"><a href="#5、对网络请求进行模块封装（重要）" class="headerlink" title="5、对网络请求进行模块封装（重要）"></a>5、对网络请求进行模块封装（重要）</h3><h4 id="1、为什么要进行网络封装？"><a href="#1、为什么要进行网络封装？" class="headerlink" title="1、为什么要进行网络封装？"></a>1、为什么要进行网络封装？</h4><ul>
<li><p>一般来说，我们都是在需要的组件里进行axios进行导入，并在组件内使用axios进行网络请求。</p>
</li>
<li><p>这种方式也可以实现网络请求。但存在了一个致命的问题：组件与框架（axios）之间的依赖太高了。</p>
</li>
<li><p>只会导致什么结果：但某一天该框架不在进行维护了，即这个框架废弃了。这个时候对项目的维护将是一个噩梦。举一个极端的例子：一个项目有100个组件，每个组件都依赖了10个框架。有一天这10个都宣布不再进行维护了。这个时候就需要对在100个组件中的框架进行替换。相当于可以放弃这个项目了。</p>
</li>
<li><p>所以，必须对我们要使用的第三方的东西（如框架）在进行一层封装，封装成一个文件。所以的组件对框架的使用都通过我们封装过后的这个文件，而该文件在对第三方的东西（框架）进行依赖。当有一天第三方的东西不再进行维护或者要对其进行替换的时候，直接修改我们封装的文件，在其中加入要替换的东西并修改代码即可，最后将结果转换为组件能够直接使用的形式进行返回，组件里的代码不用进行一点修改，就完成对第三方东西的替换。这样就完成了组件与第三方的解耦，大大增加了项目的维护性</p>
<p><img src="VUE/181.png" alt="image-20210401022031968"></p>
</li>
</ul>
<h4 id="2、对axios框架进行封装"><a href="#2、对axios框架进行封装" class="headerlink" title="2、对axios框架进行封装"></a>2、对axios框架进行封装</h4><p>在src新建文件夹network，里面封装网络层需要用到的东西。在network文件夹中新建request.js文件，里面存放对axios中网络请求的封装。</p>
<p>在request.js中使用方法function进行导出，不使用default导出的原因：</p>
<p>因为调用的时候可能不止一个实例，定义成function在使用时就可以导出为多个实例。而定义成default就只能导出一个能自定义名称的实例而已。</p>
<h5 id="1、通过回调函数进行封装"><a href="#1、通过回调函数进行封装" class="headerlink" title="1、通过回调函数进行封装"></a>1、通过回调函数进行封装</h5><p>注意：调用者（组件）调用封装的request.js进行网络请求，request.js要将封装后的结果回调给调用者，让调用者知晓本次网络请求是否成功。</p>
<h6 id="1、参数有config、success、-failure"><a href="#1、参数有config、success、-failure" class="headerlink" title="1、参数有config、success、 failure"></a>1、参数有config、success、 failure</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用function导出可以创建多个实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request1</span>(<span class="params">config</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调success</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调failure</span></span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="2、参数只有config"><a href="#2、参数只有config" class="headerlink" title="2、参数只有config"></a>2、参数只有config</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config.baseConfig)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      config.success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      config.failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="comment">// 传入基本配置</span></span><br><span class="line">  baseConfig: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 回调success</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 回调failure</span></span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2、通过promise进行封装"><a href="#2、通过promise进行封装" class="headerlink" title="2、通过promise进行封装"></a>2、通过promise进行封装</h5><h6 id="1、通过promise的resolve-reject-进行传递"><a href="#1、通过promise的resolve-reject-进行传递" class="headerlink" title="1、通过promise的resolve()/reject()进行传递"></a>1、通过promise的resolve()/reject()进行传递</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">      timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="2、直接返回instance实例（本质上是一个promise对象）（最终方案）"><a href="#2、直接返回instance实例（本质上是一个promise对象）（最终方案）" class="headerlink" title="2、直接返回instance实例（本质上是一个promise对象）（最终方案）"></a>2、直接返回instance实例（本质上是一个promise对象）（最终方案）</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="3、两种promise方式的对比"><a href="#3、两种promise方式的对比" class="headerlink" title="3、两种promise方式的对比"></a>3、两种promise方式的对比</h6><p>第一种方式只是比第二种方式多套了一层的promise。在某些情况下也是有用的。套一层promise可以做一些全局网络处理，比如全局dialog一个加载中。这个时候就得使用第一种方式而不是第二种方式。（具体使用需要根据业务进行选择）</p>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>通过以上对axios框架进行封装，就可以实现组件与axios的解耦。</p>
<p>假设：当有一天axios不在进行维护，我们使用android对axios进行替换。只需要修改request.js文件即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入android框架</span></span><br><span class="line"><span class="keyword">import</span> android <span class="keyword">from</span> <span class="string">&#x27;android&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将axios的代码替换成android的代码</span></span><br><span class="line">	android代码</span><br><span class="line">	<span class="comment">// 最后将android的相关代码包装到Promise里面进行返回</span></span><br><span class="line">	<span class="comment">// 组件代码不用进行任何修改</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Promise是ES6原生语法，而不是第三方框架。不用担心Promise失效。因为一旦ES6不再维护，那就不是一个框架的问题了。</p>
<h3 id="6、axios的拦截器"><a href="#6、axios的拦截器" class="headerlink" title="6、axios的拦截器"></a>6、axios的拦截器</h3><p>axios提供了拦截器，用于我们在<strong>发送每次请求</strong>或者<strong>得到相应结果后</strong>，即在请求或响应被 then 或 catch 处理前拦截他们，对他们进行对应的处理。</p>
<p>axios提供了四种拦截：</p>
<ul>
<li>请求成功时的拦截</li>
<li>请求失败时的拦截</li>
<li>响应成功时的拦截</li>
<li>响应失败时的拦截</li>
</ul>
<p>前后端的拦截：</p>
<p>后端也要做拦截校验的，但是前端要拦截，如页面权限、参数之类的校验。然后到后端会再拦截，再校验一遍，如果前端校验都不通过，那就不用调后端了，前端要是通过了，后端还是会做校验，保证安全性之类的。</p>
<p>过滤器与拦截器：</p>
<p>过滤器和监听器是web.xml中配置的，拦截器是springMVC中的，只有你的请求过了过滤器并且交由dispatchServlet处理，才会到拦截器这。</p>
<h4 id="1、请求拦截"><a href="#1、请求拦截" class="headerlink" title="1、请求拦截"></a>1、请求拦截</h4><p>请求拦截可以做到的事情：</p>
<ul>
<li><p>比如config中的一些信息不符合服务器的要求</p>
</li>
<li><p>比如每次发送网络请求时, 都希望在界面中显示一个请求中的图标：</p>
<p>将<code>加载中</code>图标show展示出来，在响应拦截中再把它隐藏。</p>
</li>
<li><p>某些网络请求(比如登录(token)), 必须携带一些特殊的信息：</p>
<p>在config中有一个属性url，里面存放着本次请求的路径（接口api），判断该请求是否为登陆之后才能进行访问，再去判断这次请求有没有携带token。如果有携带token的话就放行，如果没有携带token就可以提示一些错误信息并跳转到登陆界面让用户进行登陆。</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p>某些网络请求，比如登录(token)的携带也可以通过导航守卫来实现，但是存在不同：</p>
<ul>
<li>导航首位是前端在页面跳转的时候使用的，一般是同源；</li>
<li>请求拦截是请求后端数据的时候使用的，一般要跨域。</li>
</ul>
</li>
<li><p>在请求拦截，对config进行操作之后记住要放行config。不然之后响应的时候拿不到config。</p>
</li>
<li><p>被拦截的config当中的信息：</p>
<p><img src="VUE/135.png" alt="image-20210401171319639"></p>
</li>
</ul>
<p>实现：instance.interceptors.request.use(config(),err())</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="comment">// 在请求拦截，完成操作之后记住要放行请求</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、响应拦截"><a href="#2、响应拦截" class="headerlink" title="2、响应拦截"></a>2、响应拦截</h4><p>响应拦截可以做到的事情：</p>
<ul>
<li>在响应结果中一般只有data（服务器返回的真正结果）对我们有用，所以可以把响应结果当中的data过滤出来</li>
<li>在请求到响应的过程中做一些样式的显示/隐藏</li>
</ul>
<p>注意：</p>
<ul>
<li><p>响应拦截的结果res：</p>
<p><img src="VUE/182.png" alt="image-20210401172834396"></p>
</li>
<li><p><strong>在拦截了响应后，要记住将结果（可以直接返回res.data）返回给组件</strong></p>
</li>
</ul>
<p>实现：instance.interceptors.response.use(res(),err())</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="comment">// 把响应结果当中的data过滤出来</span></span><br><span class="line">    <span class="comment">// 将结果返回给组件</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p><strong>如果你想在稍后移除拦截器</strong>，可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>

<p><strong>请求时使用 application/x-www-form-urlencoded</strong>：</p>
<p>axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。</p>
<p><strong>浏览器</strong></p>
<p>在浏览器环境，你可以使用 URLSearchParams API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">&#x27;param1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">params.append(<span class="string">&#x27;param2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line">axios.post(<span class="string">&#x27;/foo&#x27;</span>, params);</span><br></pre></td></tr></table></figure>

<p>URLSearchParams 不是所有的浏览器均支持。</p>
<p>除此之外，你可以使用 qs 库来编码数据:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line">axios.post(<span class="string">&#x27;/foo&#x27;</span>, qs.stringify(&#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or in another way (ES6),</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>

<p><strong>Promises</strong></p>
<p>axios 依赖原生的 ES6 Promise 实现而<a target="_blank" rel="noopener" href="http://caniuse.com/promises">被支持</a>。</p>
<p> 如果你的环境不支持 ES6 Promise，你可以使用 <a target="_blank" rel="noopener" href="https://github.com/jakearchibald/es6-promise">polyfill</a>。</p>
<p><strong>TypeScript支持</strong></p>
<p>axios 包含 TypeScript 的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.get(<span class="string">&quot;/user?ID=12345&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7、封装的网络请求模块request-js最终版本"><a href="#7、封装的网络请求模块request-js最终版本" class="headerlink" title="7、封装的网络请求模块request.js最终版本"></a>7、封装的网络请求模块request.js最终版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十二、其他补充"><a href="#十二、其他补充" class="headerlink" title="十二、其他补充"></a>十二、其他补充</h2><h3 id="1、httpbin-org"><a href="#1、httpbin-org" class="headerlink" title="1、httpbin.org/"></a>1、httpbin.org/</h3><p>httpbin.org：该网站可以做很多网站的模拟。如果之后你想对网络模块进行封装的话，可以用该网站进行很多测试。</p>
<h3 id="2、常见的（github）："><a href="#2、常见的（github）：" class="headerlink" title="2、常见的（github）："></a>2、常见的（github）：</h3><h4 id="1、ui库"><a href="#1、ui库" class="headerlink" title="1、ui库"></a>1、ui库</h4><ul>
<li>mint-ui</li>
<li>iview</li>
</ul>
<h4 id="2、上下滚动"><a href="#2、上下滚动" class="headerlink" title="2、上下滚动"></a>2、上下滚动</h4><ul>
<li><p>scroll（不再维护）</p>
</li>
<li><p>better-scroll</p>
<p>使用：</p>
<ol>
<li>默认情况下BScroll是不可以实时的监听滚动位置，</li>
</ol>
</li>
</ul>
<h4 id="3、关于ref"><a href="#3、关于ref" class="headerlink" title="3、关于ref"></a>3、关于ref</h4><p>ref如果是绑定在组件中的, 那么通过<strong>this.$refs.refname</strong>获取到的是一个组件对象.</p>
<p>ref如果是绑定在普通的元素中, 那么通过<strong>this.$refs.refname</strong>获取到的是一个元素对象.</p>
<h3 id="4、开发新项目"><a href="#4、开发新项目" class="headerlink" title="4、开发新项目"></a>4、开发新项目</h3><h4 id="1、划分目录结构"><a href="#1、划分目录结构" class="headerlink" title="1、划分目录结构"></a>1、划分目录结构</h4><p><img src="VUE/183.png" alt="image-20210401210958061"></p>
<ul>
<li>assets:里面存放图片img与css资源<ul>
<li>img：图片资源</li>
<li>css：css相关资源</li>
</ul>
</li>
<li>common：项目相关的公共文件，如常量、工具类</li>
<li>components：项目的公共组件<ul>
<li>common：项目常用的组件（可在多个项目中使用）</li>
<li>context：当前项目数据相关的公共组件</li>
</ul>
</li>
<li>network：用来存放有关网络请求封装的文件</li>
<li>router：Vue-router路由相关<ul>
<li>index.js</li>
</ul>
</li>
<li>store：Vuex状态管理相关<ul>
<li>index.js</li>
</ul>
</li>
<li>views：用来存放视图相关的组件<ul>
<li>home.js：首页相关的视图</li>
<li>category.js：分类相关的视图</li>
</ul>
</li>
<li>App.vue</li>
<li>main.js</li>
</ul>
<h3 id="2、引用了两个css文件（normalize-css与base-css）"><a href="#2、引用了两个css文件（normalize-css与base-css）" class="headerlink" title="2、引用了两个css文件（normalize.css与base.css）"></a>2、引用了两个css文件（normalize.css与base.css）</h3><h4 id="1、统一CSS标签"><a href="#1、统一CSS标签" class="headerlink" title="1、统一CSS标签"></a>1、统一CSS标签</h4><p>使用normalize.css对CSS进行统一</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Document</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the line height in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Prevent adjustments of font size after orientation changes in iOS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sections</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the margin in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the font size and margin on `h1` elements within `section` and</span></span><br><span class="line"><span class="comment"> * `article` contexts in Chrome, Firefox, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.67em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grouping content</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Add the correct box sizing in Firefox.</span></span><br><span class="line"><span class="comment"> * 2. Show the overflow in Edge and IE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">hr</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: visible; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inheritance and scaling of font size in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Correct the odd `em` font sizing in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Text-level semantics</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the gray background on active links in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Remove the bottom border in Chrome 57-</span></span><br><span class="line"><span class="comment"> * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">abbr</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: underline; <span class="comment">/* 2 */</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: underline dotted; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct font weight in Chrome, Edge, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inheritance and scaling of font size in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Correct the odd `em` font sizing in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">samp</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct font size in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">small</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prevent `sub` and `sup` elements from affecting the line height in</span></span><br><span class="line"><span class="comment"> * all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">75%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Embedded content</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the border on images inside links in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Forms</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Change the font styles in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Remove the margin in Firefox and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">optgroup</span>,</span><br><span class="line"><span class="selector-tag">select</span>,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: inherit; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Show the overflow in IE.</span></span><br><span class="line"><span class="comment"> * 1. Show the overflow in Edge.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span> &#123; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inheritance of text transform in Edge, Firefox, and IE.</span></span><br><span class="line"><span class="comment"> * 1. Remove the inheritance of text transform in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">select</span> &#123; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">text-transform</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the inability to style clickable types in iOS and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inner border and padding in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Restore the focus styles unset by the previous rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> dotted ButtonText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the padding in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fieldset</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.35em</span> <span class="number">0.75em</span> <span class="number">0.625em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the text wrapping in Edge and IE.</span></span><br><span class="line"><span class="comment"> * 2. Correct the color inheritance from `fieldset` elements in IE.</span></span><br><span class="line"><span class="comment"> * 3. Remove the padding so developers are not caught out when they zero out</span></span><br><span class="line"><span class="comment"> *    `fieldset` elements in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">legend</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">color</span>: inherit; <span class="comment">/* 2 */</span></span><br><span class="line">  <span class="attribute">display</span>: table; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 3 */</span></span><br><span class="line">  <span class="attribute">white-space</span>: normal; <span class="comment">/* 1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct vertical alignment in Chrome, Firefox, and Opera.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">progress</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the default vertical scrollbar in IE 10+.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Add the correct box sizing in IE 10.</span></span><br><span class="line"><span class="comment"> * 2. Remove the padding in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the cursor style of increment and decrement buttons in Chrome.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;number&quot;</span>]</span><span class="selector-pseudo">::-webkit-inner-spin-button</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;number&quot;</span>]</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the odd appearance in Chrome and Safari.</span></span><br><span class="line"><span class="comment"> * 2. Correct the outline style in Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: textfield; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">outline-offset</span>: -<span class="number">2px</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inner padding in Chrome and Safari on macOS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-decoration</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inability to style clickable types in iOS and Safari.</span></span><br><span class="line"><span class="comment"> * 2. Change font properties to `inherit` in Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::-webkit-file-upload-button</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: button; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font</span>: inherit; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interactive</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add the correct display in Edge, IE 10+, and Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">details</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add the correct display in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">summary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: list-item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct display in IE 10+.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">template</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct display in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[hidden]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、创建全局基本样式base-css（可以去github上查找）"><a href="#2、创建全局基本样式base-css（可以去github上查找）" class="headerlink" title="2、创建全局基本样式base.css（可以去github上查找）"></a>2、创建全局基本样式base.css（可以去github上查找）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./normalize.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*:root -&gt; 获取根元素html*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--color-text</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">--color-high-text</span>: <span class="number">#ff5777</span>;</span><br><span class="line">  <span class="attribute">--color-tint</span>: <span class="number">#ff8198</span>;</span><br><span class="line">  <span class="attribute">--color-background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">--line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">::before</span>,</span><br><span class="line">*<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>,Helvetica,<span class="string">&quot;PingFang SC&quot;</span>,<span class="string">&quot;Hiragino Sans GB&quot;</span>,<span class="string">&quot;Microsoft YaHei&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>,Arial,sans-serif;</span><br><span class="line">  <span class="attribute">user-select</span>: none; <span class="comment">/* 禁止用户鼠标在页面上选中文字/图片等 */</span></span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: transparent; <span class="comment">/* webkit是苹果浏览器引擎，tap点击，highlight背景高亮，color颜色，颜色用数值调节 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--color-background);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">  <span class="comment">/* rem vw/vh */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>:root -&gt; 获取根元素html：可用于定义变量。在该文件的其他地方可以通过var(–变量名)拿到变量的值。<ul>
<li>–color-text: 文本颜色</li>
<li>–color-high-text: 文本颜色高亮</li>
<li>–color-tint: 整体的颜色，用于设置导航栏的背景颜色</li>
<li>–color-background: 背景颜色</li>
<li>–font-size: 整体的字体大小</li>
<li>–line-height: 线高</li>
</ul>
</li>
</ul>
<h3 id="3、配置别名与设置规范"><a href="#3、配置别名与设置规范" class="headerlink" title="3、配置别名与设置规范"></a>3、配置别名与设置规范</h3><h4 id="1、vue-config-js"><a href="#1、vue-config-js" class="headerlink" title="1、vue.config.js"></a>1、vue.config.js</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41107231/article/details/107576861">创建vue.config.js配置别名</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">      resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">          <span class="string">&#x27;assets&#x27;</span>: <span class="string">&#x27;@/assets&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;common&#x27;</span>: <span class="string">&#x27;@/common&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;components&#x27;</span>: <span class="string">&#x27;@/components&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;network&#x27;</span>: <span class="string">&#x27;@/network&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;views&#x27;</span>: <span class="string">&#x27;@/views&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、-editorconfig设置规范"><a href="#2、-editorconfig设置规范" class="headerlink" title="2、.editorconfig设置规范"></a>2、.editorconfig设置规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br></pre></td></tr></table></figure>

<h3 id="4、项目的模块划分-tabbar-gt-路由映射关系"><a href="#4、项目的模块划分-tabbar-gt-路由映射关系" class="headerlink" title="4、项目的模块划分: tabbar -&gt; 路由映射关系"></a>4、项目的模块划分: tabbar -&gt; 路由映射关系</h3><h3 id="5、首页开发"><a href="#5、首页开发" class="headerlink" title="5、首页开发"></a>5、首页开发</h3><ul>
<li>navbar 的封装</li>
<li>网络数据的请求</li>
<li>轮播图</li>
<li>推荐信息</li>
</ul>
</script></p></li></ul>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-19 03:10:19 / 修改时间：03:12:49" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><hr>
<p>[TOC]</p>
<h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><h3 id="1、设计模式采用的七大原则："><a href="#1、设计模式采用的七大原则：" class="headerlink" title="1、设计模式采用的七大原则："></a>1、设计模式采用的七大原则：</h3><ul>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转原则</p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则（ocp）</p>
<ul>
<li><p>工厂模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png" alt="image-20210410201229604"></p>
</li>
</ul>
</li>
<li><p>迪米特原则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ul>
<p>单例设计模式一共有 <strong>8</strong> 种写法:</p>
<ul>
<li>饿汉式 两种</li>
<li>懒汉式 三种</li>
<li>双重检查</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<h3 id="2、设计模式的重要性"><a href="#2、设计模式的重要性" class="headerlink" title="2、设计模式的重要性"></a>2、设计模式的重要性</h3><ul>
<li>软件工程中，<strong>设计模式</strong>（design pattern）是对软件设计中<strong>普遍存在（反复出现）</strong>的各种问题，所提出的<strong>解决方案</strong>。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的</li>
<li>拿实际工作经历来说, 当一个项目开发完后，如果<strong>客户提出增新功能</strong>，怎么办?（<strong>可扩展性</strong>,使用设计模式，软件具有很好的扩展性）</li>
<li>如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (<strong>维护性</strong>[可读性、规范性])</li>
<li>目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中<strong>使用过什么设计模式，怎样使用的，解决了什么问题</strong></li>
<li><strong>设计模式在软件中哪里</strong>？面向对象(oo)=&gt;<strong>功能模块</strong>[设计模式+算法(数据结构)]=&gt;<strong>框架</strong>[使用到多种设计模式]=&gt; 架构 [服务器集群]</li>
<li>如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的.</li>
</ul>
<h3 id="3、设计模式的讲解过程"><a href="#3、设计模式的讲解过程" class="headerlink" title="3、设计模式的讲解过程"></a>3、设计模式的讲解过程</h3><p>讲解的步骤</p>
<ol>
<li>应用场景</li>
<li>普通代码解决</li>
<li>设计模式解决【对比】</li>
<li>剖析原理</li>
<li>分析实现步骤(图解)</li>
<li>代码实现</li>
<li> 框架或项目源码分析(找到使用的地方)  的步骤讲解</li>
</ol>
<hr>
<h2 id="2、设计模式七大原则（单接依里开迪合）"><a href="#2、设计模式七大原则（单接依里开迪合）" class="headerlink" title="2、设计模式七大原则（单接依里开迪合）"></a>2、设计模式七大原则（单接依里开迪合）</h2><h3 id="2-1、设计模式的目的"><a href="#2-1、设计模式的目的" class="headerlink" title="2.1、设计模式的目的"></a>2.1、设计模式的目的</h3><p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ol>
<h3 id="2-2-、设计模式七大原则"><a href="#2-2-、设计模式七大原则" class="headerlink" title="2.2 、设计模式七大原则"></a>2.2 、设计模式七大原则</h3><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：<strong>设计模式为什么这样设计的依据</strong>)</p>
<p>设计模式常用的七大原则有:</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<h3 id="2-3、单一职责原则-Single-Responsibility-Principle"><a href="#2-3、单一职责原则-Single-Responsibility-Principle" class="headerlink" title="2.3、单一职责原则(Single Responsibility Principle)"></a>2.3、单一职责原则(Single Responsibility Principle)</h3><h4 id="2-3-1、基本介绍"><a href="#2-3-1、基本介绍" class="headerlink" title="2.3.1、基本介绍"></a>2.3.1、基本介绍</h4><p>单一职责的含义是：<strong>类的职责单一，引起类变化的原因单一</strong>。对类来说的，即<strong>一个类应该只负责一项职责</strong>。解释一下，这也是灵活的前提，如果我们把类拆分成最小的职能单位，那组合与复用就简单的多了，如果一个类做的事情太多，在组合的时候，必然会产生不必要的方法出现，这实际上是一种污染。</p>
<p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p>
<p>SRP优点：消除耦合，减小因需求变化引起代码僵化。</p>
<h4 id="2-3-2、应用实例"><a href="#2-3-2、应用实例" class="headerlink" title="2.3.2、应用实例"></a>2.3.2、应用实例</h4><p>需求：以交通工具案例讲解（海陆空）</p>
<p>方案 1  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 交通工具类</span></span><br><span class="line">    <span class="comment">// 方式 1</span></span><br><span class="line">    <span class="comment">// 1. 在方式 1 的 run 方法中，违反了单一职责原则</span></span><br><span class="line">    <span class="comment">// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 2  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方案 2</span></span><br><span class="line">    <span class="comment">//1. 遵守单一职责原则</span></span><br><span class="line">    <span class="comment">//2. 但是这样做的改动很大，即将类分解，同时修改客户端</span></span><br><span class="line">    <span class="comment">//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 3     [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub Vehicle2 vehicle2	= new Vehicle2();</span></span><br><span class="line">        vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式 3 </span></span><br><span class="line">    <span class="comment">//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span></span><br><span class="line">	<span class="comment">//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理</span></span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3、单一职责原则注意事项和细节"><a href="#2-3-3、单一职责原则注意事项和细节" class="headerlink" title="2.3.3、单一职责原则注意事项和细节"></a>2.3.3、单一职责原则注意事项和细节</h4><ol>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>在实际编码的过程中很难将它恰当地运用，需要结合实际情况进行运用。</li>
<li>通常情况下，<strong>我们应当遵守单一职责原则</strong>，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="2-4-、接口隔离原则-Interface-Segregation-Principle"><a href="#2-4-、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="2.4 、接口隔离原则(Interface Segregation Principle)"></a>2.4 、接口隔离原则(Interface Segregation Principle)</h3><h4 id="2-4-1、基本介绍"><a href="#2-4-1、基本介绍" class="headerlink" title="2.4.1、基本介绍"></a>2.4.1、基本介绍</h4><ol>
<li><p>它的含义是<strong>尽量使用职能单一的接口，而不使用职能复杂、全面的接口。</strong></p>
</li>
<li><p>接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。 相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。</p>
</li>
<li><p>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
</li>
<li><p>先看一张图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png" alt="image-20210411004513392"></p>
</li>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p>
</li>
<li><p>按隔离原则应当这样处理：</p>
<p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 **3</strong> 个接口**)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
</ol>
<h4 id="2-4-2、应用实例"><a href="#2-4-2、应用实例" class="headerlink" title="2.4.2、应用实例"></a>2.4.2、应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//接口</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation5</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation5&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation5();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3、应传统方法的问题和使用接口隔离原则改进"><a href="#2-4-3、应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="2.4.3、应传统方法的问题和使用接口隔离原则改进"></a>2.4.3、应传统方法的问题和使用接口隔离原则改进</h4><ol>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>
</li>
<li><p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
<li><p>接口 Interface1 中出现的方法，根据实际情况拆分为三个接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png" alt="image-20210411010354543"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 使用一把</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A 类通过接口去依赖 B 类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">        c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C 类通过接口去依赖(使用)D 类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接 口 3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D 实现了  operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation4</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C  类通过接口 Interface1,Interface3  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123; </span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-4-4、接口隔离原则注意事项和细节"><a href="#2-4-4、接口隔离原则注意事项和细节" class="headerlink" title="2.4.4、接口隔离原则注意事项和细节"></a>2.4.4、接口隔离原则注意事项和细节</h4><ol>
<li>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</li>
<li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
</ol>
<h3 id="2-5-、依赖倒转原则-Dependence-Inversion-Principle"><a href="#2-5-、依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="2.5 、依赖倒转原则(Dependence Inversion Principle)"></a>2.5 、依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="2-5-1、基本介绍"><a href="#2-5-1、基本介绍" class="headerlink" title="2.5.1、基本介绍"></a>2.5.1、基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该<strong>依赖其抽象</strong></li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong>，<strong>面向抽象编程，解耦调用和被调用者</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，<strong>抽象指的是接口或抽象类，细节就是具体的实现类</strong></li>
<li>当两个模块之间存在紧密的耦合关系时，最好的方法就是<strong>分离接口和实现</strong>：在<strong>依赖之间</strong>定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把<strong>展现细节</strong>的任务交给他们的<strong>实现类</strong>去完成</li>
</ol>
<h4 id="2-5-2、应用实例"><a href="#2-5-2、应用实例" class="headerlink" title="2.5.2、应用实例"></a>2.5.2、应用实例</h4><p>请编程完成 Person 接收消息 的功能。</p>
<p>实现方案 1 + 分析说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//方式1分析</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 但如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">		System.out.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方案 2(依赖倒转) + 分析说明（同时也满足了开闭原则ocp）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3、-依赖关系传递的三种方式和应用案例"><a href="#2-5-3、-依赖关系传递的三种方式和应用案例" class="headerlink" title="2.5.3、 依赖关系传递的三种方式和应用案例"></a>2.5.3、 依赖关系传递的三种方式和应用案例</h4><h5 id="2-5-3-1、接口传递"><a href="#2-5-3-1、接口传递" class="headerlink" title="2.5.3.1、接口传递"></a>2.5.3.1、接口传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        <span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.open(changHong);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-2、构造方法传递"><a href="#2-5-3-2、构造方法传递" class="headerlink" title="2.5.3.2、构造方法传递"></a>2.5.3.2、构造方法传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员</span></span><br><span class="line">    <span class="keyword">public</span> ITV tv; </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-3、setter-方式传递"><a href="#2-5-3-3、setter-方式传递" class="headerlink" title="2.5.3.3、setter 方式传递"></a>2.5.3.3、setter 方式传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">//通过setter方法进行依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.setTv(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// setter方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITV tv;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4、依赖倒转原则的注意事项和细节"><a href="#2-5-4、依赖倒转原则的注意事项和细节" class="headerlink" title="2.5.4、依赖倒转原则的注意事项和细节"></a>2.5.4、依赖倒转原则的注意事项和细节</h4><ol>
<li><strong>低层模块尽量都要有抽象类或接口</strong>，或者两者都有，程序稳定性更好.</li>
<li><strong>变量的声明类型尽量是抽象类或接口</strong>, 这样我们的变量引用和实际对象间，就存在一个<strong>缓冲层</strong>，利于程序扩展和优化</li>
<li><strong>继承时遵循里氏替换原则</strong>.</li>
</ol>
<h3 id="2-6、里氏替换原则-Liskov-Substitution-Principle"><a href="#2-6、里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="2.6、里氏替换原则(Liskov Substitution Principle)"></a>2.6、里氏替换原则(Liskov Substitution Principle)</h3><h4 id="2-6-1、OO-中的继承性的思考和说明"><a href="#2-6-1、OO-中的继承性的思考和说明" class="headerlink" title="2.6.1、OO 中的继承性的思考和说明"></a>2.6.1、OO 中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果<strong>子类对这些已经实现的方法任意修改</strong>，就会对<strong>整个继承体系造成破坏</strong>。</li>
<li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的<strong>可移植性降低</strong>， <strong>增加对象间的耦合性</strong>，如果<strong>一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类</strong>，并且<strong>父类修改</strong>后，<strong>所有涉及到子类的功能都有可能产生故障</strong></li>
<li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法。</strong></li>
<li>问题提出：在编程中，<strong>如何正确的使用继承</strong>? =&gt; <strong>里氏替换</strong>原则</li>
</ol>
<h4 id="2-6-2、-基本介绍"><a href="#2-6-2、-基本介绍" class="headerlink" title="2.6.2、 基本介绍"></a>2.6.2、 基本介绍</h4><ol>
<li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>里氏替换原则的含义是：<strong>子类可以在任何地方替换它的父类。</strong></li>
<li>也就是说在程序中将基类替换为子类，程序的行为不会发生任何变化。</li>
<li>Liskov替换原则是<strong>关于继承机制的设计原则</strong>，<strong>违反了Liskov替换原则就必然导致违反开放封闭原则</strong></li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li>
<li>在使用继承时，遵循里氏替换原则，在**<code>子类中尽量不要重写父类的方法</code>**。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**<code>聚合，组合，依赖</code>**来解决问题。</li>
</ol>
<p>里氏原则的优点：</p>
<ol>
<li>能够保证系统具有良好的拓展性</li>
<li>同时实现基于多态的抽象机制</li>
<li>能够减少代码冗余</li>
<li>避免运行期的类型判别</li>
</ol>
<h4 id="2-6-3、-一个程序引出的问题和思考"><a href="#2-6-3、-一个程序引出的问题和思考" class="headerlink" title="2.6.3、 一个程序引出的问题和思考"></a>2.6.3、 一个程序引出的问题和思考</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png" alt="image-20210411022902982"></p>
<p>程序员原本是想调用b中继承的a的func1的方法求出11-3，但b无意重写了a的func1方法，使相减变成了相加。</p>
<h4 id="2-6-4、解决方法"><a href="#2-6-4、解决方法" class="headerlink" title="2.6.4、解决方法"></a>2.6.4、解决方法</h4><ol>
<li><p>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是<strong>运行多态比较频繁</strong>的时候</p>
</li>
<li><p>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等关系代替.</p>
</li>
<li><p>即：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
</li>
<li><p>改进方案：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png" alt="image-20210411023703967"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		<span class="comment">//因为B类不再继承A类，因此调用者，不会再认为func1是求减法</span></span><br><span class="line">		<span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A类继承了Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 重写func1返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了Base</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了Base类的方法,</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-7、开闭原则（Open-Closed-Principle）"><a href="#2-7、开闭原则（Open-Closed-Principle）" class="headerlink" title="2.7、开闭原则（Open Closed Principle）"></a>2.7、开闭原则（Open Closed Principle）</h3><h4 id="2-7-1、基本介绍"><a href="#2-7-1、基本介绍" class="headerlink" title="2.7.1、基本介绍"></a>2.7.1、基本介绍</h4><ol>
<li>开闭原则（Open Closed Principle）是编程中<strong>最基础、最重要</strong>的设计原则</li>
<li>一个软件实体如类，模块和函数应该<strong>对扩展开放(对提供方)**，</strong>对修改关闭(对使用方)<strong>。用</strong>抽象构建框架<strong>，用</strong>实现扩展细节**。</li>
<li>采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。</li>
<li>所以当软件需要变化时，尽量<strong>通过扩展软件实体</strong>的行为来实现变化，而<strong>不是通过修改已有的代码</strong>来实现变化。</li>
<li><strong>编程中遵循其它原则</strong>，以及<strong>使用设计模式的目的就是遵循开闭原则</strong>。</li>
</ol>
<h4 id="2-7-2、看下面一段代码"><a href="#2-7-2、看下面一段代码" class="headerlink" title="2.7.2、看下面一段代码"></a>2.7.2、看下面一段代码</h4><p>实现画图形的功能</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png" alt="image-20210411025709019"></p>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png" alt="image-20210411025938974"></p>
<p>但我们增加一个功能：画三角形</p>
<p>方式1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">			drawRectangle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">			drawCircle(s);</span><br><span class="line">        <span class="comment">// 修改1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">			drawTriangle(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制圆形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="comment">//修改2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3、方式-1-的优缺点"><a href="#2-7-3、方式-1-的优缺点" class="headerlink" title="2.7.3、方式 1 的优缺点"></a>2.7.3、方式 1 的优缺点</h4><ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是违反了设计模式的 ocp 原则，即**对扩展开放(提供方)，对修改关闭(使用方)**。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时要<strong>新增加一个图形种类三角形，我们需要做如下修改，修改的地方较多（使用方要修改两次）</strong></p>
</li>
<li><p>代码演示（方式2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">         <span class="comment">//使用方直接使用</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类（使用抽象类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-7-4、改进的思路分析"><a href="#2-7-4、改进的思路分析" class="headerlink" title="2.7.4、改进的思路分析"></a>2.7.4、改进的思路分析</h4><p>把创建 <strong>Shape</strong> 类做成<strong>抽象类</strong>，并提供一个<strong>抽象的 draw 方法</strong>，让<strong>子类去实现</strong>即可，这样我们有<strong>新的图形种类</strong>时，只需要让<strong>新的图形类继承 Shape</strong>，并<strong>实现 draw 方法</strong>即可，<strong>使用方的代码就不需要修改-&gt;    满足了开闭原则</strong></p>
<h4 id="2-7-5、开闭原则注意事项和细节"><a href="#2-7-5、开闭原则注意事项和细节" class="headerlink" title="2.7.5、开闭原则注意事项和细节"></a>2.7.5、开闭原则注意事项和细节</h4><ol>
<li>OCP 可以具有良好的可扩展性，可维护性。</li>
<li>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它。</li>
</ol>
<h3 id="2-8、迪米特法则-Demeter-Principle"><a href="#2-8、迪米特法则-Demeter-Principle" class="headerlink" title="2.8、迪米特法则(Demeter Principle)"></a>2.8、迪米特法则(Demeter Principle)</h3><h4 id="2-8-1、基本介绍"><a href="#2-8-1、基本介绍" class="headerlink" title="2.8.1、基本介绍"></a>2.8.1、基本介绍</h4><ol>
<li>迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。就是说<strong>一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。</strong></li>
<li>一个对象应该对其他对象<strong>保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于<strong>被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></li>
<li><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要<strong>两个对象之间有耦合关系</strong>，我们就说这两个对象之间是<strong>朋友关系</strong>。耦合的方式很多，<strong>依赖</strong>，<strong>关联</strong>，<strong>组合</strong>，<strong>聚合</strong>等。其中，我们称出现<strong>成员变量</strong>，<strong>方法参数</strong>，<strong>方法返回值</strong>中的类为<strong>直接的朋友</strong>，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要以局部变量的形式出现在类的内部</strong>。最好将其封装到直接朋友里面。</li>
<li>迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。</li>
</ol>
<h4 id="2-8-2、应用实例"><a href="#2-8-2、应用实例" class="headerlink" title="2.8.2、应用实例"></a>2.8.2、应用实例</h4><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id。编程实现上面的功能, 看代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">////添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">		<span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">		<span class="comment">//3. 违反了 迪米特法则 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-3、应用实例改进"><a href="#2-8-3、应用实例改进" class="headerlink" title="2.8.3、应用实例改进"></a>2.8.3、应用实例改进</h4><ol>
<li><p>前面设计的问题在于 SchoolManager 中，<strong>CollegeEmployee</strong> 类并不是 <strong>SchoolManager</strong> 类的直接朋友 (分析)</p>
</li>
<li><p>按照迪米特法则，应该<strong>避免类中出现这样非直接朋友关系的耦合</strong></p>
</li>
<li><p>对代码按照迪米特法则 进行改进：</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出学院员工的信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-8-4、迪米特法则注意事项和细节"><a href="#2-8-4、迪米特法则注意事项和细节" class="headerlink" title="2.8.4、迪米特法则注意事项和细节"></a>2.8.4、迪米特法则注意事项和细节</h4><ol>
<li><p>迪米特法则的核心是<strong>降低类之间的耦合</strong></p>
</li>
<li><p>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</p>
</li>
</ol>
<h3 id="2-9、合成复用原则（Composite-Reuse-Principle）"><a href="#2-9、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="2.9、合成复用原则（Composite Reuse Principle）"></a>2.9、合成复用原则（Composite Reuse Principle）</h3><h4 id="2-9-1、基本介绍"><a href="#2-9-1、基本介绍" class="headerlink" title="2.9.1、基本介绍"></a>2.9.1、基本介绍</h4><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而<strong>不是使用继承</strong></p>
<p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p>
<p>因为继承的耦合性更大，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。说白了就是我只用你的方法，但我们并不是同类。</p>
<p>在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png" alt="image-20210411150334377"></p>
<h3 id="2-10、设计原则核心思想"><a href="#2-10、设计原则核心思想" class="headerlink" title="2.10、设计原则核心思想"></a>2.10、设计原则核心思想</h3><ol>
<li>找出应用中<strong>可能需要变化</strong>之处，把它们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起。</li>
<li><strong>针对接口编程</strong>，而不是针对实现编程。</li>
<li>为了交互对象之间的<strong>松耦合</strong>设计而努力</li>
</ol>
<h3 id="2-11、设计七大原则总结"><a href="#2-11、设计七大原则总结" class="headerlink" title="2.11、设计七大原则总结"></a>2.11、设计七大原则总结</h3><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p>
<p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<p>实际上，这些原则的目的只有一个：<strong>降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性</strong>。</p>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p>
<h2 id="3、UML-类图"><a href="#3、UML-类图" class="headerlink" title="3、UML 类图"></a>3、UML 类图</h2><h3 id="3-1、UML-基本介绍"><a href="#3-1、UML-基本介绍" class="headerlink" title="3.1、UML 基本介绍"></a>3.1、UML 基本介绍</h3><ol>
<li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p>
</li>
<li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<strong>类、接口、实现、泛化、依赖、组合、聚合</strong>等，如右图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.png" alt="image-20210411172838273"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png" alt="image-20210411173002251"></p>
</li>
<li><p>使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</p>
</li>
</ol>
<h3 id="3-2、UML-图"><a href="#3-2、UML-图" class="headerlink" title="3.2、UML 图"></a>3.2、UML 图</h3><p>画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML 图分类：</p>
<ol>
<li>用例图(use case)</li>
<li> 静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ol>
<p>说明：</p>
<ol>
<li>类图是描述<strong>类与类之间的关系</strong>的，是 UML 图中最核心的</li>
<li>在讲解设计模式时，我们必然会使用类图，为了让学员们能够把设计模式学到位，需要先给大家讲解类图</li>
</ol>
<h3 id="3-3、UML-类图"><a href="#3-3、UML-类图" class="headerlink" title="3.3、UML 类图"></a>3.3、UML 类图</h3><ol>
<li><p>用于描述系统中的类**(<strong>对象</strong>)<strong>本身的组成和类</strong>(<strong>对象</strong>)**之间的各种静态关系。</p>
</li>
<li><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。</p>
</li>
<li><p>类图简单举例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">//代码形式-&gt;类图</span></span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>	name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png" alt="image-20210411192255196"></p>
</li>
</ol>
<h3 id="3-4、类图—依赖关系（Dependence）"><a href="#3-4、类图—依赖关系（Dependence）" class="headerlink" title="3.4、类图—依赖关系（Dependence）"></a>3.4、类图—依赖关系（Dependence）</h3><p>只要是<strong>在类中用到了对方</strong>，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png" alt="image-20210411192418668"></p>
<p>依赖关系小结：</p>
<ol>
<li><strong>类中用到了对方</strong></li>
<li>如果是类的<strong>成员属性</strong></li>
<li>如果是<strong>方法的返回类型</strong></li>
<li>是方法<strong>接收的参数类型</strong></li>
<li><strong>方法中使用到</strong></li>
</ol>
<h3 id="3-5、类图—泛化关系-generalization）"><a href="#3-5、类图—泛化关系-generalization）" class="headerlink" title="3.5、类图—泛化关系(generalization）"></a>3.5、类图—泛化关系(generalization）</h3><p>泛化关系实际上就是<strong>继承关系</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png" alt="image-20210411192748570"></p>
<p>泛化关系小结:</p>
<ol>
<li>泛化关系实际上就是<strong>继承关系</strong></li>
<li>如果 A 类继承了 B 类，我们就说 A 和 B 存在<strong>泛化关系</strong></li>
</ol>
<h3 id="3-6、类图—实现关系（Implementation）"><a href="#3-6、类图—实现关系（Implementation）" class="headerlink" title="3.6、类图—实现关系（Implementation）"></a>3.6、类图—实现关系（Implementation）</h3><p>实现关系实际上就是 <strong>A 类实现 B 接口</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png" alt="image-20210411193029031"></p>
<h3 id="3-7、类图—关联关系（Association）"><a href="#3-7、类图—关联关系（Association）" class="headerlink" title="3.7、类图—关联关系（Association）"></a>3.7、类图—关联关系（Association）</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png" alt="image-20210411193416238"></p>
<h3 id="3-8、类图—聚合关系（Aggregation）"><a href="#3-8、类图—聚合关系（Aggregation）" class="headerlink" title="3.8、类图—聚合关系（Aggregation）"></a>3.8、类图—聚合关系（Aggregation）</h3><h4 id="3-8-1、基本介绍"><a href="#3-8-1、基本介绍" class="headerlink" title="3.8.1、基本介绍"></a>3.8.1、基本介绍</h4><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开</strong>。聚合关系是<strong>关联关系的特例</strong>，所以他具有关联的<strong>导航性与多重性</strong>。</p>
<p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png" alt="image-20210411193519679"></p>
<h3 id="3-9、类图—组合关系（Composition）"><a href="#3-9、类图—组合关系（Composition）" class="headerlink" title="3.9、类图—组合关系（Composition）"></a>3.9、类图—组合关系（Composition）</h3><h4 id="3-9-1、基本介绍"><a href="#3-9-1、基本介绍" class="headerlink" title="3.9.1、基本介绍"></a>3.9.1、基本介绍</h4><p>组合关系：也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开</strong>。</p>
<p>再看一个案例：在程序中我们定义实体：Person 与 IDCard、Head, 那么 <strong>Head 和 Person 就是 组合</strong>，<strong>IDCard 和Person 就是聚合。</strong></p>
<p>但是如果在程序中 Person 实体中定义了对 IDCard 进行<strong>级联删除</strong>，即删除 Person 时连同 IDCard 一起删除，那么 <strong>IDCard 和 Person 就是组合了.</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="comment">// 在创建Person对象的同时创建了Head对象</span></span><br><span class="line">    <span class="keyword">private</span> Head head = <span class="keyword">new</span> Head();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png" alt="image-20210411193901631"></p>
<h2 id="4、设计模式概述"><a href="#4、设计模式概述" class="headerlink" title="4、设计模式概述"></a>4、设计模式概述</h2><h3 id="4-1、设计模式介绍"><a href="#4-1、设计模式介绍" class="headerlink" title="4.1、设计模式介绍"></a>4.1、设计模式介绍</h3><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，<strong>模式</strong>不是代码，而是某类问题的<strong>通用解决方案</strong>，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li>
<li>设计模式的本质提高<strong>软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li>
<li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）</li>
<li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li>
</ol>
<h3 id="4-2、设计模式类型"><a href="#4-2、设计模式类型" class="headerlink" title="4.2、设计模式类型"></a>4.2、设计模式类型</h3><p>设计模式分为<strong>三种类型</strong>，共 <strong>23</strong> 种</p>
<ol>
<li><strong>创建型</strong>模式：<strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</li>
<li><strong>结构型</strong>模式：适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong>。</li>
<li><strong>行为型</strong>模式：模版方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li>
</ol>
<p>注意：不同的书籍上对分类和名称略有差别</p>
<p>对于创建型模式的概述请看第27点</p>
<p>对于结构型模式的概述请看第28点</p>
<p>对于行为型模式的概述请看第29点</p>
<h2 id="5、单例设计模式Singleton（创建型设计模式）"><a href="#5、单例设计模式Singleton（创建型设计模式）" class="headerlink" title="5、单例设计模式Singleton（创建型设计模式）"></a>5、单例设计模式Singleton（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/76.png" alt="image-20210415031845856"></p>
<h3 id="5-1、单例设计模式介绍"><a href="#5-1、单例设计模式介绍" class="headerlink" title="5.1、单例设计模式介绍"></a>5.1、单例设计模式介绍</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例</strong>， 并且该类**只提供一个取得其对象实例的方法(静态方法)**。</p>
<p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。<strong>SessionFactory 并不是轻量级的</strong>，一般情况下，<strong>一个项目通常只需要一个</strong> SessionFactory 就够，这是就会<strong>使用到单例模式</strong>。</p>
<p>注意：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ol>
<p>测试方法（除了枚举）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断创建的两个实例是不是同一个</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">		System.out.println(instance == instance2); </span><br><span class="line">		System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2、单例设计模式八种方式"><a href="#5-2、单例设计模式八种方式" class="headerlink" title="5.2、单例设计模式八种方式"></a>5.2、单例设计模式八种方式</h3><p><strong>加黑属于推荐使用</strong></p>
<ol>
<li><strong>饿汉式（两种）</strong><ol>
<li>饿汉式**(静态常量)**</li>
<li>饿汉式<strong>（静态代码块）</strong></li>
</ol>
</li>
<li>懒汉式（三种）<ol>
<li>懒汉式(线程不安全)</li>
<li>懒汉式(线程安全，同步方法)</li>
<li> 懒汉式(同步代码块)</li>
</ol>
</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="5-3、饿汉式（两种）"><a href="#5-3、饿汉式（两种）" class="headerlink" title="5.3、饿汉式（两种）"></a>5.3、饿汉式（两种）</h3><h4 id="5-3-1、饿汉式（静态常量）"><a href="#5-3-1、饿汉式（静态常量）" class="headerlink" title="5.3.1、饿汉式（静态常量）"></a>5.3.1、饿汉式（静态常量）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>类的<strong>内部创建对象</strong></li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态常量）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ul>
<li>优点：这种写法比较简单，就是<strong>在类装载的时候就完成实例化</strong>。避免了线程同步问题。</li>
<li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终<strong>从未使用</strong>过这个实例，则会造成<strong>内存的浪费</strong></li>
<li>这种方式基于 <code>classloder</code> 机制<strong>避免了多线程的同步问题</strong>，不过，<strong>instance 在类装载时就实例化</strong>，在单例模式中大多数都是调用 getInstance 方法， 但是导致<strong>类装载的原因有很多种</strong>，因此<strong>不能确定有其他的方式（或者其他的静态方法）导致类装载</strong>，这时候初始化 instance 就<strong>没有达到 <code>lazy loading</code> 的效果</strong></li>
<li>结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成<strong>内存浪费</strong>，同时也不能实现懒加载（lazy loading）</li>
</ul>
<h4 id="5-3-2、饿汉式（静态代码块）"><a href="#5-3-2、饿汉式（静态代码块）" class="headerlink" title="5.3.2、饿汉式（静态代码块）"></a>5.3.2、饿汉式（静态代码块）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>在<strong>静态代码块</strong>中，创建单例对象</li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态代码块）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.在静态代码块中，创建单例对象</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在<strong>类装载</strong>的时候，就<strong>执行静态代码块中的代码</strong>，<strong>初始化类的实例</strong>。优缺点和上面是一样的。</li>
<li>结论：这种单例模式可用，但是可能造成<strong>内存浪费</strong></li>
</ol>
<h3 id="5-4、懒汉式（三种）"><a href="#5-4、懒汉式（三种）" class="headerlink" title="5.4、懒汉式（三种）"></a>5.4、懒汉式（三种）</h3><h4 id="5-4-1、懒汉式-线程不安全"><a href="#5-4-1、懒汉式-线程不安全" class="headerlink" title="5.4.1、懒汉式(线程不安全)"></a>5.4.1、懒汉式(线程不安全)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，当<strong>使用到该方法</strong>时，才去创建 instance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程不安全)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在<strong>单线程下使用</strong>。</li>
<li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在<strong>多线程环境下不可使用</strong>这种方式。（线程不安全）</li>
<li>结论：在实际开发中，<strong>不要使用这种方式.</strong></li>
</ol>
<h4 id="5-4-2、懒汉式-线程安全，同步方法"><a href="#5-4-2、懒汉式-线程安全，同步方法" class="headerlink" title="5.4.2、懒汉式(线程安全，同步方法)"></a>5.4.2、懒汉式(线程安全，同步方法)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入同步处理的代码<strong>synchronized</strong> ，解决线程安全问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li><strong>解决了线程安全问题</strong></li>
<li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而<strong>其实</strong>这个方法<strong>只执行一次实例化代码就够了</strong>，<strong>后面的想获得该类实例，直接 return 就行了</strong>。方法进行同步<strong>效率太低。</strong></li>
<li>结论：在实际开发中，<strong>不推荐使用</strong>这种方式</li>
</ol>
<h4 id="5-4-3、懒汉式-同步代码块"><a href="#5-4-3、懒汉式-同步代码块" class="headerlink" title="5.4.3、懒汉式(同步代码块)"></a>5.4.3、懒汉式(同步代码块)</h4><ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入<strong>同步产生实例化的的代码块</strong>，解决效率问题。</li>
</ol>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png" alt="image-20210412194454470"></p>
<p>优缺点说明：</p>
<ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为<strong>同步产生实例化的的代码块。</strong></li>
<li>但是这种同步并<strong>不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例</strong>。（<strong>线程不安全</strong>）</li>
<li>结论：在实际开发中，**<code>不能使用</code>**这种方式</li>
</ol>
<h3 id="5-5、双重检查"><a href="#5-5、双重检查" class="headerlink" title="5.5、双重检查"></a>5.5、双重检查</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法，加入**双重检查代码(双if)**，解决线程安全问题, 同时解决懒加载问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们<strong>进行了两次 if (singleton == null)检查</strong>，这样就可以<strong>保证线程安全</strong>了。</li>
<li>是对懒汉式(线程安全，同步方法)的优化</li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也<strong>避免的反复进行方法同步</strong>。</li>
<li><strong>线程安全</strong>；<strong>延迟加载</strong>；<strong>效率较高</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>双重检锁虽然是线程安全的，会出现<strong>内部成员变量空指针异常</strong>，如果要使用，需将<strong>类实例用volatile修饰</strong></li>
<li>volatile 是<strong>改变立即更新到主存</strong>，<strong>保证变化各线程可见</strong>，即：<strong>立即从主内存中获取值，更新工作内存的值</strong>。在多线程情况下，不仅<strong>防止指令重排</strong>，而且<strong>保证happes-before规则</strong>，前一个线程的操作对后一个线程可见。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">（happens-before规则相关）</a></li>
<li>如果<strong>不用volatile关键字</strong>，有可能会出现异常。因为instance = new Singleton();并不是一个原子操作。new对象分为三步：<ol>
<li>第一步：分配对象的内存空间</li>
<li>第二步：初始化对象</li>
<li>第三步：设置instance指向内存空间</li>
</ol>
</li>
<li>但是这个被返回的instance是有问题的——它还没有被初始化（第二步还未被执行)。</li>
<li>这里必须要volatile，volatile就是保证一个线程更新了instance，其余线程立马可知，不然第二个if没有用。（可见性）</li>
<li>volitile保证了线程间的可见性，和一定程度上的顺序性（不能保证原子性），更好的方式是用一个boolean变量标识对象是否创建过（原子性）</li>
</ul>
<p>双重检查创建单例实现步骤</p>
<ol>
<li>第一个if(singleton==null){}：第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进</li>
<li>synchronized (Singleton.class) {}：第一层锁，保证只有一个线程进入</li>
<li>第二个if(singleton==null){}：第二层检查<ul>
<li>双重检查，防止多个线程同时进入第一层检查(因单例模式只允许存在一个对象，故在创建对象之前无引用指向对象，所有线程均可进入第一层检查)</li>
<li>当某一线程获得锁创建一个Singleton对象时,即已有引用指向对象，singleton不为空，从而保证只会创建一个对象</li>
<li>假设没有第二层检查，那么第一个线程创建完对象释放锁后，后面进入对象也会创建对象，会产生多个对象。（5.4.3的情况）</li>
</ul>
</li>
<li>instance = new Singleton()：volatile关键字作用为禁止指令重排，保证返回Singleton对象一定在创建对象后<ul>
<li>该语句为非原子性，实际上会执行以下内容：<ol>
<li>在堆上开辟空间</li>
<li>属性初始化</li>
<li>引用指向对象</li>
</ol>
</li>
<li>假设以上三个内容为三条单独指令，因指令重排可能会导致执行顺序为1-&gt;3-&gt;2(正常为1-&gt;2-&gt;3),当单例模式中存在普通变量需要在构造方法中进行初始化操作时，单线程情况下，顺序重排没有影响；但在多线程情况下，假如线程1执行singleton=new Singleton()语句时先1再3，由于系统调度线程2的原因没来得及执行步骤2，但此时已有引用指向对象也就是singleton!=null，故线程2在第一次检查时不满足条件直接返回singleton，此时singleton为一个没有被步骤2正确初始化的singleton。</li>
<li>volatile关键字可保证singleton=new Singleton()语句执行顺序为123，因其为非原子性依旧可能存在系统调度问题(即执行步骤时被打断)，但能确保的是只要singleton!=null，就表明一定执行了属性初始化操作；而若在步骤3之前被打断，此时singleton依旧为null，其他线程可进入第一层检查向下执行创建对象。</li>
</ul>
</li>
</ol>
<h3 id="5-6、静态内部类"><a href="#5-6、静态内部类" class="headerlink" title="5.6、静态内部类"></a>5.6、静态内部类</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>写一个<strong>静态内部类</strong>,该类中有一个<strong>静态属性 Singleton</strong></li>
<li>提供一个静态的公有方法，直接返回<strong>SingletonInstance.INSTANCE</strong></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="comment">// 1.构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式采用了<strong>类装载的机制</strong>来<strong>保证初始化实例时只有一个线程</strong>。</li>
<li>静态内部类方式<strong>在 Singleton 类被装载时并不会立即实例化</strong>，而是在需要实例化时，<strong>调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化</strong>。</li>
<li><strong>类的静态属性只会在第一次加载类的时候初始化</strong>，所以在这里，<strong>JVM</strong> 帮助我们<strong>保证了线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的。</li>
<li>优点：<strong>避免了线程不安全</strong>，利用静态内部类特点<strong>实现延迟加载</strong>，<strong>效率高</strong></li>
<li>缺点：<strong>不能传参</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>静态内部类：这里的关键是类在加载的时候是线程安全的，一个类只会被加载一次</li>
<li>JVM初始化时机：<ol>
<li>首次，主动使用才会初始化。即只有第一次加载类的时候初始化。</li>
<li>之后调用getInstance()方法，直接返回对象，不会再次初始化了</li>
</ol>
</li>
<li>这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</li>
</ul>
<h3 id="5-7、枚举"><a href="#5-7、枚举" class="headerlink" title="5.7、枚举"></a>5.7、枚举</h3><p>使用步骤：</p>
<ol>
<li>直接使用枚举实现单例</li>
<li>在枚举里面有<strong>INSTANCE属性</strong></li>
<li>外部直接通过<strong>Singleton.INSTANCE</strong>的方式创建实例</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 通过Singleton.INSTANCE的方式创建实例</span></span><br><span class="line">		Singleton instance = Singleton.INSTANCE;</span><br><span class="line">		Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">		System.out.println(instance == instance2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">		instance.sayOK();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">	INSTANCE; </span><br><span class="line">    <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        value = <span class="number">1</span>; </span><br><span class="line">        System.out.println(<span class="string">&quot;INSTANCE now created!&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能<strong>避免多线程同步</strong>问题，而且还能<strong>防止反序列化重新创建新的对象</strong>。</li>
<li><strong>JVM 会阻止反射获取枚举类的私有构造方法</strong></li>
<li>枚举真正实现了单例，把反序列化和反射创建第二对象的路都堵死了</li>
<li>这种方式是 <strong>Effective Java</strong> 作者 <strong>Josh Bloch</strong> 提倡的方式</li>
<li>缺点：<strong>无法进行懒加载</strong>。如果Singleton必须拓展一个超类，而不是扩展Enum的时候，则不宜使用这个方法。</li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<h3 id="5-8、单例模式在-JDK-应用的源码分析"><a href="#5-8、单例模式在-JDK-应用的源码分析" class="headerlink" title="5.8、单例模式在 JDK 应用的源码分析"></a>5.8、单例模式在 JDK 应用的源码分析</h3><p>我们 JDK 中，java.lang.Runtime 就是经典的<strong>单例模式(饿汉式)</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/31.png" alt="image-20210413021321623"></p>
<h3 id="5-9、单例模式总结"><a href="#5-9、单例模式总结" class="headerlink" title="5.9、单例模式总结"></a>5.9、单例模式总结</h3><h4 id="5-9-1、单例模式的优缺点"><a href="#5-9-1、单例模式的优缺点" class="headerlink" title="5.9.1、单例模式的优缺点"></a>5.9.1、单例模式的优缺点</h4><p>优点：</p>
<ul>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>可以避免对资源的多重占用。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ul>
<h4 id="5-9-2、单例模式的应用场景"><a href="#5-9-2、单例模式的应用场景" class="headerlink" title="5.9.2、单例模式的应用场景"></a>5.9.2、单例模式的应用场景</h4><p>对于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。</p>
<ul>
<li>需要<strong>频繁创建的一些类</strong>，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类<strong>只要求生成一个对象的时候</strong>，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时<strong>占用资源较多，或实例化耗时较长</strong>，且经常使用。</li>
<li>某类需要<strong>频繁实例化</strong>，而创建的对象又<strong>频繁被销毁</strong>的时候，如<strong>多线程的线程池</strong>、<strong>网络连接池</strong>等。</li>
<li><strong>频繁访问数据库或文件的对象</strong>。</li>
<li>对于一些<strong>控制硬件级别</strong>的操作，或者从系统上来讲应当是<strong>单一控制逻辑</strong>的操作，如果有多个实例，则系统会完全乱套。</li>
<li>当<strong>对象需要被共享</strong>的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 <strong>Web 中的配置对象、数据库的连接池</strong>等。</li>
</ul>
<h4 id="5-9-3、单例模式的结构"><a href="#5-9-3、单例模式的结构" class="headerlink" title="5.9.3、单例模式的结构"></a>5.9.3、单例模式的结构</h4><p>单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p>结构：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png" alt="image-20210412211111576"></p>
<h4 id="5-9-4、相关的设计模式"><a href="#5-9-4、相关的设计模式" class="headerlink" title="5.9.4、相关的设计模式"></a>5.9.4、相关的设计模式</h4><p>在以下模式中， 多数情况下只会生成一个实例。</p>
<ul>
<li>AbstractFactory模式</li>
<li>Builder模式</li>
<li>Facade模式</li>
<li>Prototype模式</li>
</ul>
<h4 id="5-9-5、单例模式注意事项和细节说明"><a href="#5-9-5、单例模式注意事项和细节说明" class="headerlink" title="5.9.5、单例模式注意事项和细节说明"></a>5.9.5、单例模式注意事项和细节说明</h4><ul>
<li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li>
<li>枚举是最安全的单例，是不可破坏的，其余所有的单例都是可以用反射破坏的</li>
<li>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符。因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</li>
<li><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种静态内部方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</li>
</ul>
<h4 id="5-9-6、反射与反序列化破坏单例模式的方法及解决办法"><a href="#5-9-6、反射与反序列化破坏单例模式的方法及解决办法" class="headerlink" title="5.9.6、反射与反序列化破坏单例模式的方法及解决办法"></a>5.9.6、反射与反序列化破坏单例模式的方法及解决办法</h4><p>除枚举方式外, 其他方法都会通过反射或反序列化的方式破坏单例</p>
<h5 id="5-9-6-1、反射破坏单例模式"><a href="#5-9-6-1、反射破坏单例模式" class="headerlink" title="5.9.6.1、反射破坏单例模式"></a>5.9.6.1、反射破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyb628/p/6371827.html">反射如何破坏单例模式</a></p>
<p>通过反射获得单例类的构造函数，由于该构造函数是private的，通过setAccessible(true)指示反射的对象在使用时应该取消 Java 语言访问检查,使得私有的构造函数能够被访问，这样使得单例模式失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Singleton s1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s2 = constructor.newInstance();</span><br><span class="line"> </span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-9-6-2、反序列化破坏单例模式"><a href="#5-9-6-2、反序列化破坏单例模式" class="headerlink" title="5.9.6.2、反序列化破坏单例模式"></a>5.9.6.2、反序列化破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903745772339214">序列化和反序列化的对单例破坏的防止及其原理</a></p>
<p>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例。</p>
<p>我们使用正常的方式来获取一个对象。通过序列化将对象写入文件中，然后我们通过反序列化的到一个对象，我们再对比这个对象，输出的内存地址和布尔结果都表示这不是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;单例构造器禁止反射调用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用之前的饿汉式的单例作为例子。在之前饿汉式的代码上做点小改动。就是让我们的单例类实现 Serializable接口。然后我们在测试类中测试一下怎么破坏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;singleton_file&quot;</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;singleton_file&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">        System.out.println(instance == newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-9-7、单例模式的扩展"><a href="#5-9-7、单例模式的扩展" class="headerlink" title="5.9.7、单例模式的扩展"></a>5.9.7、单例模式的扩展</h4><p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png" alt="image-20210412215700680"></p>
<h2 id="6、工厂模式（创建型设计模式）"><a href="#6、工厂模式（创建型设计模式）" class="headerlink" title="6、工厂模式（创建型设计模式）"></a>6、工厂模式（创建型设计模式）</h2><p>在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。</p>
<blockquote>
<p>注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。</p>
</blockquote>
<p>工厂模式的定义：定义一个<strong>创建产品对象的工厂接口</strong>，将<strong>产品对象的实际创建工作推迟到具体子工厂类</strong>当中。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="6-1、简单工厂模式SimpleFactory"><a href="#6-1、简单工厂模式SimpleFactory" class="headerlink" title="6.1、简单工厂模式SimpleFactory"></a>6.1、简单工厂模式SimpleFactory</h3><h4 id="6-1-1、简单工厂模式介绍"><a href="#6-1-1、简单工厂模式介绍" class="headerlink" title="6.1.1、简单工厂模式介绍"></a>6.1.1、简单工厂模式介绍</h4><ol>
<li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</li>
<li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li>
<li>在软件开发中，当我们会用到<strong>大量的创建某种、某类或者某批对象</strong>时，就会使用到工厂模式。</li>
<li>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</li>
<li>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
</ol>
<p>可总结：</p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<h4 id="6-1-2、模式的结构与实现"><a href="#6-1-2、模式的结构与实现" class="headerlink" title="6.1.2、模式的结构与实现"></a>6.1.2、模式的结构与实现</h4><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26.png" alt="image-20210413003915038"></p>
<p>根据上图写出该模式的代码如下：(模板)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3、应用实例"><a href="#6-1-3、应用实例" class="headerlink" title="6.1.3、应用实例"></a>6.1.3、应用实例</h4><p>看一个具体的需求：披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</li>
<li>披萨的制作有 prepare，bake, cut, box</li>
<li>完成披萨店订购功能。</li>
</ol>
<p>使用简单工厂模式实现：</p>
<p>简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.png" alt="image-20210413001450106"></p>
<p>代码实现（省略pizza抽象类与具体实现类的编写）：</p>
<p>根据简单工厂模式创建：</p>
<ol>
<li><p>创建工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据orderType 返回对应的Pizza 对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">	SimpleFactory simpleFactory;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		setFactory(simpleFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line">		<span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType(); </span><br><span class="line">			pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line">			<span class="comment">//输出pizza</span></span><br><span class="line">			<span class="keyword">if</span>(pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用简单工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> SimpleFactory());</span><br><span class="line">		System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>根据静态工厂模式创建：</p>
<ol>
<li><p>创建静态工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//简单工厂模式 也叫 静态工厂模式 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	String orderType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line">			<span class="comment">// 输出pizza</span></span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用静态工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza();</span><br><span class="line">         System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-1-4、简单工厂模式（静态工厂模式）的相关说明"><a href="#6-1-4、简单工厂模式（静态工厂模式）的相关说明" class="headerlink" title="6.1.4、简单工厂模式（静态工厂模式）的相关说明"></a>6.1.4、简单工厂模式（静态工厂模式）的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。<strong>客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品</strong>。工厂和产品的职责区分明确。</li>
<li>客户端<strong>无需知道所创建具体产品的类名，只需知道参数</strong>即可。</li>
<li>也可以<strong>引入配置文件</strong>，在<strong>不修改客户端代码</strong>的情况下<strong>更换和添加新的具体产品类</strong>。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>简单工厂模式的<strong>工厂类单一，负责所有产品的创建，职责过重</strong>，一旦异常，整个系统将受影响。且工厂类<strong>代码</strong>会非常<strong>臃肿</strong>，<strong>违背高聚合原则</strong>。</li>
<li>使用简单工厂模式会<strong>增加系统中类的个数</strong>（引入新的工厂类），增加系统的<strong>复杂度和理解难度</strong></li>
<li>系统<strong>扩展困难</strong>，一旦<strong>增加</strong>新产品不得不<strong>修改工厂逻辑</strong>，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 <strong>static 工厂方法</strong>，造成工厂角色<strong>无法形成基于继承</strong>的等级结构。</li>
</ol>
</li>
<li><p>应用场景</p>
<p>对于<strong>产品种类相对较少</strong>的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
</li>
<li><p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
</li>
</ul>
<h3 id="6-2、工厂方法模式Factory-Method"><a href="#6-2、工厂方法模式Factory-Method" class="headerlink" title="6.2、工厂方法模式Factory Method"></a>6.2、工厂方法模式Factory Method</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/75.PNG" alt="image-20210415031807022"></p>
<h4 id="6-2-1、工厂方法模式介绍"><a href="#6-2-1、工厂方法模式介绍" class="headerlink" title="6.2.1、工厂方法模式介绍"></a>6.2.1、工厂方法模式介绍</h4><ol>
<li> 简单工厂模式提到了违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是<strong>可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则</strong>。</li>
<li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</li>
</ol>
<h4 id="6-2-2、模式的结构与实现"><a href="#6-2-2、模式的结构与实现" class="headerlink" title="6.2.2、模式的结构与实现"></a>6.2.2、模式的结构与实现</h4><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h5 id="6-2-2-1-模式的结构"><a href="#6-2-2-1-模式的结构" class="headerlink" title="6.2.2.1. 模式的结构"></a>6.2.2.1. 模式的结构</h5><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图 1 所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/27.png" alt="image-20210413004548795"></p>
<h5 id="6-2-2-2、模式的实现"><a href="#6-2-2-2、模式的实现" class="headerlink" title="6.2.2.2、模式的实现"></a>6.2.2.2、模式的实现</h5><p>根据图 1 写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3、应用实例"><a href="#6-2-3、应用实例" class="headerlink" title="6.2.3、应用实例"></a>6.2.3、应用实例</h4><ol>
<li><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/28.png" alt="image-20210413012849728"></p>
</li>
<li><p>代码实现：</p>
<p>订购披萨OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">			<span class="comment">//输出pizza 制作过程</span></span><br><span class="line">			pizza.prepare();</span><br><span class="line">			pizza.bake();</span><br><span class="line">			pizza.cut();</span><br><span class="line">			pizza.box();	</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京的pizza继承OrderPizza（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String loc = <span class="string">&quot;bj&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (loc.equals(<span class="string">&quot;bj&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">//创建北京口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> BJOrderPizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//创建伦敦口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-2-4、工厂方法模式的相关说明"><a href="#6-2-4、工厂方法模式的相关说明" class="headerlink" title="6.2.4、工厂方法模式的相关说明"></a>6.2.4、工厂方法模式的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li><strong>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类</strong>。</li>
<li>典型的<strong>解耦框架</strong>。高层模块只需要知道产品的抽象类，无须关心其他实现类，<strong>满足迪米特法则、依赖倒置原则和里氏替换原则。</strong></li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><strong>类的个数容易过多，增加复杂度</strong></li>
<li><strong>增加了系统的抽象性和理解难度</strong></li>
<li><strong>抽象产品只能生产一种产品</strong>，此弊端可使用<strong>抽象工厂模式</strong>解决。</li>
</ol>
</li>
<li><p>应用场景：</p>
<ol>
<li><strong>客户只知道创建产品的工厂名</strong>，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li><strong>创建对象的任务由多个具体子工厂中的某一个完成</strong>，而抽象工厂只提供创建产品的接口。</li>
<li><strong>客户</strong>不关心创建产品的细节，<strong>只关心产品的品牌</strong></li>
</ol>
</li>
<li><p>注意：</p>
<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p>
</li>
</ul>
<h3 id="6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）"><a href="#6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）" class="headerlink" title="6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）"></a>6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）</h3><p>在 Factory Method 模式中有以下登场角色。 通过查看 Factory Method 模式的类图，我们可以知道， <strong>父类（框架）这一方的 Creator 角色</strong>和 <strong>Product 角色的关系</strong>与<strong>子类（具体加工）</strong>这一方的 ConcreteCreator 角色和 ConcreteProduct 角色的<strong>关系是平行的</strong>。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34.png" alt="image-20210413023513528"></p>
<ul>
<li><p>Product (产品）</p>
<p>Product角色属于框架这一方， 是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口(API)， 但具体的处理则由子类ConcreteProduct角色决定。 在示例程序中由Product类扮演此角色。</p>
</li>
<li><p>Creator (创建者）</p>
<p>Creator角色属千框架这一方， 它是负责生成 Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。 在示例程序中， 由Factory类扮演此角色。</p>
</li>
<li><p>Creator角色对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的就是， 只要调用Product角色和生成实例的方法（图4-3中的factoryMethod 方法）， 就可以生成Productde的实例。 在示例程序中，createProduct 方法是用于生成实例的方法。 <strong>不用new关键字来生成实例， 而是调用生成实例的专用方法来生成实例， 这样就可以防止父类与其他具体类耦合。</strong></p>
</li>
<li><p>ConcreteProduct (具体的产品）</p>
<p>Concrete Product角色属于具体加工这一方，它决定了具体的产品。 在示例程序中， 由IDCard 类扮演此角色。</p>
</li>
<li><p>ConcreteCreator (具体的创建者）</p>
<p>ConcreteCreator角色属于具体加工这一方， 它负责生成具体的产品。 在示例程序中，由IDCardFactory类扮演此角色。</p>
</li>
</ul>
<h3 id="6-2-6、相关的设计模式"><a href="#6-2-6、相关的设计模式" class="headerlink" title="6.2.6、相关的设计模式"></a>6.2.6、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>Factory Method模式是Template Method的典型应用。在示例程序中， create方法就是模板方法。</p>
</li>
<li><p>Singleton 模式</p>
<p>在多数情况下我们都可以将Singleton模式用于扮演Creator角色（或是ConcreteCreator角色） 的类。这是因为在程序中没有必要存在多个 Creator角色（或是ConcreteCreator角色）的实例。不过在示例程序中， 我们并没有使用Singleton模式。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以将 Composite模式用于Product角色（或是ConcreteProduct角色）。</p>
</li>
<li><p>Iterator 模式</p>
<p>有时， 在Iterator模式中使用iterator方法生成Iterator的实例时会使用Factory Method 模式。</p>
</li>
</ul>
<h3 id="6-3、抽象工厂模式Abstract-Factory"><a href="#6-3、抽象工厂模式Abstract-Factory" class="headerlink" title="6.3、抽象工厂模式Abstract Factory"></a>6.3、抽象工厂模式Abstract Factory</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/79.png" alt="image-20210415032040170"></p>
<h4 id="6-3-1、抽象工厂模式介绍"><a href="#6-3-1、抽象工厂模式介绍" class="headerlink" title="6.3.1、抽象工厂模式介绍"></a>6.3.1、抽象工厂模式介绍</h4><ol>
<li>前面介绍的<strong>工厂方法模式中考虑的是一类产品的生产</strong>，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</li>
<li>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</li>
<li><strong>抽象工厂模式将考虑多等级产品的生产</strong>，将同一个具体工厂所生产的位于<strong>不同等级的一组产品称为一个产品族</strong>.</li>
</ol>
<p>抽象工厂（AbstractFactory）模式的定义：定义了一个 <strong>interface</strong> 用于创建相关或有依赖关系的对象簇，而无需指明具体的类，是一种<strong>为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且<strong>访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</strong>。可以看作：抽象工厂是一个超级工厂，围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。</p>
<p><strong>抽象工厂模式是工厂方法模式的升级版本</strong>，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p>
<p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</p>
<p>将工厂抽象成两层，<strong>AbsFactory(**抽象工厂</strong>)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<h4 id="6-3-2、模式的结构与实现"><a href="#6-3-2、模式的结构与实现" class="headerlink" title="6.3.2、模式的结构与实现"></a>6.3.2、模式的结构与实现</h4><h5 id="6-3-2-1、模式的结构"><a href="#6-3-2-1、模式的结构" class="headerlink" title="6.3.2.1、模式的结构"></a>6.3.2.1、模式的结构</h5><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<h5 id="6-3-2-2、模式的实现类图（具体代码）"><a href="#6-3-2-2、模式的实现类图（具体代码）" class="headerlink" title="6.3.2.2、模式的实现类图（具体代码）"></a>6.3.2.2、模式的实现类图（<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html">具体代码</a>）</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/29.png" alt="image-20210413015123090"></p>
<h4 id="6-3-3、应用实例"><a href="#6-3-3、应用实例" class="headerlink" title="6.3.3、应用实例"></a>6.3.3、应用实例</h4><p>使用抽象工厂模式来完成披萨项目。</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30.png" alt="image-20210413015603989"></p>
<p>代码：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京工厂实现抽象工厂生产披萨（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是工厂子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订购披萨：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	AbsFactory factory;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		setFactory(factory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">		<span class="keyword">this</span>.factory = factory;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			<span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">			pizza = factory.createPizza(orderType);</span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> BJFactory());</span><br><span class="line">		<span class="comment">// new OrderPizza(new LDFactory());</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4、抽象工厂模式的相关说明"><a href="#6-3-4、抽象工厂模式的相关说明" class="headerlink" title="6.3.4、抽象工厂模式的相关说明"></a>6.3.4、抽象工厂模式的相关说明</h4><ul>
<li><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ol>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，<strong>抽象工厂可以保证客户端始终只使用同一个产品的产品组</strong>。</li>
<li>抽象工厂增强了<strong>程序的可扩展性</strong>，当增加一个新的产品族时，不需要修改原代码，<strong>满足开闭原则</strong>。</li>
</ol>
</li>
<li><p>其缺点是：<strong>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度</strong></p>
<p>模式的应用场景</p>
<p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 Java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p>
<ol>
<li>当需要创建的对象是一系列<strong>相互关联或相互依赖的产品族</strong>时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li><strong>系统中有多个产品族，但每次只使用其中的某一族产品</strong>。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li><strong>系统中提供了产品的类库，且所有产品的接口相同</strong>，客户端不依赖产品实例的创建细节和内部结构。</li>
</ol>
</li>
<li><p>模式的扩展</p>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
</li>
<li><p>进阶阅读</p>
<p>如果您想了解抽象工厂在框架源码中的应用，可阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8392.html">《抽象工厂在Java源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8393.html">《抽象工厂模式在Spring源码中的应用》</a></li>
</ul>
</li>
</ul>
<h4 id="6-3-5、相关的设计模式"><a href="#6-3-5、相关的设计模式" class="headerlink" title="6.3.5、相关的设计模式"></a>6.3.5、相关的设计模式</h4><ul>
<li><p>Builder模式</p>
<p>Abstract Factory模式通过调用抽象产品的接口 (APl) 来组装抽象产品， 生成具有复杂结构的实例。</p>
<p>Builder模式则是分阶段地制作复杂实例。</p>
</li>
<li><p>Factory Method模式</p>
<p>有时AbstractFactory模式中零件和产品的生成会使用到Factory Method模式。</p>
</li>
<li><p>Composite模式</p>
<p>有时AbstractFactory模式在制作产品时会使用Composite模式。</p>
</li>
<li><p>Singleton模式</p>
<p>有时AbstractFactory模式中的具体工厂会使用Singleton模式。</p>
</li>
</ul>
<h3 id="6-4、工厂模式在-JDK-Calendar-应用的源码分析"><a href="#6-4、工厂模式在-JDK-Calendar-应用的源码分析" class="headerlink" title="6.4、工厂模式在 JDK-Calendar 应用的源码分析"></a>6.4、工厂模式在 JDK-Calendar 应用的源码分析</h3><p>JDK 中的 Calendar 类中，就使用了<strong>简单工厂模式</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/33.png" alt="image-20210413021425940"></p>
<p>其中createCalendar()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32.png" alt="image-20210413022320157"></p>
<h3 id="6-5、工厂模式小结"><a href="#6-5、工厂模式小结" class="headerlink" title="6.5、工厂模式小结"></a>6.5、工厂模式小结</h3><ol>
<li><p>工厂模式的意义</p>
<p>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p>
</li>
<li><p>三种工厂模式 </p>
<ol>
<li>简单工厂模式（不在23种之中）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
</li>
<li><p>设计模式的<strong>依赖抽象原则</strong></p>
</li>
</ol>
<p>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</p>
<p>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</p>
<p>不要覆盖基类中已经实现的方法。</p>
<h2 id="7、原型模式ProtoType（创建型设计模式）"><a href="#7、原型模式ProtoType（创建型设计模式）" class="headerlink" title="7、原型模式ProtoType（创建型设计模式）"></a>7、原型模式ProtoType（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/77.png" alt="image-20210415031921912"></p>
<h3 id="7-1、基本介绍"><a href="#7-1、基本介绍" class="headerlink" title="7.1、基本介绍"></a>7.1、基本介绍</h3><ol>
<li>原型模式(Prototype 模式)是指：用<strong>原型实例指定创建对象的种类</strong>，并且通过<strong>拷贝</strong>这些原型，创建新的对象</li>
<li>原型模式是一种<strong>创建型设计</strong>模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象<strong>通过请求原型对象拷贝它们自己来实施创建</strong>，即 对象**.clone**()</li>
</ol>
<h3 id="7-2、原型模式原理结构图-uml-类图"><a href="#7-2、原型模式原理结构图-uml-类图" class="headerlink" title="7.2、原型模式原理结构图-uml 类图"></a>7.2、原型模式原理结构图-uml 类图</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.png" alt="image-20210413222550496"></p>
<p>原理结构图说明：</p>
<ul>
<li>Prototype : 原型类，<strong>声明一个克隆自己的接口</strong></li>
<li>ConcretePrototype: 具体的原型类, <strong>实现</strong>一个克隆自己的操作</li>
<li>Client: 使用者；让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li>
</ul>
<h3 id="7-3、应用举例"><a href="#7-3、应用举例" class="headerlink" title="7.3、应用举例"></a>7.3、应用举例</h3><p>克隆羊问题：</p>
<p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊。</p>
<h4 id="7-3-1、传统方式解决克隆羊问题"><a href="#7-3-1、传统方式解决克隆羊问题" class="headerlink" title="7.3.1、传统方式解决克隆羊问题"></a>7.3.1、传统方式解决克隆羊问题</h4><h5 id="7-3-1-1、思路分析-类图"><a href="#7-3-1-1、思路分析-类图" class="headerlink" title="7.3.1.1、思路分析(类图)"></a>7.3.1.1、思路分析(类图)</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.png" alt="image-20210413222817657"></p>
<h5 id="7-3-1-2、相关代码：（在Client中）"><a href="#7-3-1-2、相关代码：（在Client中）" class="headerlink" title="7.3.1.2、相关代码：（在Client中）"></a>7.3.1.2、相关代码：（在Client中）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的方法</span></span><br><span class="line">Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); </span><br></pre></td></tr></table></figure>

<h5 id="7-3-1-3、传统的方式的优缺点"><a href="#7-3-1-3、传统的方式的优缺点" class="headerlink" title="7.3.1.3、传统的方式的优缺点"></a>7.3.1.3、传统的方式的优缺点</h5><ol>
<li>优点是比较好理解，简单易操作。</li>
<li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
</ol>
<h5 id="7-3-1-4、改进方法（使用原型模式）"><a href="#7-3-1-4、改进方法（使用原型模式）" class="headerlink" title="7.3.1.4、改进方法（使用原型模式）"></a>7.3.1.4、改进方法（使用原型模式）</h5><p>Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt;原型模式</p>
<h4 id="7-3-2、原型模式解决克隆羊问题"><a href="#7-3-2、原型模式解决克隆羊问题" class="headerlink" title="7.3.2、原型模式解决克隆羊问题"></a>7.3.2、原型模式解决克隆羊问题</h4><p>实现步骤：</p>
<ol>
<li>实例实现接口Cloneable，并重写Object的clone方法</li>
<li>在Client使用创建的实例的clone方法进行对象的克隆</li>
</ol>
<p>代码实现：</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sheep;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">		sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		<span class="comment">//克隆</span></span><br><span class="line">		Sheep sheep2 = (Sheep)sheep.clone(); </span><br><span class="line">		System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原型模式改进传统方式，让程序具有<strong>更高的效率和扩展性</strong>。</p>
<h3 id="7-4、浅拷贝和深拷贝"><a href="#7-4、浅拷贝和深拷贝" class="headerlink" title="7.4、浅拷贝和深拷贝"></a>7.4、浅拷贝和深拷贝</h3><h4 id="7-4-1、浅拷贝的介绍"><a href="#7-4-1、浅拷贝的介绍" class="headerlink" title="7.4.1、浅拷贝的介绍"></a>7.4.1、浅拷贝的介绍</h4><ol>
<li>对于数据类型是<strong>基本数据类型</strong>的成员变量，<strong>浅拷贝会直接进行值传递</strong>，也就是将该<strong>属性值复制一份给新的对象</strong>。</li>
<li>对于String，虽然String不是基本数据结构，而是应用数据类型。但是在JVM中存在字符串常量池会存储已创建的字符串。在克隆的时候也是引用也是直接指向字符串常量池里的字符串。所以在clone当中可以将String近似于看作基本数据类型。</li>
<li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是<strong>某个数组、某个类的对象</strong>等，那么浅拷贝会进行<strong>引用传递</strong>，也就是只是将<strong>该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为实际上两个对象的该成员变量都<strong>指向同一个实例</strong>。在这种情况下，在<strong>一个对象中修改该成员变量会影响到另一个对象的该成员变量值</strong>。</li>
<li>前面我们克隆羊就是浅拷贝（里面的friend是同一个friend，即所有的克隆羊都有同一个朋友）</li>
<li>浅拷贝是使用默认的 clone()方法来实现：sheep = (Sheep) super.clone();</li>
</ol>
<h4 id="7-4-2、深拷贝基本介绍"><a href="#7-4-2、深拷贝基本介绍" class="headerlink" title="7.4.2、深拷贝基本介绍"></a>7.4.2、深拷贝基本介绍</h4><ol>
<li>复制对象的<strong>所有基本数据类型</strong>的成员变量值</li>
<li>为<strong>所有引用数据类型的成员变量申请存储空间</strong>，并<strong>复制每个引用数据类型成员变量所引用的对象</strong>，直到该对象可达的所有对象。也就是说，对象进行深拷贝要<strong>对整个对象(包括对象的引用类型)进行拷贝</strong></li>
<li>深拷贝实现方式 1：重写 <strong>clone</strong> 方法来实现深拷贝</li>
<li>深拷贝实现方式 2：通过<strong>对象序列化</strong>实现深拷贝(<strong>推荐</strong>)</li>
</ol>
<h4 id="7-4-3、深拷贝应用实例"><a href="#7-4-3、深拷贝应用实例" class="headerlink" title="7.4.3、深拷贝应用实例"></a>7.4.3、深拷贝应用实例</h4><h5 id="7-4-3-1、使用-重写-clone-方法实现深拷贝"><a href="#7-4-3-1、使用-重写-clone-方法实现深拷贝" class="headerlink" title="7.4.3.1、使用 重写 clone 方法实现深拷贝"></a>7.4.3.1、使用 重写 clone 方法实现深拷贝</h5><p>DeepCloneableTarget：其他实例当中的成员变量：实现克隆接口与序列化接口Serializable, Cloneable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String cloneName;</span><br><span class="line">	<span class="keyword">private</span> String cloneClass;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">		<span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//深拷贝 - 方式 1 使用clone 方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Object deep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">		deep = <span class="keyword">super</span>.clone(); </span><br><span class="line">		<span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">		DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line">		<span class="keyword">return</span> deepProtoType;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);	</span><br><span class="line">        <span class="comment">//方式1 完成深拷贝</span></span><br><span class="line">        DeepProtoType p2 = (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-2、使用序列化来实现深拷贝"><a href="#7-4-3-2、使用序列化来实现深拷贝" class="headerlink" title="7.4.3.2、使用序列化来实现深拷贝"></a>7.4.3.2、使用序列化来实现深拷贝</h5><p>DeepCloneableTarget：同上</p>
<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建流对象</span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//序列化</span></span><br><span class="line">			bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">			<span class="comment">//反序列化</span></span><br><span class="line">			bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">			DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">			<span class="keyword">return</span> copyObj;	</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭流</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bos.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				bis.close();</span><br><span class="line">				ois.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">		p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">		p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);</span><br><span class="line">		<span class="comment">//方式2 完成深拷贝</span></span><br><span class="line">		DeepProtoType p2 = (DeepProtoType) p.deepClone();</span><br><span class="line">		System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝："><a href="#7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝：" class="headerlink" title="7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝："></a>7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝：</h5><p>使用序列化可以实现，但是使用clone方法会报StackOverflowError异常</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//实例类的成员变量为本身</span></span><br><span class="line">    <span class="keyword">public</span> Sheep friend;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, friend=&quot;</span> + friend +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝 通过对象的序列化实现 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Sheep copyObj = (Sheep)ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>,<span class="string">&quot;black&quot;</span>);</span><br><span class="line">        sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;john&quot;</span>, <span class="number">2</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.deepClone();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;sheep.name=&quot;</span> + sheep.getName() + <span class="string">&quot; sheep.age=&quot;</span> + sheep.getAge() + <span class="string">&quot; sheep.color=&quot;</span> + sheep.getColor() + <span class="string">&quot; sheep.friend&quot;</span> + sheep.friend.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;sheep1.name=&quot;</span> + sheep1.getName() + <span class="string">&quot; sheep1.age=&quot;</span> + sheep1.getAge() + <span class="string">&quot; sheep1.color=&quot;</span> + sheep1.getColor() + <span class="string">&quot; sheep1.friend&quot;</span> + sheep1.friend.hashCode());</span><br><span class="line">        System.out.println(sheep.friend == sheep1.friend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-4、对于深拷贝的clone方法与序列化方法"><a href="#7-4-4、对于深拷贝的clone方法与序列化方法" class="headerlink" title="7.4.4、对于深拷贝的clone方法与序列化方法"></a>7.4.4、对于深拷贝的clone方法与序列化方法</h4><h5 id="7-4-4-1、clone方法"><a href="#7-4-4-1、clone方法" class="headerlink" title="7.4.4.1、clone方法"></a>7.4.4.1、clone方法</h5><ul>
<li>clone方法分成两步：<ol>
<li>先克隆<strong>基本数据类型和String</strong></li>
<li>在对其<strong>引用数据类型</strong>进行多次克隆</li>
</ol>
</li>
<li>如果想要深拷贝一个对象， 这个对象必须要<strong>实现Cloneable接口，实现clone方法</strong>，并且在<strong>clone方法内部，把该对象引用的其他对象也要clone一份</strong> ， 这就要求这个<strong>被引用的对象必须也要实现Cloneable接口并且实现clone方法。</strong></li>
<li>clone实际上就是实现了<strong>多重clone</strong>，实例本身有其他的应用数据类型（除String），就先重写其他的<strong>引用数据类型</strong>的clone方法；若在其他的应用数据类型（除String）又有其他的引用数据类型，又重复该过程，直到做到所有的成员变量都完成clone。</li>
<li>所以，如果在拷贝一个对象时，要想让<strong>这个拷贝的对象和源对象完全彼此独立</strong>，那么在<strong>引用链上的每一级对象都要被显式的拷贝</strong>。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而<strong>这个对象没有实现clone方法</strong>， 那么在它之后的所有引用的对象都是被共享的。或者如果某一个类<strong>没有实现Cloneable接口</strong>，我们还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中这种深拷贝方式<strong>不常用</strong>。</li>
</ul>
<h5 id="7-4-4-2、序列化方法"><a href="#7-4-4-2、序列化方法" class="headerlink" title="7.4.4.2、序列化方法"></a>7.4.4.2、序列化方法</h5><ul>
<li>序列化方法也分成两步<ol>
<li>将要实现克隆的实例进行序列化</li>
<li>在将其进行反序列化出来实现实例的拷贝</li>
</ol>
</li>
<li>使用该类的<strong>对象必须要实现Serializable接口</strong>，否则是没有办法实现克隆的。无须继承Cloneable接口实现clone()方法。</li>
<li>在内存中通过字节流的拷贝是比较容易实现的。把<strong>母对象写入到一个字节流</strong>中，再<strong>从字节流中将其读出来</strong>，这样就可以<strong>创建一个新的对象</strong>了，并且该<strong>新对象与母对象之间并不存在引用共享</strong>的问题，<strong>真正实现对象的深拷贝</strong>。</li>
<li>能实现<strong>对于实例类的成员变量为本身的实例的深拷贝</strong></li>
<li>缺点：使用该类的<strong>对象必须要实现Serializable接口</strong>，所以在一些类并没有实现Serializable接口，如果还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中<strong>推荐</strong>使用这种方式进行深拷贝。</li>
</ul>
<h3 id="7-5、原型模式在-Spring-框架中源码分析"><a href="#7-5、原型模式在-Spring-框架中源码分析" class="headerlink" title="7.5、原型模式在 Spring 框架中源码分析"></a>7.5、原型模式在 Spring 框架中源码分析</h3><p>Spring 中原型 bean 的创建，就是原型模式的应用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.png" alt="image-20210414025832896"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.png" alt="image-20210414030430256"></p>
<h3 id="7-6、new一个对象的过程和clone一个对象的过程区别"><a href="#7-6、new一个对象的过程和clone一个对象的过程区别" class="headerlink" title="7.6、new一个对象的过程和clone一个对象的过程区别"></a>7.6、new一个对象的过程和clone一个对象的过程区别</h3><p>关于new：</p>
<p>new操作符的本意是<strong>分配内存</strong>。程序执行到new操作符时，会<strong>先去看new操作符后面的类型</strong>，因为知道了类型，才能知道要分配多大的内存空间。<strong>分配</strong>完<strong>内存</strong>之后，<strong>再调用构造函数</strong>，填充对象的各个域，这一步叫做<strong>对象的初始化</strong>，构造方法返回后，一个对象创建完毕，可以<strong>把它的引用</strong>（也就是地址）<strong>发布到外部</strong>，在外部就可以使用这个引用操作这个对象。</p>
<p>关于clone：</p>
<p><strong>clone在第一步</strong>是和new相似的，都是<strong>分配内存</strong>，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后<strong>再使用原对象中对应的各个域，填充新对象的域</strong>，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把<strong>这个新对象的引用发布到外部</strong>。</p>
<blockquote>
<ol>
<li>clone()不会调用构造方法；new会调用构造方法。</li>
<li>new对象时根据类型确定分配内存空间的大小, clone是根据原对象分配内</li>
</ol>
</blockquote>
<h3 id="7-7、原型模式的总结"><a href="#7-7、原型模式的总结" class="headerlink" title="7.7、原型模式的总结"></a>7.7、原型模式的总结</h3><p>原型模式的优点：</p>
<ul>
<li>Java 自带的原型模式基于内存<strong>二进制流的复制</strong>，在<strong>性能上比直接 new 一个对象更加优良</strong>。</li>
<li>它<strong>逃避了构造函数的约束</strong>。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如<strong>恢复到历史某一状态</strong>），可辅助实现<strong>撤销操作</strong>。</li>
</ul>
<p>原型模式的缺点：</p>
<ul>
<li>需要为<strong>每一个类都配置一个 clone 方法</strong></li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，<strong>违背了开闭原则</strong>。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，<strong>每一层对象对应的类都必须支持深克隆</strong>，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<p>原型模式的应用场景：</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</li>
<li>资源优化场景</li>
<li>一个对象多个修改者的场景</li>
<li>想要生成实例的框架不依赖与具体的类，解耦框架与生成的实例</li>
</ul>
<p>在实际项目中，原型模式很少单独出现，一般是<strong>和工厂方法模式一起出现</strong>，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 中，原型模式应用的非常广泛，例如 scope=’prototype’、JSON.parseObject() 等都是原型模式的具体应用。</p>
<h3 id="7-8、原型模式的扩展（带原型管理器的原型模式）"><a href="#7-8、原型模式的扩展（带原型管理器的原型模式）" class="headerlink" title="7.8、原型模式的扩展（带原型管理器的原型模式）"></a>7.8、原型模式的扩展（带原型管理器的原型模式）</h3><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/35.png" alt="image-20210414092155079"></p>
<p>举例：</p>
<p>用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，是其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/36.png" alt="image-20210414092311712"></p>
<p>ProtoTypeManager ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt; ht = <span class="keyword">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>, <span class="keyword">new</span> Circle());</span><br><span class="line">        ht.put(<span class="string">&quot;Square&quot;</span>, <span class="keyword">new</span> Square());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String key, Shape obj)</span> </span>&#123;</span><br><span class="line">        ht.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Shape temp = ht.get(key);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-9、进阶阅读"><a href="#7-9、进阶阅读" class="headerlink" title="7.9、进阶阅读"></a>7.9、进阶阅读</h3><p>原型模式也称为克隆模式，如果您想深入了解原型（克隆）模式，可以猛击阅读下面的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8379.html">《浅克隆和深克隆》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8382.html">《克隆会破坏单例对象吗》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8383.html">《原型模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="7-10、相关的设计模式"><a href="#7-10、相关的设计模式" class="headerlink" title="7.10、相关的设计模式"></a>7.10、相关的设计模式</h3><ul>
<li><p>Flyweight 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。 而使用Flyweight模式可以在不同的地方使用同一个实例。</p>
</li>
<li><p>Memento 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。而使用Memento模式可以保存当前实例的状态， 以实现快照和撤销功能。</p>
</li>
<li><p>Composite 模式以及 Decorator 模式</p>
<p>经常使用Composite模式和Decorator模式时， 需要能够动态地创建复杂结构的实例。 这时可 以使用Prototype模式， 以帮助我们方便地生成实例。</p>
</li>
<li><p>Command 模式</p>
<p>想要复制Command模式中出现的命令时， 可以使用Prototype模式。</p>
</li>
</ul>
<h3 id="7-11、原型模式的注意事项和细节"><a href="#7-11、原型模式的注意事项和细节" class="headerlink" title="7.11、原型模式的注意事项和细节"></a>7.11、原型模式的注意事项和细节</h3><ul>
<li>创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程，同时也能够提高效率</strong></li>
<li>不用<strong>重新初始化对象</strong>，而是<strong>动态地获得对象运行时的状态</strong></li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li>Cloneable接口是一个标记接口，没有声明方法</li>
<li>缺点：需要为<strong>每一个类配备一个克隆方法</strong>，这对全新的类来说不是很难，但<strong>对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。</strong></li>
<li>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</li>
</ul>
<h2 id="8、建造者模式Builder（创建型设计模式）"><a href="#8、建造者模式Builder（创建型设计模式）" class="headerlink" title="8、建造者模式Builder（创建型设计模式）"></a>8、建造者模式Builder（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/78.png" alt="image-20210415031952053"></p>
<h3 id="8-1、基本介绍"><a href="#8-1、基本介绍" class="headerlink" title="8.1、基本介绍"></a>8.1、基本介绍</h3><ol>
<li>建造者模式（<strong>Builder Pattern</strong>） 又叫<strong>生成器模式</strong>，是一种<strong>对象构建模式</strong>。它可以将<strong>复杂对象</strong>的建造过程<strong>抽象出来（抽象类别）</strong>，使这个抽象过程的<strong>不同实现方法可以构造出不同表现（属性）的对象</strong>。</li>
<li>建造者模式将一个复杂对象的<strong>构造</strong>与它的<strong>表示分离</strong>，使<strong>同样的构建过程可以创建不同的表示</strong>。它是将<strong>一个复杂的对象分解为多个简单的对象，然后一步一步构建而成</strong>。它将<strong>变与不变相分离</strong>，即<strong>产品的组成部分</strong>是<strong>不变</strong>的，但<strong>每一部分</strong>是可以<strong>灵活选择</strong>的。</li>
</ol>
<h3 id="8-2、建造者模原理结构图-uml类图与模板实现"><a href="#8-2、建造者模原理结构图-uml类图与模板实现" class="headerlink" title="8.2、建造者模原理结构图-uml类图与模板实现"></a>8.2、建造者模原理结构图-uml类图与模板实现</h3><h4 id="8-2-1、建造者模式的四个角色"><a href="#8-2-1、建造者模式的四个角色" class="headerlink" title="8.2.1、建造者模式的四个角色"></a>8.2.1、建造者模式的四个角色</h4><p>建造者（Builder）模式由<strong>产品</strong>、<strong>抽象建造者</strong>、<strong>具体建造者</strong>、<strong>指挥者</strong>等 4 个要素构成</p>
<ol>
<li>Product（<strong>产品角色</strong>）： 它是包含多个组成部件的复杂对象，由<strong>具体建造者来创建其各个零部件</strong>。</li>
<li>Builder（<strong>抽象建造者</strong>）： 它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回**复杂产品的方法 getResult()**。</li>
<li>ConcreteBuilder（<strong>具体建造者</strong>）： <strong>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</strong></li>
<li>Director（<strong>指挥者</strong>）： 构建一个<strong>使用 Builder 接口的对象</strong>。它主要是用于<strong>创建一个复杂的对象</strong>。它主要有两个作用：<ol>
<li><strong>隔离</strong>了客户与对象的生产过程</li>
<li>负责<strong>控制</strong>产品对象的生产过程</li>
</ol>
</li>
</ol>
<h4 id="8-2-2、建造者模式原理类图"><a href="#8-2-2、建造者模式原理类图" class="headerlink" title="8.2.2、建造者模式原理类图"></a>8.2.2、建造者模式原理类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/37.png" alt="image-20210414182531377"></p>
<h4 id="8-2-3、类图的模板代码实现"><a href="#8-2-3、类图的模板代码实现" class="headerlink" title="8.2.3、类图的模板代码实现"></a>8.2.3、类图的模板代码实现</h4><p>产品角色Product：包含多个组成部件的复杂对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">	<span class="comment">// setters方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象建造者Builder：包含创建产品各个子部件的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者ConcreteBuilder：实现了抽象建造者接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者Director：调用建造者中的方法完成复杂对象的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3、应用举例"><a href="#8-3、应用举例" class="headerlink" title="8.3、应用举例"></a>8.3、应用举例</h3><p>盖房项目需求</p>
<ol>
<li>需要建房子：这一过程为打桩、砌墙、封顶</li>
<li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li>
<li>请编写程序，完成需求.</li>
</ol>
<h4 id="8-3-1、传统方法"><a href="#8-3-1、传统方法" class="headerlink" title="8.3.1、传统方法"></a>8.3.1、传统方法</h4><p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/38.png" alt="image-20210414183731177"></p>
<p>传统方式的问题分析</p>
<ol>
<li>优点是比较好理解，简单易操作。</li>
<li>设计的程序结构，过于简单，<strong>没有设计缓存层对象</strong>，程序的<strong>扩展和维护不好</strong>. 也就是说，这种设计方案，把<strong>产品(**即：房子) 和 **创建产品的过程</strong>(即：建房子流程) <strong>封装在一起，耦合性增强了</strong>。</li>
<li>解决方案：将<strong>产品和产品建造过程解耦</strong>  =&gt; <strong>建造者模式</strong></li>
</ol>
<h4 id="8-3-2、建造者模式解决盖房子问题"><a href="#8-3-2、建造者模式解决盖房子问题" class="headerlink" title="8.3.2、建造者模式解决盖房子问题"></a>8.3.2、建造者模式解决盖房子问题</h4><p>思路分析图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/39.png" alt="image-20210414183956399"></p>
<h3 id="8-4、建造者模式在JDK中的应用与源码分析"><a href="#8-4、建造者模式在JDK中的应用与源码分析" class="headerlink" title="8.4、建造者模式在JDK中的应用与源码分析"></a>8.4、建造者模式在JDK中的应用与源码分析</h3><p>java.lang.StringBuilder 中的建造者模式</p>
<p>代码说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/40.png" alt="image-20210414185001199"></p>
<p>源码中建造者模式角色分析</p>
<ul>
<li>Appendable 接口定义了多个 append 方法(抽象方法), 即 <strong>Appendable 为抽象建造者（builder）</strong>, 定义了<strong>抽象方法</strong></li>
<li>AbstractStringBuilder <strong>实现</strong>了  Appendable <strong>接口方法</strong>，这里的 AbstractStringBuilder 已经是<strong>建造者（ConcreteBuilder）</strong>，只是<strong>不能实例化</strong></li>
<li>StringBuilder 即充当了<strong>指挥者角色（Director）</strong>，同时充当了<strong>具体的建造者（ConcreteBuilder）</strong>，<strong>建造方法的实现是由 AbstractStringBuilder 完成</strong> , 而 StringBuilder <strong>继承了 AbstractStringBuilder</strong>。直接使用了AbstractStringBuilder实现的方法。</li>
</ul>
<h3 id="8-5、建造者模式与工厂模式对区别"><a href="#8-5、建造者模式与工厂模式对区别" class="headerlink" title="8.5、建造者模式与工厂模式对区别"></a>8.5、建造者模式与工厂模式对区别</h3><ul>
<li>抽象工厂模式实现对<strong>产品家族</strong>的创建，一个产品家族是这样的一系列产品：具有<strong>不同分类维度的产品组合</strong>，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。</li>
<li>建造者模式则是要求<strong>按照指定的蓝图建造产品</strong>，它的主要目的是通过<strong>组装零配件而产生一个新产品</strong>。</li>
</ul>
<p>主要区别：</p>
<ul>
<li><strong>建造者模式</strong>更加注重方法的<strong>调用顺序</strong>，<strong>工厂模式</strong>注重<strong>创建对象</strong>。</li>
<li>创建对象的<strong>力度不同</strong>，<strong>建造者模式创建复杂的对象，由各种复杂的部件组成</strong>，<strong>工厂模式创建出来的对象都一样</strong></li>
<li><strong>关注重点不一样</strong>，<strong>工厂模式</strong>只需要把<strong>对象创建出来</strong>就可以了，而<strong>建造者模式</strong>不仅要<strong>创建出对象</strong>，还要知道<strong>对象由哪些部件组成</strong>。</li>
<li><strong>建造者模式</strong>根据建造过程中的<strong>顺序不一样</strong>，最终<strong>对象部件组成也不一样</strong>。</li>
</ul>
<p>建造者模式唯一区别于工厂模式的是<strong>针对复杂对象的创建</strong>。也就是说，如果<strong>创建简单对象</strong>，通常都是使用<strong>工厂模式</strong>进行创建，而如果<strong>创建复杂对象</strong>，就可以考虑使用<strong>建造者模式</strong>。</p>
<p>当需要创建的产品具备<strong>复杂创建过程</strong>时，可以<strong>抽取出共性创建过程</strong>，然后交由<strong>具体实现类自定义创建流程</strong>，使得同样的创建行为可以生产出不同的产品，<strong>分离了创建与表示</strong>，使创建产品的灵活性大大增加。</p>
<h3 id="8-6、建造者模式总结"><a href="#8-6、建造者模式总结" class="headerlink" title="8.6、建造者模式总结"></a>8.6、建造者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>封装性好</strong>，构建和表示分离。</li>
<li><strong>扩展性好</strong>，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于<strong>控制细节风险</strong>。</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>产品的<strong>组成部分必须相同</strong>，这限制了其使用范围。</li>
<li>如果产品的<strong>内部变化复杂</strong>，如果<strong>产品内部发生变化</strong>，则<strong>建造者也要同步修改</strong>，后期<strong>维护成本较大</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ul>
<li><strong>相同的方法</strong>，<strong>不同的执行顺序</strong>，<strong>产生不同的结果</strong>。</li>
<li><strong>多个部件或零件</strong>，都可以<strong>装配到一个对象中</strong>，但是产生的<strong>结果又不相同</strong>。</li>
<li><strong>产品类非常复杂</strong>，或者产品类中<strong>不同的调用顺序产生不同的作用</strong>。</li>
<li><strong>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</strong></li>
</ul>
<h3 id="8-7、进阶阅读"><a href="#8-7、进阶阅读" class="headerlink" title="8.7、进阶阅读"></a>8.7、进阶阅读</h3><p>如果您想了解建造者模式在实际项目中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8404.html">《建造者模式实现链式赋值》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8409.html">《使用静态内部类实现建造者模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8415.html">《使用建造者模式构建动态SQL语句》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8420.html">《建造者模式在框架源码中的应用》</a></li>
</ul>
<h3 id="8-8、相关的设计模式"><a href="#8-8、相关的设计模式" class="headerlink" title="8.8、相关的设计模式"></a>8.8、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<ul>
<li>在 Builder 模式中， Director 角色控制 Builder 角色。</li>
<li>在 Template Method 模式中 ， 父类控制子类。</li>
</ul>
</li>
<li><p>Composite 模式</p>
<p>有些情况下 Builder 模式生成的实例构成了 Composite 模式。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>Builder 模式和 Abstract Factory 模式都用千生成复杂的实例。</p>
</li>
<li><p>Facade 模式</p>
<p>在 Builder 模式中， Director 角色通过组合 Builder 角色中的复杂方法向外部提供可以简单生成 实例的接口 (API) （相当于示例程序中的 construct 方法）。</p>
<p>Facade 模式中的 Facade 角色则是通过组合内部模块向外部提供可以简单调用的接口 (API)。</p>
</li>
</ul>
<h3 id="8-9、建造者模式的注意事项和细节"><a href="#8-9、建造者模式的注意事项和细节" class="headerlink" title="8.9、建造者模式的注意事项和细节"></a>8.9、建造者模式的注意事项和细节</h3><ol>
<li>客户端(使用程序)不必知道产品内部组成的细节，将<strong>产品本身与产品的创建过程解耦</strong>，使得<strong>相同的创建过程可以创建不同的产品对象</strong></li>
<li>每一个<strong>具体建造者都相对独立</strong>，而<strong>与其他的具体建造者无关</strong>，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></li>
<li>可以更加<strong>精细</strong>地控制产品的创建过程 。将<strong>复杂产品的创建步骤分解在不同的方法中</strong>，使得创建过程更加清晰， 也更方便使用程序来<strong>控制创建过程</strong></li>
<li>增加新的具体建造者<strong>无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统<strong>扩展方便</strong>，<strong>符合“开闭原则”</strong></li>
<li>建造者（Builder）模式在应用过程中可以根据需要改变，如果<strong>创建的产品种类只有一种</strong>，只需要<strong>一个具体建造者</strong>，这时可以<strong>省略</strong>掉<strong>抽象建造者</strong>，甚至可以<strong>省略掉指挥者角色</strong>。</li>
<li>建造者模式所创建的产品<strong>一般具有较多的共同点</strong>，其<strong>组成部分相似</strong>，如果<strong>产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li>
<li>如果产品的<strong>内部变化复杂</strong>，可能会导致需要定义<strong>很多具体建造者类来实现这种变化</strong>，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li>
</ol>
<h2 id="9、适配器模式Adapter（结构型模式）"><a href="#9、适配器模式Adapter（结构型模式）" class="headerlink" title="9、适配器模式Adapter（结构型模式）"></a>9、适配器模式Adapter（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/73.PNG" alt="image-20210415031546174"></p>
<h3 id="9-1、基本介绍"><a href="#9-1、基本介绍" class="headerlink" title="9.1、基本介绍"></a>9.1、基本介绍</h3><ol>
<li><p>适配器模式(Adapter Pattern)将<strong>某个类的接口转换成客户端期望的另一个接口表示</strong>，主的目的是<strong>兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为<strong>包装器(Wrapper)</strong></p>
</li>
<li><p>适配器模式属于<strong>结构型模式</strong></p>
</li>
<li><p>主要分为三类</p>
<ol>
<li>类适配器模式</li>
<li>对象适配器模式</li>
<li>接口适配器模式</li>
</ol>
</li>
<li><p>工作原理</p>
<p>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p>
<ol>
<li><p>从用户的角度看不到被适配者，是解耦的</p>
</li>
<li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p>
</li>
<li><p>用户收到反馈结果，感觉只是和目标接口交互，如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/41.png" alt="image-20210414214311154"></p>
</li>
</ol>
</li>
</ol>
<h3 id="9-2、适配器模式原理结构图-uml类图"><a href="#9-2、适配器模式原理结构图-uml类图" class="headerlink" title="9.2、适配器模式原理结构图-uml类图"></a>9.2、适配器模式原理结构图-uml类图</h3><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li><strong>目标</strong>（Target）接口：当前系统业务<strong>所期待的接口</strong>，它可以是<strong>抽象类或接口</strong>。</li>
<li><strong>被适配者</strong>（Adaptee\src）类：它是<strong>被访问和适配</strong>的现存组件库中的<strong>组件接口</strong>。</li>
<li><strong>适配器</strong>（Adapter）类：它是一个<strong>转换器</strong>，通过<strong>继承(类适配器)或引用(对象适配器)适配者的对象</strong>，把<strong>适配者接口转换成目标接口</strong>，让客户按目标接口的格式访问适配者。</li>
</ol>
<h4 id="9-2-1、类适配器模式"><a href="#9-2-1、类适配器模式" class="headerlink" title="9.2.1、类适配器模式"></a>9.2.1、类适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42.png" alt="image-20210414215313478"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2、对象适配器模式"><a href="#9-2-2、对象适配器模式" class="headerlink" title="9.2.2、对象适配器模式"></a>9.2.2、对象适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/43.png" alt="image-20210414215540735"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3、接口适配器模式"><a href="#9-2-3、接口适配器模式" class="headerlink" title="9.2.3、接口适配器模式"></a>9.2.3、接口适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44.png" alt="image-20210414215753292"></p>
<p>代码：</p>
<p>Interface4（适配者（Adaptee）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbsAdapter（适配器（Adapter）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="comment">//默认实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client（）：只需要去覆盖我们 需要使用 接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">			<span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		absAdapter.m1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3、三种适配器模式的基本介绍"><a href="#9-3、三种适配器模式的基本介绍" class="headerlink" title="9.3、三种适配器模式的基本介绍"></a>9.3、三种适配器模式的基本介绍</h3><h4 id="9-3-1、类适配器模式"><a href="#9-3-1、类适配器模式" class="headerlink" title="9.3.1、类适配器模式"></a>9.3.1、类适配器模式</h4><p>实现步骤：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</p>
<p>类适配器模式注意事项和细节：</p>
<ol>
<li>由于其<strong>继承了 src 类</strong>，所以它可以<strong>根据需求重写 src 类的方法</strong>，使得 Adapter 的灵活性增强了。</li>
<li>Java 是<strong>单继承机制</strong>，所以类适配器需要<strong>继承 src 类这一点算是一个缺点</strong>, 因为这<strong>要求 dst 必须是接口</strong>，有一定局限性。</li>
<li>由于Adapter继承了src类，所以不可避免的会去重写src的方法。在一定程度上<strong>违反了里氏原则</strong>与<strong>合成复用原则</strong>。</li>
<li><strong>src 类的方法在 Adapter 中都会暴露出来</strong>，也<strong>增加了使用的成本</strong>。</li>
</ol>
<h4 id="9-3-2、对象适配器模式"><a href="#9-3-2、对象适配器模式" class="headerlink" title="9.3.2、对象适配器模式"></a>9.3.2、对象适配器模式</h4><p>对象适配器模式介绍</p>
<ol>
<li>基本思路和类的适配器模式相同，只是将 <strong>Adapter 类</strong>作修改，<strong>不是继承 src 类</strong>，而是<strong>持有 src 类的实例（依赖），</strong>以解决兼容性的问题**。 </li>
<li>实现步骤：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li>
<li>根据“<strong>合成复用原则</strong>”，在系统中尽量<strong>使用关联关系（聚合）来替代继承</strong>关系。</li>
<li>对象适配器模式是适配器模式<strong>常用</strong>的一种</li>
</ol>
<p>对象适配器模式注意事项和细节 </p>
<ol>
<li>对象适配器和类适配器其实算是<strong>同一种思想</strong>，只不过<strong>实现方式不同</strong>。</li>
<li>根据<strong>合成复用原则</strong>，使用<strong>聚合替代继承</strong>， 所以它解决了<strong>类适配器必须继承 src 的局限性问题</strong>，也<strong>不再要求 dst必须是接口</strong>。</li>
<li>使用<strong>成本更低，更灵活</strong>。</li>
</ol>
<h4 id="9-3-3、接口适配器模式"><a href="#9-3-3、接口适配器模式" class="headerlink" title="9.3.3、接口适配器模式"></a>9.3.3、接口适配器模式</h4><p>接口适配器模式介绍 </p>
<ol>
<li>一些书籍称为：<strong>适配器模式(Default Adapter Pattern)**或</strong>缺省适配器模式**。</li>
<li>核心思路：当<strong>不需要全部实现接口</strong>提供的方法时，可先<strong>设计一个抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现（空方法）</strong>，那么<strong>该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</strong></li>
<li>适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</li>
</ol>
<p>接口适配器模式注意事项和细节 </p>
<ol>
<li>在<strong>JDK8</strong>开始，<strong>接口就可以默认实现</strong>了，所以这个可以不要抽象类，全部弄个默认实现就好。</li>
<li>然后定义接口的实现类可有选择地覆盖接口的默认方法来实现需求</li>
</ol>
<h3 id="9-4、应用举例"><a href="#9-4、应用举例" class="headerlink" title="9.4、应用举例"></a>9.4、应用举例</h3><p>需求：</p>
<p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电。</p>
<h4 id="9-4-1、使用类适配器模式实现"><a href="#9-4-1、使用类适配器模式实现" class="headerlink" title="9.4.1、使用类适配器模式实现"></a>9.4.1、使用类适配器模式实现</h4><p>思路分析(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/45.png" alt="image-20210414222333677"></p>
<p>代码实现</p>
<p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">	<span class="comment">//输出220V的电压</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> src;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IVoltage5V：<strong>目标</strong>（Target）接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//获取到220V电压</span></span><br><span class="line">		<span class="keyword">int</span> srcV = output220V();</span><br><span class="line">		<span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">		<span class="keyword">return</span> dstV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//充电</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-2、使用对象适配器模式实现"><a href="#9-4-2、使用对象适配器模式实现" class="headerlink" title="9.4.2、使用对象适配器模式实现"></a>9.4.2、使用对象适配器模式实现</h4><p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类：同上</p>
<p>IVoltage5V：<strong>目标</strong>（Target）接口：同上</p>
<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line">	<span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">			<span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">			System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">			dst = src / <span class="number">44</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> dst;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：同上</p>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-3、接口适配器模式应用实例"><a href="#9-4-3、接口适配器模式应用实例" class="headerlink" title="9.4.3、接口适配器模式应用实例"></a>9.4.3、接口适配器模式应用实例</h4><ul>
<li><p>Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener)方法添加监听器， 那么常规写法如下：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46.png" alt="image-20210414224410293"></p>
</li>
<li><p>有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/47.png" alt="image-20210414224454278"></p>
</li>
<li><p>AnimatorListenerAdapter 类，就是一个接口适配器，代码如下图:它空实现了Animator.AnimatorListener 类(src)的所有方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48.png" alt="image-20210414224618055"></p>
</li>
<li><p>AnimatorListener 是一个接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/49.png" alt="image-20210414224645907"></p>
</li>
<li><p>程序里的匿名内部类就是 Listener 具体实现类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210414224710829.png" alt="image-20210414224710829"></p>
</li>
</ul>
<h3 id="9-5、适配器模式在Spring-MVC的应用与源码分析"><a href="#9-5、适配器模式在Spring-MVC的应用与源码分析" class="headerlink" title="9.5、适配器模式在Spring MVC的应用与源码分析"></a>9.5、适配器模式在Spring MVC的应用与源码分析</h3><ul>
<li><p>SpringMvc 中的 <strong>HandlerAdapter,</strong> 就使用了适配器模式</p>
</li>
<li><p>SpringMVC 处理请求的流程回顾</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53.png" alt="image-20210414234012692"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/54.png" alt="image-20210414234049194"></p>
</li>
<li><p>使用 HandlerAdapter 的原因分析：</p>
<p>可以看到<strong>处理器的类型不同</strong>，有<strong>多重实现方式</strong>，那么<strong>调用方式就不是确定的</strong>，如果需要直接调用 Controller 方法，需要调用的时候就得<strong>不断是使用 if else 来进行判断是哪一种子类然后执行</strong>。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 <strong>OCP 原则</strong>。</p>
</li>
<li><p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/55.png" alt="image-20210415002836481"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/56.png" alt="image-20210415002913253"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/57.png" alt="image-20210415002940414"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/58.png" alt="image-20210415003150913"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/59.png" alt="image-20210415003221357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/60.png" alt="image-20210415003242857"></p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61.png" alt="image-20210415003342721"></p>
<p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/62.png" alt="image-20210415010612924"></p>
<p>动手写 SpringMVC 通过适配器设计模式获取到对应的 Controller 的源码：</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/50.png" alt="image-20210414225130202"></p>
<p>实现代码：</p>
<p>HandlerAdapter：一个Adapter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Adapter接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多种适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((SimpleController) handler).doSimplerHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((HttpController) handler).doHttpHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((AnnotationController) handler).doAnnotationHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多种Controller实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;http...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;simple...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;annotation...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span></span><br><span class="line">		<span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">		 HttpController controller = <span class="keyword">new</span> HttpController();</span><br><span class="line">		<span class="comment">// AnnotationController controller = new AnnotationController();</span></span><br><span class="line">		<span class="comment">//SimpleController controller = new SimpleController();</span></span><br><span class="line">		<span class="comment">// 得到对应适配器</span></span><br><span class="line">		HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">		<span class="comment">// 通过适配器执行对应的controller对应方法</span></span><br><span class="line">		adapter.handle(controller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span></span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adapter.supports(controller)) &#123;</span><br><span class="line">				<span class="keyword">return</span> adapter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关补充：</p>
<ul>
<li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</li>
<li>适配器代替Controller执行相应的方法</li>
<li>扩展Controller时（即添加一个OtherController），只需要增加一个适配器类就完成了SpringMVC的扩展了（满足OCP原则）</li>
</ul>
<h3 id="9-6、适配器模式总结"><a href="#9-6、适配器模式总结" class="headerlink" title="9.6、适配器模式总结"></a>9.6、适配器模式总结</h3><p>主要优点如下：</p>
<ul>
<li>客户端通过适配器可以<strong>透明地调用目标接口</strong>。</li>
<li><strong>复用了现存的类</strong>，程序员<strong>不需要修改原有代码</strong>而重用现有的适配者类。</li>
<li>将<strong>目标类和适配者类解耦</strong>，<strong>解决</strong>了目标类和适配者类<strong>接口不一致</strong>的问题。</li>
<li>在很多业务场景中<strong>符合开闭原则</strong>。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会<strong>增加系统的复杂性</strong>。</li>
<li>增加代码阅读难度，<strong>降低代码可读性</strong>，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<p>模式的应用场景：</p>
<ul>
<li>以前开发的系统<strong>存在满足新系统功能需求的类</strong>，但<strong>其接口同新系统的接口不一致</strong>。</li>
<li>使用<strong>第三方提供的组件</strong>，但<strong>组件接口定义和自己要求的接口定义不同</strong>。</li>
</ul>
<h3 id="9-7、适配器模式的扩展"><a href="#9-7、适配器模式的扩展" class="headerlink" title="9.7、适配器模式的扩展"></a>9.7、适配器模式的扩展</h3><p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51.png" alt="image-20210414225959454"></p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;目标代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapteeRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双向适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapter</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span>,<span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TwoWayTarget target;</span><br><span class="line">    <span class="keyword">private</span> TwoWayAdaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayTarget target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayAdaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标通过双向适配器访问适配者：&quot;</span>);</span><br><span class="line">        TwoWayAdaptee adaptee = <span class="keyword">new</span> AdapteeRealize();</span><br><span class="line">        TwoWayTarget targe = <span class="keyword">new</span> TwoWayAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者通过双向适配器访问目标：&quot;</span>);</span><br><span class="line">        target = <span class="keyword">new</span> TargetRealize();</span><br><span class="line">        adaptee = <span class="keyword">new</span> TwoWayAdapter(target);</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8、进阶阅读"><a href="#9-8、进阶阅读" class="headerlink" title="9.8、进阶阅读"></a>9.8、进阶阅读</h3><p>如果您想了解适配器模式在实际中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8439.html">《使用类适配器重构第三方登录自由适配》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8447.html">《适配器模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="9-9、相关的设计模式"><a href="#9-9、相关的设计模式" class="headerlink" title="9.9、相关的设计模式"></a>9.9、相关的设计模式</h3><ul>
<li><p>Bridge模式</p>
<p>Adapter模式用千连接接口(API)不同的类，而Bridge模式则用于连接类的功能层次结构与实现层次结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Adapter 模式用于填补不同接口 (API) 之间的缝隙，而 Decorator 模式则是在不改变接口 (API)的前提下增加功能。</p>
</li>
</ul>
<h3 id="9-10、适配器模式的注意事项和细节"><a href="#9-10、适配器模式的注意事项和细节" class="headerlink" title="9.10、适配器模式的注意事项和细节"></a>9.10、适配器模式的注意事项和细节</h3><ol>
<li>三种命名方式，是<strong>根据 src 是以怎样的形式给到 Adapter</strong>（在 Adapter 里的形式）来命名的。</li>
<li>类适配器：以<strong>类</strong>给到，在 Adapter 里，就是将 src 当做<strong>类</strong>，<strong>继承</strong></li>
<li>对象适配器：以<strong>对象</strong>给到，在 Adapter 里，将 src 作为一个<strong>对象</strong>，持有接口适配器：以<strong>接口给到</strong>，在 Adapter 里，将 src 作为一个<strong>接口</strong>，<strong>实现</strong></li>
<li>Adapter 模式最大的作用还是<strong>将原本不兼容的接口融合在一起工作</strong>。</li>
<li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li>
</ol>
<h2 id="10、桥接模式Bridge（结构型模式）"><a href="#10、桥接模式Bridge（结构型模式）" class="headerlink" title="10、桥接模式Bridge（结构型模式）"></a>10、桥接模式Bridge（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/80.png" alt="image-20210415032242015"></p>
<h3 id="10-1、基本介绍"><a href="#10-1、基本介绍" class="headerlink" title="10.1、基本介绍"></a>10.1、基本介绍</h3><ol>
<li>桥接模式(Bridge 模式)是指：将<strong>实现与抽象放在两个不同的类层次</strong>中，使<strong>两个层次可以独立改变</strong>。</li>
<li>是一种结构型设计模式</li>
<li>Bridge 模式<strong>基于类的最小设计原则</strong>，通过使用<strong>封装</strong>、<strong>聚合</strong>及<strong>继承</strong>等行为<strong>让不同的类承担不同的职责</strong>。它的主要特点是<strong>把抽象(Abstraction)与行为实现(Implementation)分离开来</strong>，从而可以保持各部分的独立性以及应对他们的功能扩展</li>
<li>它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</li>
<li>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
</ol>
<h3 id="10-2、桥接模式原结构图-uml类图"><a href="#10-2、桥接模式原结构图-uml类图" class="headerlink" title="10.2、桥接模式原结构图-uml类图"></a>10.2、桥接模式原结构图-uml类图</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="10-2-1、-模式的结构"><a href="#10-2-1、-模式的结构" class="headerlink" title="10.2.1、 模式的结构"></a>10.2.1、 模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li><strong>抽象化（Abstraction）</strong>角色：定义抽象类，并<strong>包含一个对实现化对象的引用</strong>。</li>
<li><strong>扩展抽象化（Refined Abstraction）</strong>角色：是<strong>抽象化角色的子类</strong>，<strong>实现父类中的业务方法</strong>，并通过<strong>组合关系调用实现化角色中的业务方法</strong>。</li>
<li><strong>实现化（Implementor）</strong>角色：定义<strong>实现化角色的接口</strong>，供<strong>扩展抽象化角色调用</strong>。</li>
<li><strong>具体实现化（Concrete Implementor）</strong>角色：给出<strong>实现化角色接口的具体实现</strong>。</li>
</ol>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63.png" alt="image-20210415020129290"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3、应用举例"><a href="#10-3、应用举例" class="headerlink" title="10.3、应用举例"></a>10.3、应用举例</h3><p>手机操作问题：</p>
<p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/64.png" alt="image-20210415020831299"></p>
<h4 id="10-3-1、使用传统方式"><a href="#10-3-1、使用传统方式" class="headerlink" title="10.3.1、使用传统方式"></a>10.3.1、使用传统方式</h4><p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65.png" alt="image-20210415021009808"></p>
<p>传统方案解决手机操作问题分析</p>
<ol>
<li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li>
<li><strong>违反了单一职责原则</strong>，当我们增加手机样式时，要同时增加所有品牌的手机，这样<strong>增加了代码维护成本</strong>.</li>
<li>解决方案-使用桥接模式</li>
</ol>
<h4 id="10-3-2、使用桥接模式"><a href="#10-3-2、使用桥接模式" class="headerlink" title="10.3.2、使用桥接模式"></a>10.3.2、使用桥接模式</h4><p>对应的类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/66.png" alt="image-20210415021509975"></p>
<p>对于类图的相关解析：</p>
<ol>
<li>在FoldedPhone调用的open()方法其实调用了其父类Phone的open()方法</li>
<li>然而在Phone当中是通过聚合了Brand接口拿到了open()方法</li>
<li>而Vivo类才是真正实现Brank接口open()方法的实现类</li>
<li>所以FoldedPhone调用的open()方法最终是调用了Vivo的open()方法</li>
<li>而Phone在这其中起到了一个桥接的作用</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68.png" alt="image-20210415024111311"></p>
<p>代码实现：</p>
<p>Brand：实现化（Implementor）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phone：抽象化（Abstraction）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//组合品牌</span></span><br><span class="line">	<span class="keyword">private</span> Brand brand;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.brand.open();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.call();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FoldedPhone：扩展抽象化（Refined Abstraction）（UpRightPhone类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(brand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.open();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.close();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.call();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vivo：具体实现化（Concrete Implementor）（XiaoMi类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机开机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机关机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//获取折叠式手机 (样式 + 品牌 )</span></span><br><span class="line">		Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">		phone1.open();</span><br><span class="line">		phone1.call();</span><br><span class="line">		phone1.close();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Phone phone2 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">		phone2.open();</span><br><span class="line">		phone2.call();</span><br><span class="line">		phone2.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4、桥接模式在JDBC的应用与源码分析"><a href="#10-4、桥接模式在JDBC的应用与源码分析" class="headerlink" title="10.4、桥接模式在JDBC的应用与源码分析"></a>10.4、桥接模式在JDBC的应用与源码分析</h3><p>JDBC的 <strong>Driver</strong> 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的Driver，这些就可以当做实现接口类</p>
<p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/71.png" alt="image-20210415030654222"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/72.png" alt="image-20210415031227696"></p>
<h3 id="10-5、桥接模式总结"><a href="#10-5、桥接模式总结" class="headerlink" title="10.5、桥接模式总结"></a>10.5、桥接模式总结</h3><p>桥接模式遵循了<strong>里氏替换原则</strong>和<strong>依赖倒置原则</strong>，<strong>最终实现了开闭原则</strong>，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>优点：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点：</p>
<p>由于聚合关系建立在<strong>抽象层</strong>，要求开发者针对抽象化进行设计与编程，能<strong>正确地识别出系统中两个独立变化的维度</strong>，这增加了系统的理解与设计难度。</p>
<p>桥接模式的应用场景：</p>
<p>当<strong>一个类内部具备两种或多种变化维度</strong>时，使用桥接模式可以<strong>解耦这些变化的维度</strong>，使高层代码架构稳定。</p>
<p>桥接模式通常适用于以下场景：</p>
<ol>
<li>当<strong>一个类存在两个独立变化的维度</strong>，且这<strong>两个维度都需要进行扩展</strong>时。</li>
<li>当一个系统<strong>不希望使用继承</strong>或因为<strong>多层次继承导致系统类的个数急剧增加</strong>时。</li>
<li>当一个系统<strong>需要在构件的抽象化角色</strong>和<strong>具体化角色之间增加更多的灵活性</strong>时。</li>
</ol>
<p>桥接模式的一个常见使用场景就是<strong>替换继承</strong>。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。因为父类拥有的方法，子类也会继承得到，<strong>无论子类需不需要</strong>，这说明<strong>继承具备强侵入性（父类代码侵入子类）</strong>，同时会导致<strong>子类臃肿</strong>。因此，在设计模式中，<strong>有一个原则为优先使用组合/聚合，而不是继承（合成复用原则）</strong>。</p>
<p>在实际系统开发时常见的应用场景：</p>
<ul>
<li><p>JDBC 驱动程序</p>
</li>
<li><p>银行转账系统转账分类: </p>
<p>网上转账，柜台转账，AMT 转账    （抽象层）</p>
<p>转账用户类型：普通用户，银卡用户，金卡用户..    (实现层)</p>
</li>
<li><p>消息管理</p>
<p>消息类型：即时消息，延时消息    （抽象层）</p>
<p>消息分类：手机短信，邮件消息，QQ 消息…    (实现层)</p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/69.png" alt="image-20210415025038485"></p>
<p>很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。</p>
<h3 id="10-6、桥接模式的扩展"><a href="#10-6、桥接模式的扩展" class="headerlink" title="10.6、桥接模式的扩展"></a>10.6、桥接模式的扩展</h3><p>在软件开发中，有时<strong>桥接（Bridge）模式可与适配器模式联合使用</strong>。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/70.png" alt="image-20210415025940379"></p>
<h3 id="10-7、进阶阅读"><a href="#10-7、进阶阅读" class="headerlink" title="10.7、进阶阅读"></a>10.7、进阶阅读</h3><p>如果您想深入了解桥接模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8458.html">《使用桥接模式设计复杂消息系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8460.html">《桥接模式在JDBC源码中的应用》</a></li>
</ul>
<h3 id="10-8、相关设计模式"><a href="#10-8、相关设计模式" class="headerlink" title="10.8、相关设计模式"></a>10.8、相关设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>在 Template Method 模式中使用了 ＂类的实现层次结构＂。父类调用抽象方法， 而子类实现抽象方法。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>为了能够根据需求设计出良好的 ConcreteImplementor 角色， 有时我们会使用Abstract Factory 模式。</p>
</li>
<li><p>Adapter 模式</p>
<p>使用 Bridge 模式可以达到类的功能层次结构与类的实现层次结构分离的目的， 并在此基础上使这些层次结构结合起来。</p>
<p>而使用Adapter 模式则可以结合那些功能上相似但是接口 (API) 不同的类。</p>
</li>
</ul>
<h3 id="10-9、桥接模式的注意事项和细节"><a href="#10-9、桥接模式的注意事项和细节" class="headerlink" title="10.9、桥接模式的注意事项和细节"></a>10.9、桥接模式的注意事项和细节</h3><ol>
<li>实现了<strong>抽象和实现部分的分离</strong>，从而极大的<strong>提升了系统的灵活性</strong>，让抽象部分和实现部分独立开来，这有助于<strong>系统进行分层设计</strong>，从而产生更好的<strong>结构化系统</strong>。</li>
<li>对于<strong>系统的高层部分</strong>，只需要知道<strong>抽象部分和实现部分的接口</strong>就可以了，<strong>其它的部分由具体业务</strong>来完成。</li>
<li>桥接模式<strong>替代多层继承方案</strong>，可以减少子类的个数，降低系统的管理和维护成本</li>
<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者**针对抽象进行设计和编程桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性。</li>
</ol>
<h2 id="11、装饰者模式Decorator（结构型模式）"><a href="#11、装饰者模式Decorator（结构型模式）" class="headerlink" title="11、装饰者模式Decorator（结构型模式）"></a>11、装饰者模式Decorator（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/81.png" alt="image-20210415032321784"></p>
<h3 id="11-1、基本介绍"><a href="#11-1、基本介绍" class="headerlink" title="11.1、基本介绍"></a>11.1、基本介绍</h3><ol>
<li>装饰者模式：在不改变现有对象结构的情况下，<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也**体现了开闭原则(ocp)**。</li>
<li>它属于对象结构型模式</li>
</ol>
<h3 id="11-2、装饰者模式原理结构图-uml类图"><a href="#11-2、装饰者模式原理结构图-uml类图" class="headerlink" title="11.2、装饰者模式原理结构图-uml类图"></a>11.2、装饰者模式原理结构图-uml类图</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但<strong>继承具有静态特征，耦合度高</strong>，并且随着扩展功能的增多，<strong>子类会很膨胀（类爆炸）</strong>。如果<strong>使用<code>组合关系</code>来创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。装饰者模式就像打包一个快递。</p>
<p>下面来分析其基本结构和实现方法。</p>
<h4 id="11-2-1、模式的结构"><a href="#11-2-1、模式的结构" class="headerlink" title="11.2.1、模式的结构"></a>11.2.1、模式的结构</h4><p>装饰器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象构件（Component）</strong>角色：定义一个<strong>抽象接口以规范准备接收附加责任的对象</strong>。（被装饰者）</li>
<li><strong>具体构件（ConcreteComponent）</strong>角色：<strong>实现抽象构件</strong>，通过装饰角色为其添加一些职责。</li>
<li><strong>抽象装饰（Decorator）</strong>角色：<strong>继承抽象构件</strong>，并<strong>包含具体构件的实例（组合）</strong>，可以通过其子类扩展具体构件的功能。（装饰者）</li>
<li><strong>具体装饰（ConcreteDecorator）</strong>角色：<strong>实现抽象装饰的相关方法</strong>，并<strong>给具体构件对象添加附加的责任</strong>。</li>
<li>（可选）缓冲角色：如果有太多的具体构建角色，可以在<strong>具体构件（ConcreteComponent）</strong>角色与<strong>抽象构件（Component）</strong>角色建立一个缓冲角色。抽取<strong>具体构件（ConcreteComponent）</strong>角色的公共部分，对其进行进一步的抽象。</li>
</ol>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/82.png" alt="image-20210415105021790"></p>
<h4 id="11-2-2、实现代码"><a href="#11-2-2、实现代码" class="headerlink" title="11.2.2、实现代码"></a>11.2.2、实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3、应用举例"><a href="#11-3、应用举例" class="headerlink" title="11.3、应用举例"></a>11.3、应用举例</h3><p>星巴克咖啡订单项目（咖啡馆）：</p>
<ol>
<li>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li>
<li>调料：Milk、Soy(豆浆)、Chocolate</li>
<li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li>
<li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li>
</ol>
<h4 id="11-3-1、使用方案1（较差）解决需求"><a href="#11-3-1、使用方案1（较差）解决需求" class="headerlink" title="11.3.1、使用方案1（较差）解决需求"></a>11.3.1、使用方案1（较差）解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/83.png" alt="image-20210415110413076"></p>
<p>方案 1-解决星巴克咖啡订单实现与问题分析</p>
<ol>
<li>Drink 是一个抽象类，表示饮料</li>
<li>des 就是对咖啡的描述, 比如咖啡的名字</li>
<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li>
<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li>
<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>
<li>问题：这样设计，<strong>会有很多类</strong>，当我们<strong>增加</strong>一个单品咖啡，或者一个新的调料，<strong>类的数量就会倍增</strong>，就会出现<strong>类爆炸</strong></li>
</ol>
<h4 id="11-3-2、使用方案2（较好）解决需求"><a href="#11-3-2、使用方案2（较好）解决需求" class="headerlink" title="11.3.2、使用方案2（较好）解决需求"></a>11.3.2、使用方案2（较好）解决需求</h4><p>思路分析（类图）：</p>
<p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进：</p>
<ol>
<li>将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性</li>
<li>说明: milk,soy,chocolate 可以设计为 Boolean,表示是否要添加相应的调料.</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/84.png" alt="image-20210415110911652"></p>
<p>方案 2-解决星巴克咖啡订单问题分析</p>
<ol>
<li>方案 2 将调料放在了Drink当中，把它作为<strong>成员变量</strong>。它可以<strong>控制类的数量</strong>，不至于造成很多的类。</li>
<li>在<strong>增加或者删除调料种类</strong>时，代码的维护量很大</li>
<li>考虑到用户可以<strong>添加多份调料</strong>时，可以将hasMilk返回一个对应<strong>int</strong></li>
<li>考虑使用 装饰者 模式</li>
</ol>
<h4 id="11-3-3、使用装饰者模式解决需求"><a href="#11-3-3、使用装饰者模式解决需求" class="headerlink" title="11.3.3、使用装饰者模式解决需求"></a>11.3.3、使用装饰者模式解决需求</h4><p>说明：</p>
<ul>
<li>Drink 类就是前面说的抽象类，Component</li>
<li>ShortBlack 就单品咖啡</li>
<li>Decorator 是一个装饰类，含有一个被装饰的对象(Drink obj)</li>
<li>Decorator 的cost 方法进行一个费用的叠加计算，递归的计算价格</li>
<li>Coffee类就是具体构件（ConcreteComponent）角色与抽象构件（Component）角色之间的缓冲角色，将ShortBlack等等各种咖啡抽象成一个Coffee类</li>
</ul>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85.png" alt="image-20210415111510913"></p>
<p>装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack的CoffeeBar(Client)实现思路：</p>
<ul>
<li>Milk包含了LongBlack</li>
<li>一份Chocolate包含了(Milk+LongBlack)</li>
<li>一份Chocolate包含了(Chocolate+Milk+LongBlack)</li>
<li>这样不管是什么形式的单品咖啡+调料组合，通过<strong>递归方式</strong>可以方便的组合和维护。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/86.png" alt="image-20210415112049116"></p>
<p>实现代码：</p>
<p>Drink：饮料抽象类。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算费用的抽象方法</span></span><br><span class="line">	<span class="comment">//子类来实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Coffee：咖啡类。（可选）缓冲角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShortBlack：具体咖啡对象。<strong>具体构件（ConcreteComponent）</strong>角色（其他具体咖啡类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setDes(<span class="string">&quot; shortblack &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">4.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator：调料装饰者。<strong>抽象装饰（Decorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Drink obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123; <span class="comment">//组合</span></span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// getPrice 自己价格</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// super.des/super.getPrice()：输出装饰者的描述信息与价格</span></span><br><span class="line">		<span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.des + <span class="string">&quot; &quot;</span> + <span class="keyword">super</span>.getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Milk：牛奶。<strong>具体装饰（ConcreteDecorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(obj);</span><br><span class="line">		setDes(<span class="string">&quot; 牛奶 &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">2.0f</span>); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeBar：星巴克。调用2 份巧克力+一份牛奶的 LongBlack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line">		<span class="comment">// 1. 点一份 LongBlack</span></span><br><span class="line">		Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">		System.out.println(<span class="string">&quot;费用1=&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;描述=&quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">		order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 4. order 再加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4、装饰者模式在IO结构的应用与源码"><a href="#11-4、装饰者模式在IO结构的应用与源码" class="headerlink" title="11.4、装饰者模式在IO结构的应用与源码"></a>11.4、装饰者模式在IO结构的应用与源码</h3><p>Java 的 IO 结构，FilterInputStream 就是一个装饰者</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/89.png" alt="image-20210415131821549"></p>
<p>源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/90.png" alt="image-20210415132235381"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/91.png" alt="image-20210415132326718"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/92.png" alt="image-20210415132344822"></p>
<p>对源码的解析：</p>
<ol>
<li>InputStream 是抽象类, 类似我们前面讲的 Drink</li>
<li>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</li>
<li>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</li>
<li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li>
<li>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</li>
<li>分析得出在jdk 的io体系中，就是使用装饰者模式</li>
</ol>
<h3 id="11-5、装饰者模式总结"><a href="#11-5、装饰者模式总结" class="headerlink" title="11.5、装饰者模式总结"></a>11.5、装饰者模式总结</h3><p>主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在<strong>不改变原有对象的情况下</strong>，<strong>动态的给一个对象扩展功能</strong>，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式<strong>完全遵守开闭原则</strong></li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，<strong>装饰模式是继承的一个替代模式</strong>，装饰模式可以动态扩展一个实现类的功能。</li>
</ul>
<p>主要缺点：</p>
<ul>
<li>装饰器模式会增加许多子类，过度使用会<strong>增加程序得复杂性</strong>。</li>
</ul>
<p>装饰者模式的应用场景：</p>
<ul>
<li>当需要给一个<strong>现有类添加附加职责</strong>，而又<strong>不能采用生成子类的方法</strong>进行扩充时。例如，<strong>该类被隐藏</strong>或者<strong>该类是终极类</strong>或者<strong>采用继承方式会产生大量的子类</strong>。</li>
<li>当需要通过对<strong>现有的一组基本功能进行排列组合而产生非常多的功能</strong>时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>
<li>当对象的<strong>功能</strong>要求可以<strong>动态地添加</strong>，也可以再<strong>动态地撤销</strong>时。（可插拔）</li>
</ul>
<p>装饰器模式在 Java 语言中的最著名的应用莫过于 <strong>Java I/O 标准库</strong>的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<h3 id="11-6、装饰者模式扩展"><a href="#11-6、装饰者模式扩展" class="headerlink" title="11.6、装饰者模式扩展"></a>11.6、装饰者模式扩展</h3><p>装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p>
<h4 id="11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"><a href="#11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件" class="headerlink" title="11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"></a>11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/87.png" alt="image-20210415115027987"></p>
<h4 id="11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"><a href="#11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并" class="headerlink" title="11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"></a>11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/88.png" alt="image-20210415115057914"></p>
<h3 id="11-7、进阶阅读"><a href="#11-7、进阶阅读" class="headerlink" title="11.7、进阶阅读"></a>11.7、进阶阅读</h3><p>如果您想深入了解装饰器模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8461.html">《使用装饰器模式解决煎饼“加码”问题》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8463.html">《装饰器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8464.html">《装饰器模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8466.html">《装饰器模式和代理模式的区别》</a></li>
</ul>
<h3 id="11-8、相关设计模式"><a href="#11-8、相关设计模式" class="headerlink" title="11.8、相关设计模式"></a>11.8、相关设计模式</h3><ul>
<li><p>Adapter模式</p>
<p>Decorator 模式可以在不改变被装饰物的接口 (API) 的前提下， 为被装饰物添加边框（透明性）。</p>
<p>Adapter 模式用千适配两个不同的接口 (API)。</p>
</li>
<li><p>Stragety模式</p>
<p>Decorator 模式可以像改变被装饰物的边框或是为被装饰物添加多重边框那样， 来增加类的功能。</p>
<p>Stragety 模式通过整体地替换算法来改变类的功能。</p>
</li>
</ul>
<h3 id="11-9、装饰者模式的注意事项与细节"><a href="#11-9、装饰者模式的注意事项与细节" class="headerlink" title="11.9、装饰者模式的注意事项与细节"></a>11.9、装饰者模式的注意事项与细节</h3><ul>
<li>得益于接口(API)的透明性， Decorator模式中也形成了类似千Composite模式中的递归结构。 </li>
<li>也就是说， 装饰边框里面的 ”被装饰物” 实际上又是别的物体的 ＂装饰边框＂。就像是剥洋葱时以为洋葱心要出来了， 结果却发现还是皮。 </li>
<li>不过， Decorator模式虽然与Composite模式一样， 都具有递归 结构， 但是它们的使用目的不同。 </li>
<li>Decorator模式的主要目的是通过添加装饰物来增加对象的功能。</li>
</ul>
<h2 id="12、组合模式Composite（结构型模式）"><a href="#12、组合模式Composite（结构型模式）" class="headerlink" title="12、组合模式Composite（结构型模式）"></a>12、组合模式Composite（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/93.png" alt="image-20210415133116987"></p>
<h3 id="12-1、基本介绍"><a href="#12-1、基本介绍" class="headerlink" title="12.1、基本介绍"></a>12.1、基本介绍</h3><ol>
<li><p>组合模式（Composite Pattern），又叫<strong>部分整体模式</strong>，它创建了<strong>对象组的树形结构</strong>，将对象组合成树状结构以表示“<strong>整体-部分</strong>”的层次关系。</p>
</li>
<li><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
</li>
<li><p>这种类型的设计模式属于<strong>结构型模式</strong>。</p>
</li>
<li><p>组合模式使得用户对<strong>单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象</p>
</li>
<li><p>组合模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
</li>
<li><p>组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，<strong>顶层的节点被称为根节点</strong>，根节点下面可以包含<strong>树枝节点</strong>和<strong>叶子节点</strong>，<strong>树枝节点</strong>下面<strong>又可以包含树枝节点和叶子节点</strong>，树形结构图如下:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/94.png" alt="image-20210415201954362"></p>
<p>由上图可以看出，其实<strong>根节点和树枝节点本质上属于同一种数据类型</strong>，可以作为<strong>容器</strong>使用；而<strong>叶子节点与树枝节点在语义上不属于用一种类型</strong>。但是在组合模式中，会把<strong>树枝节点和叶子节点看作属于同一种数据类型</strong>（用统一接口定义），让它们<strong>具备一致行为</strong>。</p>
<p>这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p>
</li>
</ol>
<h3 id="12-2、组合模式的原理结构图-uml类图"><a href="#12-2、组合模式的原理结构图-uml类图" class="headerlink" title="12.2、组合模式的原理结构图-uml类图"></a>12.2、组合模式的原理结构图-uml类图</h3><p>组合模式主要包含以下角色：</p>
<ul>
<li><strong>抽象构件（Component）</strong>角色：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</li>
<li><strong>树叶构件（Leaf）</strong>角色： 在组合中表示叶子节点，叶子节点没有子节点。用于继承或实现抽象构件。</li>
<li><strong>树枝构件（Composite）</strong>角色 / 中间构件：是组合中的分支节点对象，非叶子节点，用于存储子部件。它的主要作用是存储和管理子部件，在Component接口中实现子部件的相关操作，比如增加(add), 删除（remove）。</li>
</ul>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/95.png" alt="image-20210415203743668"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树叶&quot;</span> + name + <span class="string">&quot;：被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3、应用举例"><a href="#12-3、应用举例" class="headerlink" title="12.3、应用举例"></a>12.3、应用举例</h3><p>看一个学校院系展示需求 </p>
<p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/96.png" alt="image-20210415205203158"></p>
<h4 id="12-3-1、传统方案解决需求"><a href="#12-3-1、传统方案解决需求" class="headerlink" title="12.3.1、传统方案解决需求"></a>12.3.1、传统方案解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统方案解决学校院系展示存在的问题分析</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在<strong>组织大小</strong>来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，<strong>不能很好实现的管理</strong>的操作，比如对学院、系的添加，删除，遍历等</li>
<li>解决方案：把学校、院、系都看做是<strong>组织结构</strong>，<strong>他们之间没有继承</strong>的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt; 组合模式</li>
</ol>
<h4 id="12-3-2、组合模式进阶需求"><a href="#12-3-2、组合模式进阶需求" class="headerlink" title="12.3.2、组合模式进阶需求"></a>12.3.2、组合模式进阶需求</h4><p>思路分析和图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/98.png" alt="image-20210415215204104"></p>
<p>代码实现</p>
<p>OrganizationComponent：组织。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">	<span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line">	<span class="comment">// add():增加</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// remove():删除</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>University：大学，组织的一种，管理学院College。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">    <span class="comment">// List 中 存放的College</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院，组织的一种，被University管理，管理各个专业。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">	<span class="comment">// List 中 存放的Department</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Department：专业，组织的一种，被学院College管理，本身是叶子构件，没有管理对象。<strong>树叶构件（Leaf）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 本身是叶子构件，没有管理对象，没有集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">		OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建 学院</span></span><br><span class="line">		OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>);</span><br><span class="line">		OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line">		</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>));</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line">		<span class="comment">//将学院加入到 学校</span></span><br><span class="line">		university.add(computerCollege);</span><br><span class="line">		university.add(infoEngineercollege);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//university.print();</span></span><br><span class="line">		infoEngineercollege.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4、组合模式在JDK的应用与源码"><a href="#12-4、组合模式在JDK的应用与源码" class="headerlink" title="12.4、组合模式在JDK的应用与源码"></a>12.4、组合模式在JDK的应用与源码</h3><p>Java 的集合类-<strong>HashMap</strong> 就使用了组合模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/101.png" alt="image-20210415223718110"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/107.png" alt="image-20210415225016875"></p>
<p>说明：</p>
<ol>
<li><p>Map 就是一个抽象的构建 (类似我们的Component)</p>
</li>
<li><p>HashMap是一个中间的构建(Composite), 实现/继承了相关方法put, putall等等</p>
</li>
<li><p>Node 是 HashMap的静态内部类，类似Leaf叶子节点, 这里就没有put, putall等方法</p>
<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</p>
</li>
</ol>
<p>Map：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/102.png" alt="image-20210415224234562"></p>
<p>AbstractMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/103.png" alt="image-20210415224422322"></p>
<p>HashMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/104.png" alt="image-20210415224607666"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/105.png" alt="image-20210415224705647"></p>
<p>Node：HashMap的静态内部类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/106.png" alt="image-20210415224934928"></p>
<h3 id="12-5、组合模式总结"><a href="#12-5、组合模式总结" class="headerlink" title="12.5、组合模式总结"></a>12.5、组合模式总结</h3><p>主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li><strong>不容易用继承的方法</strong>来增加构件的新功能；</li>
</ol>
<p>组合模式的应用场景</p>
<ol>
<li>在需要<strong>表示一个对象整体与部分的层次结构</strong>的场合。</li>
<li>要求对用户<strong>隐藏组合对象与单个对象的不同</strong>，用户可以<strong>用统一的接口使用组合结构中的所有对象</strong>的场合。</li>
</ol>
<p><strong>应用实例：</strong> </p>
<ol>
<li><strong>算术表达式</strong>包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 </li>
<li>在 <strong>JAVA AWT 和 SWING</strong> 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ol>
<h3 id="12-6、组合模式扩展"><a href="#12-6、组合模式扩展" class="headerlink" title="12.6、组合模式扩展"></a>12.6、组合模式扩展</h3><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/99.png" alt="image-20210415221758204"></p>
<h3 id="12-7、进阶阅读"><a href="#12-7、进阶阅读" class="headerlink" title="12.7、进阶阅读"></a>12.7、进阶阅读</h3><p>如果您想深入了解组合模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8473.html">《使用透明组合模式实现课程目录结构》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8474.html">《使用安全组合模式实现无限级文件系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8475.html">《组合模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8476.html">《组合模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="12-8、相关设计模式"><a href="#12-8、相关设计模式" class="headerlink" title="12.8、相关设计模式"></a>12.8、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>使用Command模式编写宏命令时使用了Composite模式。</p>
</li>
<li><p>Visitor模式</p>
<p>可以使用Visitor模式访问Composite模式中的递归结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Composite模式通过Component角色使容器(Composite角色）和内容(Leaf角色）具有一致性</p>
<p>Decorator模式使装饰框和内容具有一致性。</p>
</li>
</ul>
<h3 id="12-9、组合模式的注意事项与细节"><a href="#12-9、组合模式的注意事项与细节" class="headerlink" title="12.9、组合模式的注意事项与细节"></a>12.9、组合模式的注意事项与细节</h3><ol>
<li>简化客户端操作。客户端<strong>只需要面对一致的对象而不用考虑整体部分或者节点叶子</strong>的问题。</li>
<li>具有<strong>较强的扩展性</strong>。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。<strong>满足了OCP原则</strong>。</li>
<li><strong>方便创建出复杂的层次结构</strong>。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。</li>
<li>需要<strong>遍历组织机构</strong>，或者<strong>处理的对象具有树形结构</strong>时, 非常适合使用组合模式.</li>
<li>要求<strong>较高的抽象性</strong>，如果节点和叶子有<strong>很多差异性</strong>的话，比如<strong>很多方法和属性都不一样</strong>，<strong>不适合</strong>使用组合模式</li>
</ol>
<h2 id="13、外观模式Facade（结构型模式）"><a href="#13、外观模式Facade（结构型模式）" class="headerlink" title="13、外观模式Facade（结构型模式）"></a>13、外观模式Facade（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/108.png" alt="image-20210415225627971"></p>
<h3 id="13-1、基本介绍"><a href="#13-1、基本介绍" class="headerlink" title="13.1、基本介绍"></a>13.1、基本介绍</h3><ol>
<li>外观模式（Facade），也叫<strong>过程模式</strong>、<strong>门面模式</strong>：外观模式为<strong>子系统中的一组接口提供一个一致的界面</strong>，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用</li>
<li>外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。这样会大大降低应用程序的复杂度，提高了程序的可维护性。</li>
<li>外观设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</li>
<li>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度<strong>多个子系统（2个以上的类对象）</strong>，我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段<strong>各种第三方SDK</strong>、<strong>开源类库</strong>，很大概率都会使用外观模式。</li>
</ol>
<h3 id="13-2、外观模式的原理结构图-uml类图"><a href="#13-2、外观模式的原理结构图-uml类图" class="headerlink" title="13.2、外观模式的原理结构图-uml类图"></a>13.2、外观模式的原理结构图-uml类图</h3><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h4 id="13-2-1、模式的结构"><a href="#13-2-1、模式的结构" class="headerlink" title="13.2.1、模式的结构"></a>13.2.1、模式的结构</h4><p>外观（Facade）模式包含以下主要角色。</p>
<ol>
<li><strong>外观（Facade）</strong>角色：为多个子系统对外提供一个<strong>统一的接口</strong>。</li>
<li><strong>子系统（Sub System）</strong>角色：<strong>实现系统的部分功能</strong>，客户可以通过外观角色访问它。</li>
<li><strong>客户（Client）</strong>角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/109.png" alt="image-20210416002002708"></p>
<h4 id="13-2-2、模式的实现"><a href="#13-2-2、模式的实现" class="headerlink" title="13.2.2、模式的实现"></a>13.2.2、模式的实现</h4><p>外观模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade;</span><br><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade f = <span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3、应用举例"><a href="#13-3、应用举例" class="headerlink" title="13.3、应用举例"></a>13.3、应用举例</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/111.png" alt="image-20210416003604096"></p>
<h4 id="13-3-1、使用传统方式解决需求"><a href="#13-3-1、使用传统方式解决需求" class="headerlink" title="13.3.1、使用传统方式解决需求"></a>13.3.1、使用传统方式解决需求</h4><p>思路解析（相关类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/112.png" alt="image-20210416003740197"></p>
<p>传统方式解决影院管理问题分析</p>
<ol>
<li><p>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成<strong>调用过程混乱</strong>，没有清晰的过程</p>
</li>
<li><p><strong>不利于</strong>在 ClientTest 中，去<strong>维护对子系统的操作</strong></p>
</li>
<li><p>解决思路：<strong>定义一个高层接口</strong>，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</p>
</li>
<li><p>也就是说：就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节（既使子系统之间互相调用），使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 =&gt; 外观模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/113.png" alt="image-20210416004046940"></p>
</li>
</ol>
<h4 id="13-3-2、使用外观模式解决需求"><a href="#13-3-2、使用外观模式解决需求" class="headerlink" title="13.3.2、使用外观模式解决需求"></a>13.3.2、使用外观模式解决需求</h4><p>传统方式解决影院管理说明：</p>
<ol>
<li>外观模式可以理解为<strong>转换一群接口</strong>，客户只要<strong>调用一个接口</strong>，而不用调用多个接口才能达到目的。比如：在 pc 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li>
<li>外观模式就是<strong>解决多个复杂接口带来的使用困难，起到简化用户操作</strong>的作用</li>
</ol>
<p>思路解析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/114.png" alt="image-20210416004253007"></p>
<p>代码实现：</p>
<p>Screen：显示器。<strong>子系统（Sub System）</strong>角色，使用<strong>单例模式</strong>实现子系统角色的创建。（其他子系统角色类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构造器私有化, 外部不能new </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Screen</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Screen instance = <span class="keyword">new</span> Screen();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 显示器相关操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen up &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen down &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HomeTheaterFacade：家庭电影院外观控制器。<strong>外观（Facade）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义各个子系统对象</span></span><br><span class="line">	<span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">	<span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">	<span class="keyword">private</span> Stereo stereo;</span><br><span class="line">	<span class="keyword">private</span> Projector projector;</span><br><span class="line">	<span class="keyword">private</span> Screen screen;</span><br><span class="line">	<span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line">	<span class="comment">//构造器（单例模式）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作分成 4 步</span></span><br><span class="line">	<span class="comment">// 开始</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.on();</span><br><span class="line">		popcorn.pop();</span><br><span class="line">		screen.down();</span><br><span class="line">		projector.on();</span><br><span class="line">		stereo.on();</span><br><span class="line">		dVDPlayer.on();</span><br><span class="line">		theaterLight.dim();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 播放</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.play();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 暂停</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.pause();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 结束</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.off();</span><br><span class="line">		theaterLight.bright();</span><br><span class="line">		screen.up();</span><br><span class="line">		projector.off();</span><br><span class="line">		stereo.off();</span><br><span class="line">		dVDPlayer.off();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。<strong>客户（Client）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">         <span class="comment">// 开始</span></span><br><span class="line">		homeTheaterFacade.ready();</span><br><span class="line">         <span class="comment">// 播放</span></span><br><span class="line">		homeTheaterFacade.play();</span><br><span class="line">         <span class="comment">// 暂停</span></span><br><span class="line">         homeTheaterFacade.pause();</span><br><span class="line">         <span class="comment">// 结束</span></span><br><span class="line">		homeTheaterFacade.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-4、外观模式在Mybatis的应用与源码"><a href="#13-4、外观模式在Mybatis的应用与源码" class="headerlink" title="13.4、外观模式在Mybatis的应用与源码"></a>13.4、外观模式在Mybatis的应用与源码</h3><p><strong>MyBatis</strong> 中的 <strong>Configuration</strong> 去创建 <strong>MetaObject</strong>  对象使用到外观模式</p>
<p>代码分析+Debug 源码+示意图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/115.png" alt="image-20210416005522209"></p>
<p>对源码中使用到的外观模式的角色类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/121.png" alt="image-20210416010838982"></p>
<p>Mybatis的Configuration：(Facade外观)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/116.png" alt="image-20210416005648774"></p>
<p>Configuration中组合的三个工厂对象：（子系统Sub System）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/117.png" alt="image-20210416010052394"></p>
<p>Configuration中的newMetaObject()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/118.png" alt="image-20210416010317177"></p>
<p>MetaObject：Client借助Mybatis的Configuration生成的对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/119.png" alt="image-20210416010527422"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/120.png" alt="image-20210416010710795"></p>
<h3 id="13-5、外观模式总结"><a href="#13-5、外观模式总结" class="headerlink" title="13.5、外观模式总结"></a>13.5、外观模式总结</h3><p>外观（Facade）模式是“迪米特法则”的典型应用</p>
<p>主要优点：</p>
<ol>
<li><strong>降低了子系统与客户端之间的耦合度</strong>，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户<strong>屏蔽了子系统组件</strong>，减少了客户处理的对象数目，并使得<strong>子系统使用起来更加容易</strong>。</li>
<li><strong>降低了大型软件系统中的编译依赖性</strong>，<strong>简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li><strong>不能很好地限制客户使用子系统类</strong>，很容易带来未知风险。</li>
<li>增加新的子系统可能需要<strong>修改外观类或客户端的源代码</strong>，<strong>违背了“开闭原则”</strong>，继承重写都不合适。</li>
</ol>
<p>外观模式的应用场景：</p>
<ol>
<li>对<strong>分层结构系统构建</strong>时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当<strong>一个复杂系统的子系统很多</strong>时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当<strong>客户端与多个子系统</strong>之间存在很大的联系时，引入外观模式可将它们<strong>分离</strong>，从而<strong>提高子系统的独立性和可移植性。</strong></li>
</ol>
<p>外观模式应用实例：</p>
<ol>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供<strong>接待人员</strong>，只让接待人员来处理，就很方便</li>
<li><strong>JAVA 的三层开发模式：Controller、Service、Dao</strong></li>
<li>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</li>
<li>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个<strong>统一的网关入口</strong>来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</li>
</ol>
<h3 id="13-6、外观模式扩展"><a href="#13-6、外观模式扩展" class="headerlink" title="13.6、外观模式扩展"></a>13.6、外观模式扩展</h3><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果<strong>引入抽象外观类</strong>，则在一定程度上解决了该问题，其结构图如图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/110.png" alt="image-20210416002803095"></p>
<h3 id="13-7、进阶阅读"><a href="#13-7、进阶阅读" class="headerlink" title="13.7、进阶阅读"></a>13.7、进阶阅读</h3><p>如果您想了解外观模式的实际应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8467.html">《使用外观模式整合调用已知API》</a>一节。</p>
<h3 id="13-8、相关设计模式"><a href="#13-8、相关设计模式" class="headerlink" title="13.8、相关设计模式"></a>13.8、相关设计模式</h3><ul>
<li><p>Abstract Factory 模式</p>
<p>可以将AbstractFactory模式看作生成复杂实例时的Facade模式。 因为它提供了 “要想生成这个实例只需要调用这个方法就OK了＂ 的简单接口。</p>
</li>
<li><p>Singleton 模式</p>
<p>有时会使用Singleton模式创建Facade角色。</p>
</li>
<li><p>Mediator 模式</p>
<p>在Facade模式中，Facade角色单方面地使用其他角色来提供高层接口(API)。</p>
<p>而在Mediator模式中，Mediator角色作为Colleague角色间的仲裁者负责调停。 可以说， <strong>Facade模式是单向的， 而Mediator角色是双向的。</strong></p>
</li>
</ul>
<h3 id="13-9、外观模式的注意事项与细节"><a href="#13-9、外观模式的注意事项与细节" class="headerlink" title="13.9、外观模式的注意事项与细节"></a>13.9、外观模式的注意事项与细节</h3><ol>
<li>外观模式<strong>对外屏蔽了子系统的细节</strong>，因此外观模式降低了客户端对子系统使用的复杂性</li>
<li>外观模式对<strong>客户端与子系统的耦合关系 - 解耦</strong>，让子系统内部的模块更易维护和扩展</li>
<li>通过合理的使用外观模式，可以帮我们<strong>更好的划分访问的层次</strong></li>
<li>当系统需要进行<strong>分层设计</strong>时，可以考虑使用 Facade 模式</li>
<li>在<strong>维护一个遗留的大型系统</strong>时，可能这个系统已经变得<strong>非常难以维护和扩展</strong>，此时可以考虑为新系统开发一个Facade 类，来<strong>提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</strong></li>
<li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以<strong>让系统有层次</strong>，<strong>利于维护</strong>为目的。</li>
</ol>
<h2 id="14、享元模式Flyweight（结构型模式）"><a href="#14、享元模式Flyweight（结构型模式）" class="headerlink" title="14、享元模式Flyweight（结构型模式）"></a>14、享元模式Flyweight（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/122.png" alt="image-20210416011234518"></p>
<h3 id="14-1、基本介绍"><a href="#14-1、基本介绍" class="headerlink" title="14.1、基本介绍"></a>14.1、基本介绍</h3><ol>
<li><p>享元模式（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用<strong>共享技术有效地支持大量细粒度的对象</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</li>
<li><p>享元模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p>
</li>
<li><p>常用于<strong>系统底层开发</strong>，解决<strong>系统的性能</strong>问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</p>
</li>
<li><p>享元模式能够解决<strong>重复对象的内存浪费</strong>的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以<strong>降低系统内存，同时提高效率</strong></p>
</li>
<li><p>享元模式的核心思想：如果<strong>一个对象实例一经创建就不可变</strong>，那么反复创建相同的实例就没有必要，直接向<strong>调用方返回一个共享的实例</strong>就行，这样即<strong>节省内存</strong>，又可以<strong>减少创建对象的过程</strong>，<strong>提高运行速度</strong>。（注意区别单例模式）</p>
<p>一言蔽之：<strong>通过尽量共享实例来避免new出实例</strong>。</p>
</li>
<li><p>享元模式经典的应用场景就是<strong>池技术</strong>了，<strong>String 常量池</strong>、<strong>数据库连接池</strong>、<strong>缓冲池</strong>等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/123.png" alt="image-20210416020802732"></p>
</li>
</ol>
<h3 id="14-2、享元模式的原理结构图-uml类图"><a href="#14-2、享元模式的原理结构图-uml类图" class="headerlink" title="14.2、享元模式的原理结构图-uml类图"></a>14.2、享元模式的原理结构图-uml类图</h3><h4 id="14-2-1、内部状态与外部状态"><a href="#14-2-1、内部状态与外部状态" class="headerlink" title="14.2.1、内部状态与外部状态"></a>14.2.1、内部状态与外部状态</h4><p>享元模式的定义提出了两个要求，<strong>细粒度</strong>和<strong>共享对象</strong>。因为要求细粒度，所以不可避免地会<strong>使对象数量多且性质相近</strong>，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<ul>
<li>内部状态指<strong>对象共享出来的信息</strong>，存储在<strong>享元信息内部</strong>，并且<strong>不会随环境的改变而改变</strong>；</li>
<li>外部状态指<strong>对象得以依赖的一个标记</strong>，<strong>随环境的改变而改变，不可共享</strong>。</li>
</ul>
<p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以<strong>棋子颜色</strong>就是棋子的<strong>内部状态</strong>；而各个棋子之间的差别就是<strong>位置的不同</strong>，当我们落子后，落子颜色是定的，但位置是变化的，所以<strong>棋子坐标</strong>就是棋子的<strong>外部状态</strong>。</p>
<p>又比如，<strong>连接池中的连接对象</strong>，保存在连接对象中的<strong>用户名</strong>、<strong>密码</strong>、<strong>连接URL等信息</strong>，在创建对象的时候就设置好了，<strong>不会随环境的改变而改变</strong>，这些为<strong>内部状态</strong>。而当<strong>每个连接要被回收利用</strong>时，我们需要<strong>将它标记为可用状态</strong>，这些为<strong>外部状态</strong>。</p>
<p>享元模式的本质是缓存共享对象，降低内存消耗。</p>
<p>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p>
<h4 id="14-2-2、模式的结构"><a href="#14-2-2、模式的结构" class="headerlink" title="14.2.2、模式的结构"></a>14.2.2、模式的结构</h4><p>享元模式的主要角色有如下。</p>
<ol>
<li><strong>抽象享元角色（Flyweight）</strong>（轻量级）：是所有的<strong>具体享元类的基类</strong>，为具体享元规范需要实现的<strong>公共接口</strong>，<strong>非享元的外部状态</strong>以<strong>参数</strong>的形式<strong>通过方法传入</strong>。</li>
<li><strong>具体享元（Concrete Flyweight）角色</strong>：<strong>实现抽象享元角色</strong>中所规定的<strong>接口</strong>。</li>
<li><strong>非享元（Unsharable Flyweight)角色</strong>：是<strong>不可以共享的外部状态</strong>，它<strong>以参数的形式注入具体享元的相关方法</strong>中。一般<strong>不会出现在享元工厂</strong>。</li>
<li><strong>享元工厂（Flyweight Factory）角色</strong>（轻量级）：负责<strong>创建和管理享元角色</strong>。用于构建一个池容器(集合)， 同时提供从池中获取对象方法（池技术）。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>享元模式的结构图，其中：</p>
<ul>
<li>UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；</li>
<li>Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；</li>
<li>ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；</li>
<li>FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元；</li>
<li>客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/124.png" alt="image-20210416021500116"></p>
<h4 id="14-2-3、代码实现"><a href="#14-2-3、代码实现" class="headerlink" title="14.2.3、代码实现"></a>14.2.3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f02 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f03 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f11 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Flyweight f12 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用a。&quot;</span>));</span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用a。&quot;</span>));</span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第3次调用a。&quot;</span>));</span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用b。&quot;</span>));</span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用b。&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被调用，&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非享元信息是:&quot;</span> + outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用HashMap作池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;已经存在，被成功获取！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-3、应用举例"><a href="#14-3、应用举例" class="headerlink" title="14.3、应用举例"></a>14.3、应用举例</h3><p>展示网站项目需求：</p>
<p>小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p>
<ul>
<li>有客户要求以新闻的形式发布</li>
<li>有客户人要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ul>
<h4 id="14-3-1、使用传统方式解决需求"><a href="#14-3-1、使用传统方式解决需求" class="headerlink" title="14.3.1、使用传统方式解决需求"></a>14.3.1、使用传统方式解决需求</h4><ol>
<li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li>
<li>给每个网站租用一个空间</li>
</ol>
<p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/127.png" alt="image-20210416024816721"></p>
<p>传统方案解决网站展现项目问题分析：</p>
<ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，<strong>造成服务器的资源浪费</strong></li>
<li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源</li>
<li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li>
<li>上面的解决思路就可以使用享元模式来解决</li>
</ol>
<h4 id="14-3-2、使用享元模式解决需求"><a href="#14-3-2、使用享元模式解决需求" class="headerlink" title="14.3.2、使用享元模式解决需求"></a>14.3.2、使用享元模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/128.png" alt="image-20210416025317394"></p>
<p>代码实现：</p>
<p>WebSite：网站，当中的use方法传入外部状态User。<strong>抽象享元角色（Flyweight）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteWebSite：具体网站，继承WebSite，包含有内部状态type。<strong>具体享元（Concrete Flyweight）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="comment">//共享的部分，内部状态</span></span><br><span class="line">	<span class="keyword">private</span> String type = <span class="string">&quot;&quot;</span>; <span class="comment">//网站发布的形式(类型)</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User：用户，不同的用户的构建网站的类型不同，属于外部状态，通过方法参数传入。<strong>非享元（Unsharable Flyweight)角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSiteFactory：网站工厂类，根据需要返回一个网站。<strong>享元工厂（Flyweight Factory）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站工厂类，根据需要返回一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合， 充当池的作用</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pool.containsKey(type)) &#123;</span><br><span class="line">			<span class="comment">//就创建一个网站，并放入到池中</span></span><br><span class="line">			pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (WebSite)pool.get(type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pool.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个工厂类</span></span><br><span class="line">		WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line">		<span class="comment">// 客户tom要一个以新闻形式发布的网站</span></span><br><span class="line">		WebSite webSite1 = factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">		webSite1.use(<span class="keyword">new</span> User(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户jack要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite2 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite2.use(<span class="keyword">new</span> User(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户smith要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite3 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite3.use(<span class="keyword">new</span> User(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户king要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite4 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite4.use(<span class="keyword">new</span> User(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">         <span class="comment">// 网站的分类共=2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;网站的分类共=&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4、享元模式在JDK-Integer的应用与源码"><a href="#14-4、享元模式在JDK-Integer的应用与源码" class="headerlink" title="14.4、享元模式在JDK-Integer的应用与源码"></a>14.4、享元模式在JDK-Integer的应用与源码</h3><p>Integer 中的享元模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span></span><br><span class="line">		Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span></span><br><span class="line">		Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">		Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">	</span><br><span class="line">		System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">		System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">		System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">		System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">		System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line">	</span><br><span class="line">		Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;x1==x2&quot;</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>如果 Integer.valueOf(x)的参数 x 在  -128 — 127 之间，就是使用享元模式返回,如果不在范围内，则仍然 new 一个Integer对象</li>
<li>在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new)；否则，就直接从缓存池返回</li>
<li>valueOf 方法，就使用到享元模式</li>
<li>如果使用valueOf 方法得到一个Integer 实例，<strong>范围在 -128 - 127 ，执行速度比 new 快</strong></li>
</ul>
<p>为什么使用Integer.valueOf(x)并且其参数 x 的范围在  -128 — 127 之间就是同一个对象，看源码：</p>
<p>Debug 源码+说明：</p>
<p>Integer：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/129.png" alt="image-20210416031357474"></p>
<p>Integer当中的IntegerCache：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/130.png" alt="image-20210416031820357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/131.png" alt="image-20210416032125850"></p>
<h3 id="14-5、享元模式总结"><a href="#14-5、享元模式总结" class="headerlink" title="14.5、享元模式总结"></a>14.5、享元模式总结</h3><p>主要优点是</p>
<ul>
<li><strong>相同对象只要保存一份</strong>，这<strong>降低了系统中对象的数量</strong>，从而<strong>降低了系统中细粒度对象给内存带来的压力</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li>为了使对象可以共享，需要<strong>将一些不能共享的状态外部化</strong>，这将<strong>增加程序的复杂性</strong>。</li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li><strong>读取享元模式的外部状态会使得运行时间稍微变长</strong>。</li>
</ul>
<p>享元模式的应用场景：</p>
<p>当系统中<strong>多处需要同一组信息</strong>时，可以<strong>把这些信息封装到一个对象</strong>中，然后<strong>对该对象进行缓存</strong>，这样，一个对象就可以提供给多出需要使用的地方，<strong>避免大量同一对象的多次创建</strong>，<strong>降低大量内存空间的消耗</strong>。</p>
<p>享元模式其实是<strong>工厂方法模式的一个改进机制</strong>，<strong>享元模式同样要求创建一个或一组对象</strong>，并且<strong>就是通过工厂方法模式生成对象</strong>的，只不过享元模式为工厂方法模式<strong>增加了缓存</strong>这一功能。</p>
<p>享元模式是<strong>通过减少内存中对象的数量来节省内存空间</strong>的，所以以下几种情形适合采用享元模式。</p>
<ol>
<li>系统中<strong>存在大量相同或相似的对象</strong>，这些对象耗费大量的内存资源。</li>
<li>大部分的对象<strong>可以按照内部状态进行分组，且可将不同部分外部化</strong>，这样<strong>每一个组只需保存一个内部状态</strong>。</li>
<li>由于享元模式需要<strong>额外维护一个保存享元的数据结构（多为HashMap\HashTable）</strong>，所以应当在<strong>有足够多的享元实例</strong>时才值得使用享元模式。</li>
</ol>
<h3 id="14-6、享元模式扩展"><a href="#14-6、享元模式扩展" class="headerlink" title="14.6、享元模式扩展"></a>14.6、享元模式扩展</h3><p>在前面介绍的享元模式中，其结构图通常包含<strong>可以共享的部分</strong>和<strong>不可以共享的部分</strong>。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：<strong>单纯享元模式</strong>和<strong>复合享元模式</strong></p>
<h4 id="14-6-1、单纯享元模式"><a href="#14-6-1、单纯享元模式" class="headerlink" title="14.6.1、单纯享元模式"></a>14.6.1、单纯享元模式</h4><p>这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/125.png" alt="image-20210416024136156"></p>
<h4 id="14-6-2、复合享元模式"><a href="#14-6-2、复合享元模式" class="headerlink" title="14.6.2、复合享元模式"></a>14.6.2、复合享元模式</h4><p>这种享元模式中的有些享元对象是<strong>由一些单纯享元对象组合而成的</strong>，它们就是<strong>复合享元对象</strong>。虽然复合享元对象<strong>本身不能共享</strong>，但它们<strong>可以分解成单纯享元对象再被共享</strong>。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/126.png" alt="image-20210416024246399"></p>
<h3 id="14-7、进阶阅读"><a href="#14-7、进阶阅读" class="headerlink" title="14.7、进阶阅读"></a>14.7、进阶阅读</h3><p>如果您想深入了解享元模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8468.html">《使用享元模式实现资源共享池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8469.html">《使用享元模式实现数据库连接池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8471.html">《String中的享元模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8472.html">《Integer中的享元模式》</a></li>
</ul>
<h3 id="14-8、相关设计模式"><a href="#14-8、相关设计模式" class="headerlink" title="14.8、相关设计模式"></a>14.8、相关设计模式</h3><ul>
<li><p>Proxy 模式</p>
<p>如果生成实例的处理需要花费较长时间， 那么使用 Flyweight 模式可以提高程序的处理速度。</p>
<p>而 Proxy 模式则是通过设置代理提高程序的处理速度。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以使用 Flyweight 模式共享 Composite 模式中的 Leaf 角色。</p>
</li>
<li><p>Singleton 模式</p>
<p>在 FlyweightFactory 角色中有时会使用 Singleton 模式。</p>
<p>此外如果使用了 Singleton 模式，由于只会生成一个 Singleton 角色，因此所有使用该实例的地方都共享同一个实例。 在 Singleton 角色的实例中只持有内部（固有）信息。</p>
</li>
</ul>
<h3 id="14-9、享元模式的注意事项与细节"><a href="#14-9、享元模式的注意事项与细节" class="headerlink" title="14.9、享元模式的注意事项与细节"></a>14.9、享元模式的注意事项与细节</h3><ol>
<li>在享元模式这样理解，<strong>“享”就表示共享</strong>，<strong>“元”表示对象</strong></li>
<li>系统中有大量对象，这些对象消耗大量内存，并且<strong>对象的状态大部分可以外部化</strong>时，我们就可以考虑选用享元模式</li>
<li>用<strong>唯一标识码</strong>判断，如果在内存中有，则<strong>返回这个唯一标识码所标识的对象</strong>，用 <strong>HashMap/HashTable</strong> 存储</li>
<li>享元模式大大<strong>减少了对象的创建</strong>，<strong>降低了程序内存的占用</strong>，<strong>提高效率</strong></li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li>使用享元模式时，<strong>注意划分内部状态和外部状态</strong>，并且<strong>需要有一个工厂类加以控制</strong>。</li>
<li>在使用享元模式的时候要注意：<strong>不要让被共享的实例被垃圾回收机制（GC）回收了</strong>。</li>
<li>享元模式经典的应用场景是<strong>需要缓冲池的场景</strong>，比如 String 常量池、数据库连接池。</li>
</ol>
<h3 id="14-10、享元模式与单例模式的区别"><a href="#14-10、享元模式与单例模式的区别" class="headerlink" title="14.10、享元模式与单例模式的区别"></a>14.10、享元模式与单例模式的区别</h3><ol>
<li><p>单例模式是<strong>整个应用系统共用一个实例对象</strong>。</p>
<p>享元模式是<strong>整个系统共用好几个同类型对象</strong>。</p>
</li>
<li><p><strong>连接池本身是单例模式</strong>，连接池里的<strong>多个连接对象是享元模式</strong>。</p>
</li>
<li><p>而且<strong>享元模式的共享对象是按需分配</strong>的，如果<strong>不够还会再创建</strong>！</p>
<p>而<strong>单例模式绝对不会重复创建第二个对象</strong>，这是<strong>本质不同</strong>！</p>
</li>
<li><p><strong>享元模式里的共享对象</strong>在使用时一定是<strong>线程私有的</strong>。</p>
<p>就比如共享单车，虽然是共享的，但在使用时一定是只属于你的</p>
</li>
<li><p>享元模式的<strong>共享对象</strong>是<strong>有借有还</strong>的，在<strong>宏观上是共享</strong>的。</p>
</li>
</ol>
<h2 id="15、代理模式Proxy（结构型模式）"><a href="#15、代理模式Proxy（结构型模式）" class="headerlink" title="15、代理模式Proxy（结构型模式）"></a>15、代理模式Proxy（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/100.png" alt="image-20210416084620231"></p>
<h3 id="15-1、基本介绍"><a href="#15-1、基本介绍" class="headerlink" title="15.1、基本介绍"></a>15.1、基本介绍</h3><ol>
<li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即<strong>通过代理对象访问目标对象</strong>。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</li>
<li><p>这样做的好处是：可以在目标对象实现的基础上，<strong>增强额外的功能操作</strong>，即<strong>扩展目标对象的功能</strong>。</p>
</li>
<li><p>被代理的对象可以是<strong>远程对象</strong>、<strong>创建开销大的对象</strong>或<strong>需要安全控制的对象</strong></p>
</li>
<li><p>代理模式有不同的形式, 主要有三种：</p>
<ul>
<li>静态代理模式：<ul>
<li>静态代理在使用时，需要<strong>定义接口或者父类</strong>,<strong>被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。</strong></li>
</ul>
</li>
<li>动态代理模式 (JDK 代理、接口代理)：<ul>
<li><strong>代理对象不需要实现接口</strong>，但是<strong>目标对象要实现接口</strong>，否则不能用动态代理</li>
<li>代理对象的生成，是利用 <strong>JDK 的 API （反射）</strong>，<strong>动态的在内存中构建代理对象</strong></li>
<li>动态代理也叫做：<strong>JDK 代理</strong>、<strong>接口代理</strong></li>
<li>JDK 中生成代理对象的 API：<ul>
<li>代理类所在包:java.lang.reflect.Proxy</li>
<li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )<ol>
<li>ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</li>
<li>Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</li>
<li>InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Cglib</strong> 代理模式(可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) ：<ul>
<li>静态代理和 JDK 代理模式<strong>都要求目标对象是实现一个接口</strong>，但是有时候<strong>目标对象只是一个单独的对象</strong>，<strong>并没有实现任何的接口</strong>，这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib</strong> 代理。</li>
<li>Cglib 代理也叫作<strong>子类代理**</strong>,<strong>它是</strong>在内存中构建一个子类对象从而实现对目标对象功能扩展**, 有些书也将Cglib 代理归属到动态代理。</li>
<li>Cglib 是<strong>一个强大的高性能的代码生成包</strong>,它可以<strong>在运行期扩展 java 类与实现 java 接口</strong>。它广泛的被许多 <strong>AOP 的框架使用</strong>,例如 <strong>Spring AOP</strong>，实现方法拦截</li>
<li>在 AOP 编程中如何选择代理模式：<ul>
<li><strong>目标对象需要实现接口，用 JDK 代理</strong></li>
<li><strong>目标对象不需要实现接口，用 Cglib 代理</strong></li>
</ul>
</li>
<li>Cglib 包的底层是<strong>通过使用<code>字节码处理框架 ASM</code> 来转换字节码并生成新的类</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代理模式总的类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52.png" alt="image-20210416132054743"></p>
</li>
</ol>
<h3 id="15-2、代理模式的原理结构图-uml类图"><a href="#15-2、代理模式的原理结构图-uml类图" class="headerlink" title="15.2、代理模式的原理结构图-uml类图"></a>15.2、代理模式的原理结构图-uml类图</h3><p>代理模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li><strong>真实主题（Real Subject）</strong>类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li><strong>代理（Proxy）</strong>类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<h4 id="15-2-1、静态代理模式"><a href="#15-2-1、静态代理模式" class="headerlink" title="15.2.1、静态代理模式"></a>15.2.1、静态代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/132.png" alt="image-20210416132423219"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-2、JDK动态代理模式"><a href="#15-2-2、JDK动态代理模式" class="headerlink" title="15.2.2、JDK动态代理模式"></a>15.2.2、JDK动态代理模式</h4><p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/134.png" alt="image-20210416134249061"></p>
<p>执行原理：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/137.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		Subject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		Subject proxyInstance = (Subject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.Request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3、Cglib代理模式"><a href="#15-2-3、Cglib代理模式" class="headerlink" title="15.2.3、Cglib代理模式"></a>15.2.3、Cglib代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/135.png" alt="image-20210416135654386"></p>
<p>执行原理：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/138.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		RealSubject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		RealSubject proxyInstance = (RealSubject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.Request();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3、应用举例"><a href="#15-3、应用举例" class="headerlink" title="15.3、应用举例"></a>15.3、应用举例</h3><p>具体要求：</p>
<ol>
<li>定义一个接口:ITeacherDao</li>
<li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li>
<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li>
<li>调用的时候通过调用代理对象的方法来调用目标对象.</li>
</ol>
<h4 id="15-3-1、使用静态代理模式解决需求"><a href="#15-3-1、使用静态代理模式解决需求" class="headerlink" title="15.3.1、使用静态代理模式解决需求"></a>15.3.1、使用静态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/133.png" alt="image-20210416132715029"></p>
<p>实现代码：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDaoProxy：教师操作代理对象。代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象,静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来组合</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class="comment">//方法</span></span><br><span class="line">		target.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;提交。。。。。&quot;</span>);<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象(被代理对象)</span></span><br><span class="line">		TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class="line">		TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line">		<span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">		<span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class="line">		teacherDaoProxy.teach();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-2、使用动态代理模式解决需求"><a href="#15-3-2、使用动态代理模式解决需求" class="headerlink" title="15.3.2、使用动态代理模式解决需求"></a>15.3.2、使用动态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/136.png" alt="image-20210416141108093"></p>
<p>代码实现：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中.... &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">// 代理工厂，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		ITeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		ITeacherDao proxyInstance = (ITeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.teach();</span><br><span class="line">		proxyInstance.sayHello(<span class="string">&quot; tom &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-3、使用cglib代理模式解决需求"><a href="#15-3-3、使用cglib代理模式解决需求" class="headerlink" title="15.3.3、使用cglib代理模式解决需求"></a>15.3.3、使用cglib代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/140.png" alt="image-20210416143133820"></p>
<p>代码实现：</p>
<p>TeacherDao：教师操作类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="comment">// ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4、代理模式总结"><a href="#15-4、代理模式总结" class="headerlink" title="15.4、代理模式总结"></a>15.4、代理模式总结</h3><h4 id="15-4-1、静态代理优缺点"><a href="#15-4-1、静态代理优缺点" class="headerlink" title="15.4.1、静态代理优缺点"></a>15.4.1、静态代理优缺点</h4><ul>
<li>优点：<ul>
<li>在不修改目标对象的功能前提下, 能<strong>通过代理对象对目标功能扩展</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>因为<strong>代理对象需要与目标对象实现一样的接口</strong>，所以会<strong>有很多代理类</strong></li>
<li>一旦<strong>接口增加方法</strong>,<strong>目标对象与代理对象都要维护</strong></li>
</ul>
</li>
</ul>
<h4 id="15-4-2、JDK动态代理优缺点"><a href="#15-4-2、JDK动态代理优缺点" class="headerlink" title="15.4.2、JDK动态代理优缺点"></a>15.4.2、JDK动态代理优缺点</h4><ul>
<li>优点：<ul>
<li>JDK原声动态代理时java原声支持的、不需要任何外部依赖</li>
</ul>
</li>
<li>缺点：<ul>
<li>但是它只能基于接口进行代理（因为它已经继承了proxy了，java不支持多继承）</li>
</ul>
</li>
</ul>
<h4 id="15-4-3、Cglib动态代理优缺点"><a href="#15-4-3、Cglib动态代理优缺点" class="headerlink" title="15.4.3、Cglib动态代理优缺点"></a>15.4.3、Cglib动态代理优缺点</h4><p>优点：</p>
<ul>
<li>CGLIB通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>需要引入 cglib 的 jar 文件</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/139.png" alt="image-20210416143100693"></p>
</li>
<li><p>在内存中动态构建子类，注意代理的类不能为 final，否则报错java.lang.IllegalArgumentException:</p>
</li>
<li><p>目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。（final修饰的方法不能被覆写）</p>
</li>
</ul>
<h4 id="15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）"><a href="#15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）" class="headerlink" title="15.4.4、两种动态代理模式的对比（JDK VS CGLIB）"></a>15.4.4、两种动态代理模式的对比（JDK VS CGLIB）</h4><table>
<thead>
<tr>
<th></th>
<th>JDK原生动态代理</th>
<th>CGLB动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>核心原理</td>
<td>基于”接口实现”方式</td>
<td>基于类集成方式</td>
</tr>
<tr>
<td>优点</td>
<td>Java原生支持的，不需要任何依赖</td>
<td>对与代理的目标对象无限制，无需实现接口</td>
</tr>
<tr>
<td>不足之处</td>
<td>只能基于接口进行实现</td>
<td>无法处理final方法</td>
</tr>
<tr>
<td>实现方式</td>
<td>Java原生支持，不需要任何依赖</td>
<td>需要引用JAR包cglib-nodep-3.2.5.jar和asm.jar</td>
</tr>
</tbody></table>
<h4 id="15-4-5、代理模式总结"><a href="#15-4-5、代理模式总结" class="headerlink" title="15.4.5、代理模式总结"></a>15.4.5、代理模式总结</h4><p>主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个<strong>中介作用和保护目标对象</strong>的作用；</li>
<li>代理对象可以<strong>扩展目标对象的功能</strong>；</li>
<li>代理模式能将<strong>客户端与目标对象分离</strong>，在一定程度上<strong>降低了系统的耦合度</strong>，<strong>增加了程序的可扩展性</strong></li>
</ul>
<p>主要缺点是（有些缺点可通过动态代理解决）：</p>
<ul>
<li>代理模式会造成系统设计中<strong>类的数量增加</strong></li>
<li>在客户端和目标对象之间增加一个代理对象，会造成<strong>请求处理速度变慢</strong>；</li>
<li><strong>增加了系统的复杂度</strong>；</li>
</ul>
<p>应用场景：</p>
<p>当<strong>无法或不想直接引用某个对象</strong>或<strong>访问某个对象存在困难</strong>时，可以<strong>通过代理对象来间接访问</strong>。使用代理模式主要有两个目的：一是<strong>保护目标对象</strong>，二是<strong>增强目标对象</strong>。</p>
<ol>
<li><p>远程代理：</p>
<ul>
<li>远程代理即<strong>Remote Proxy</strong>，<strong>本地的调用者持有的接口实际上是一个代理</strong>，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。</li>
<li>这种方式通常是为了<strong>隐藏目标对象存在于不同地址空间的事实</strong>，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>Java内置的RMI机制就是一个完整的远程代理模式。</li>
</ul>
</li>
<li><p>虚拟代理：</p>
<ul>
<li>虚代理即<strong>Virtual Proxy</strong>，它让调用者<strong>先持有一个代理对象</strong>，但<strong>真正的对象尚未创建</strong>。如果<strong>没有必要</strong>，这个<strong>真正的对象是不会被创建</strong>的，直到客户端需要<strong>真的必须调用</strong>时，<strong>才创建</strong>真正的对象。</li>
<li>这种方式通常用于<strong>要创建的目标对象开销很大</strong>时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</li>
</ul>
</li>
<li><p>保护代理：</p>
<ul>
<li>保护代理即<strong>Protection Proxy</strong>，它用代理对象控制对原始对象的访问，常用于鉴权。</li>
<li>这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
</ul>
</li>
<li><p>智能引用：</p>
<ul>
<li>智能引用即<strong>Smart Reference</strong>，它也是一种代理对象，如果有很多客户端对它进行访问，通过<strong>内部的计数器可以在外部调用者都不使用后自动释放它</strong>。</li>
<li>主要用于调用目标对象时，<strong>代理附加一些额外的处理功能</strong>。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
</ul>
</li>
<li><p>延迟加载：</p>
<ul>
<li>延迟加载即<strong>Cache缓存代理</strong>。指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>
<li>当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li>
</ul>
</li>
<li><p>防火墙（Firewall）代理：内网通过代理穿透防火墙，实现对公网的访问。</p>
</li>
<li><p>同步化（Synchronization）代理：主要使用在多线程编程中，完成多线程间同步工作</p>
</li>
<li><p>Copy-on-Write 代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</p>
<p>Immer提供了一种更方便的不可变状态操作方式。详情：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>其<strong>方便之处</strong>主要体现在：</p>
<ul>
<li>只有一个（核心）API：<code>produce(currentState, producer: (draftState) =&gt; void): nextState</code></li>
<li>不引入额外的数据结构：没有 List、Map、Set 等任何自定义数据结构，因此也不需要特殊的相等性比较方法</li>
<li>数据操作完全基于类型：用纯原生 API 操作数据，符合直觉</li>
</ul>
</li>
</ol>
<p>应用实际：</p>
<ul>
<li>spring aop</li>
<li>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</li>
<li>买火车票不一定在火车站买，也可以去代售点。</li>
<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</li>
</ul>
<h3 id="15-5、代理模式扩展"><a href="#15-5、代理模式扩展" class="headerlink" title="15.5、代理模式扩展"></a>15.5、代理模式扩展</h3><p>动态代理的一种实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/141.png" alt="image-20210416145841201"></p>
<h3 id="15-6、进阶阅读"><a href="#15-6、进阶阅读" class="headerlink" title="15.6、进阶阅读"></a>15.6、进阶阅读</h3><p>如果您想深入了解代理模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8424.html">《静态代理和动态代理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8427.html">《使用代理模式切换数据源》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8429.html">《彻底搞懂JDK动态代理核心原理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8433.html">《代理模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8435.html">《代理模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="15-7、相关设计模式"><a href="#15-7、相关设计模式" class="headerlink" title="15.7、相关设计模式"></a>15.7、相关设计模式</h3><ul>
<li><p>Adapter 模式：</p>
<p>Adapter 模式适配了两种具有不同接口 (API) 的对象，以使它们可以一同工作。而在 Proxy 模式中，Proxy 角色与Rea)Subject 角色的接口 (API) 是相同的（透明性）。</p>
</li>
<li><p>Decorator 模式：</p>
<p>Decorator 模式与 Proxy 模式在实现上很相似．不过它们的使用目的不同。</p>
<p>Decorator 模式的目的在于增加新的功能。而在 Proxy 模式中，与增加新功能相比，它更注重通过设置代理人的方式来减轻本人的工作负担。</p>
</li>
</ul>
<h3 id="15-8、代理模式与其他模式的区别"><a href="#15-8、代理模式与其他模式的区别" class="headerlink" title="15.8、代理模式与其他模式的区别"></a>15.8、代理模式与其他模式的区别</h3><h4 id="15-8-1、Proxy模式VSDecorator模式"><a href="#15-8-1、Proxy模式VSDecorator模式" class="headerlink" title="15.8.1、Proxy模式VSDecorator模式"></a>15.8.1、Proxy模式VSDecorator模式</h4><ul>
<li>Decorator模式让调用者自己创建核心类，然后组合各种功能</li>
<li>Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能</li>
<li>Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</li>
<li>装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ul>
<h4 id="15-8-2、Proxy模式VSAdapter模式"><a href="#15-8-2、Proxy模式VSAdapter模式" class="headerlink" title="15.8.2、Proxy模式VSAdapter模式"></a>15.8.2、Proxy模式VSAdapter模式</h4><ul>
<li>适配器模式主要改变所考虑对象的接口</li>
<li>代理模式不能改变所代理类的接口</li>
</ul>
<h3 id="15-9、代理模式的注意事项与细节"><a href="#15-9、代理模式的注意事项与细节" class="headerlink" title="15.9、代理模式的注意事项与细节"></a>15.9、代理模式的注意事项与细节</h3><ol>
<li>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</li>
<li>静态代理模式：代理对象与目标对象（被代理对象）都实现同一个接口或者继承同一个抽象类</li>
<li>JDK动态代理模式：目标对象（被代理对象）需要实现接口或继承抽象类，而代理对象不用，它由一个代理工厂来生产</li>
<li>CGLIB动态代模式：目标对象（被代理对象）不需要实现接口或继承抽象类，但是用来生产代理对象的代理工厂需要实现cglib的MethodInterceptor接口。</li>
</ol>
<h2 id="16、模板方法模式Template-Method（行为型模式）"><a href="#16、模板方法模式Template-Method（行为型模式）" class="headerlink" title="16、模板方法模式Template Method（行为型模式）"></a>16、模板方法模式Template Method（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/74.PNG"></p>
<h3 id="16-1、基本介绍"><a href="#16-1、基本介绍" class="headerlink" title="16.1、基本介绍"></a>16.1、基本介绍</h3><ol>
<li>模板方法模式（Template Method Pattern），又叫<strong>模板模式(Template Pattern)**，</strong>在一个抽象类公开定义了执行它的方法的模板<strong>。它的</strong>子类可以按需要重写方法实现<strong>，但</strong>调用将以抽象类中定义的方式进行**。</li>
<li>简单说，模板方法模式<strong>定义一个操作中的算法的骨架</strong>，而将一些步骤延迟到子类中，使得<strong>子类可以不改变一个算法的结构</strong>，就可以<strong>重定义该算法的某些特定步骤</strong></li>
<li>模板方法的核心思想是：<strong>父类定义骨架</strong>，<strong>子类实现某些细节</strong>。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong>。</li>
</ol>
<h3 id="16-2、模板方法模式的原理结构图-uml类图"><a href="#16-2、模板方法模式的原理结构图-uml类图" class="headerlink" title="16.2、模板方法模式的原理结构图-uml类图"></a>16.2、模板方法模式的原理结构图-uml类图</h3><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了<strong>虚函数的多态性技术</strong>以及“不用调用我，让我来调用你”的<strong>反向控制技术</strong>。</p>
<h4 id="16-2-1、模式的结构"><a href="#16-2-1、模式的结构" class="headerlink" title="16.2.1、模式的结构"></a>16.2.1、模式的结构</h4><p>模板方法模式包含以下主要角色：</p>
<ul>
<li>抽象类/抽象模板（Abstract Class）<ul>
<li>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：<ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是整个算法中的一个步骤，包含以下几种类型：<ul>
<li>抽象方法：在抽象类中声明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它。包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体子类/具体实现（Concrete Class）：具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</li>
</ul>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/142.png" alt="image-20210416200400531"></p>
<h4 id="16-2-2、模式的实现"><a href="#16-2-2、模式的实现" class="headerlink" title="16.2.2、模式的实现"></a>16.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass tm = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3、应用举例"><a href="#16-3、应用举例" class="headerlink" title="16.3、应用举例"></a>16.3、应用举例</h3><p>豆浆制作问题：</p>
<p>编写制作豆浆的程序，说明如下:</p>
<ol>
<li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>也可以不添加配料，制作纯豆浆（钩子方法）</li>
<li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
<li>请使用模板方法模式完成 </li>
</ol>
<p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210416200834855.png" alt="image-20210416200834855"></p>
<p>代码实现：</p>
<p>SoyaMilk：制作豆浆的抽象类。抽象类/抽象模板（Abstract Class）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		select(); </span><br><span class="line">		<span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">			addCondiments();</span><br><span class="line">		&#125;</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打碎</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedBeanSoyaMilk：红豆豆浆。具体子类/具体实现（Concrete Class）（PeanutSoyaMilk等等其他豆浆类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PureSoyaMilk：纯豆浆。具体子类/具体实现（Concrete Class）（钩子方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//空实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用制作豆浆。客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line">		System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">		pureSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-4、模板方法模式在Spring框架的应用与源码"><a href="#16-4、模板方法模式在Spring框架的应用与源码" class="headerlink" title="16.4、模板方法模式在Spring框架的应用与源码"></a>16.4、模板方法模式在Spring框架的应用与源码</h3><p><strong>Spring IOC 容器初始化</strong>时运用到的模板方法模式</p>
<p>代码分析+角色分析+说明类图：</p>
<h4 id="16-4-1、说明类图"><a href="#16-4-1、说明类图" class="headerlink" title="16.4.1、说明类图"></a>16.4.1、说明类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/144.png" alt="image-20210416204002753"></p>
<h4 id="16-4-2、角色分析"><a href="#16-4-2、角色分析" class="headerlink" title="16.4.2、角色分析"></a>16.4.2、角色分析</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/145.png" alt="image-20210416204322032"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/146.png" alt="image-20210416204443297"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/147.png" alt="image-20210416204542192"></p>
<h4 id="16-4-3、代码分析"><a href="#16-4-3、代码分析" class="headerlink" title="16.4.3、代码分析"></a>16.4.3、代码分析</h4><p>ConfigurableApplicationContext接口与refresh()抽象模板方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/148.png" alt="image-20210416204750043"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/149.png" alt="image-20210416204918844"></p>
<p>AbstractApplicationContext抽象类实现了ConfigurableApplicationContext接口，并对refresh()模板方法进行了重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/150.png" alt="image-20210416204959220"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/151.png" alt="image-20210416205223899"></p>
<p>refresh()模板方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/152.png" alt="image-20210416205621834"></p>
<p>refresh()模板方法当中的obtainFreshBeanFactory()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/153.png" alt="image-20210416205735418"></p>
<p>refresh()模板方法当中的钩子方法postProcessBeanFactory()与onRefresh()</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/155.png" alt="image-20210416210548820"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/154.png" alt="image-20210416210318005"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/156.png" alt="image-20210416210706001"></p>
<p>GenericApplicationContext类继承了AbstractApplicationContext抽象类，对父类的getBeanFactory()与refreshBeanFactory()抽象方法进行重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/157.png" alt="image-20210416211006295"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/158.png" alt="image-20210416211737520"></p>
<p>XmlWebApplicationContext类、ClassPathXmlApplicationContext类等等子类继承了各自的父类。最好按照父类定义好的模板去实现对应的需求。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/159.png" alt="image-20210416212050470"></p>
<h3 id="16-5、模板方法模式总结"><a href="#16-5、模板方法模式总结" class="headerlink" title="16.5、模板方法模式总结"></a>16.5、模板方法模式总结</h3><p>主要优点：</p>
<ol>
<li>它<strong>封装了不变部分</strong>，<strong>扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在<strong>父类中提取了公共的部分代码</strong>，便于代码复用。</li>
<li><strong>部分方法是由子类实现</strong>的，因此子类可以<strong>通过扩展方式增加相应的功能</strong>，<strong>符合开闭原则</strong>。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li>对<strong>每个不同的实现都需要定义一个子类，这会导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，<strong>子类执行的结果会影响父类的结果</strong>，这导致一种<strong>反向的控制结构</strong>，它<strong>提高了代码阅读的难度</strong>。</li>
<li>由于<strong>继承关系自身的缺点</strong>，如果<strong>父类添加新的抽象方法，则所有子类都要改一遍</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li>算法的<strong>整体步骤很固定，但其中个别部分易变</strong>时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当<strong>多个子类存在公共的行为</strong>时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当<strong>需要控制子类的扩展</strong>时，模板方法<strong>只在特定点调用钩子操作</strong>，这样就<strong>只允许在这些点进行扩展</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异</li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ol>
<h3 id="16-6、模板方法模式扩展"><a href="#16-6、模板方法模式扩展" class="headerlink" title="16.6、模板方法模式扩展"></a>16.6、模板方法模式扩展</h3><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/143.png" alt="image-20210416203027578"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HookAbstractClass tm = <span class="keyword">new</span> HookConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        HookMethod1();</span><br><span class="line">        <span class="keyword">if</span> (HookMethod2()) &#123;</span><br><span class="line">            SpecificMethod();</span><br><span class="line">        &#125;</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookConcreteClass</span> <span class="keyword">extends</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子方法1被重写...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果钩子方法 HookMethod1() 和钩子方法 HookMethod2() 的代码改变，则程序的运行结果也会改变。</p>
<h3 id="16-7、进阶阅读"><a href="#16-7、进阶阅读" class="headerlink" title="16.7、进阶阅读"></a>16.7、进阶阅读</h3><p>如果您想深入了解模板方法模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8477.html">《使用模板模式实现课程基本流程》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8478.html">《使用模板方法模式重构JDBC业务操作》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8479.html">《模板方法模式在Servlet中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8480.html">《模板方法模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="16-8、相关设计模式"><a href="#16-8、相关设计模式" class="headerlink" title="16.8、相关设计模式"></a>16.8、相关设计模式</h3><ul>
<li><p>Factory Method 模式</p>
<p>Factory Method模式是将Template Method模式用于生成实例的一个典型例子。</p>
</li>
<li><p>Strategy 模式</p>
<p>在Template Method模式中， 可以<strong>使用继承改变程序的行为</strong>。 这是因为Template Method模式在父类中定义程序行为的框架．在子类中决定具体的处理。</p>
<p>与此相对的是Strategy模式 ， 它可以<strong>使用委托改变程序的行为</strong>。 与Template Method模式中改 变部分程序行为不同的是，Strategy模式<strong>用于替换整个算法</strong>。</p>
</li>
</ul>
<h3 id="16-9、模板方法模式的注意事项与细节"><a href="#16-9、模板方法模式的注意事项与细节" class="headerlink" title="16.9、模板方法模式的注意事项与细节"></a>16.9、模板方法模式的注意事项与细节</h3><ol>
<li>基本思想是：<strong>算法只存在</strong>于一个地方，也就是在<strong>父类中</strong>，<strong>容易修改</strong>。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。</li>
<li>实现了<strong>最大化代码复用</strong>。<strong>父类的模板方法和已实现的某些步骤会被子类继承而直接使用</strong>。</li>
<li>既<strong>统一了算法</strong>，也<strong>提供了很大的灵活性</strong>。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li>
<li>该模式的不足之处：<strong>每一个不同的实现都需要一个子类实现</strong>，导致<strong>类的个数增加</strong>，使得系统更加庞大</li>
<li>一般<strong>模板方法都加上 <code>final</code> 关键字</strong>， <strong>防止子类重写模板方法</strong>。</li>
<li>模板方法模式使用场景：当要<strong>完成在某个过程，该过程要执行一系列步骤</strong> ，<strong>这一系列的步骤基本相同</strong>，但其<strong>个别步骤在实现时可能不同</strong>，通常考虑用模板方法模式来处理</li>
<li>模板方法是一种<strong>高层定义骨架</strong>，<strong>底层实现细节的设计模式</strong>，适用于<strong>流程固定</strong>，<strong>但某些步骤不确定或可替换</strong>的情况。</li>
</ol>
<h2 id="17、命令模式Command（行为型模式）"><a href="#17、命令模式Command（行为型模式）" class="headerlink" title="17、命令模式Command（行为型模式）"></a>17、命令模式Command（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/160.png" alt="image-20210416212741618"></p>
<h3 id="17-1、基本介绍"><a href="#17-1、基本介绍" class="headerlink" title="17.1、基本介绍"></a>17.1、基本介绍</h3><ol>
<li>命令（Command）模式的定义如下：将<strong>一个请求封装为一个对象</strong>，使<strong>发出请求的责任和执行请求的责任分割开</strong>。这样两者之间通过命令对象进行沟通，这样方便将<strong>命令对象进行储存、传递、调用、增加与管理</strong>。</li>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要<strong>向某些对象发送请求</strong>，但是并<strong>不知道请求的接收者</strong>是谁，<strong>也不知道被请求的操作</strong>是哪个，我们<strong>只需在程序运行时指定具体的请求接收者</strong>即可，此时，可以使用命令模式来进行设计</li>
<li>命名模式使得<strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活，实现解耦。</li>
<li>在命名模式中，会<strong>将一个请求封装为一个对象</strong>，以便<strong>使用不同参数来表示不同的请求(即命名)**，同时命令模式也</strong>支持可撤销**的操作。</li>
<li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象</li>
</ol>
<h3 id="17-2、命令模式的原理结构图-uml类图"><a href="#17-2、命令模式的原理结构图-uml类图" class="headerlink" title="17.2、命令模式的原理结构图-uml类图"></a>17.2、命令模式的原理结构图-uml类图</h3><h4 id="17-2-1、模式的结构"><a href="#17-2-1、模式的结构" class="headerlink" title="17.2.1、模式的结构"></a>17.2.1、模式的结构</h4><p>命令模式包含以下主要角色。</p>
<ol>
<li>抽象命令类（Command）角色：是命令角色，需要执行的所有命令都在这里，拥有执行命令的抽象方法 execute()，可以是接口或抽象类</li>
<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/161.png" alt="image-20210417005514313"></p>
<h4 id="173-2-2、模式的实现"><a href="#173-2-2、模式的实现" class="headerlink" title="173.2.2、模式的实现"></a>173.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker ir = <span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的call()方法...&quot;</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;命令被撤销...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3、应用举例"><a href="#17-3、应用举例" class="headerlink" title="17.3、应用举例"></a>17.3、应用举例</h3><p>17.1   智能生活项目需求</p>
<ol>
<li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个app就可以控制全部智能家电。</li>
<li>要实现一个 app 控制所有智能家电的需要，则<strong>每个智能家电厂家</strong>都要<strong>提供一个统一的接口给 app 调用</strong>，这时 就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li>
<li>在我们的例子中，动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产</li>
<li>编写程序，使用命令模式完成前面的智能家电项目</li>
</ol>
<p>思路分析和图解</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/162.png" alt="image-20210417010355805"></p>
<p>代码实现：</p>
<p>Command：命令接口。抽象命令类（Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//撤销动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightReceiver：电灯接受者。实现者/接收者（Receiver）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯打开了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯关闭了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOnCommand：打开电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.light = light;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOffCommand：关闭电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoCommand：空命令。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做</span></span><br><span class="line"><span class="comment"> * 其实，这样是一种设计模式, 可以省掉对空判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteController：遥控器。调用者/请求者（Invoker）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 开 按钮的命令数组</span></span><br><span class="line">	Command[] onCommands;</span><br><span class="line">	Command[] offCommands;</span><br><span class="line">	<span class="comment">// 执行撤销的命令</span></span><br><span class="line">	Command undoCommand;</span><br><span class="line">	<span class="comment">// 构造器，完成对按钮初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">			offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给我们的按钮设置你需要的命令</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">		onCommands[no] = onCommand;</span><br><span class="line">		offCommands[no] = offCommand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下开按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的开的按钮， 并调用对应方法</span></span><br><span class="line">		onCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = onCommands[no];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下关按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的关的按钮， 并调用对应方法</span></span><br><span class="line">		offCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = offCommands[no];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下撤销按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		undoCommand.undo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。调用遥控器RemoteController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用命令设计模式，完成通过遥控器，对电灯的操作</span></span><br><span class="line">		<span class="comment">//创建电灯的对象(接受者)</span></span><br><span class="line">		LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();</span><br><span class="line">		<span class="comment">//创建电灯相关的开关命令</span></span><br><span class="line">		LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);</span><br><span class="line">		LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);</span><br><span class="line">		<span class="comment">//需要一个遥控器</span></span><br><span class="line">		RemoteController remoteController = <span class="keyword">new</span> RemoteController();</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;=========使用遥控器操作电视机==========&quot;</span>);</span><br><span class="line">		TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line">		TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);</span><br><span class="line">		TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-4、命令模式在Spring框架的应用与源码"><a href="#17-4、命令模式在Spring框架的应用与源码" class="headerlink" title="17.4、命令模式在Spring框架的应用与源码"></a>17.4、命令模式在Spring框架的应用与源码</h3><p>Spring 框架的 JdbcTemplate 就使用到了命令模式</p>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/164.png" alt="image-20210417014539023"></p>
<p>具体代码：</p>
<p>JdbcTemplate类的query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/165.png" alt="image-20210417021850007"></p>
<p>在query方法使用递归调用了query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/166.png" alt="image-20210417022006816"></p>
<p>query方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/167.png" alt="image-20210417022151453"></p>
<p>StatementCallback接口，里面有doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/168.png" alt="image-20210417022235885"></p>
<p>QueryStatementCallback这个静态内部类实现了StatementCallback接口，在里面实现了doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/169.png" alt="image-20210417022649537"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/170.png" alt="image-20210417022952614"></p>
<p>同时，QueryStatementCallback又作为实现者/接收者(Receiver) 角色执行execute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/171.png" alt="image-20210417023039518"></p>
<p>StatementCallback接口的其他实现类：ExecuteStatementCallback</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/173.png" alt="image-20210417023427416"></p>
<p>ExecuteStatementCallback的excute方法：最后调用了JdbcTemplate的excute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/172.png" alt="image-20210417023156907"></p>
<p>JdbcTemplate的excute方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/174.png" alt="image-20210417023635405"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/175.png" alt="image-20210417023940383"></p>
<h3 id="17-5、命令模式总结"><a href="#17-5、命令模式总结" class="headerlink" title="17.5、命令模式总结"></a>17.5、命令模式总结</h3><p>主要优点：</p>
<ol>
<li>通过<strong>引入中间件（抽象接口）降低系统的耦合度</strong>。</li>
<li><strong>扩展性良好</strong>，<strong>增加或删除命令非常方便</strong>。采用命令模式增加与删除命令不会影响其他类，且<strong>满足“开闭原则”</strong>。</li>
<li>可以实现宏命令。<strong>命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</strong>。</li>
<li><strong>方便实现 Undo 和 Redo 操作</strong>。命令模式可以与后面介绍的<strong>备忘录模式结合，实现命令的撤销与恢复</strong>。</li>
<li>可以在现有命令的基础上，<strong>增加额外功能</strong>。比如<strong>日志记录，结合装饰器模式会更加灵活</strong>。</li>
</ol>
<p>缺点是：</p>
<ol>
<li>可能产生<strong>大量具体的命令类</strong>。因为<strong>每一个具体操作都需要设计一个具体命令类</strong>，这会增加系统的复杂性。</li>
<li>命令模式的结果其实就是<strong>接收方的执行结果</strong>，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
</ol>
<p>命令模式的应用场景：</p>
<p>当系统的<strong>某项操作具备命令语义</strong>，且<strong>命令实现不稳定（变化）</strong>时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。<strong>接收方与抽象命令呈现弱耦合</strong>（内部方法无需一致），具备良好的扩展性。</p>
<p>命令模式通常适用于以下场景：</p>
<ol>
<li><strong>请求调用者需要与请求接收者解耦</strong>时，命令模式可以使调用者和接收者不直接交互。</li>
<li>系统<strong>随机请求命令或经常增加、删除命令</strong>时，命令模式可以方便地实现这些功能。</li>
<li>当系统需要<strong>执行一组操作</strong>时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要<strong>支持命令的撤销（Undo）操作和恢复（Redo）操作</strong>时，可以<strong>将命令对象存储起来</strong>，采用<strong>备忘录模式</strong>来实现。</li>
<li>界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制</li>
</ol>
<h3 id="17-6、命令模式扩展"><a href="#17-6、命令模式扩展" class="headerlink" title="17.6、命令模式扩展"></a>17.6、命令模式扩展</h3><p>在软件开发中，有时将命令模式与前面学的<strong>组合模式</strong>联合使用，这就构成了<strong>宏命令模式</strong>，也叫<strong>组合命令模式</strong>。<strong>宏命令包含了一组命令，它充当了具体命令与调用者的双重角色</strong>，执行它时将<strong>递归调用它所包含的所有命令</strong>，其具体结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/163.png" alt="image-20210417013804833"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCommand cmd1 = <span class="keyword">new</span> ConcreteCommand1();</span><br><span class="line">        AbstractCommand cmd2 = <span class="keyword">new</span> ConcreteCommand2();</span><br><span class="line">        CompositeInvoker ir = <span class="keyword">new</span> CompositeInvoker();</span><br><span class="line">        ir.add(cmd1);</span><br><span class="line">        ir.add(cmd2);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的execute()方法...&quot;</span>);</span><br><span class="line">        ir.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand1() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand2() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件: 调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeInvoker</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;AbstractCommand&gt; children = <span class="keyword">new</span> ArrayList&lt;AbstractCommand&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractCommand <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((AbstractCommand) obj).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action1()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action2()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-7、进阶阅读"><a href="#17-7、进阶阅读" class="headerlink" title="17.7、进阶阅读"></a>17.7、进阶阅读</h3><p>如果您想深入了解命令模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8485.html">《使用命令模式实现播放器功能》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8486.html">《命令模式在框架（JDK和JUnit）源码中的应用》</a></li>
</ul>
<h3 id="17-8、相关设计模式"><a href="#17-8、相关设计模式" class="headerlink" title="17.8、相关设计模式"></a>17.8、相关设计模式</h3><ul>
<li><p>Composite 模式</p>
<p>有时会使用Composite模式实现宏命令(macrocommand)。</p>
</li>
<li><p>Memento 模式</p>
<p>有时会使用Memento模式来保存Command角色的历史记录。</p>
</li>
<li><p>Protype 模式</p>
<p>有时会使用Protype模式复制发生的事件（生成的命令）。</p>
</li>
</ul>
<h3 id="17-9、命令模式的注意事项与细节"><a href="#17-9、命令模式的注意事项与细节" class="headerlink" title="17.9、命令模式的注意事项与细节"></a>17.9、命令模式的注意事项与细节</h3><ol>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：<strong>”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用</strong>。</li>
<li>容易设计一个<strong>命令队列</strong>。只要把命令对象放到列队，就可以<strong>多线程的执行命令</strong></li>
<li>容易实现<strong>对请求的撤销和重做</strong></li>
<li>命令模式不足：可能导致某些系统有<strong>过多的具体命令类</strong>，增加了系统的复杂度，这点在在使用的时候要注意</li>
<li><strong>空命令也是一种设计模式</strong>，它为我们<strong>省去了判空的操作</strong>。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li>
<li>命令模式经典的应用场景：<strong>界面的一个按钮都是一条命令</strong>、<strong>模拟 CMD（DOS 命令）订单的撤销/恢复</strong>、<strong>触发- 反馈机制</strong></li>
</ol>
<h2 id="18、访问者模式Visitor（行为型模式）"><a href="#18、访问者模式Visitor（行为型模式）" class="headerlink" title="18、访问者模式Visitor（行为型模式）"></a>18、访问者模式Visitor（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\176.png" alt="image-20210417141823535"></p>
<h3 id="18-1、基本介绍"><a href="#18-1、基本介绍" class="headerlink" title="18.1、基本介绍"></a>18.1、基本介绍</h3><ol>
<li>访问者模式（Visitor Pattern），<strong>封装一些作用于某种数据结构的各元素的操作</strong>，它可以在<strong>不改变数据结构</strong>的前提下定义作用于这些元素的<strong>新的操作</strong>。为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>
<li>主要将<strong>数据结构与数据操作分离</strong>，<strong>解决数据结构和操作耦合</strong>性问题</li>
<li>访问者模式的基本工作原理是：在<strong>被访问的类里面加一个对外提供接待访问者的接口</strong></li>
<li>访问者模式主要应用场景是：需要<strong>对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)**，同时需要</strong>避免让这些操作”污染”这些对象的类**，可以选用访问者模式解决</li>
</ol>
<h3 id="18-2、访问者模式的原理结构图-uml类图"><a href="#18-2、访问者模式的原理结构图-uml类图" class="headerlink" title="18.2、访问者模式的原理结构图-uml类图"></a>18.2、访问者模式的原理结构图-uml类图</h3><p>访问者（Visitor）模式实现的关键是<strong>如何将作用于元素的操作分离出来封装成独立的类</strong></p>
<h4 id="18-2-1、模式的结构"><a href="#18-2-1、模式的结构" class="headerlink" title="18.2.1、模式的结构"></a>18.2.1、模式的结构</h4><p>访问者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象访问者（Visitor）</strong>角色：<strong>定义一个访问具体元素的接口</strong>，为<strong>每个具体元素类对应一个访问操作 visit()</strong> ，该操作中的**参数类型标识了被访问的<code>具体元素</code>**。即：为该对象结构中的 ConcreteElement 的每一个类声明一个 visit 操作。</li>
<li><strong>具体访问者（ConcreteVisitor）</strong>角色：<strong>实现抽象访问者角色</strong>中声明的<strong>各个访问操作</strong>，确定访问者访问一个元素时该做什么。</li>
<li><strong>抽象元素（Element）</strong>角色：声明<strong>一个包含接受操作 accept() 的接口</strong>，<strong>被接受的访问者对象作为 accept() 方法的参数</strong>。即：定义一个 accept 方法，接收一个访问者对象。（与<strong>抽象访问者（Visitor）</strong>角色实现互相关联（但相关联的抽象元素的具体实现类））</li>
<li><strong>具体元素（ConcreteElement）</strong>角色：实现抽象元素角色提供的 accept() 操作，其<strong>方法体通常都是 visitor.visit(this)</strong> （<strong>双分派</strong>），另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li><strong>对象结构（Object Structure）</strong>角色：是<strong>一个包含元素角色的容器</strong>，提供让访问者对象遍历容器中的所有元素的方法，通常由 <code>List</code>、<code>Set</code>、<code>Map</code> 等聚合类实现。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/177.png" alt="img"></p>
<h4 id="18-2-2、代码实现"><a href="#18-2-2、代码实现" class="headerlink" title="18.2.2、代码实现"></a>18.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是具体的元素类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是Visitor访问类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过visit(this)实现双分派</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3、应用举例"><a href="#18-3、应用举例" class="headerlink" title="18.3、应用举例"></a>18.3、应用举例</h3><p>测评系统的需求</p>
<p>将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价有不同的种类，比如 成功、失败等，之后会增加一种状态“待定”以测试程序的扩展性)</p>
<h4 id="18-3-1、使用传统方式解决需求"><a href="#18-3-1、使用传统方式解决需求" class="headerlink" title="18.3.1、使用传统方式解决需求"></a>18.3.1、使用传统方式解决需求</h4><p>思路分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/178.png" alt="image-20210417144957917"></p>
<p>传统方式的问题分析：</p>
<ol>
<li>如果系统比较小，还是 ok 的，但是考虑<strong>系统增加越来越多新的功能</strong>时，对代码改动较大，<strong>违反了 ocp 原则</strong>， 不利于维护</li>
<li>扩展性不好，比如增加了新的人员类型，或者管理方法，都不好做</li>
<li>引出我们会使用新的设计模式 – 访问者模式</li>
</ol>
<h4 id="18-3-2、使用访问者模式解决需求"><a href="#18-3-2、使用访问者模式解决需求" class="headerlink" title="18.3.2、使用访问者模式解决需求"></a>18.3.2、使用访问者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/179.png" alt="image-20210417145718031"></p>
<p>代码实现：</p>
<p>Action：行为抽象类，在里面的方法将<strong>具体元素作为参数传入</strong>。<strong>抽象访问者（Visitor）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到男性 的测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span></span>;</span><br><span class="line">	<span class="comment">//得到女的 测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Success：成功的行为。<strong>具体访问者（ConcreteVisitor）</strong>角色（Fail失败与Wait待定等等行为类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 男人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 女人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person：人类，<strong>将访问者Visitor作为参数传入accept()方法</strong>。<strong>抽象元素（Element）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//提供一个方法，让访问者可以访问</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Man：男人，重写父类的accept方法，并在accept方法里调用<strong>访问者的方法并将this作为参数</strong>传入，以此实现双分派。<strong>具体元素（ConcreteElement）</strong>角色（Woman女人类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</span></span><br><span class="line"><span class="comment">//2. 然后Man类调用作为参数的 &quot;具体方法&quot; 中方法getWomanResult, 同时将自己(this)作为参数</span></span><br><span class="line"><span class="comment">//   传入，完成第二次的分派</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		action.getManResult(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectStructure：<strong>对象结构（Object Structure）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构，管理很多人（Man , Woman）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护了一个集合</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">//增加到list</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.add(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.remove(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示测评情况</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Person p: persons) &#123;</span><br><span class="line">			p.accept(action);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，用来进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建ObjectStructure</span></span><br><span class="line">		ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Man());</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Woman());</span><br><span class="line">		<span class="comment">// 成功</span></span><br><span class="line">		Success success = <span class="keyword">new</span> Success();</span><br><span class="line">		objectStructure.display(success);</span><br><span class="line">		<span class="comment">// 失败</span></span><br><span class="line">		System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">		Fail fail = <span class="keyword">new</span> Fail();</span><br><span class="line">		objectStructure.display(fail);</span><br><span class="line">  		<span class="comment">// 待定</span></span><br><span class="line">		System.out.println(<span class="string">&quot;=======给的是待定的测评========&quot;</span>);	</span><br><span class="line">		Wait wait = <span class="keyword">new</span> Wait();</span><br><span class="line">		objectStructure.display(wait);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4、双分派"><a href="#18-4、双分派" class="headerlink" title="18.4、双分派"></a>18.4、双分派</h3><p>整理一下 Visitor 模式中方法的调用关系：</p>
<ul>
<li><p>accept（接受）方法的调用方式如下：</p>
<p>element.accept(visitor); </p>
</li>
<li><p>visit（访问）方法的调用方式如下：</p>
</li>
<li><p> visitor.visit(element); </p>
</li>
</ul>
<p>对比一下这两个方法会发现， 它们是相反的关系。 <strong>element 接受 visitor, 而 visitor 又访问 element</strong>。</p>
<p>在 Visitor 模式中， ConcreteElement 和 ConcreteVisitor 这两个角色<strong>共同决定了实际进行的处理</strong>。这种消息分发的方式一般被称为双重分发 (double dispatch)。</p>
<p>访问者模式为了实现所谓的“双重分派”，设计了<strong>一个回调再回调的机制</strong>。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>所谓双分派是指<strong>不管类怎么变化</strong>，我们<strong>都能找到期望的方法运行</strong>。双分派意味着<strong>得到执行的操作取决于请求的种类和两个接收者的类型</strong></p>
<p>上述实例为例，假设我们要添加一个 <strong>Wait</strong> 的状态类，考察 <strong>Man</strong> 类和 <strong>Woman</strong> 类的反应，由于使用了双分派，只需增加一个 Action 子类即可在客户端调用即可，不需要改动任何其他类的代码。</p>
<h3 id="18-5、访问者模式总结"><a href="#18-5、访问者模式总结" class="headerlink" title="18.5、访问者模式总结"></a>18.5、访问者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li><strong>复用性好</strong>。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li><strong>灵活性好</strong>。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li><strong>符合单一职责原则</strong>。访问者模式<strong>把相关的行为封装在一起，构成一个访问者</strong>，使每一个访问者的功能都比较单一。可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>增加新的元素类很困难</strong>。在访问者模式中，每增加一个新的元素类，都要在<strong>每一个具体访问者类中增加相应的具体操作</strong>，这<strong>违背了“开闭原则”</strong>。</li>
<li><strong>破坏封装</strong>。访问者模式中<strong>具体元素对访问者公布细节</strong>，这破坏了对象的封装性。</li>
<li><strong>违反了依赖倒置原则</strong>。访问者模式<strong>依赖了具体类，而没有依赖抽象类</strong>。</li>
<li>具体元素对访问者公布细节，<strong>违反了迪米特原则</strong></li>
</ol>
<p>总结一下就是：易于增加的ConcreteVisitor角色，难以增加的ConcreteElement角色</p>
<p>模式的应用场景：</p>
<p>当系统中存在<strong>类型数量稳定（固定）的一类数据结构</strong>时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。</p>
<p>简而言之，就是<strong>当对集合中的不同类型数据（类型数量稳定）进行多种操作</strong>时，使用访问者模式。</p>
<p>通常在以下情况可以考虑使用访问者（Visitor）模式：</p>
<ol>
<li><strong>对象结构相对稳定</strong>，但其<strong>操作算法经常变化</strong>的程序。</li>
<li>对象结构中的对象<strong>需要提供多种不同且不相关的操作</strong>，而且要<strong>避免让这些操作的变化影响对象</strong>的结构。</li>
<li><strong>对象结构包含很多类型的对象</strong>，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ol>
<h3 id="18-6、访问者模式扩展"><a href="#18-6、访问者模式扩展" class="headerlink" title="18.6、访问者模式扩展"></a>18.6、访问者模式扩展</h3><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它<strong>常常同以下两种设计模式联用</strong>。</p>
<ul>
<li>与“<strong>迭代器模式</strong>”联用。因为访问者模式中的“<strong>对象结构</strong>”是一个<strong>包含元素角色的容器</strong>，当<strong>访问者遍历容器中的所有元素时，常常要用迭代器</strong>。如应用举例中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</li>
<li><strong>访问者（Visitor）模式</strong>同“<strong>组合模式</strong>”联用。因为访问者（Visitor）模式中的“<strong>元素对象</strong>”<strong>可能是叶子对象或者是容器对象</strong>，如果<strong>元素对象包含容器对象，就必须用到组合模式</strong>，其结构图如图：</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/180.png" alt="image-20210417153952680"></p>
<h3 id="18-7、进阶阅读"><a href="#18-7、进阶阅读" class="headerlink" title="18.7、进阶阅读"></a>18.7、进阶阅读</h3><p>如果您想深入了解访问者模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8499.html">《访问者模式的伪动态双分派》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8501.html">《访问者模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8502.html">《访问者模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="18-8、相关设计模式"><a href="#18-8、相关设计模式" class="headerlink" title="18.8、相关设计模式"></a>18.8、相关设计模式</h3><ul>
<li><p>Iterator模式</p>
<p>Iterator模式和Visitor模式都是在某种数据结构上进行处理。 </p>
<p>Iterator模式用于逐个遍历保存在数据结构中的元素。</p>
<p>Visitor模式用于对保存在数据结构中的元素进行某种特定的处理。</p>
</li>
<li><p>Composite模式</p>
<p>有时访问者所访问的数据结构会使用Composite模式。</p>
</li>
<li><p>Interpreter模式</p>
<p>在Interpreter模式中， 有时会使用Visitor模式。 例如， 在生成了语法树后， 可能会使用Visitor 模式访问语法树的各个节点进行处理。</p>
</li>
</ul>
<h2 id="19、迭代器模式Iterator（行为型模式）"><a href="#19、迭代器模式Iterator（行为型模式）" class="headerlink" title="19、迭代器模式Iterator（行为型模式）"></a>19、迭代器模式Iterator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/181.png" alt="image-20210417155331998"></p>
<h3 id="19-1、基本介绍"><a href="#19-1、基本介绍" class="headerlink" title="19.1、基本介绍"></a>19.1、基本介绍</h3><ol>
<li>迭代器模式（Iterator Pattern）是常用的设计模式，属于<strong>行为型模式</strong></li>
<li>如果我们的<strong>集合元素是用不同的方式实现</strong>的，有数组，还有 java 的集合类，或者还有其他方式，当客户端<strong>要遍历</strong>这些集合元素的时候<strong>就要使用多种遍历方式</strong>，而且还<strong>会暴露元素的内部结构</strong>，可以考虑使用迭代器模式解决。</li>
<li>迭代器模式，<strong>提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素</strong>，不需要知道集合对象的底层表示，即：<strong>不暴露其内部的结构</strong>。</li>
<li>迭代器模式在客户访问类与聚合类之间插入一个迭代器，这<strong>分离了聚合对象与其遍历行为</strong>，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</li>
</ol>
<h3 id="19-2、迭代器模式的原理结构图-uml类图"><a href="#19-2、迭代器模式的原理结构图-uml类图" class="headerlink" title="19.2、迭代器模式的原理结构图-uml类图"></a>19.2、迭代器模式的原理结构图-uml类图</h3><p>迭代器模式是通过将<strong>聚合对象的遍历行为分离出来，抽象成迭代器类</strong>来实现的，其目的是<strong>在不暴露聚合对象的内部结构的</strong>情况下，<strong>让外部代码透明地访问聚合的内部数据</strong>。现在我们来分析其基本结构与实现方法。</p>
<h4 id="19-2-1、-模式的结构"><a href="#19-2-1、-模式的结构" class="headerlink" title="19.2.1、 模式的结构"></a>19.2.1、 模式的结构</h4><p>迭代器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象聚合（Aggregate）</strong>角色：一个统一的聚合接口， 将客户端和具体聚合解耦。定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li><strong>具体聚合（ConcreteAggregate）</strong>角色：实现抽象聚合类，并提供一个方法，返回一个具体迭代器的实例。该迭代器可以正确遍历集合</li>
<li><strong>抽象迭代器（Iterator）</strong>角色：<strong>定义访问和遍历聚合元素的接口</strong>，是java系统提供的，通常包含 <strong>hasNext()、remove()、next()</strong> 等方法。</li>
<li><strong>具体迭代器（Concretelterator）</strong>角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
<li><strong>Client</strong> :客户端，  通过 Iterator 和   Aggregate 依赖子类</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/183.png" alt="image-20210417182430431"></p>
<h4 id="19-2-2、代码实现"><a href="#19-2-2、代码实现" class="headerlink" title="19.2.2、代码实现"></a>19.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it = ag.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object ob = it.next();</span><br><span class="line">            System.out.print(ob.toString() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object ob = it.first();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFirst：&quot;</span> + ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ConcreteIterator(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-3、应用举例"><a href="#19-3、应用举例" class="headerlink" title="19.3、应用举例"></a>19.3、应用举例</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/184.png" alt="image-20210417183413954"></p>
<h4 id="19-3-1、使用传统方式解决需求"><a href="#19-3-1、使用传统方式解决需求" class="headerlink" title="19.3.1、使用传统方式解决需求"></a>19.3.1、使用传统方式解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统的方式的问题分析：</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的遍历的操作</li>
<li>解决方案：=&gt; 迭代器模式</li>
</ol>
<h4 id="19-3-2、使用迭代器模式解决需求"><a href="#19-3-2、使用迭代器模式解决需求" class="headerlink" title="19.3.2、使用迭代器模式解决需求"></a>19.3.2、使用迭代器模式解决需求</h4><p>原理类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/186.png" alt="image-20210417184732598"></p>
<p>代码实现：</p>
<p>Department：专业。元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象迭代器（Iterator）</strong>角色：java自带的Iterator迭代器接口</p>
<p>ComputerCollegeIterator：计算机学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollegeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们需要Department 是以怎样的方式存放=&gt;数组</span></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">//遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollegeIterator</span><span class="params">(Department[] departments)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departments = departments;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(position &gt;= departments.length || departments[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Department department = departments[position];</span><br><span class="line">		position += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> department;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除的方法，默认空实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoColleageIterator：信息学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoColleageIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList; <span class="comment">// 信息工程学院是以List方式存放系</span></span><br><span class="line">	<span class="keyword">int</span> index = -<span class="number">1</span>;<span class="comment">//索引</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoColleageIterator</span><span class="params">(List&lt;Department&gt; departmentList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departmentList = departmentList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断list中还有没有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(index &gt;= departmentList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			index += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> departmentList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//空实现remove</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院接口，里面有createIterator()方法返回一个迭代器。<strong>抽象聚合（Aggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//增加系的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span></span>;</span><br><span class="line">	<span class="comment">//返回一个迭代器,遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ComputerCollege：计算机学院，实现学院接口，里面对专业这个元素<strong>采用数组方式</strong>存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> numOfDepartment = <span class="number">0</span> ;<span class="comment">// 保存当前数组的对象个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departments = <span class="keyword">new</span> Department[<span class="number">5</span>];</span><br><span class="line">		addDepartment(<span class="string">&quot;Java专业&quot;</span>, <span class="string">&quot; Java专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;PHP专业&quot;</span>, <span class="string">&quot; PHP专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;大数据专业&quot;</span>, <span class="string">&quot; 大数据专业 &quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;计算机学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departments[numOfDepartment] = department;</span><br><span class="line">		numOfDepartment += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ComputerCollegeIterator(departments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoCollege：信息学院，实现学院接口，里面对专业这个元素<strong>采用集合</strong>方式存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departmentList = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line">		addDepartment(<span class="string">&quot;信息安全专业&quot;</span>, <span class="string">&quot; 信息安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;网络安全专业&quot;</span>, <span class="string">&quot; 网络安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;服务器安全专业&quot;</span>, <span class="string">&quot; 服务器安全专业 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;信息工程学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departmentList.add(department);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InfoColleageIterator(departmentList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OutPutImpl：遍历实现对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPutImpl</span> </span>&#123;</span><br><span class="line">	<span class="comment">//学院集合</span></span><br><span class="line">	List&lt;College&gt; collegeList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OutPutImpl</span><span class="params">(List&lt;College&gt; collegeList)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.collegeList = collegeList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有学院,然后调用printDepartment 输出各个学院的系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator</span></span><br><span class="line">		Iterator&lt;College&gt; iterator = collegeList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//取出一个学院</span></span><br><span class="line">			College college = iterator.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;=== &quot;</span>+college.getName() +<span class="string">&quot;=====&quot;</span> );</span><br><span class="line">			printDepartment(college.createIterator()); <span class="comment">//得到对应迭代器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出 学院输出 系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printDepartment</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			Department d = (Department)iterator.next();</span><br><span class="line">			System.out.println(d.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建学院</span></span><br><span class="line">		List&lt;College&gt; collegeList = <span class="keyword">new</span> ArrayList&lt;College&gt;();</span><br><span class="line">		ComputerCollege computerCollege = <span class="keyword">new</span> ComputerCollege();</span><br><span class="line">		InfoCollege infoCollege = <span class="keyword">new</span> InfoCollege();</span><br><span class="line">        </span><br><span class="line">		collegeList.add(computerCollege);</span><br><span class="line">		collegeList.add(infoCollege);</span><br><span class="line">        </span><br><span class="line">		OutPutImpl outPutImpl = <span class="keyword">new</span> OutPutImpl(collegeList);</span><br><span class="line">		outPutImpl.printCollege();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4、迭代器模式在JDK的应用与源码"><a href="#19-4、迭代器模式在JDK的应用与源码" class="headerlink" title="19.4、迭代器模式在JDK的应用与源码"></a>19.4、迭代器模式在JDK的应用与源码</h3><p>JDK 的 <strong>ArrayList</strong> 集合中就使用了迭代器模式</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/189.png" alt="image-20210417202305992"></p>
<p>角色说明：</p>
<ul>
<li>内部类 Itr 充当具体实现迭代器 Iterator 的类， 作为 ArrayList 内部类</li>
<li>List 就是充当了聚合接口，含有一个 iterator() 方法，返回一个迭代器对象</li>
<li>ArrayList 是实现聚合接口 List 的子类，实现了 iterator()</li>
<li>Iterator 接口系统提供</li>
<li>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li>
</ul>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/188.png" alt="image-20210417200928815"></p>
<p>List接口，其中有获取迭代器Iterator的抽象方法，交给实现类去实现</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/191.png" alt="image-20210417203037908"></p>
<p>ArrayList实现了List接口，并实现了List接口的Iterator方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/190.png" alt="image-20210417202736654"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/192.png" alt="image-20210417203908088"></p>
<p>在ArrayList中把元素对象存进了数组里面</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/193.png" alt="image-20210417204155507"></p>
<p>Itr为ArrayList的内部类，实现了Iterator接口，并实现了接口的next()方法与hasNext()方法，由于元素是定义在ArrayList当中的，直接使用即可。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/194.png" alt="image-20210417204819687"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/195.png" alt="image-20210417205056646"></p>
<p>另外实现List接口的实现类的LinkedList类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/196.png" alt="image-20210417210006152"></p>
<p>LinkedList继承了AbstractSequentialList类实现了AbstractSequentialList类当中的Iterator迭代器方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/197.png" alt="image-20210417210011958"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/198.png" alt="image-20210417211542896"></p>
<p>Enumerator实现了Iterator接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/200.png" alt="image-20210417224627356"></p>
<h3 id="19-5、迭代器模式总结"><a href="#19-5、迭代器模式总结" class="headerlink" title="19.5、迭代器模式总结"></a>19.5、迭代器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>访问一个聚合对象的内容而无须暴露它的内部</strong>表示。</li>
<li><strong>遍历任务交由迭代器完成</strong>，这简化了聚合类。</li>
<li>它<strong>支持以不同方式遍历一个聚合</strong>，甚至可以<strong>自定义迭代器的子类以支持新的遍历</strong>。</li>
<li><strong>增加新的聚合类和迭代器类</strong>都很方便，<strong>无须修改原有代码</strong>。</li>
<li><strong>封装性良好</strong>，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<p>其主要缺点是：<strong>增加了类的个数</strong>，这在一定程度上增加了系统的复杂性。</p>
<p>在日常开发中，我们<strong>几乎不会自己写迭代器</strong>。除非需要定制一个自己实现的数据结构对应的迭代器，否则，<strong>开源框架提供的 API 完全够用</strong>。</p>
<p>应用场景：</p>
<ol>
<li>当<strong>需要为聚合对象提供多种遍历方式</strong>时。</li>
<li>当<strong>需要为遍历不同的聚合结构提供一个统一的接口</strong>时。</li>
<li>当<strong>访问一个聚合对象的内容而无须暴露其内部细节的表示</strong>时。</li>
<li>当要<strong>展示一组相似对象，或者遍历一组相同对象</strong>时。</li>
</ol>
<p>由于<strong>聚合与迭代器的关系非常密切</strong>，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p>
<h3 id="19-6、迭代器模式扩展"><a href="#19-6、迭代器模式扩展" class="headerlink" title="19.6、迭代器模式扩展"></a>19.6、迭代器模式扩展</h3><p><strong>迭代器模式常常与组合模式结合起来使用</strong>，在<strong>对组合模式中的容器构件进行访问</strong>时，经常<strong>将迭代器潜藏在组合模式的容器构成类</strong>中。当然也<strong>可以构造一个外部迭代器来对容器构件进行访问</strong>，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/187.png" alt="image-20210417200821530"></p>
<h3 id="19-7、进阶阅读"><a href="#19-7、进阶阅读" class="headerlink" title="19.7、进阶阅读"></a>19.7、进阶阅读</h3><p>如果您想了解迭代器模式在框架源码中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8497.html">《迭代器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8498.html">《迭代器模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="19-8、相关设计模式"><a href="#19-8、相关设计模式" class="headerlink" title="19.8、相关设计模式"></a>19.8、相关设计模式</h3><ul>
<li><p>Visitor 模式</p>
<p>Iterator模式是从集合中一个一个取出元素进行遍历， 但是并没有在Iterator接口中声明对取出的元素进行何种处理。</p>
<p>Visitor模式则是在遍历元素集合的过程中， 对元素进行相同的处理。</p>
<p>在遍历集合的过程中对元素进行固定的处理是常有的需求。 Visitor模式正是为了应对这种需求而出现的。 在访问元素集合的过程中对元素进行相同的处理， 这种模式就是Visitor模式。</p>
</li>
<li><p>Composite 模式</p>
<p>Composite模式是具有递归结构的模式， 在其中使用Iterator模式比较困难。</p>
</li>
<li><p>Factory Method 模式</p>
<p>在iterator方法中生成Iterator的实例时可能会使用Factory Method模式。</p>
</li>
</ul>
<h3 id="19-9、迭代器模式的注意事项与细节"><a href="#19-9、迭代器模式的注意事项与细节" class="headerlink" title="19.9、迭代器模式的注意事项与细节"></a>19.9、迭代器模式的注意事项与细节</h3><p>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。</p>
<h2 id="20、观察者模式Observer（行为型模式）"><a href="#20、观察者模式Observer（行为型模式）" class="headerlink" title="20、观察者模式Observer（行为型模式）"></a>20、观察者模式Observer（行为型模式）</h2><h3 id="20-1、基本介绍"><a href="#20-1、基本介绍" class="headerlink" title="20.1、基本介绍"></a>20.1、基本介绍</h3><ol>
<li><p>观察者（Observer）模式的定义：指<strong>多个对象间存在一对多的依赖关系</strong>，当<strong>一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作<strong>发布-订阅模式</strong>、<strong>模型-视图模式</strong>，它是<strong>对象行为型模式</strong>。</p>
</li>
<li><p>观察者模式类似订牛奶业务</p>
</li>
<li><p>奶站/气象局：Subject 用户/第三方网站：Observer</p>
</li>
<li><p>Subject：登记注册、移除和通知</p>
<ul>
<li>registerObserver 注 册</li>
<li>removeObserver 移 除</li>
<li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送， 看具体需求定</li>
<li>Observer：接收输入</li>
</ul>
<p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject</p>
<p>通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p>
</li>
</ol>
<h3 id="20-2、观察者模式的原理结构图-uml类图"><a href="#20-2、观察者模式的原理结构图-uml类图" class="headerlink" title="20.2、观察者模式的原理结构图-uml类图"></a>20.2、观察者模式的原理结构图-uml类图</h3><p>实现观察者模式时要注意<strong>具体目标对象</strong>和<strong>具体观察者对象之间不能直接调用</strong>，否则<strong>将使两者之间紧密耦合起来</strong>，这<strong>违反了面向对象的设计原则</strong>。</p>
<h4 id="20-2-1、模式的结构"><a href="#20-2-1、模式的结构" class="headerlink" title="20.2.1、模式的结构"></a>20.2.1、模式的结构</h4><p>观察者模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>角色：也叫<strong>抽象目标类</strong>，它提供了一个<strong>用于保存观察者对象的聚集类和增加、删除观察者对象的方法</strong>，以及<strong>通知所有观察者的抽象方法</strong>。</li>
<li><strong>具体主题（Concrete Subject）</strong>角色：也叫<strong>具体目标类</strong>，它<strong>实现抽象目标中的通知方法</strong>，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者（Observer）</strong>角色：它是<strong>一个抽象类或接口</strong>，它<strong>包含了一个更新自己的抽象方法</strong>，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者（Concrete Observer）</strong>角色：<strong>实现抽象观察者中定义的抽象方法</strong>，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p>观察者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/199.png" alt="image-20210417224339045"></p>
<h4 id="20-2-2、代码实现"><a href="#20-2-2、代码实现" class="headerlink" title="20.2.2、代码实现"></a>20.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1 = <span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3、应用举例"><a href="#20-3、应用举例" class="headerlink" title="20.3、应用举例"></a>20.3、应用举例</h3><p>天气预报项目需求，具体要求如下：</p>
<ol>
<li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li>
<li>需要设计开放型 <strong>API</strong>，便于其他第三方也能接入气象站获取数据。</li>
<li>提供温度、气压和湿度的接口</li>
<li>测量数据更新时，要能实时的通知给第三方</li>
</ol>
<h4 id="20-3-1、使用传统方法解决需求"><a href="#20-3-1、使用传统方法解决需求" class="headerlink" title="20.3.1、使用传统方法解决需求"></a>20.3.1、使用传统方法解决需求</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001550797.png" alt="image-20210418001550797"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001617106.png" alt="image-20210418001617106"></p>
<p>实现代码：</p>
<p>WeatherData：天气情况</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002547098.png" alt="image-20210418002547098"></p>
<p>CurrentConditions</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002701455.png" alt="image-20210418002701455"></p>
<p>Client</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002801559.png" alt="image-20210418002801559"></p>
<p>问题分析：</p>
<ol>
<li>其他第三方接入气象站获取数据的问题</li>
<li>无法在运行时动态的添加第三方 (新浪网站)</li>
<li>违反 ocp 原则=&gt;观察者模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-3-2、使用观察者模式解决需求"><a href="#20-3-2、使用观察者模式解决需求" class="headerlink" title="20.3.2、使用观察者模式解决需求"></a>20.3.2、使用观察者模式解决需求</h4><p>类图说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002150098.png" alt="image-20210418002150098"></p>
<p>代码实现：</p>
<p>Subject：<strong>抽象主题（Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口, 让WeatherData 来实现 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WeatherData：包含最新的天气情况信息。<strong>具体主题（Concrete Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类是核心</span></span><br><span class="line"><span class="comment"> * 1. 包含最新的天气情况信息 </span></span><br><span class="line"><span class="comment"> * 2. 含有 观察者集合，使用ArrayList管理</span></span><br><span class="line"><span class="comment"> * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">//观察者集合</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">	<span class="comment">//加入新的第三方</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> temperatrue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pressure;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> humidity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用 接入方的 update</span></span><br><span class="line">		notifyObservers();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		<span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">		dataChange();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		observers.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">			observers.remove(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">			observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer：观察者接口，由观察者来实现。<strong>抽象观察者（Observer）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者接口，由观察者来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CurrentConditions：当前环境。<strong>具体观察者（Concrete Observer）</strong>角色（百度、新浪等等第三方类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 温度，气压，湿度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个WeatherData</span></span><br><span class="line">		WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">		<span class="comment">//创建观察者</span></span><br><span class="line">		CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line">		BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();</span><br><span class="line">		<span class="comment">//注册到weatherData</span></span><br><span class="line">		weatherData.registerObserver(currentConditions);</span><br><span class="line">		weatherData.registerObserver(baiduSite);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">		weatherData.removeObserver(currentConditions);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4、观察者模式在JDK的应用与源码"><a href="#20-4、观察者模式在JDK的应用与源码" class="headerlink" title="20.4、观察者模式在JDK的应用与源码"></a>20.4、观察者模式在JDK的应用与源码</h3><p>Jdk 的 Observable 类就使用了观察者模式</p>
<p>角色分析：</p>
<ul>
<li>Observable  的作用和地位等价于 我们前面讲过 Subject</li>
<li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法 add.. delete .. notify…</li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update</li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式</li>
</ul>
<p>代码分析</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015159710.png" alt="image-20210418015159710"></p>
<p>Observable：相当于Subject接口，但是Observable为一个普通的类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015442922.png" alt="image-20210418015442922"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015737148.png" alt="image-20210418015737148"></p>
<p>Observe接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015636229.png" alt="image-20210418015636229"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418020018759.png" alt="image-20210418020018759"></p>
<h3 id="20-5、观察者模式总结"><a href="#20-5、观察者模式总结" class="headerlink" title="20.5、观察者模式总结"></a>20.5、观察者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了目标与观察者之间的耦合关系</strong>，两者之间是抽象耦合关系。<strong>符合依赖倒置原则</strong>。</li>
<li><strong>目标与观察者之间建立了一套触发机制</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><p>如果在<strong>观察者和观察目标之间有循环依赖</strong>的话，<strong>观察目标会触发它们之间进行循环调用，可能导致系统崩溃</strong></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418011458744.png" alt="image-20210418011458744"></p>
</li>
<li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
</li>
<li><p>当<strong>观察者对象很多</strong>时，<strong>通知的发布会花费很多时间，影响程序的效率</strong>。</p>
</li>
</ol>
<p>在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。</p>
<p>观察者模式的应用情景：</p>
<ol>
<li>对象间<strong>存在一对多关系</strong>，<strong>一个对象的改变将导致其他一个或多个对象也发生改变</strong>，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>当<strong>一个抽象模型有两个方面</strong>，其中<strong>一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</strong>。</li>
<li><strong>实现类似广播机制的功能</strong>，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，<strong>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</strong></li>
</ol>
<h3 id="20-6、观察者模式扩展"><a href="#20-6、观察者模式扩展" class="headerlink" title="20.6、观察者模式扩展"></a>20.6、观察者模式扩展</h3><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口<strong>定义了观察者模式</strong>，只要实现它们的子类就可以编写观察者模式实例。</p>
<h4 id="20-6-1、-Observable类"><a href="#20-6-1、-Observable类" class="headerlink" title="20.6.1、 Observable类"></a>20.6.1、 Observable类</h4><p>Observable 类是<strong>抽象目标类</strong>，它<strong>有一个 Vector 向量</strong>，<strong>用于保存所有要通知的观察者对象</strong>，下面来介绍它最重要的 3 个方法：</p>
<ol>
<li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li>
<li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。<strong>通常越晚加入向量的观察者越先得到通知</strong>。（类似于栈结构）</li>
<li>void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。</li>
</ol>
<h4 id="20-6-2、-Observer-接口"><a href="#20-6-2、-Observer-接口" class="headerlink" title="20.6.2、 Observer 接口"></a>20.6.2、 Observer 接口</h4><p>Observer 接口是<strong>抽象观察者</strong>，它<strong>监视目标对象的变化</strong>，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。</p>
<h4 id="20-6-3、对应例子"><a href="#20-6-3、对应例子" class="headerlink" title="20.6.3、对应例子"></a>20.6.3、对应例子</h4><p>利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例。</p>
<p>分析：当原油价格上涨时，空方伤心，多方局兴；当油价下跌时，空方局兴，多方伤心。本实例中的抽象目标（Observable）类在 Java 中已经定义，可以直接定义其子类，即原油期货（OilFutures）类，它是具体目标类，该类中定义一个 SetPriCe(float price) 方法，当原油数据发生变化时调用其父类的 notifyObservers(Object arg) 方法来通知所有观察者；另外，本实例中的抽象观察者接口（Observer）在 Java 中已经定义，只要定义其子类，即具体观察者类（包括多方类 Bull 和空方类 Bear），并实现 update(Observable o,Object arg) 方法即可。</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418010916983.png" alt="image-20210418010916983"></p>
<h4 id="20-6-4、java-util-Observer接口和java-util-Observable类的相关解析"><a href="#20-6-4、java-util-Observer接口和java-util-Observable类的相关解析" class="headerlink" title="20.6.4、java. util.Observer接口和java. util . Observable类的相关解析"></a>20.6.4、java. util.Observer接口和java. util . Observable类的相关解析</h4><p>话虽如此，但是java. util.Observer接口和java. util . Observable类并不好用。理由很简单，传递给java. util . Observer接口的Subject角色必须是java . util. Observable类型(或者它的子类型)的。但Java只能单继承， 也就说如果Subject角色已经是某个类的子类了，那么它将无法继承java . util . Observable类。</p>
<h3 id="20-7、进阶阅读"><a href="#20-7、进阶阅读" class="headerlink" title="20.7、进阶阅读"></a>20.7、进阶阅读</h3><p>如果您想了解观察者模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8494.html">《基于Java API实现通知机制》</a>文章。</p>
<h3 id="20-8、相关设计模式"><a href="#20-8、相关设计模式" class="headerlink" title="20.8、相关设计模式"></a>20.8、相关设计模式</h3><p>Mediator模式</p>
<ul>
<li>在Mediator模式中，有时会使用Observer模式来实现Mediator角色与Colleague角色之间的通信。</li>
<li>就“发送状态变化通知”这一- 点而言，Mediator 模式与Observer模式是类似的。不过，两种模式中，通知的目的和视角不同。</li>
<li>在Mediator模式中，虽然也会发送通知，不过那不过是为了对Colleague角色进行仲裁而已。</li>
<li>而在Observer模式中，将Subject角色的状态变化通知给Observer 角色的目的则主要是为了使Subject角色和Observer角色同步。</li>
</ul>
<h3 id="20-9、观察者模式的注意事项与细节"><a href="#20-9、观察者模式的注意事项与细节" class="headerlink" title="20.9、观察者模式的注意事项与细节"></a>20.9、观察者模式的注意事项与细节</h3><ol>
<li>观察者模式，又称<strong>发布-订阅模式</strong>，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身</li>
<li>JAVA 中已经有了对观察者模式的支持类，但一般不支持使用。</li>
<li><strong>避免循环引用</strong>。</li>
<li>各个观察者是<strong>依次获得的同步通知</strong>，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，<strong>一般采用异步方式</strong>。</li>
</ol>
<h2 id="21、中介者模式Mediator（行为型模式）"><a href="#21、中介者模式Mediator（行为型模式）" class="headerlink" title="21、中介者模式Mediator（行为型模式）"></a>21、中介者模式Mediator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418021014591.png" alt="image-20210418021014591"></p>
<h3 id="21-1、基本介绍"><a href="#21-1、基本介绍" class="headerlink" title="21.1、基本介绍"></a>21.1、基本介绍</h3><ol>
<li><p>中介者模式（Mediator Pattern），又称调停者模式，是迪米特法则的典型应用。用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
</li>
<li><p>中介者模式属于行为型模式，使代码易于维护</p>
</li>
<li><p>比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141702195.png" alt="image-20210418141702195"></p>
</li>
</ol>
<h3 id="21-2、中介者模式的原理结构图-uml类图"><a href="#21-2、中介者模式的原理结构图-uml类图" class="headerlink" title="21.2、中介者模式的原理结构图-uml类图"></a>21.2、中介者模式的原理结构图-uml类图</h3><p>中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。</p>
<h4 id="21-2-1、模式的结构"><a href="#21-2-1、模式的结构" class="headerlink" title="21.2.1、模式的结构"></a>21.2.1、模式的结构</h4><p>中介者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象中介者（Mediator）</strong>角色：它是中介者的接口，<strong>提供了同事对象注册与转发同事对象信息</strong>的抽象方法。</li>
<li><strong>具体中介者（Concrete Mediator）</strong>角色：实现中介者接口，定义一个 List 来管理同事对象，<strong>协调各个同事角色之间的交互关系</strong>，因此<strong>它依赖于同事角色</strong>。</li>
<li><strong>抽象同事类（Colleague）</strong>角色：定义同事类的接口，<strong>保存中介者对象</strong>，<strong>提供同事对象交互的抽象方法</strong>，<strong>实现所有相互影响的同事类的公共功能</strong>。</li>
<li><strong>具体同事类（Concrete Colleague）</strong>角色：是抽象同事类的实现者，当需要与其他同事对象交互时，<strong>由中介者对象负责后续的交互。</strong></li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141912987.png" alt="image-20210418141912987"></p>
<p>中介者模式的结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141852365.png" alt="image-20210418141852365"></p>
<h4 id="21-2-2、代码实现"><a href="#21-2-2、代码实现" class="headerlink" title="21.2.2、代码实现"></a>21.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator md = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;Colleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ((Colleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3、应用举例"><a href="#21-3、应用举例" class="headerlink" title="21.3、应用举例"></a>21.3、应用举例</h3><p>智能家庭项目：</p>
<ol>
<li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等</li>
<li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作</li>
<li>比如流程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li>
</ol>
<h4 id="21-3-1、使用传统方式解决需求"><a href="#21-3-1、使用传统方式解决需求" class="headerlink" title="21.3.1、使用传统方式解决需求"></a>21.3.1、使用传统方式解决需求</h4><p>思路分析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142259490.png" alt="image-20210418142259490"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂</li>
<li><strong>各个电器对象彼此联系，你中有我，我中有你，不利于松耦合</strong>.</li>
<li>各个电器对象之间所传递的消息(参数)，容易混乱当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 =》 考虑中介者模式</li>
</ol>
<h4 id="21-3-2、使用中介者模式解决需求"><a href="#21-3-2、使用中介者模式解决需求" class="headerlink" title="21.3.2、使用中介者模式解决需求"></a>21.3.2、使用中介者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142556064.png" alt="image-20210418142556064"></p>
<p>代码实现：</p>
<p>Mediator：中介者。<strong>抽象中介者（Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line">	<span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Colleague：<strong>抽象同事类（Colleague）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mediator mediator;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteMediator：<strong>具体中介者（Concrete Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将具体的同事类放入集合中</span></span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Alarm&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;CoffeeMachine&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;TV&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Curtains&quot;</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">&quot;CoffeeMachine&quot;</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//处理咖啡机发出的消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">&quot;Curtains&quot;</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体同事类（Concrete Colleague）</strong>角色：</p>
<p>Alarm：闹钟同事类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeMachine：咖啡机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to startcoffee!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;After 5 minutes!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Coffee is ok!&quot;</span>);</span><br><span class="line">		SendMessage(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TV：电视机、Curtains：窗帘类似</p>
<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个中介者对象</span></span><br><span class="line">		Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">		<span class="comment">//创建Alarm 并且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">		<span class="comment">//创建了CoffeeMachine 对象，并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachine(mediator,<span class="string">&quot;coffeeMachine&quot;</span>);</span><br><span class="line">		<span class="comment">//创建 Curtains , 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">&quot;curtains&quot;</span>);</span><br><span class="line">		TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">&quot;TV&quot;</span>);</span><br><span class="line">		<span class="comment">//让闹钟发出消息</span></span><br><span class="line">		alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">		coffeeMachine.FinishCoffee();</span><br><span class="line">		alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-4、中介者模式总结"><a href="#21-4、中介者模式总结" class="headerlink" title="21.4、中介者模式总结"></a>21.4、中介者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>类之间各司其职，符合迪米特法则。</strong></li>
<li><strong>降低了对象之间的耦合性</strong>，使得对象易于独立地被复用。</li>
<li>将<strong>对象间的一对多关联转变为一对一的关联</strong>，把<strong>多边关系变成多个双边关系</strong>，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>中介者模式将原本<strong>多个对象直接的相互依赖</strong>变成了<strong>中介者和多个同事类的依赖关系</strong>。</li>
<li>当<strong>同事类越多</strong>时，<strong>中介者就会越臃肿</strong>，变得复杂且难以维护。</li>
</ol>
<p>中介者模式的应用场景：</p>
<ul>
<li>当<strong>对象之间存在复杂的网状结构关系</strong>而导致依赖关系混乱且难以复用时。</li>
<li>当想<strong>创建一个运行于多个类之间的对象，又不想生成新的子类</strong>时。</li>
</ul>
<h3 id="21-5、中介者模式扩展"><a href="#21-5、中介者模式扩展" class="headerlink" title="21.5、中介者模式扩展"></a>21.5、中介者模式扩展</h3><p>在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。</p>
<ol>
<li><strong>不定义中介者接口</strong>，把<strong>具体中介者对象实现成为单例</strong>。</li>
<li><strong>同事对象不持有中介者</strong>，而是<strong>在需要的时候直接获取中介者对象并调用</strong>。</li>
</ol>
<p>简化中介者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418143949322.png" alt="image-20210418143949322"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleColleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> SimpleConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> SimpleConcreteColleague2();</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单单例中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleMediator smd = <span class="keyword">new</span> SimpleMediator();</span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleColleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;SimpleColleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleMediator <span class="title">getMedium</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (smd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SimpleColleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(SimpleColleague scl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleColleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(scl)) &#123;</span><br><span class="line">                ((SimpleColleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague1</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague1() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague2</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague2() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-6、进阶阅读"><a href="#21-6、进阶阅读" class="headerlink" title="21.6、进阶阅读"></a>21.6、进阶阅读</h3><p>如果您想了解中介者模式在JDK源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8496.html">《中介者模式在JDK源码中的应用》</a>文章。</p>
<h3 id="21-7、相关设计模式"><a href="#21-7、相关设计模式" class="headerlink" title="21.7、相关设计模式"></a>21.7、相关设计模式</h3><ul>
<li><p>Facade模式</p>
<p>在Mediator模式中，Mediator 角色与Colleague角色进行交互。</p>
<p>而在Facade模式中，Facade 角色单方面地使用其他角色来对外提供高层接口( API)。因此，可以说Mediator模式是双向的，而Facade模式是单向的。</p>
</li>
<li><p>Observer模式</p>
<p>有时会使用Observer模式来实现Mediator角色与Colleague 角色之间的通信。</p>
</li>
</ul>
<h3 id="21-8、中介者模式的注意事项与细节"><a href="#21-8、中介者模式的注意事项与细节" class="headerlink" title="21.8、中介者模式的注意事项与细节"></a>21.8、中介者模式的注意事项与细节</h3><ol>
<li><strong>多个类相互耦合，会形成网状结构</strong>，使用<strong>中介者模式</strong>将网状结构分离为<strong>星型结构</strong>，<strong>进行解耦</strong></li>
<li><strong>减少类间依赖</strong>，降低了耦合，<strong>符合迪米特原则</strong></li>
<li><strong>中介者</strong>承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，<strong>中介者对象本身变得过于复杂</strong>，这点在实际使用时，要特别注意</li>
</ol>
<h2 id="22、备忘录模式Memento（行为型模式）"><a href="#22、备忘录模式Memento（行为型模式）" class="headerlink" title="22、备忘录模式Memento（行为型模式）"></a>22、备忘录模式Memento（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418145233471.png" alt="image-20210418145233471"></p>
<h3 id="22-1、基本介绍"><a href="#22-1、基本介绍" class="headerlink" title="22.1、基本介绍"></a>22.1、基本介绍</h3><ol>
<li>备忘录模式（Memento Pattern）,该模式又叫<strong>快照模式</strong>。在<strong>不破坏封装性</strong>的前提下，<strong>捕获一个对象的内部状态</strong>，并<strong>在该对象之外保存这个状态</strong>。这样以后就可将该对象恢复到原先保存的状态。</li>
<li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</li>
<li>备忘录模式属于行为型模式。</li>
</ol>
<h3 id="22-2、备忘录模式的原理结构图-uml类图"><a href="#22-2、备忘录模式的原理结构图-uml类图" class="headerlink" title="22.2、备忘录模式的原理结构图-uml类图"></a>22.2、备忘录模式的原理结构图-uml类图</h3><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。</p>
<h4 id="22-2-1、模式的结构"><a href="#22-2-1、模式的结构" class="headerlink" title="22.2.1、模式的结构"></a>22.2.1、模式的结构</h4><p>备忘录模式的主要角色如下：</p>
<ol>
<li><p><strong>发起人（Originator）</strong>角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li><p><strong>备忘录（Memento）</strong>角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
<p>Memento角色有以下两种按口( API )：</p>
<ol>
<li><p>wide interface - 宽接口( API )：</p>
<p>Memento角色提供的“宽接口( API)”是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口( API)会暴露所有Memento角色的内部信息，因此能够使用宽接口( API)的只有Originator角色。</p>
</li>
<li><p>narrowinterface - 窄接口 ( API )：</p>
<p>Memento角色为外部的Caretaker角色提供了“窄接口( API)”。可以通过窄接口( API)获取的Memento角色的内部信息非常有限，因此可以有效地防止信息泄露。</p>
</li>
</ol>
<p>通过对外提供以上两种接口( API),可以有效地防止对象的封装性被破坏。</p>
</li>
<li><p><strong>守护者（Caretaker）</strong>角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p>
</li>
</ol>
<p>说明：如果希望保存多个 originator 对象的不同时间的状态也可以，只需要在守护者Caretaker当中使用 HashMap &lt;String, 集合&gt;进行保存就行。</p>
<p>备忘录模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418152450078.png" alt="image-20210418152450078"></p>
<h4 id="22-2-2、代码实现"><a href="#22-2-2、代码实现" class="headerlink" title="22.2.2、代码实现"></a>22.2.2、代码实现</h4><p><strong>发起人（Originator）</strong>角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//编写一个方法，可以保存一个状态对象 Memento</span></span><br><span class="line">	<span class="comment">//因此编写一个方法，返回 Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		state = memento.getState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		mementoList.add(memento);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">         <span class="comment">// 状态#1</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#1 攻击力 100 &quot;</span>);</span><br><span class="line">		<span class="comment">//保存了当前的状态</span></span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#2</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#2 攻击力 80 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#3</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#3 攻击力 50 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());		</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">		<span class="comment">//希望得到状态 1, 将 originator 恢复到状态1	</span></span><br><span class="line">		originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复到状态1 , 当前的状态是&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-3、应用举例"><a href="#22-3、应用举例" class="headerlink" title="22.3、应用举例"></a>22.3、应用举例</h3><p>游戏角色状态恢复问题：</p>
<p>游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态。</p>
<h4 id="22-3-1、使用传统模式解决需求"><a href="#22-3-1、使用传统模式解决需求" class="headerlink" title="22.3.1、使用传统模式解决需求"></a>22.3.1、使用传统模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153109616.png" alt="image-20210418153109616"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大。</li>
<li>传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节</li>
<li>解决方案： =&gt; 备忘录模式</li>
</ol>
<h4 id="22-3-2、使用备忘录模式解决需求"><a href="#22-3-2、使用备忘录模式解决需求" class="headerlink" title="22.3.2、使用备忘录模式解决需求"></a>22.3.2、使用备忘录模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153258446.png" alt="image-20210418153258446"></p>
<p>代码实现：</p>
<p>GameRole：游戏角色。<strong>发起人（Originator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="comment">//创建Memento ,即根据当前的状态得到Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(vit, def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从备忘录对象，恢复GameRole的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverGameRoleFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = memento.getVit();</span><br><span class="line">		<span class="keyword">this</span>.def = memento.getDef();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示当前游戏角色的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;游戏角色当前的攻击力：&quot;</span> + <span class="keyword">this</span>.vit + <span class="string">&quot; 防御力: &quot;</span> + <span class="keyword">this</span>.def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memento：<strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="comment">//攻击力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="comment">//防御力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caretaker：<strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">//守护者对象, 保存游戏角色的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果只保存一次状态</span></span><br><span class="line">	<span class="keyword">private</span> Memento  memento;</span><br><span class="line">	<span class="comment">//对GameRole 保存多次状态</span></span><br><span class="line">	<span class="comment">//private ArrayList&lt;Memento&gt; mementos;</span></span><br><span class="line">	<span class="comment">//对多个游戏角色保存多个状态</span></span><br><span class="line">	<span class="comment">//private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memento;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.memento = memento;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建游戏角色</span></span><br><span class="line">		GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">		gameRole.setVit(<span class="number">100</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战前的状态&quot;</span>);</span><br><span class="line">		gameRole.display();	</span><br><span class="line">		<span class="comment">//把当前状态保存caretaker</span></span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">		caretaker.setMemento(gameRole.createMemento());	</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战~~~&quot;</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">30</span>);</span><br><span class="line">		gameRole.setVit(<span class="number">30</span>);	</span><br><span class="line">		gameRole.display();</span><br><span class="line">		System.out.println(<span class="string">&quot;大战后，使用备忘录对象恢复到大战前&quot;</span>);		</span><br><span class="line">		gameRole.recoverGameRoleFromMemento(caretaker.getMemento());</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复后的状态&quot;</span>);</span><br><span class="line">		gameRole.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-4、备忘录模式总结"><a href="#22-4、备忘录模式总结" class="headerlink" title="22.4、备忘录模式总结"></a>22.4、备忘录模式总结</h3><p>主要优点如下：</p>
<ul>
<li>提供了一种<strong>可以恢复状态</strong>的机制。当用户需要时能够比较<strong>方便地将数据恢复到某个历史的状态</strong>。</li>
<li><strong>实现了内部状态的封装</strong>。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人（Originator）类。<strong>发起人不需要管理和保存其内部状态的各个备份</strong>，所有状态信息都保存在备忘录中，并由管理者进行管理，这<strong>符合单一职责原则</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li><strong>资源消耗大</strong>。如果要保存的<strong>内部状态信息过多</strong>或者<strong>特别频繁</strong>，将会<strong>占用比较大的内存资源</strong>。而且每一次保存都会消耗一定的内存</li>
</ul>
<p>备忘录模式应用场景：</p>
<ol>
<li><strong>需要保存与恢复数据的场景</strong>，如玩游戏时的中间结果的存档功能。</li>
<li>需要<strong>提供一个可回滚操作</strong>的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ol>
<p>备忘录模式应用实例：</p>
<ul>
<li>后悔药</li>
<li>打游戏时的存档</li>
<li>Windows 里的 ctri + z</li>
<li>IE 中的后退</li>
<li>数据库的事务管理</li>
<li>编辑过程中的Undo（撤销）、Redo（重做）、History（历史记录）、Snapshot (快照）都是备忘录模式的应用</li>
</ul>
<h3 id="22-5、备忘录模式扩展"><a href="#22-5、备忘录模式扩展" class="headerlink" title="22.5、备忘录模式扩展"></a>22.5、备忘录模式扩展</h3><h4 id="22-5-1、备忘录模式-原型模式"><a href="#22-5-1、备忘录模式-原型模式" class="headerlink" title="22.5.1、备忘录模式 + 原型模式"></a>22.5.1、备忘录模式 + 原型模式</h4><p>备忘录模式如何同原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类，其结构图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418154508695.png" alt="image-20210418154508695"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeMemento</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OriginatorPrototype or = <span class="keyword">new</span> OriginatorPrototype();</span><br><span class="line">        PrototypeCaretaker cr = <span class="keyword">new</span> PrototypeCaretaker();</span><br><span class="line">        or.setState(<span class="string">&quot;S0&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态:&quot;</span> + or.getState());</span><br><span class="line">        cr.setMemento(or.createMemento()); <span class="comment">//保存状态</span></span><br><span class="line">        or.setState(<span class="string">&quot;S1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;新的状态:&quot;</span> + or.getState());</span><br><span class="line">        or.restoreMemento(cr.getMemento()); <span class="comment">//恢复状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态:&quot;</span> + or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发起人原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginatorPrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(opt.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (OriginatorPrototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型管理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OriginatorPrototype opt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.opt = opt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> opt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-5-2、关于备忘录模式在源码当中的应用"><a href="#22-5-2、关于备忘录模式在源码当中的应用" class="headerlink" title="22.5.2、关于备忘录模式在源码当中的应用"></a>22.5.2、关于备忘录模式在源码当中的应用</h4><p>由于 JDK、Spring、Mybatis 中很少有备忘录模式，所以该设计模式不做典型应用源码分析。</p>
<p>Spring Webflow 中 DefaultMessageContext 类实现了 StateManageableMessageContext 接口，查看其源码可以发现其主要逻辑就相当于给 Message 备份</p>
<h3 id="22-6、进阶阅读"><a href="#22-6、进阶阅读" class="headerlink" title="22.6、进阶阅读"></a>22.6、进阶阅读</h3><p>如果您想了解备忘录模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8504.html">《使用备忘录模式实现草稿箱功能》</a>文章。</p>
<h3 id="22-7、相关设计模式"><a href="#22-7、相关设计模式" class="headerlink" title="22.7、相关设计模式"></a>22.7、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>在使用Command模式处理命令时，可以使用Memento模式实现撤销功能。</p>
</li>
<li><p>Protype模式</p>
<p>在Memento模式中，为了能够实现快照和撤销功能，保存了对象当前的状态。保存的信息只是在恢复状态时所需要的那部分信息。</p>
<p>而在Protype模式中，会生成- 一个与当前实例完全相同的另外一个实例。 这两个实例的内容完全一样。</p>
</li>
<li><p>State 模式</p>
<p>在Memento模式中，是用“实例”表示状态。</p>
<p>而在State模式中，则是用“类”表示状态。</p>
</li>
</ul>
<h3 id="22-8、备忘录模式的注意事项与细节"><a href="#22-8、备忘录模式的注意事项与细节" class="headerlink" title="22.8、备忘录模式的注意事项与细节"></a>22.8、备忘录模式的注意事项与细节</h3><ol>
<li><p>给用户提供了一种<strong>可以恢复状态</strong>的机制，可以使用户能够比较方便地回到某个历史的状态</p>
</li>
<li><p><strong>实现了信息的封装</strong>，使得用户不需要关心状态的保存细节</p>
</li>
<li><p>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</p>
</li>
<li><p>为了节约内存，<strong>备忘录模式可以和原型模式配合使用</strong></p>
</li>
<li><p>在守护者当中的不同情况：</p>
<ol>
<li><p>如果只保存一次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Memento memento;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对发起人（Originator）对象保存多次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Memento&gt; mementos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对多个发起人（Originator）角色保存多个状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="23、解释器模式Interpreter（行为型模式）"><a href="#23、解释器模式Interpreter（行为型模式）" class="headerlink" title="23、解释器模式Interpreter（行为型模式）"></a>23、解释器模式Interpreter（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418162744613.png" alt="image-20210418162744613"></p>
<h3 id="23-1、基本介绍"><a href="#23-1、基本介绍" class="headerlink" title="23.1、基本介绍"></a>23.1、基本介绍</h3><ol>
<li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li>
<li>解释器模式（Interpreter Pattern）：是指给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子(表达式)。也就是说，用编译语言的方式来分析应用中的实例。</li>
<li>这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</li>
<li>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。</li>
</ol>
<h3 id="23-2、编译原理中的“文法、句子、语法树”等相关概念"><a href="#23-2、编译原理中的“文法、句子、语法树”等相关概念" class="headerlink" title="23.2、编译原理中的“文法、句子、语法树”等相关概念"></a>23.2、编译原理中的“文法、句子、语法树”等相关概念</h3><h4 id="23-2-1、文法"><a href="#23-2-1、文法" class="headerlink" title="23.2.1、文法"></a>23.2.1、文法</h4><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。</p>
<p>例如，中文中的“句子”的文法如下：</p>
<p>注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">〈句子〉::&#x3D;〈主语〉〈谓语〉〈宾语〉</span><br><span class="line">〈主语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈谓语〉::&#x3D;〈动词〉</span><br><span class="line">〈宾语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈代词〉你|我|他</span><br><span class="line">〈名词〉7大学生I筱霞I英语</span><br><span class="line">〈动词〉::&#x3D;是|学习</span><br></pre></td></tr></table></figure>

<h4 id="23-2-2、句子"><a href="#23-2-2、句子" class="headerlink" title="23.2.2、句子"></a>23.2.2、句子</h4><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。</p>
<p>例如，上述文法可以推出“我是大学生”，所以它是句子。</p>
<h4 id="23-2-3、语法树"><a href="#23-2-3、语法树" class="headerlink" title="23.2.3、语法树"></a>23.2.3、语法树</h4><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。</p>
<p>下图所示是“我是大学生”的语法树：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180415987.png" alt="image-20210418180415987"></p>
<p>解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。</p>
<h3 id="23-3、解释器模式的原理结构图-uml类图"><a href="#23-3、解释器模式的原理结构图-uml类图" class="headerlink" title="23.3、解释器模式的原理结构图-uml类图"></a>23.3、解释器模式的原理结构图-uml类图</h3><h4 id="23-3-1、模式的结构"><a href="#23-3-1、模式的结构" class="headerlink" title="23.3.1、模式的结构"></a>23.3.1、模式的结构</h4><p>解释器模式包含以下主要角色：</p>
<ol>
<li><strong>抽象表达式（Abstract Expression）</strong>角色：定义解释器的接口，约定解释器的解释操作，主要**包含解释方法 interpret()**，这个方法为抽象语法树中所有的节点所共享。</li>
<li><strong>终结符表达式（Terminal Expression）</strong>角色：是抽象表达式的子类，用来<strong>实现文法中与终结符相关</strong>的操作，文法中的<strong>每一个终结符都有一个具体终结表达式与之相对应</strong>。</li>
<li><strong>非终结符表达式（Nonterminal Expression）</strong>角色：也是抽象表达式的子类，用来<strong>实现文法中与非终结符相关</strong>的操作，文法中的<strong>每条规则都对应于一个非终结符表达式</strong>。</li>
<li><strong>环境（Context）</strong>角色：通常包含<strong>各个解释器需要的数据或是公共的功能</strong>，一般用来传递被所有解释器共享的数据，后面的<strong>解释器可以从这里获取这些值</strong>。</li>
<li><strong>客户端（Client）</strong>：主要任务是<strong>将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树</strong>，然后<strong>调用解释器的解释方法</strong>，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<p>解释器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180640123.png" alt="image-20210418180640123"></p>
<h4 id="23-3-2、代码实现"><a href="#23-3-2、代码实现" class="headerlink" title="23.3.2、代码实现"></a>23.3.2、代码实现</h4><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;    <span class="comment">//解释方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-4、应用举例"><a href="#23-4、应用举例" class="headerlink" title="23.4、应用举例"></a>23.4、应用举例</h3><p>四则运算问题：</p>
<p>通过解释器模式来实现四则运算，如计算 a+b-c 的值，具体要求：</p>
<ol>
<li><p>先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复</p>
</li>
<li><p>在分别输入 a ,b, c, d, e 的值</p>
</li>
<li><p>最后求出结果：如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181009303.png" alt="image-20210418181009303"></p>
</li>
</ol>
<h4 id="23-4-1、使用传统方式解决需求"><a href="#23-4-1、使用传统方式解决需求" class="headerlink" title="23.4.1、使用传统方式解决需求"></a>23.4.1、使用传统方式解决需求</h4><p>传统方案解决四则运算问题分析：</p>
<ol>
<li>编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果</li>
<li>问题分析：如果加入新的运算符，比如<code>*</code>(乘)<code>/</code>(除) 等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，不够清晰。</li>
<li>解决方案：可以考虑使用解释器模式，即：  表达式  -&gt; 解释器(可以有多种) -&gt; 结果</li>
</ol>
<h4 id="23-4-2、使用解释器模式解决需求"><a href="#23-4-2、使用解释器模式解决需求" class="headerlink" title="23.4.2、使用解释器模式解决需求"></a>23.4.2、使用解释器模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181353124.png" alt="image-20210418181353124"></p>
<p>代码实现：</p>
<p>Expression：<strong>抽象表达式（Abstract Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a + b - c</span></span><br><span class="line">	<span class="comment">// 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值</span></span><br><span class="line">	<span class="comment">// HashMap &#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VarExpression：变量的解释器。<strong>终结符表达式（Terminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量的解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String key; <span class="comment">// key=a,key=b,key=c</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VarExpression</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// var 就是&#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="comment">// interpreter 根据 变量名称，返回对应值</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="keyword">this</span>.key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SymbolExpression：抽象运算符号解析器。<strong>非终结符表达式（Nonterminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，</span></span><br><span class="line"><span class="comment"> * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Expression left;</span><br><span class="line">	<span class="keyword">protected</span> Expression right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SymbolExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AddExpression：加法解释器（减法解释器SubExpression类似）继承了SymbolExpression</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加法解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span>  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AddExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(left, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理相加</span></span><br><span class="line">	<span class="comment">//var 仍然是 &#123;a=10,b=20&#125;..</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10</span></span><br><span class="line">		<span class="comment">//super.right.interpreter(var): 返回right 表达式对应值 b = 20</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calculator：计算器。环境（Context）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义表达式</span></span><br><span class="line">	<span class="keyword">private</span> Expression expression;</span><br><span class="line">	<span class="comment">// 构造函数传参，并解析</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expStr)</span> </span>&#123; <span class="comment">// expStr = a+b</span></span><br><span class="line">		<span class="comment">// 安排运算先后顺序</span></span><br><span class="line">		Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">// 表达式拆分成字符数组 </span></span><br><span class="line">		<span class="keyword">char</span>[] charArray = expStr.toCharArray();<span class="comment">// [a, +, b]</span></span><br><span class="line">		Expression left = <span class="keyword">null</span>;</span><br><span class="line">		Expression right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//遍历我们的字符数组， 即遍历  [a, +, b]</span></span><br><span class="line">		<span class="comment">//针对不同的情况，做处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// &#x27;+&#x27;号</span></span><br><span class="line">				left = stack.pop();<span class="comment">// 从stack取出left =&gt; &quot;a&quot;</span></span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));<span class="comment">// 取出右表达式 &quot;b&quot;</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> AddExpression(left, right));<span class="comment">// 然后根据得到left 和 right 构建 AddExpresson加入stack</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// &#x27;-&#x27;号</span></span><br><span class="line">				left = stack.pop();</span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">				stack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: </span><br><span class="line">				<span class="comment">//如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> VarExpression(String.valueOf(charArray[i])));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当遍历完整个 charArray 数组后，stack 就得到最后Expression</span></span><br><span class="line">		<span class="keyword">this</span>.expression = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//最后将表达式a+b和 var = &#123;a=10,b=20&#125;</span></span><br><span class="line">		<span class="comment">//然后传递给expression的interpreter进行解释执行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String expStr = getExpStr(); <span class="comment">// a+b</span></span><br><span class="line">		HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);<span class="comment">// var &#123;a=10, b=20&#125;</span></span><br><span class="line">		Calculator calculator = <span class="keyword">new</span> Calculator(expStr);</span><br><span class="line">		System.out.println(<span class="string">&quot;运算结果：&quot;</span> + expStr + <span class="string">&quot;=&quot;</span> + calculator.run(<span class="keyword">var</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得表达式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;请输入表达式：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得值映射</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> ch : expStr.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!map.containsKey(String.valueOf(ch))) &#123;</span><br><span class="line">					System.out.print(<span class="string">&quot;请输入&quot;</span> + String.valueOf(ch) + <span class="string">&quot;的值：&quot;</span>);</span><br><span class="line">					String in = (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">					map.put(String.valueOf(ch), Integer.valueOf(in));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-5、解释器模式在Spring框架的应用与源码"><a href="#23-5、解释器模式在Spring框架的应用与源码" class="headerlink" title="23.5、解释器模式在Spring框架的应用与源码"></a>23.5、解释器模式在Spring框架的应用与源码</h3><p>Spring 框架中 SpelExpressionParser 就使用到解释器模式</p>
<p>代码分析+Debug源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194307766.png" alt="image-20210418194307766"></p>
<p>main：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194430819.png" alt="image-20210418194430819"></p>
<p>Expression接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194613016.png" alt="image-20210418194613016"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194717484.png" alt="image-20210418194717484"></p>
<p>SpelExpressionParser的parseExpression()方法是继承了其父类TemplateAwareExpressionParser的parseExpression()方法，而TemplateAwareExpressionParser又实现了ExpressionParser接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194936179.png" alt="image-20210418194936179"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195208607.png" alt="image-20210418195208607"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195226794.png" alt="image-20210418195226794"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195314345.png" alt="image-20210418195314345"></p>
<p>TemplateAwareExpressionParser的parseExpression()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195658830.png" alt="image-20210418195658830"></p>
<p>其中的parseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195826923.png" alt="image-20210418195826923"></p>
<p>其中的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210418200021479.png" alt="image-20210418200021479"></p>
<p>子类SpelExpressionParser实现了父类TemplateAwareExpressionParser的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200257640.png" alt="image-20210418200257640"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200553239.png" alt="image-20210418200553239"></p>
<p>说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194009115.png" alt="image-20210418194009115"></p>
<h3 id="23-6、解释器模式总结"><a href="#23-6、解释器模式总结" class="headerlink" title="23.6、解释器模式总结"></a>23.6、解释器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。由于在解释器模式中使用类来表示语言的文法规则，因此可以<strong>通过继承等机制来改变或扩展文法</strong>。</li>
<li><strong>容易实现</strong>。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>执行效率较低</strong>。解释器模式中通常使用<strong>大量的循环和递归调用</strong>，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li><strong>会引起类膨胀</strong>。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li><strong>可应用的场景比较少</strong>。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>当<strong>语言的文法较为简单</strong>，且<strong>执行效率不是关键</strong>问题时。</li>
<li>当<strong>问题重复出现</strong>，且<strong>可以用一种简单的语言来进行表达</strong>时。</li>
<li>当<strong>一个语言需要解释执行</strong>，并且<strong>语言中的句子可以表示为一个抽象语法树</strong>的时候，如 <strong>XML 文档解释</strong>。</li>
</ol>
<p>应用实例：编译器、运算表达式计算、正则表达式、机器人等</p>
<p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</p>
<h3 id="23-7、解释器模式扩展"><a href="#23-7、解释器模式扩展" class="headerlink" title="23.7、解释器模式扩展"></a>23.7、解释器模式扩展</h3><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p>现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。</p>
<p>下面以计算存款利息为例来介绍。存款利息的计算公式是：本金x利率x时间=利息，其相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"><span class="keyword">import</span> com.singularsys.jep.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JepException </span>&#123;</span><br><span class="line">        Jep jep = <span class="keyword">new</span> Jep();</span><br><span class="line">        <span class="comment">//定义要计算的数据表达式</span></span><br><span class="line">        String 存款利息 = <span class="string">&quot;本金*利率*时间&quot;</span>;</span><br><span class="line">        <span class="comment">//给相关变量赋值</span></span><br><span class="line">        jep.addVariable(<span class="string">&quot;本金&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;利率&quot;</span>, <span class="number">0.038</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;时间&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        jep.parse(存款利息);    <span class="comment">//解析表达式</span></span><br><span class="line">        Object accrual = jep.evaluate();    <span class="comment">//计算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;存款利息：&quot;</span> + accrual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-8、进阶阅读"><a href="#23-8、进阶阅读" class="headerlink" title="23.8、进阶阅读"></a>23.8、进阶阅读</h3><p>如果您想了解解释器模式在框架源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8505.html">《解释器模式在JDK和Spring源码中的应用》</a>文章。</p>
<h3 id="23-9、相关设计模式"><a href="#23-9、相关设计模式" class="headerlink" title="23.9、相关设计模式"></a>23.9、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>NonterminalExpression角色多是递归结构，因此常会使用Composite模式来实现NonterminalExpression角色</p>
</li>
<li><p>Flyweight 模式</p>
<p>有时会使用Flyweight模式来共享TerminalExpression角色。</p>
</li>
<li><p>Visitor 模式</p>
<p>在推导出语法树后，有时会使用Visitor模式来访问语法树的各个节点。</p>
</li>
</ul>
<h3 id="23-10、解释器模式的注意事项与细节"><a href="#23-10、解释器模式的注意事项与细节" class="headerlink" title="23.10、解释器模式的注意事项与细节"></a>23.10、解释器模式的注意事项与细节</h3><ol>
<li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展</li>
<li>使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。</li>
<li>解释器模式通过抽象语法树实现对用户输入的解释执行。</li>
<li>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</li>
</ol>
<h2 id="24、状态模式State（行为型模式）"><a href="#24、状态模式State（行为型模式）" class="headerlink" title="24、状态模式State（行为型模式）"></a>24、状态模式State（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418201124106.png" alt="image-20210418201124106"></p>
<h3 id="24-1、基本介绍"><a href="#24-1、基本介绍" class="headerlink" title="24.1、基本介绍"></a>24.1、基本介绍</h3><ol>
<li>状态模式（<strong>State Pattern</strong>）：它主要用来解决<strong>对象在多种状态转换时，需要对外输出不同的行为的</strong>问题。<strong>状态和行为是一一对应的，状态之间可以相互转换</strong></li>
<li>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</li>
<li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</li>
<li><strong>替代了使用if-else解决问题</strong></li>
</ol>
<h3 id="24-2、状态模式的原理结构图-uml类图"><a href="#24-2、状态模式的原理结构图-uml类图" class="headerlink" title="24.2、状态模式的原理结构图-uml类图"></a>24.2、状态模式的原理结构图-uml类图</h3><p>状态模式把<strong>受环境改变的对象行为包装在不同的状态对象</strong>里，其意图是<strong>让一个对象在其内部状态改变的时候</strong>，其<strong>行为也随之改变</strong>。</p>
<h4 id="24-2-1、模式的结构"><a href="#24-2-1、模式的结构" class="headerlink" title="24.2.1、模式的结构"></a>24.2.1、模式的结构</h4><p>状态模式包含以下主要角色：</p>
<ol>
<li><strong>环境类（Context）</strong>角色：也称为<strong>上下文</strong>，它<strong>定义了客户端需要的接口</strong>，<strong>内部维护一个当前状态</strong>，并<strong>负责具体状态的切换</strong>。</li>
<li><strong>抽象状态（State）</strong>角色：定义一个接口，用以<strong>封装环境对象中的特定状态所对应的行为</strong>，可以有<strong>一个或多个</strong>行为。</li>
<li><strong>具体状态（Concrete State）</strong>角色：实现抽象状态所对应的行为，并且<strong>在需要的情况下进行状态切换</strong>。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205430235.png" alt="image-20210418205430235"></p>
<h4 id="24-2-2、代码实现"><a href="#24-2-2、代码实现" class="headerlink" title="24.2.2、代码实现"></a>24.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();    <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle();    <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 A.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 B.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-3、应用举例"><a href="#24-3、应用举例" class="headerlink" title="24.3、应用举例"></a>24.3、应用举例</h3><p>APP 抽奖活动问题：</p>
<p>请编写程序完成 APP 抽奖活动 具体要求如下:</p>
<ol>
<li><p>假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10%</p>
</li>
<li><p>奖品数量固定，抽完就不能抽奖</p>
</li>
<li><p>活动有四个状态: </p>
<ul>
<li>可以抽奖</li>
<li>不能抽奖</li>
<li>发放奖品</li>
<li>奖品领完</li>
</ul>
</li>
<li><p>活动的四个状态转换关系图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205732564.png" alt="image-20210418205732564"></p>
</li>
</ol>
<h4 id="24-3-1、使用传统方式解决需求"><a href="#24-3-1、使用传统方式解决需求" class="headerlink" title="24.3.1、使用传统方式解决需求"></a>24.3.1、使用传统方式解决需求</h4><p>通常通过if/else判断抽奖的状态，从而实现不同的逻辑，伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(不能抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(可以抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(发放奖品)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>传统的方式的问题分析： </p>
<ul>
<li>这类代码难以应对变化，在添加一种状态时，我们需要手动添加if/else</li>
<li>在添加一种功能时，要对所有的状态进行判断。</li>
<li>因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的BUG，难以维护</li>
<li>不符合开闭原则</li>
</ul>
<h4 id="24-3-2、使用状态模式解决需求"><a href="#24-3-2、使用状态模式解决需求" class="headerlink" title="24.3.2、使用状态模式解决需求"></a>24.3.2、使用状态模式解决需求</h4><p>思路分析和图解(类图)</p>
<ul>
<li>定义出一个接口叫状态接口，每个状态都实现它。</li>
<li>接口有扣除积分方法、抽奖方法、发放奖品方法</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418210441898.png" alt="image-20210418210441898"></p>
<p>代码实现：</p>
<p>State：<strong>抽象状态（State）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扣除积分 - 50</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 是否抽中奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 发放奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体状态（Concrete State）</strong>：四种状态：</p>
<p>NoRaffleState：不能抽奖状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不能抽奖状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 初始化时传入活动引用，扣除积分后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);</span><br><span class="line">        activity.setState(activity.getCanRaffleState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能抽奖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣了积分才能抽奖喔！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能发奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CanRaffleState：可以抽奖的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以抽奖的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CanRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经扣除了积分，不能再扣</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经扣取过了积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽奖，请稍等！&quot;</span>);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10%中奖机会</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 改变活动状态为发放奖品 context</span></span><br><span class="line">            activity.setState(activity.getDispenseState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾没有抽中奖品！&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没中奖，不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseState：发放奖品的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发放奖品的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用，发放奖品后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能扣除积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能抽奖&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(activity.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜中奖了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾，奖品发送完了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span></span><br><span class="line">            activity.setState(activity.getDispensOutState());</span><br><span class="line">            <span class="comment">//System.out.println(&quot;抽奖活动结束&quot;);</span></span><br><span class="line">            <span class="comment">//System.exit(0);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseOutState：奖品发放完毕状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖品发放完毕状态</span></span><br><span class="line"><span class="comment"> * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseOutState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseOutState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity：抽奖活动。<strong>环境类（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖活动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="comment">// state 表示活动当前的状态，是变化</span></span><br><span class="line">    State state = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 奖品数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 四个属性，表示四种状态</span></span><br><span class="line">    State noRafflleState = <span class="keyword">new</span> NoRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State canRaffleState = <span class="keyword">new</span> CanRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State dispenseState =   <span class="keyword">new</span> DispenseState(<span class="keyword">this</span>);</span><br><span class="line">    State dispensOutState = <span class="keyword">new</span> DispenseOutState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span></span><br><span class="line">    <span class="comment">//2. 初始化奖品的数量 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RaffleActivity</span><span class="params">( <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = getNoRafflleState();</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣分, 调用当前状态的 deductMoney</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debuctMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.deductMoney();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽奖 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raffle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 如果当前的状态是抽奖成功</span></span><br><span class="line">        <span class="keyword">if</span>(state.raffle())&#123;</span><br><span class="line">        	<span class="comment">//领取奖品</span></span><br><span class="line">            state.dispensePrize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里请大家注意，每领取一次奖品，count--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> curCount = count; </span><br><span class="line">    	count--;</span><br><span class="line">        <span class="keyword">return</span> curCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getNoRafflleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoRafflleState</span><span class="params">(State noRafflleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.noRafflleState = noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCanRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCanRaffleState</span><span class="params">(State canRaffleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseState</span><span class="params">(State dispenseState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispenseState = dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispensOutState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispensOutState</span><span class="params">(State dispensOutState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispensOutState = dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态模式测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建活动对象，奖品有1个奖品</span></span><br><span class="line">        RaffleActivity activity = <span class="keyword">new</span> RaffleActivity(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 我们连续抽30次奖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次抽奖----------&quot;</span>);</span><br><span class="line">            <span class="comment">// 参加抽奖，第一步点击扣除积分</span></span><br><span class="line">            activity.debuctMoney();</span><br><span class="line">            <span class="comment">// 第二步抽奖</span></span><br><span class="line">            activity.raffle();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-4、状态模式在实际项目-借贷平台源码分析"><a href="#24-4、状态模式在实际项目-借贷平台源码分析" class="headerlink" title="24.4、状态模式在实际项目-借贷平台源码分析"></a>24.4、状态模式在实际项目-借贷平台源码分析</h3><p>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态, 项目中的这个模块实现就会使用到状态模式：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213432465.png" alt="image-20210418213432465"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213517578.png" alt="image-20210418213517578"></p>
<p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213541498.png" alt="image-20210418213541498"></p>
<p>代码实现：</p>
<p>State：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定价发布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无人接单失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 付款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单有人支付失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反馈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractState：实现State接口方法的默认实现。子类通过自己的需求进行重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	rotected <span class="keyword">static</span> <span class="keyword">final</span> RuntimeException EXCEPTION = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;操作流程不允许&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各种具体状态类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedBackState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.FEED_BACKED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> ReviewState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.GENERATE.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotPayState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PaidState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.NOT_PAY.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaidState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PAID.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> NotPayState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PUBLISHED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.REVIEWED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StateEnum：状态枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//订单生成</span></span><br><span class="line">    GENERATE(<span class="number">1</span>, <span class="string">&quot;GENERATE&quot;</span>),</span><br><span class="line">    <span class="comment">//已审核</span></span><br><span class="line">    REVIEWED(<span class="number">2</span>, <span class="string">&quot;REVIEWED&quot;</span>),</span><br><span class="line">    <span class="comment">//已发布</span></span><br><span class="line">    PUBLISHED(<span class="number">3</span>, <span class="string">&quot;PUBLISHED&quot;</span>),</span><br><span class="line">    <span class="comment">//待付款</span></span><br><span class="line">    NOT_PAY(<span class="number">4</span>, <span class="string">&quot;NOT_PAY&quot;</span>),</span><br><span class="line">    <span class="comment">//已付款</span></span><br><span class="line">    PAID(<span class="number">5</span>, <span class="string">&quot;PAID&quot;</span>),</span><br><span class="line">    <span class="comment">//已完结</span></span><br><span class="line">    FEED_BACKED(<span class="number">6</span>, <span class="string">&quot;FEED_BACKED&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    StateEnum(<span class="keyword">int</span> key, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context：环境上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">extends</span> <span class="title">AbstractState</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> State state;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkFailEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.makePriceEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.acceptOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.notPeopleAcceptEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.payOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.orderFailureEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.feedBackEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态 : &quot;</span> + state.getCurrentState());</span><br><span class="line">        <span class="keyword">return</span> state.getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientTest：测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">        <span class="comment">//然后可以根据操作变化状态.</span></span><br><span class="line">        <span class="comment">//publish --&gt; not pay</span></span><br><span class="line">       context.acceptOrderEvent(context);</span><br><span class="line">        <span class="comment">//not pay --&gt; paid</span></span><br><span class="line">        context.payOrderEvent(context);</span><br><span class="line">        <span class="comment">// 失败, 检测失败时，会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	context.checkFailEvent(context);</span><br><span class="line">        	System.out.println(<span class="string">&quot;流程正常..&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-5、状态模式总结"><a href="#24-5、状态模式总结" class="headerlink" title="24.5、状态模式总结"></a>24.5、状态模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>结构清晰</strong>，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，<strong>满足“单一职责原则”</strong>。</li>
<li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li>
<li><strong>将状态转换显示化，减少对象间的相互依赖</strong>。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li><strong>允许状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li>
<li>将<strong>所有与某个状态有关的行为放到一个类中</strong>，并且<strong>可以方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。 </li>
<li>可以让多个环境对象共享一个状态对象，从而<strong>减少系统中对象的个数</strong></li>
<li><strong>状态类职责明确，有利于程序的扩展</strong>。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>状态模式的主要缺点如下：</p>
<ol>
<li>状态模式的使用必然会<strong>增加系统的类与对象的个数</strong>。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
<li><strong>状态模式对开闭原则的支持并不太好</strong>，对于可以切换状态的状态模式，增加新的状态类<strong>需要修改那些负责状态转换的源码，否则无法切换到新增状态</strong>，而且修改某个状态类的行为也需要修改对应类的源码。</li>
</ol>
<p>状态模式的应用场景：</p>
<ul>
<li>当一个对象的<strong>行为取决于它的状态</strong>，并且它必须<strong>在运行时根据状态改变它的行为</strong>时，就可以考虑使用状态模式。</li>
<li><strong>一个操作中含有庞大的分支结构</strong>，并且这些<strong>分支决定于对象的状态</strong>时。</li>
<li>当<strong>一个事件或者对象有很多种状态</strong>，<strong>状态之间会相互转换</strong>，对<strong>不同的状态要求有不同的行为</strong>的时候， 可以考虑使用状态模式</li>
</ul>
<h3 id="24-6、状态模式扩展"><a href="#24-6、状态模式扩展" class="headerlink" title="24.6、状态模式扩展"></a>24.6、状态模式扩展</h3><h4 id="24-6-1、状态模式-享元模式"><a href="#24-6-1、状态模式-享元模式" class="headerlink" title="24.6.1、状态模式 + 享元模式"></a>24.6.1、状态模式 + 享元模式</h4><p>在有些情况下，可能有<strong>多个环境对象需要共享一组状态</strong>，这时需要引入<strong>享元模式</strong>，将这些具体状态对象放在集合中供程序共享，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418212557965.png" alt="image-20210418212557965"></p>
<p>分析：共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取，其程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightStatePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareContext context = <span class="keyword">new</span> ShareContext(); <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle(); <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShareState state;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, ShareState&gt; stateSet = <span class="keyword">new</span> HashMap&lt;String, ShareState&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState1();</span><br><span class="line">        stateSet.put(<span class="string">&quot;1&quot;</span>, state);</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState2();</span><br><span class="line">        stateSet.put(<span class="string">&quot;2&quot;</span>, state);</span><br><span class="line">        state = getState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ShareState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShareState <span class="title">getState</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        ShareState s = (ShareState) stateSet.get(key);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态1类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态1&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态2类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态2&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-6-2、状态模式与责任链模式的区别"><a href="#24-6-2、状态模式与责任链模式的区别" class="headerlink" title="24.6.2、状态模式与责任链模式的区别"></a>24.6.2、状态模式与责任链模式的区别</h4><ol>
<li><strong>状态模式和责任链模式都能消除 if-else 分支过多的问题</strong>。但在某些情况下，<strong>状态模式中的状态可以理解为责任</strong>，那么在这种情况下，<strong>两种模式都可以使用</strong>。</li>
<li>从<strong>定义</strong>来看，<strong>状态模式强调的是一个对象内在状态的改变</strong>，而<strong>责任链模式强调的是外部节点对象间的改变</strong>。</li>
<li>从<strong>代码实现</strong>上来看，两者最大的区别就是<strong>状态模式的各个状态对象知道自己要进入的下一个状态对象</strong>，而<strong>责任链模式并不清楚其下一个节点处理对象</strong>，因为<strong>链式组装由客户端负责</strong>。</li>
</ol>
<h4 id="24-6-3、状态模式与策略模式的区别"><a href="#24-6-3、状态模式与策略模式的区别" class="headerlink" title="24.6.3、状态模式与策略模式的区别"></a>24.6.3、状态模式与策略模式的区别</h4><p><strong>状态模式和策略模式的 UML 类图架构几乎完全一样，但两者的应用场景是不一样的</strong>。<strong>策略模式的多种算法行为择其一都能满足，彼此之间是独立的</strong>，<strong>用户可自行更换策略算法</strong>，而<strong>状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果</strong>，并且<strong>用户无法指定状态，只能设置初始状态</strong>。</p>
<h3 id="24-7、进阶阅读"><a href="#24-7、进阶阅读" class="headerlink" title="24.7、进阶阅读"></a>24.7、进阶阅读</h3><p>如果您想深入了解状态模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8490.html">《使用状态模式自由切换登录状态》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8492.html">《使用状态机实现订单状态流转控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8493.html">《状态模式在JSF源码中的应用》</a></li>
</ul>
<h3 id="24-8、相关设计模式"><a href="#24-8、相关设计模式" class="headerlink" title="24.8、相关设计模式"></a>24.8、相关设计模式</h3><ul>
<li><p>Singleton 模式</p>
<p>Singleton模式常常会出现在ConcreteState角色中。这是因为在表示状态的类中并没有定义任何实例字段(即表示实例的状态的字段)。</p>
</li>
<li><p>Flyweight 模式</p>
<p>在表示状态的类中并没有定义任何实例字段。因此，有时我们可以使用Flyweight模式在多个Context角色之间共享ConcreteState角色。</p>
</li>
</ul>
<h3 id="24-9、状态模式的注意事项与细节"><a href="#24-9、状态模式的注意事项与细节" class="headerlink" title="24.9、状态模式的注意事项与细节"></a>24.9、状态模式的注意事项与细节</h3><ol>
<li>代码有<strong>很强的可读性</strong>。状态模式将<strong>每个状态的行为封装到对应的一个类</strong>中</li>
<li><strong>方便维护</strong>。将<strong>容易产生问题的 if-else 语句删除</strong>了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错</li>
<li>会产生很多类。<strong>每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</strong></li>
</ol>
<h2 id="25、策略模式Strategy（行为型模式）"><a href="#25、策略模式Strategy（行为型模式）" class="headerlink" title="25、策略模式Strategy（行为型模式）"></a>25、策略模式Strategy（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418214750299.png" alt="image-20210418214750299"></p>
<h3 id="25-1、基本介绍"><a href="#25-1、基本介绍" class="headerlink" title="25.1、基本介绍"></a>25.1、基本介绍</h3><ol>
<li>策略模式（Strategy Pattern）中，<strong>定义算法族（策略组），分别封装起来，让他们之间可以互相替换</strong>，此模式让<strong>算法的变化独立于使用算法的客户</strong></li>
<li>策略模式属于对象行为模式，它通过<strong>对算法进行封装</strong>，把<strong>使用算法的责任和算法的实现分割开来</strong>，并<strong>委派给不同的对象对这些算法进行管理</strong>。</li>
<li>在策略模式中，我们创建表示<strong>各种策略的对象和一个行为随着策略对象改变而改变的 context 对象</strong>。策略对象改变 context 对象的执行算法。</li>
<li>策略模式的核心思想是<strong>在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去</strong>，从而使得<strong>新增策略不必修改原有逻辑</strong>。</li>
<li>这算法体现了几个设计原则：<ol>
<li>把变化的代码从不变的代码中分离出来</li>
<li>第二、针对接口编程而不是具体类（定义了策略接口）</li>
<li>第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）。</li>
</ol>
</li>
</ol>
<h3 id="25-2、策略模式的原理结构图-uml类图"><a href="#25-2、策略模式的原理结构图-uml类图" class="headerlink" title="25.2、策略模式的原理结构图-uml类图"></a>25.2、策略模式的原理结构图-uml类图</h3><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的<strong>重心</strong>不是如何实现算法，而<strong>是如何组织这些算法</strong>，从而让程序结构更加灵活，具有更好的维护性和扩展性。</p>
<h4 id="25-2-1、模式的结构"><a href="#25-2-1、模式的结构" class="headerlink" title="25.2.1、模式的结构"></a>25.2.1、模式的结构</h4><p>策略模式的主要角色如下：</p>
<ol>
<li><strong>抽象策略（Strategy）</strong>类：定义了一个<strong>公共接口</strong>，<strong>各种不同的算法以不同的方式实现这个接口</strong>，<strong>环境角色使用这个接口调用不同的算法</strong>，一般使用<strong>接口或抽象类</strong>实现。</li>
<li><strong>具体策略（Concrete Strategy）</strong>类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li><strong>环境（Context）</strong>类：<strong>持有一个策略类的引用</strong>，最终给客户端调用。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418225857983.png" alt="image-20210418225857983"></p>
<h4 id="25-3-2、代码实现"><a href="#25-3-2、代码实现" class="headerlink" title="25.3.2、代码实现"></a>25.3.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s = <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略C的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyD</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略D的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> Strategy1 strategy1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-3、应用举例"><a href="#25-3、应用举例" class="headerlink" title="25.3、应用举例"></a>25.3、应用举例</h3><p>编写鸭子项目，具体要求如下:</p>
<ol>
<li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)</li>
<li>显示鸭子的信息</li>
</ol>
<h4 id="25-3-1、使用传统方式解决需求"><a href="#25-3-1、使用传统方式解决需求" class="headerlink" title="25.3.1、使用传统方式解决需求"></a>25.3.1、使用传统方式解决需求</h4><p>传统的设计方案(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230442078.png" alt="image-20210418230442078"></p>
<p>传统的方式实现的问题分析和解决方案：</p>
<ol>
<li>其它鸭子，都继承了 Duck 类，所以 fly 让所有子类都会飞了，这是不正确的</li>
<li>上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应</li>
<li>为了改进 1 问题，我们可以通过覆盖 fly 方法来解决 =&gt; 覆盖解决</li>
<li>问题又来了，如果我们有一个玩具鸭子 ToyDuck, 这样就需要 <strong>ToyDuck</strong> 去覆盖 <strong>Duck</strong> 的所有实现的方法 =&gt; 解决思路 -》 策略模式 (strategy pattern)</li>
</ol>
<h4 id="25-3-2、使用策略模式解决需求"><a href="#25-3-2、使用策略模式解决需求" class="headerlink" title="25.3.2、使用策略模式解决需求"></a>25.3.2、使用策略模式解决需求</h4><p>思路分析(类图)：</p>
<p>策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p>
<p>原则就是： 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230737776.png" alt="image-20210418230737776"></p>
<p>代码实现：</p>
<p>FlyBehavior：飞行。（QuackBehavior：叫行为。等等其它抽象策略与其具体实现类类似）<strong>抽象策略（Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 子类具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoodFlyBehavior：飞行技术高超。（BadFlyBehavior：飞行技术一般、NoFlyBehavior：不会飞行等等类似）<strong>具体策略（Concrete Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 飞翔技术高超 ~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duck：鸭子抽象类。<strong>环境（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//属性, 策略接口</span></span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	<span class="comment">//其它属性&lt;-&gt;策略接口</span></span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子嘎嘎叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//改进</span></span><br><span class="line">		<span class="keyword">if</span>(flyBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">			flyBehavior.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WildDuck：野鸭具体类，继承了鸭子抽象类。（PekingDuck：北京鸭，飞行技术一般、ToyDuck：玩具鸭，不会飞行类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器，传入FlyBehavor 的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 这是野鸭 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WildDuck wildDuck = <span class="keyword">new</span> WildDuck();</span><br><span class="line">		wildDuck.fly();</span><br><span class="line">		ToyDuck toyDuck = <span class="keyword">new</span> ToyDuck();</span><br><span class="line">		toyDuck.fly();</span><br><span class="line">		PekingDuck pekingDuck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">		<span class="comment">//动态改变某个对象的行为, 北京鸭 不能飞</span></span><br><span class="line">		pekingDuck.setFlyBehavior(<span class="keyword">new</span> NoFlyBehavior());</span><br><span class="line">		System.out.println(<span class="string">&quot;北京鸭的实际飞翔能力&quot;</span>);</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-4、策略模式在JDK的应用与源码"><a href="#25-4、策略模式在JDK的应用与源码" class="headerlink" title="25.4、策略模式在JDK的应用与源码"></a>25.4、策略模式在JDK的应用与源码</h3><p>JDK 的 Arrays 的 Comparator 就使用了策略模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001920044.png" alt="image-20210419001920044"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//数组</span></span><br><span class="line">		Integer[] data = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">		<span class="comment">// 实现降序排序，返回-1放左边，1放右边，0保持不变</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span></span><br><span class="line">		<span class="comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了 策略接口 的对象</span></span><br><span class="line">		<span class="comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span></span><br><span class="line">		Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class="line"><span class="comment">		        if (c == null) &#123;</span></span><br><span class="line"><span class="comment">		            sort(a); //默认方法</span></span><br><span class="line"><span class="comment">		        &#125; else &#123; </span></span><br><span class="line"><span class="comment">		            if (LegacyMergeSort.userRequested)</span></span><br><span class="line"><span class="comment">		                legacyMergeSort(a, c); //使用策略对象c</span></span><br><span class="line"><span class="comment">		            else</span></span><br><span class="line"><span class="comment">		            	// 使用策略对象c</span></span><br><span class="line"><span class="comment">		                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">		        &#125;</span></span><br><span class="line"><span class="comment">		    &#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//方式1 </span></span><br><span class="line">		Arrays.sort(data, comparator);</span><br><span class="line">		System.out.println(Arrays.toString(data)); <span class="comment">// 降序排序</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//方式2- 同时lambda 表达式实现 策略模式</span></span><br><span class="line">		Integer[] data2 = &#123; <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">13</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(data2, (var1, var2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(var1.compareTo(var2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		System.out.println(<span class="string">&quot;data2=&quot;</span> + Arrays.toString(data2));	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator<T>：是一个接口，其中有一个compare的核心方法：告诉代码应该怎么去比较两个实例，然后根据比较结果进行排序</T></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419000512228.png" alt="image-20210419000512228"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001129754.png" alt="image-20210419001129754"></p>
<p>Array的sort排序方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001333373.png" alt="image-20210419001333373"></p>
<h3 id="25-5、-策略模式总结"><a href="#25-5、-策略模式总结" class="headerlink" title="25.5、 策略模式总结"></a>25.5、 策略模式总结</h3><p>主要优点如下：</p>
<ol>
<li>多重条件语句不易维护，而<strong>使用策略模式可以避免使用多重条件语句</strong>，如 if…else 语句、switch…case 语句。</li>
<li>策略模式提供了<strong>一系列的可供重用的算法族</strong>，<strong>恰当使用继承可以把算法族的公共代码转移到父类里面</strong>，从而避免重复的代码。</li>
<li>策略模式可以<strong>提供相同行为的不同实现</strong>，<strong>客户可以根据不同时间或空间要求选择不同的实现</strong>。</li>
<li>策略模式提供了<strong>对开闭原则的完美支持</strong>，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把<strong>算法的使用放到环境类</strong>中，而<strong>算法的实现移到具体策略类</strong>中，<strong>实现了二者的分离</strong>。</li>
</ol>
<p>其主要缺点如下：</p>
<ol>
<li>所有策略类都需要对外暴露。<strong>客户端必须理解所有策略算法的区别</strong>，以便适时选择恰当的算法类。</li>
<li>策略模式造成<strong>很多的策略类，增加维护难度</strong>。</li>
</ol>
<p>策略模式的应用场景：</p>
<p>策略模式在很多地方用到，如 <strong>Java SE 中的容器布局管理</strong>就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p>
<ol>
<li><strong>一个系统需要动态地在几种算法中选择一种</strong>时，可将每个算法封装到策略类中。</li>
<li>一个类定义了<strong>多种行为</strong>，并且<strong>这些行为在这个类的操作中以多个条件语句的形式出现</strong>，可<strong>将每个条件分支移入它们各自的策略类中以代替这些条件语句</strong>。</li>
<li>系统中<strong>各算法彼此完全独立</strong>，且<strong>要求对客户隐藏具体算法的实现细节</strong>时。</li>
<li>系统要求<strong>使用算法的客户不应该知道其操作的数据</strong>时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li><strong>多个类只区别在表现行为不同</strong>，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ol>
<h3 id="25-6、策略模式扩展（策略模式-工厂模式）"><a href="#25-6、策略模式扩展（策略模式-工厂模式）" class="headerlink" title="25.6、策略模式扩展（策略模式+工厂模式）"></a>25.6、策略模式扩展（策略模式+工厂模式）</h3><p>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果<strong>在环境类中使用策略工厂模式来管理这些策略类</strong>将大大减少客户端的工作复杂度，其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418232858259.png" alt="image-20210418232858259"></p>
<h3 id="25-7、进阶阅读"><a href="#25-7、进阶阅读" class="headerlink" title="25.7、进阶阅读"></a>25.7、进阶阅读</h3><p>如果您想深入了解策略模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8481.html">《使用策略模式实现电商多种促销优惠方案选择》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8482.html">《使用策略模式实现支付方式选择场景》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8483.html">《策略模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8484.html">《策略模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="25-8、相关设计模式"><a href="#25-8、相关设计模式" class="headerlink" title="25.8、相关设计模式"></a>25.8、相关设计模式</h3><ul>
<li><p>Flyweight模式</p>
<p>有时会使用Flyweight模式让多个地方可以共用ConcreteStrategy角色。</p>
</li>
<li><p>Abstract Factory模式</p>
<p>使用Strategy模式可以整体地替换算法。</p>
<p>使用Abstract Factory模式则可以整体地替换具体工厂、零件和产品。</p>
</li>
<li><p>State 模式</p>
<p>使用Strategy模式和State模式都可以替换被委托对象，而且它们的类之间的关系也很相似。但是两种模式的目的不同。</p>
<p>在Strategy模式中，ConcreteStrategy 角色是表示算法的类。在Strategy模式中，可以替换被委托对象的类。当然如果没有必要，也可以不替换。</p>
<p>而在State模式中，ConcreteState角色是表示“状态”的类。在State模式中，每次状态变化时，被委托对象的类都必定会被替换。</p>
</li>
</ul>
<h3 id="25-9、策略模式的注意事项与细节"><a href="#25-9、策略模式的注意事项与细节" class="headerlink" title="25.9、策略模式的注意事项与细节"></a>25.9、策略模式的注意事项与细节</h3><ol>
<li>策略模式的关键是：<strong>分析项目中变化部分与不变部分</strong></li>
<li>策略模式的核心思想是：<strong>多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</strong></li>
<li><strong>体现了“对修改关闭，对扩展开放”原则</strong>，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，<strong>避免了使用多重转移语句（if..else if..else）</strong></li>
<li>提供了可以<strong>替换继承关系</strong>的办法： 策略模式将算法封装在独立的 Strategy 类中使得你可以独立于其 Context 改变它，使它易于切换、易于理解、易于扩展</li>
<li>需要注意的是：每添加一个策略就要增加一个类，当<strong>策略过多是会导致类数目庞大</strong></li>
<li>如果一个系统的策略多于四个，就需要考虑<strong>使用混合模式（策略模式+工厂模式）</strong>，解决策略类膨胀的问题。</li>
</ol>
<h2 id="26、职责链模式Chain-of-Responsibility（行为型模式）"><a href="#26、职责链模式Chain-of-Responsibility（行为型模式）" class="headerlink" title="26、职责链模式Chain of Responsibility（行为型模式）"></a>26、职责链模式Chain of Responsibility（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419002157100.png" alt="image-20210419002157100"></p>
<h3 id="26-1、基本介绍"><a href="#26-1、基本介绍" class="headerlink" title="26.1、基本介绍"></a>26.1、基本介绍</h3><ol>
<li>职责链模式（Chain of Responsibility Pattern）, 又叫<strong>责任链模式</strong>，为<strong>请求创建了一个接收者对象的链</strong>。这种模式对<strong>请求的发送者和接收者进行解耦</strong>。</li>
<li>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</li>
<li>职责链模式通常<strong>每个接收者都包含对另一个接收者的引用（形成闭环）</strong>。如果<strong>一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</li>
<li>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong></li>
</ol>
<h3 id="26-2、职责链模式的原理结构图-uml类图"><a href="#26-2、职责链模式的原理结构图-uml类图" class="headerlink" title="26.2、职责链模式的原理结构图-uml类图"></a>26.2、职责链模式的原理结构图-uml类图</h3><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p>
<h4 id="26-2-1、模式的结构"><a href="#26-2-1、模式的结构" class="headerlink" title="26.2.1、模式的结构"></a>26.2.1、模式的结构</h4><p>职责链模式主要包含以下角色：</p>
<ol>
<li><strong>抽象处理者（Handler）</strong>角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接Handler对象。</li>
<li><strong>具体处理者（Concrete Handler）</strong>角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。从而形成一个职责链。</li>
<li><strong>请求类（Request）</strong>角色 ， 含义很多属性，表示一个请求</li>
<li><strong>客户类（Client）</strong>角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419020914621.png" alt="image-20210419020914621"></p>
<p>客户端可按下图所示设置责任链：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419021241297.png" alt="image-20210419021241297"></p>
<h4 id="26-2-2、代码实现"><a href="#26-2-2、代码实现" class="headerlink" title="26.2.2、代码实现"></a>26.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们把消息硬编码为 String 类型，而在真实业务中，消息是具备多样性的，可以是 int、String 或者自定义类型。因此，在上面代码的基础上，可以<strong>对消息类型进行抽象 Request，增强了消息的兼容性</strong>。</p>
<h3 id="26-3、应用举例"><a href="#26-3、应用举例" class="headerlink" title="26.3、应用举例"></a>26.3、应用举例</h3><p>学校 OA 系统的采购审批项目：需求是</p>
<p>采购员采购教学器材</p>
<ol>
<li>如果金额 小于等于 5000, 由教学主任审批 （0&lt;=x&lt;=5000）</li>
<li>如果金额 小于等于 10000, 由院长审批 (5000&lt;x&lt;=10000)</li>
<li>如果金额 小于等于 30000, 由副校长审批 (10000&lt;x&lt;=30000)</li>
<li>如果金额 超过 30000 以上，有校长审批 ( 30000&lt;x)</li>
</ol>
<p>请设计程序完成采购审批项目</p>
<h4 id="26-3-1、使用传统方法解决需求"><a href="#26-3-1、使用传统方法解决需求" class="headerlink" title="26.3.1、使用传统方法解决需求"></a>26.3.1、使用传统方法解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022414374.png" alt="image-20210419022414374"></p>
<p>传统方案解决 OA 系统审批问题分析：</p>
<p>传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver (审批人)完成审批。</p>
<p>传统方式的问题分析 : </p>
<ol>
<li>客户端这里会<strong>使用到分支判断(比如 switch) 来对不同的采购请求处理</strong>， 这样就存在如下问题：<ol>
<li> 如果各个级别的人员审批金额发生变化，在客户端的也需要变化</li>
<li>客户端必须明确的知道 有多少个审批级别和访问</li>
</ol>
</li>
<li>这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代码的扩展和维护</li>
<li>解决方案 =》 职责链模式</li>
</ol>
<h4 id="26-3-2、使用职责链模式解决需求"><a href="#26-3-2、使用职责链模式解决需求" class="headerlink" title="26.3.2、使用职责链模式解决需求"></a>26.3.2、使用职责链模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022837598.png" alt="image-20210419022837598"></p>
<p>代码实现：</p>
<p>PurchaseRequest：采购请求。<strong>请求类（Request）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Approver：<strong>抽象处理者（Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	Approver approver;  <span class="comment">//下一个处理者</span></span><br><span class="line">	String name; <span class="comment">// 名字	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下一个处理者</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver approver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.approver = approver;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DepartmentApprover：教学主任处理类。（其中CollegeApprover：院长处理类（5000&lt;x&lt;=10000）、ViceSchoolMasterApprover：副校长处理类（10000&lt;x&lt;=30000）、SchoolMasterApprover：院长处理类（30000&lt;x）类似）<strong>具体处理者（Concrete Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：<strong>客户类（Client）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个请求</span></span><br><span class="line">		PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">31000</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//创建相关的审批人</span></span><br><span class="line">		DepartmentApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">&quot;张主任&quot;</span>);</span><br><span class="line">		CollegeApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">&quot;李院长&quot;</span>);</span><br><span class="line">		ViceSchoolMasterApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">&quot;王副校&quot;</span>);</span><br><span class="line">		SchoolMasterApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">&quot;佟校长&quot;</span>);</span><br><span class="line">		<span class="comment">//需要将各个审批级别的下一个设置好 (处理人构成环形: )</span></span><br><span class="line">		departmentApprover.setApprover(collegeApprover);</span><br><span class="line">		collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">		viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">		schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line">		</span><br><span class="line">		departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">		viceSchoolMasterApprover.processRequest(purchaseRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-4、职责链模式在SpringMVC框架的应用与源码"><a href="#26-4、职责链模式在SpringMVC框架的应用与源码" class="headerlink" title="26.4、职责链模式在SpringMVC框架的应用与源码"></a>26.4、职责链模式在SpringMVC框架的应用与源码</h3><p>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</p>
<p>SpringMVC 请求流程简图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419011833309.png" alt="image-20210419011833309"></p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012005876.png" alt="image-20210419012005876"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExecutionChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponsibilityChain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// DispatcherServlet 	</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 *  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></span><br><span class="line"><span class="comment">		 *   HandlerExecutionChain mappedHandler = null; </span></span><br><span class="line"><span class="comment">		 *   mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象</span></span><br><span class="line"><span class="comment">		 *    //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor</span></span><br><span class="line"><span class="comment">		 *    //调用了拦截器的  interceptor.preHandle</span></span><br><span class="line"><span class="comment">		 *   if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></span><br><span class="line"><span class="comment">					return;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">			  //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用 </span></span><br><span class="line"><span class="comment">			  //拦截器的  interceptor.postHandle(request, response, this.handler, mv);</span></span><br><span class="line"><span class="comment">			 mappedHandler.applyPostHandle(processedRequest, response, mv);</span></span><br><span class="line"><span class="comment">		 *  &#125;</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  //说明：在  mappedHandler.applyPreHandle内部中，</span></span><br><span class="line"><span class="comment">		 *  还调用了  triggerAfterCompletion 方法，该方法中调用了  </span></span><br><span class="line"><span class="comment">		 *  HandlerInterceptor interceptor = getInterceptors()[i];</span></span><br><span class="line"><span class="comment">			try &#123;</span></span><br><span class="line"><span class="comment">				interceptor.afterCompletion(request, response, this.handler, ex);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			catch (Throwable ex2) &#123;</span></span><br><span class="line"><span class="comment">				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC中的最重要的DispatcherServlet类，当中有一个核心方法：doDispatcher方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012029050.png" alt="image-20210419012029050"></p>
<p>在doDispatcher方法中一开始就获取了HandlerExecutionChain对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012220314.png" alt="image-20210419012220314"></p>
<p>调用preHandle方法：</p>
<p>在得到HandlerExecutionChain对象后调用了其applyPreHandle()方法，在其内部得到了HandlerInterceptor interceptor拦截器并调用了拦截器的interceptor.preHandle方法。调用成功就返回。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012326046.png" alt="image-20210419012326046"></p>
<p>在applyPreHandle()中通过getInterceptors( ) [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的preHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012558289.png" alt="image-20210419012558289"></p>
<p>调用postHandle方法：</p>
<p>在doDispatcher方法的applyPreHandle()下面：HandlerExecutionChain对象还调用了其applyPostHandle()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210419013424983.png" alt="image-20210419013424983"></p>
<p>在applyPostHandle()中通过getInterceptors() [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的postHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419013555142.png" alt="image-20210419013555142"></p>
<p>调用afterCompletion方法：</p>
<p>triggerAfterCompletion方法中得到了拦截器HandlerInterceptor并调用了拦截器的interceptor.afterCompletion方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014131628.png" alt="image-20210419014131628"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014819146.png" alt="image-20210419014819146"></p>
<p>对源码总结</p>
<ol>
<li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等</li>
<li>在处理 SpringMvc 请求时，使用到职责链模式还使用到适配器模式</li>
<li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li>
<li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器.</li>
</ol>
<h3 id="26-5、职责链模式总结"><a href="#26-5、职责链模式总结" class="headerlink" title="26.5、职责链模式总结"></a>26.5、职责链模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了对象之间的耦合度</strong>。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li><strong>增强了系统的可扩展性</strong>。可以根据需要增加新的请求处理类，<strong>满足开闭原则</strong>。</li>
<li><strong>增强了给对象指派职责的灵活性</strong>。当工作流程发生变化，可以<strong>动态地改变链内的成员或者调动它们的次序</strong>，也可<strong>动态地新增或者删除责任</strong>。</li>
<li><strong>责任链简化了对象之间的连接</strong>。<strong>每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用</strong>，这<strong>避免了使用众多的 if 或者 if···else 语句</strong>。</li>
<li><strong>责任分担</strong>。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，<strong>符合类的单一职责原则</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>不能保证每个请求一定被处理</strong>。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，<strong>该请求可能一直传到链的末端都得不到处理</strong>。所以最好形成闭环调用，保证请求一定可以得到调用。</li>
<li>对比较长的职责链，<strong>请求的处理可能涉及多个处理对象</strong>，<strong>系统性能将受到一定影响</strong>。</li>
<li>职责链建立的合理性<strong>要靠客户端来保证，增加了客户端的复杂性</strong>，可能会由于职责链的<strong>错误设置而导致系统出错</strong>，如可能会造成<strong>循环调用</strong>。</li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li><strong>多个对象可以处理一个请求</strong>，但具体由哪个对象处理该请求在运行时自动确定。</li>
<li>可<strong>动态指定一组对象处理请求</strong>，或<strong>添加新的处理者</strong>。</li>
<li>需要<strong>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>JS 中的事件冒泡。</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理</li>
<li>Struts2 的拦截器</li>
<li>jsp servlet 的 Filter</li>
<li>责任链模式经常用在拦截、预处理请求等。</li>
</ol>
<h3 id="26-6、职责链模式扩展"><a href="#26-6、职责链模式扩展" class="headerlink" title="26.6、职责链模式扩展"></a>26.6、职责链模式扩展</h3><p>职责链模式存在以下两种情况：</p>
<ol>
<li><strong>纯的职责链模式</strong>：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li><strong>不纯的职责链模式</strong>：允许出现某一个具体处理者对象<strong>在承担了请求的一部分责任后又将剩余的责任传给下家</strong>的情况，且<strong>一个请求可以最终不被任何接收端对象所接收</strong>。</li>
</ol>
<h3 id="26-7、进阶阅读"><a href="#26-7、进阶阅读" class="headerlink" title="26.7、进阶阅读"></a>26.7、进阶阅读</h3><p>如果您想深入了解责任链模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8487.html">《使用责任链模式实现热插拔权限控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8488.html">《责任链模式和建造者模式结合使用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8489.html">《责任链模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="26-8、相关设计模式"><a href="#26-8、相关设计模式" class="headerlink" title="26.8、相关设计模式"></a>26.8、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>Handler角色经常会使用Composite模式。</p>
</li>
<li><p>Command模式</p>
<p>有时会使用Command模式向Handler角色发送请求。</p>
</li>
</ul>
<h3 id="26-9、职责链模式的注意事项与细节"><a href="#26-9、职责链模式的注意事项与细节" class="headerlink" title="26.9、职责链模式的注意事项与细节"></a>26.9、职责链模式的注意事项与细节</h3><ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此<strong>需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量</strong>，<strong>在 setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</strong></li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web 中 Tomcat对 Encoding 的处理、拦截器</li>
</ol>
<h2 id="27、创建型模式的特点和分类"><a href="#27、创建型模式的特点和分类" class="headerlink" title="27、创建型模式的特点和分类"></a>27、创建型模式的特点和分类</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象</strong>？”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种：</p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式</p>
<h2 id="28、结构型模式概述（结构型模式的分类）"><a href="#28、结构型模式概述（结构型模式的分类）" class="headerlink" title="28、结构型模式概述（结构型模式的分类）"></a>28、结构型模式概述（结构型模式的分类）</h2><p>结构型模式描述<strong>如何将类或对象按某种布局组成更大的结构</strong>。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，<strong>前者采用继承机制来组织接口和类</strong>，<strong>后者釆用组合或聚合来组合对象</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性</strong>。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<strong>适配器模式分为类结构型模式和对象结构型模式两种</strong>，<strong>其他的全部属于对象结构型模式</strong>。</p>
<h2 id="29、行为型模式概述（行为型模式的分类）"><a href="#29、行为型模式概述（行为型模式的分类）" class="headerlink" title="29、行为型模式概述（行为型模式的分类）"></a>29、行为型模式概述（行为型模式的分类）</h2><p>行为型模式用于<strong>描述程序在运行时复杂的流程控制</strong>，即<strong>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。</p>
<p><strong>行为型模式分为类行为模式和对象行为模式</strong>，<strong>前者采用继承机制来在类间分派行为</strong>，<strong>后者采用组合或聚合在对象间分配行为</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</strong></p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了<strong>模板方法模式和解释器模式是类行为型模式</strong>，<strong>其他的全部属于对象行为型模式</strong>。</p>
<h2 id="30、一句话归纳设计模式"><a href="#30、一句话归纳设计模式" class="headerlink" title="30、一句话归纳设计模式"></a>30、一句话归纳设计模式</h2><table>
<thead>
<tr>
<th>分类</th>
<th>设计模式</th>
<th>简述</th>
<th>一句话归纳</th>
<th>目的</th>
<th>生活案例</th>
</tr>
</thead>
<tbody><tr>
<td>创建型设计模式 （简单来说就是用来创建对象的）</td>
<td>工厂模式（Factory Pattern）</td>
<td>不同条件下创建不同实例</td>
<td>产品标准化，生产更高效</td>
<td>封装创建细节</td>
<td>实体工厂</td>
</tr>
<tr>
<td>单例模式（Singleton Pattern）</td>
<td>保证一个类仅有一个实例，并且提供一个全局访问点</td>
<td>世上只有一个我</td>
<td>保证独一无二</td>
<td>CEO</td>
<td></td>
</tr>
<tr>
<td>原型模式（Prototype Pattern）</td>
<td>通过拷贝原型创建新的对象</td>
<td>拔一根猴毛，吹出千万个</td>
<td>高效创建对象</td>
<td>克隆</td>
<td></td>
</tr>
<tr>
<td>建造者模式（Builder Pattern）</td>
<td>用来创建复杂的复合对象</td>
<td>高配中配和低配，想选哪配就哪配</td>
<td>开放个性配置步骤</td>
<td>选配</td>
<td></td>
</tr>
<tr>
<td>结构型设计模式 （关注类和对象的组合）</td>
<td>代理模式（Proxy Pattern）</td>
<td>为其他对象提供一种代理以控制对这个对象的访问</td>
<td>没有资源没时间，得找别人来帮忙</td>
<td>增强职责</td>
<td>媒婆</td>
</tr>
<tr>
<td>外观模式（Facade Pattern）</td>
<td>对外提供一个统一的接口用来访问子系统</td>
<td>打开一扇门，通向全世界</td>
<td>统一访问入口</td>
<td>前台</td>
<td></td>
</tr>
<tr>
<td>装饰器模式（Decorator Pattern）</td>
<td>为对象添加新功能</td>
<td>他大舅他二舅都是他舅</td>
<td>灵活扩展、同宗同源</td>
<td>煎饼</td>
<td></td>
</tr>
<tr>
<td>享元模式（Flyweight Pattern）</td>
<td>使用对象池来减少重复对象的创建</td>
<td>优化资源配置，减少重复浪费</td>
<td>共享资源池</td>
<td>全国社保联网</td>
<td></td>
</tr>
<tr>
<td>组合模式（Composite Pattern）</td>
<td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td>
<td>人在一起叫团伙，心在一起叫团队</td>
<td>统一整体和个体</td>
<td>组织架构树</td>
<td></td>
</tr>
<tr>
<td>适配器模式（Adapter Pattern）</td>
<td>将原来不兼容的两个类融合在一起</td>
<td>万能充电器</td>
<td>兼容转换</td>
<td>电源适配</td>
<td></td>
</tr>
<tr>
<td>桥接模式（Bridge Pattern）</td>
<td>将两个能够独立变化的部分分离开来</td>
<td>约定优于配置</td>
<td>不允许用继承</td>
<td>桥</td>
<td></td>
</tr>
<tr>
<td>行为型设计模式 （关注对象之间的通信）</td>
<td>模板模式（Template Pattern）</td>
<td>定义一套流程模板，根据需要实现模板中的操作</td>
<td>流程全部标准化，需要微调请覆盖</td>
<td>逻辑复用</td>
<td>把大象装进冰箱</td>
</tr>
<tr>
<td>策略模式（Strategy Pattern）</td>
<td>封装不同的算法，算法之间能互相替换</td>
<td>条条大道通罗马，具体哪条你来定</td>
<td>把选择权交给用户</td>
<td>选择支付方式</td>
<td></td>
</tr>
<tr>
<td>责任链模式（Chain of Responsibility Pattern）</td>
<td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td>
<td>各人自扫门前雪，莫管他们瓦上霜</td>
<td>解耦处理逻辑</td>
<td>踢皮球</td>
<td></td>
</tr>
<tr>
<td>迭代器模式（Iterator Pattern）</td>
<td>提供一种方法顺序访问一个聚合对象中的各个元素</td>
<td>流水线上坐一天，每个包裹扫一遍</td>
<td>统一对集合的访问方式</td>
<td>逐个检票进站</td>
<td></td>
</tr>
<tr>
<td>命令模式（Command Pattern）</td>
<td>将请求封装成命令，并记录下来，能够撤销与重做</td>
<td>运筹帷幄之中，决胜千里之外</td>
<td>解耦请求和处理</td>
<td>遥控器</td>
<td></td>
</tr>
<tr>
<td>状态模式（State Pattern）</td>
<td>根据不同的状态做出不同的行为</td>
<td>状态驱动行为，行为决定状态</td>
<td>绑定状态和行为</td>
<td>订单状态跟踪</td>
<td></td>
</tr>
<tr>
<td>备忘录模式（Memento Pattern）</td>
<td>保存对象的状态，在需要时进行恢复</td>
<td>失足不成千古恨，想重来时就重来</td>
<td>备份、后悔机制</td>
<td>草稿箱</td>
<td></td>
</tr>
<tr>
<td>中介者模式（Mediator Pattern）</td>
<td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td>
<td>联系方式我给你，怎么搞定我不管</td>
<td>统一管理网状资源</td>
<td>朋友圈</td>
<td></td>
</tr>
<tr>
<td>解释器模式（Interpreter Pattern）</td>
<td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td>
<td>我想说”方言“，一切解释权都归我</td>
<td>实现特定语法解析</td>
<td>摩斯密码</td>
<td></td>
</tr>
<tr>
<td>观察者模式（Observer Pattern）</td>
<td>状态发生改变时通知观察者，一对多的关系</td>
<td>到点就通知我</td>
<td>解耦观察者与被观察者</td>
<td>闹钟</td>
<td></td>
</tr>
<tr>
<td>访问者模式（Visitor Pattern）</td>
<td>稳定数据结构，定义新的操作行为</td>
<td>横看成岭侧成峰，远近高低各不同</td>
<td>解耦数据结构和数据操作</td>
<td>KPI考核</td>
<td></td>
</tr>
<tr>
<td></td>
<td>委派模式（Delegate Pattern）</td>
<td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td>
<td>这个需求很简单，怎么实现我不管</td>
<td>只对结果负责</td>
<td>授权委托书</td>
</tr>
</tbody></table>
<h2 id="31、其他设计模式（不属于23种）"><a href="#31、其他设计模式（不属于23种）" class="headerlink" title="31、其他设计模式（不属于23种）"></a>31、其他设计模式（不属于23种）</h2><ol>
<li><p>MVC 模式：Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><p><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</p>
</li>
<li><p><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</p>
</li>
<li><p><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419025540539.png" alt="image-20210419025540539"></p>
</li>
</ul>
</li>
<li><p>业务代表模式（Business Delegate Pattern）：用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体：</p>
<ul>
<li><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。</li>
<li><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li>
<li><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li>
<li><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。</li>
</ul>
</li>
<li><p>组合实体模式（Composite Entity Pattern）：用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者：</p>
<ul>
<li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li>
<li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li>
<li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li>
<li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。</li>
</ul>
</li>
<li><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式：用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者：</p>
<ul>
<li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li>
<li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li>
<li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。</li>
</ul>
</li>
<li><p>前端控制器模式（Front Controller Pattern）：是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li>
<li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li>
<li><strong>视图（View）</strong> - 视图是为请求而创建的对象。</li>
</ul>
</li>
<li><p>拦截过滤器模式（Intercepting Filter Pattern）：用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li>
<li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li>
<li><strong>Target</strong> - Target 对象是请求处理程序。</li>
<li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li>
<li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。</li>
</ul>
</li>
<li><p>服务定位器模式（Service Locator Pattern）：用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体：</p>
<ul>
<li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li>
<li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li>
<li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li>
<li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li>
<li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。</li>
</ul>
</li>
<li><p>传输对象模式（Transfer Object Pattern）：用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体：</p>
<ul>
<li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li>
<li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li>
<li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。</li>
</ul>
</li>
<li><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p>
<p>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
</li>
</ol>
<h2 id="32、设计模式相关的网站"><a href="#32、设计模式相关的网站" class="headerlink" title="32、设计模式相关的网站"></a>32、设计模式相关的网站</h2><ul>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science)">Wiki Page for Design Patterns</a> - 以一种非常通用的方式检查设计模式。</li>
<li><a target="_blank" rel="noopener" href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns">Java Programming/Design Patterns</a> - 一篇关于设计模式的好文章。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/docs/books/tutorial/index.html">The JavaTM Tutorials</a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.4.2/docs/index.html">JavaTM 2 SDK, Standard Edition </a>- JavaTM 2 SDK, Standard Edition 的官网。</li>
</ul>
<h2 id="0、延伸"><a href="#0、延伸" class="headerlink" title="0、延伸"></a>0、延伸</h2><h3 id="1、各种生成实例的方法的介绍"><a href="#1、各种生成实例的方法的介绍" class="headerlink" title="1、各种生成实例的方法的介绍"></a>1、各种生成实例的方法的介绍</h3><p>在Java中可以使用下面这些方法生成实例。</p>
<h4 id="1、new"><a href="#1、new" class="headerlink" title="1、new"></a>1、new</h4><p>一般我们使用Java关键字new生成实例。</p>
<p>可以像下面这样生成Something类的实例并将其保存在obj变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something obj = <span class="keyword">new</span> Something(); </span><br></pre></td></tr></table></figure>

<p>这时， 类名（此处的Something)会出现在代码中 。（即形成强耦合关系）</p>
<h4 id="2、clone"><a href="#2、clone" class="headerlink" title="2、clone"></a>2、clone</h4><p>我们也可以使用在Prototype模式中学习过的clone方法， 根据现有 的实例复制出一个新的实例。</p>
<p>我们可以像下面这样根据自身来复制出新的实例（不过不会调用构造函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123; </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Something <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Something obj = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            obj = (Something) clone(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、new-Instance"><a href="#3、new-Instance" class="headerlink" title="3、new Instance"></a>3、new Instance</h4><p>使用java.lang.Class类的newinstance方法可以通过Class类的实例生成出Class类所表示的类0的实例（会调用无参构造函数）。</p>
<p>下面我们再看一个例子。 假设我们现在已经有了Something类的实例someobj， 通过下面的表达式可以生成另外一个 Something类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someobj.getClass().newinstance() </span><br></pre></td></tr></table></figure>

<p>实际上， 调用newinstance方法可能会导致抛出InstantiationException异常或是 illegalAccessException异常， 因此需要将其置千try…catch语句块中或是用throws关键字指定调用newinstance方法的方法可能会抛出的异常。</p>
<h3 id="2、类名是束缚吗"><a href="#2、类名是束缚吗" class="headerlink" title="2、类名是束缚吗"></a>2、类名是束缚吗</h3><p>话说回来， 在源程序中使用类名到底会有什么问题呢？在代码中出现要使用的类的名字不是理 所当然的吗？</p>
<p>这里， 让我们再回忆一下面向对象编程的目标之一，即“作为组件复用” 。</p>
<p>在代码中出现要使用的类的名字并非总是坏事。 不过 ，<strong>—旦在代码中出现要使用的类的名字， 就无法与该类分离开来， 也就无法实现复用</strong>。</p>
<p>当然 ， 可以通过替换源代码或是改变类名来解决这个问题。 但是， 此处说的“作为组件复用”中不包含替换源代码。 以Java来说， 重要的是当手边只有class文件(.class)时， 该类能否被复用。 <strong>即使没有Java文件(.java)也能复用该类才是关键。</strong></p>
<p>当多个类必须紧密结合时， 代码中出现这些类的名字是没有问题的。但是如果那些需要被独立 出来作为组件复用的类的名字出现在代码中， 那就有问题了。</p>
<h3 id="3、类的层次与抽象类"><a href="#3、类的层次与抽象类" class="headerlink" title="3、类的层次与抽象类"></a>3、类的层次与抽象类</h3><p>父类对子类的要求：</p>
<p>我们在理解类的层次时 ， 通常是站在子类的角度进行思考的。也就是说 ， 很容易着眼千以 下几点：</p>
<ul>
<li>在子类中可以使用父类中定义的方法</li>
<li>可以通过在子类中增加方法以实现新的功能</li>
<li>在子类中重写父类的方法可以改变程序的行为</li>
</ul>
<p>现在 ， 让我们稍微改变一下立场 ， 站在父类的角度进行思考。在父类中， 我们声明了抽象方法、而将该方法的实现交给了子类。换言之 ， 就程序而言，声明抽象方法是希望达到以下目的：</p>
<ul>
<li>期待子类去实现抽象方法</li>
<li>要求子类去实现抽象方法</li>
</ul>
<p>也就是说 ，子类具有实现在父类中所声明的抽象方法的责任。因此，这种责任被称为 “子类责任”(subclass responsibility）。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟驿站-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">廖雪峰-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64b7b86a3ee">面向对象的七大设计原则</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">设计模式之七大基本原则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before规则相关</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/18369201">详解Java中的clone方法 – 原型模式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/12952063">java提高篇（五）—–使用序列化实现对象的拷贝</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149775781">动态代理的几种实现方式及优缺点</a></p>
<p>有关于Copy-on-write代理：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>相关书籍：</p>
<p>《图解设计模式》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-05 22:23:15" itemprop="dateCreated datePublished" datetime="2021-04-05T22:23:15+08:00">2021-04-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/03/15/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/springcloud/" class="post-title-link" itemprop="url">SpringCloud</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-15 00:30:19 / 修改时间：01:13:19" itemprop="dateCreated datePublished" datetime="2021-03-15T00:30:19+08:00">2021-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/springcloud/" itemprop="url" rel="index"><span itemprop="name">springcloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="1、微服务架构概述"><a href="#1、微服务架构概述" class="headerlink" title="1、微服务架构概述"></a>1、微服务架构概述</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务。</p>
<p>服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独</p>
<p>立的进程中，服务与服务间采用轻量级的通信机制互相协作(通常是基于</p>
<p>HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够</p>
<p>被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集</p>
<p>中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合</p>
<p>适的语言、工具对其进行构建。</p>
<h3 id="2、微服务架构编码构建"><a href="#2、微服务架构编码构建" class="headerlink" title="2、微服务架构编码构建"></a>2、微服务架构编码构建</h3><p>Rest微服务工程搭建：</p>
<ol>
<li><p>约定&gt;配置&gt;编码</p>
</li>
<li><p>IDEA新建project工作空间</p>
<ul>
<li>微服务cloud整体聚合工程<ul>
<li>父工程步骤<ul>
<li>New Project</li>
<li>聚合总父工程名字</li>
<li>Maven选版本</li>
<li>工程名字</li>
<li>字符编码</li>
<li>注解生效激活</li>
<li>java编译版本选8</li>
<li>File Type过滤</li>
</ul>
</li>
<li>父工程POM<ul>
<li>DependencyManagement(版本统一管理)</li>
<li>maven中跳过单元测试</li>
</ul>
</li>
<li>父工程创建完成执行mvn:insall将父工程发布到仓库方便子工程继承</li>
</ul>
</li>
</ul>
</li>
<li><p>Rest微服务工程搭建</p>
<ul>
<li><p>创建公共的模块</p>
<ul>
<li>实体类emtities<ul>
<li>主实体</li>
<li>Json封装体</li>
</ul>
</li>
<li>常量类</li>
<li>枚举类</li>
<li>创建步骤<ul>
<li>建module</li>
<li>改pom</li>
<li>编写</li>
<li>执行mvn:insall将公共工程发布到仓库方便需要的工程继承</li>
</ul>
</li>
</ul>
</li>
<li><p>微服务提供者Module模块</p>
<ul>
<li>建module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类<ul>
<li>建表sql</li>
<li>dao<ul>
<li>接口</li>
<li>mybatis的映射文件(src\main\resources\mapper\XxxxxMapper.xml)</li>
</ul>
</li>
<li>service<ul>
<li>接口</li>
<li>实现类</li>
</ul>
</li>
<li>controller</li>
</ul>
</li>
<li>测试（postman）</li>
</ul>
</li>
<li><p>热部署Devtools</p>
</li>
<li><p>微服务消费者订单Module模块</p>
<ul>
<li>建module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类<ul>
<li>config配置类</li>
<li>controller</li>
</ul>
</li>
<li>测试</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3、SpringCloud简介"><a href="#3、SpringCloud简介" class="headerlink" title="3、SpringCloud简介"></a>3、SpringCloud简介</h3><p>SpringCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落</p>
<p>地技术的集合体，俗称微服务全家桶。</p>
<p><img src="/2021/03/15/springcloud/1.jpg" alt="1"></p>
<p><img src="/2021/03/15/springcloud/2.jpg" alt="2"></p>
<h3 id="4、SpringCloud技术栈"><a href="#4、SpringCloud技术栈" class="headerlink" title="4、SpringCloud技术栈"></a>4、SpringCloud技术栈</h3><p><img src="/2021/03/15/springcloud/206.png" alt="image-20210305205540848"></p>
<p><img src="/2021/03/15/springcloud/207.png" alt="image-20210305205647548"></p>
<p><img src="/2021/03/15/springcloud/3.jpg" alt="3"></p>
<h3 id="5、版本选择"><a href="#5、版本选择" class="headerlink" title="5、版本选择"></a>5、版本选择</h3><p>springboot：2.2.RELEASE</p>
<p>springcloud：Hoxton.SR1</p>
<p>springcloud Alibaba：2.1.0.RELEASE</p>
<p>java：8</p>
<p>Maven：3.5及以上</p>
<p>Mysql：5.7及以上</p>
<h3 id="6、访问方式"><a href="#6、访问方式" class="headerlink" title="6、访问方式"></a>6、访问方式</h3><ul>
<li>网页</li>
<li>postman</li>
<li>dos窗口 + crul<ul>
<li>加入curl返回中文乱码（<a target="_blank" rel="noopener" href="https://blog.csdn.net/leedee/article/details/82685636%EF%BC%89">https://blog.csdn.net/leedee/article/details/82685636）</a></li>
</ul>
</li>
</ul>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="7、Eureka注册中心"><a href="#7、Eureka注册中心" class="headerlink" title="7、Eureka注册中心"></a>7、Eureka注册中心</h3><h4 id="7-1、Eureka基础知识："><a href="#7-1、Eureka基础知识：" class="headerlink" title="7.1、Eureka基础知识："></a>7.1、Eureka基础知识：</h4><ul>
<li><p>服务治理：SpringCloud封装了Netflix公司开发的Eureka模块来实现服</p>
<p>务治理。</p>
<p>在传统的rpc远程调用框架中，管理每个服务与服务之间的依赖关系比</p>
<p>较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间</p>
<p>的依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的发现</p>
<p>与注册。</p>
</li>
<li><p>服务发现与注册：Eureka采用了CS的设计架构，Eureka Server作为服</p>
<p>务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使</p>
<p>用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的</p>
<p>维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常</p>
<p>运行。</p>
<p>在服务注册与发现中，有一个注册中心。但服务器启动的时候，会把当</p>
<p>前自己的服务的信息。比如：服务地址、通讯地址等以别名方式注册到</p>
<p>注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册</p>
<p>中心上获取到实际的服务通讯地址，然后在实现本地的RPC调用。远程</p>
<p>RPC调用的框架核心设计思想：在于注册中心，因为使用注册中心管理</p>
<p>每个服务与服务之间的一个依赖关系（服务治理概念）。在任何远程</p>
<p>RPC框架中，都会有一个注册中心（存放服务地址相关信息（接口地</p>
<p>址））</p>
</li>
<li><p>Eureka系统架构与Dubbo架构的对比</p>
<p><img src="/2021/03/15/springcloud/4.png" alt="image-20210309193119872"></p>
<p><img src="/2021/03/15/springcloud/5.png" alt="image-20210309193236970"></p>
</li>
<li><p>Eureka的两大组件</p>
<ul>
<li><p>Eureka Server：提供服务注册服务</p>
<p>各个微服务结点通过配置启动后，会在Eureka Server中进行注</p>
<p>册，这样Eureka Server中的服务注册表中将会存储所有可用服务</p>
<p>注册节点的信息，服务节点的信息可以在界面中直观看到。</p>
<p>主启动加注解：@EnableEurekaServer</p>
<p>pom:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Eureka Client：通过注册中心进行访问</p>
<p>是一个java客户端，用于简化Eureka Server的交互，客户端同时也</p>
<p>具备一个内置的，使用轮询（round-robin）负载算法的负载均衡</p>
<p>器。在启动应用后，将会向Eureka Server发送心跳（默认周期</p>
<p>30s）。如果Eureka Server在多个心跳周期内没有接收到某个节点</p>
<p>的心跳，Eureka Server将会从访问注册表中把这个服务节点移除</p>
<p>（默认90s）</p>
<p>主启动加注解：@EnableEurekaClient</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="7-2、工作流程："><a href="#7-2、工作流程：" class="headerlink" title="7.2、工作流程："></a>7.2、工作流程：</h4><p><img src="/2021/03/15/springcloud/springcloud%5C6.png" alt="img"></p>
<p> 解决办法: 搭建Eureka注册中心集群,实现负载均衡+故障容错</p>
<h4 id="7-3、集群搭建"><a href="#7-3、集群搭建" class="headerlink" title="7.3、集群搭建"></a>7.3、集群搭建</h4><p>相互依赖，相互守望（在application.yml中配置文件互相配置）</p>
<h4 id="7-4、eureka自我保护"><a href="#7-4、eureka自我保护" class="headerlink" title="7.4、eureka自我保护"></a>7.4、eureka自我保护</h4><p>概述：保护模式主要用于一组客户端和Eureka Server之间存在网络分区场</p>
<p>景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册</p>
<p>表中的信息，不在删除服务注册表中的数据，也就是不会注销任何微服务。</p>
<p><img src="/2021/03/15/springcloud/7.png" alt="image-20210309203401792"></p>
<p>导致原因：</p>
<p><img src="/2021/03/15/springcloud/8.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/9.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/10.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/11.png" alt="img"> </p>
<p>一句话总结:某时刻 一个微服务不可用了,Eureka不会立刻清理,依旧会对该</p>
<p>服务的信息进行保存。属于CAP里面的AP分支</p>
<p>如何禁用Eureka的保护模式：</p>
<p>在Eureka服务端（Eureka Server）：</p>
<p>使用eureka.server.enable-self-preservation=false 可以禁用自我保护模式</p>
<p>在Eureka客户端（Eureka Client）（修改时间）：</p>
<ul>
<li><p>eureka.instance.lease-renewal-interval-in-seconds=1</p>
<p>Eureka客户端向服务端发送心跳的时间间隔,单位为秒。默认是30秒</p>
</li>
<li><p>eureka.instance.lease-expiration-duration-in-seconds=90</p>
<p>Eureka服务端在收到最后一次心跳后等待时间上限 ,单位为秒(默认是90</p>
<p>秒),超时删除服务</p>
</li>
</ul>
<h3 id="8、Zookeeper注册中心"><a href="#8、Zookeeper注册中心" class="headerlink" title="8、Zookeeper注册中心"></a>8、Zookeeper注册中心</h3><p>Zookeeper是一个分布式协调工具,可以实现注册中心功能。</p>
<p>依赖导入：</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>服务节点是临时节点还是持久节点？</p>
<p>临时节点。所以Zookeeper属于CAP中里的CP分支。</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C12.png" alt="img"> </p>
<h3 id="9、Consul注册中心"><a href="#9、Consul注册中心" class="headerlink" title="9、Consul注册中心"></a>9、Consul注册中心</h3><h4 id="9-1、什么是consul"><a href="#9-1、什么是consul" class="headerlink" title="9.1、什么是consul"></a>9.1、什么是consul</h4><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用</p>
<p>Go语言开发。Consul提供了微服务系统中的服务治理、配置中心、控制总</p>
<p>线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用</p>
<p>以构建全方位的服务网络，总之Consul提供了一种完整服务网络解决方</p>
<p>案。</p>
<p>优点：</p>
<ul>
<li>基于raft协议，比较简洁</li>
<li>支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群</li>
<li>提供图形界面</li>
<li>跨平台</li>
<li>支持Linux、Mac、Windows</li>
</ul>
<p><img src="/2021/03/15/springcloud/13.png" alt="image-20210309210438031">  </p>
<h4 id="9-2、功能"><a href="#9-2、功能" class="headerlink" title="9.2、功能"></a>9.2、功能</h4><ul>
<li>服务发现：提供HTTP/DNS两种发现方式</li>
<li>健康检测：支持多种方式,HTTP、TCP、Docker、shell脚本定制化</li>
<li>KV存储：Key、Value的存储方式</li>
<li>多数据中心：Consul支持多数据中心</li>
<li>可视化界面</li>
</ul>
<h4 id="9-3、依赖导入"><a href="#9-3、依赖导入" class="headerlink" title="9.3、依赖导入"></a>9.3、依赖导入</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="10、三个注册中心异同点"><a href="#10、三个注册中心异同点" class="headerlink" title="10、三个注册中心异同点"></a>10、三个注册中心异同点</h3><p><img src="/2021/03/15/springcloud/14.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/15.png" alt="img"> </p>
<p>CP(Zookeeper/Consul)：</p>
<p>当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性</p>
<p>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP。</p>
<p><img src="/2021/03/15/springcloud/16.png" alt="image-20210307031636572"></p>
<p>AP(Eureka):</p>
<p><img src="/2021/03/15/springcloud/19.png" alt="img"> </p>
<p>CAP（分区容错性要保证,所以要么是CP,要么是AP）：</p>
<ul>
<li>C: Consistency(强一致性)</li>
<li>A: Availability(可用性)</li>
<li>P: Parttition tolerance(分区容错性)</li>
</ul>
<p>CAP理论关注粒度是否是数据,而不是整体系统设计的策略</p>
<p>经典CAP图：</p>
<p><img src="/2021/03/15/springcloud/17.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/18.png" alt="img"> </p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="11、Ribbon负载均衡调用"><a href="#11、Ribbon负载均衡调用" class="headerlink" title="11、Ribbon负载均衡调用"></a>11、Ribbon负载均衡调用</h3><h4 id="11-1、是什么"><a href="#11-1、是什么" class="headerlink" title="11.1、是什么"></a>11.1、是什么</h4><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的</p>
<p>工具。</p>
<p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软</p>
<p>件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项</p>
<p>如连接超时，重试等。简单的说，就是在配置文件中列出Load </p>
<p>Balancer（LB）后面所有机器，Ribbon会自动的帮助你基于某种规则(如简</p>
<p>单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义</p>
<p>的负载均衡算法。 </p>
<p>总结: Ribbon其实就是一个软负载均衡的客户端组件,  他可以和其他所需请</p>
<p>求的客户端结合使用,和eureka结合只是其中一个实例.</p>
<h4 id="11-2、作用（负载均衡-RestTemplate调用）"><a href="#11-2、作用（负载均衡-RestTemplate调用）" class="headerlink" title="11.2、作用（负载均衡+RestTemplate调用）"></a>11.2、作用（负载均衡+RestTemplate调用）</h4><p>LB(负载均衡)：</p>
<p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的</p>
<p>HA（高可用）。</p>
<p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p>
<p>Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡的区别：</p>
<ul>
<li><p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由</p>
<p>nginx实现转发请求。即负载均衡是由服务端实的。</p>
</li>
<li><p>Ribbon本地负载均衡，在调用微服务接口的时候，会在注册中心上获</p>
<p>取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。 </p>
</li>
</ul>
<p>LB(负载均衡)可分为：</p>
<ul>
<li><p>集中式LB</p>
<p>即在服务的消费方和提供方之间提供独立的LB设施(可以是硬件如F5，</p>
<p>也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发</p>
<p>至服务的提供方。</p>
</li>
<li><p>进程内LB</p>
<p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，</p>
<p>然后自己再从这些地址中选择出一台合适的服务器。Ribbon就属于进</p>
<p>程内LB，它只是一个类库，集成与消费方进程，消费方通过它来获取服</p>
<p>务提供方的地址。 </p>
</li>
</ul>
<h4 id="11-3、框架说明"><a href="#11-3、框架说明" class="headerlink" title="11.3、框架说明"></a>11.3、框架说明</h4><p><img src="/2021/03/15/springcloud/20.png" alt="img"> </p>
<p>Ribbon在工作时分成两步：</p>
<ul>
<li><p>第一步：</p>
<p>先选择Eureka Server，它优先选择在同一区域内负载较少的server</p>
</li>
<li><p>第二步：</p>
<p>再根据用户指定的策略，再从server取到的服务注册列表中选择一个地</p>
<p>址。其中Ribbon提供了多种策略:比如轮询、随机和根据响应时间加</p>
<p>权。</p>
</li>
</ul>
<p>RestTemplate的使用：</p>
<ul>
<li><p>getForObject(String url,class)方法:返回对象为响应体中数据转化成的</p>
<p>对象，基本上可以理解成Json</p>
</li>
<li><p>getForEntity(String url,class)方法：返回对象为ResponseEntity对象，</p>
<p>包含响应中的一些重要信息，比如响应头、响应状态码、响应体等。  </p>
</li>
</ul>
<h4 id="11-4、Ribbon核心组件IRule"><a href="#11-4、Ribbon核心组件IRule" class="headerlink" title="11.4、Ribbon核心组件IRule"></a>11.4、Ribbon核心组件IRule</h4><h5 id="11-4-1、IRule是什么"><a href="#11-4-1、IRule是什么" class="headerlink" title="11.4.1、IRule是什么"></a>11.4.1、IRule是什么</h5><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p>
<p><img src="/2021/03/15/springcloud/21.png" alt="img"> </p>
<ul>
<li><p>com.netflix.loadbalancer.RoundRobinRule：轮询（默认）</p>
</li>
<li><p>com.netflix.loadbalancer.RandomRule：随机</p>
</li>
<li><p>com.netflix.loadbalancer.RetryRule：先按照RoundRobinRule的策略</p>
<p>获取服务,如果获取服务失败则在指定时间内进行重试,获取可用的服务</p>
</li>
<li><p>WeightedResponseTimeRule：对RoundRobinRule的扩展,响应速度</p>
<p>越快的实例选择权重越多大,越容易被选择</p>
</li>
<li><p>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸</p>
<p>状态的服务,然后选择一个并发量最小的服务</p>
</li>
<li><p>AvailabilityFilteringRule：先过滤掉故障实例,再选择并发较小的实例</p>
</li>
<li><p>ZoneAvoidanceRule：默认规则,复合判断server所在区域的性能和</p>
<p>server的可用性选择服务器</p>
</li>
</ul>
<h5 id="11-4-2、替换："><a href="#11-4-2、替换：" class="headerlink" title="11.4.2、替换："></a>11.4.2、替换：</h5><p>注意配置细节</p>
<p>官方文档明确给出了警告：</p>
<p>这个自定义配置类不能放在@ComponentScan所扫描的当前包以及子包</p>
<p>下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达</p>
<p>不到特殊化定制的目的了。 </p>
<p><img src="/2021/03/15/springcloud/22.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/23.png" alt="img"> </p>
<p>@ComponentScan所扫描的当前包以及子包：因为</p>
<p>@SpringBootApplication注解包含了@ComponentScan注解，所以该自定</p>
<p>义配置类不能放在当前包（springcloud）下。</p>
<p>新建package：com.atguigu.myrule</p>
<p>上面包下新建MySelfRule规则类</p>
<p>主启动类添加@RibbonClient</p>
<h5 id="11-4-3、Ribbon负载均衡算法"><a href="#11-4-3、Ribbon负载均衡算法" class="headerlink" title="11.4.3、Ribbon负载均衡算法"></a>11.4.3、Ribbon负载均衡算法</h5><p>RoundRobinRule：轮询的算法思想</p>
<p><img src="/2021/03/15/springcloud/24.png" alt="img"> </p>
<h3 id="12、OenFeign"><a href="#12、OenFeign" class="headerlink" title="12、OenFeign"></a>12、OenFeign</h3><h4 id="12-1、是什么？"><a href="#12-1、是什么？" class="headerlink" title="12.1、是什么？"></a>12.1、是什么？</h4><p>官方解释：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign</a></p>
<p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客</p>
<p>户端更加简单。它的使用方法是<strong>定义一个服务接口然后在上面添加注解</strong>。</p>
<p>Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封</p>
<p>装，使其支持了Spring MVC标准注解和HTTPMessageConverters。Feign</p>
<p>可以与Eureka和Ribbon组合使用以支持负载均衡。</p>
<h4 id="12-2、作用："><a href="#12-2、作用：" class="headerlink" title="12.2、作用："></a>12.2、作用：</h4><p>Feign旨在使编写Java Http客户端变得更容易。</p>
<p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处</p>
<p>理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用</p>
<p>可能不止一处，<strong>往往一个接口会被多处调用，所以通常都会针对每个微服务自行</strong></p>
<p><strong>封装一些客户端类来包装这些依赖服务的调用</strong>。所以，Feign在此基础上做了进</p>
<p>一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下</p>
<p><strong>我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标</strong></p>
<p><strong>注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)，即可完</strong></p>
<p>成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服</p>
<p>务调用客户端的开发量。</p>
<p>Feign集成了Ribbon</p>
<p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负</p>
<p>载均衡。而与Ribbon不同的是，<strong>通过feign只需要定义服务绑定接口且以声明式</strong></p>
<p><strong>的方法</strong>，优雅而简单的实现了服务调用。</p>
<h4 id="12-3、Feign和OpenFeign两者区别"><a href="#12-3、Feign和OpenFeign两者区别" class="headerlink" title="12.3、Feign和OpenFeign两者区别"></a>12.3、Feign和OpenFeign两者区别</h4><p><img src="/2021/03/15/springcloud/25.png" alt="img"> </p>
<h4 id="12-4、使用步骤"><a href="#12-4、使用步骤" class="headerlink" title="12.4、使用步骤"></a>12.4、使用步骤</h4><ul>
<li><p>接口+注解：微服务调用接口+@FeignClient</p>
</li>
<li><p>Feign在消费端使用</p>
</li>
<li><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加上@EnableFeignClients注解开启Feign</p>
</li>
<li><p>业务逻辑接口+@FeignClient配置调用provider服务</p>
<p>@FeignClient(value = “xxx-xxx-xxx”)value的值要写服务提供方在Eureka注册的名称</p>
</li>
<li><p>控制层Controller</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/26.png" alt="img"> </p>
<h4 id="12-5、OpenFeign超时控制"><a href="#12-5、OpenFeign超时控制" class="headerlink" title="12.5、OpenFeign超时控制"></a>12.5、OpenFeign超时控制</h4><h5 id="12-5-1、是什么？"><a href="#12-5-1、是什么？" class="headerlink" title="12.5.1、是什么？"></a>12.5.1、是什么？</h5><p>默认Feign客户端<strong>只等待1秒钟</strong>，但是服务端处理需要超过1秒钟，导致Feign客</p>
<p>户端不想等待了，直接返回报错。</p>
<h5 id="12-5-2、解决方法-OpenFeign默认支持Ribbon"><a href="#12-5-2、解决方法-OpenFeign默认支持Ribbon" class="headerlink" title="12.5.2、解决方法(OpenFeign默认支持Ribbon)"></a>12.5.2、解决方法(OpenFeign默认支持Ribbon)</h5><p>为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p>
<p>yml文件中开启配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h4 id="12-6、OpenFeign日志打印功能"><a href="#12-6、OpenFeign日志打印功能" class="headerlink" title="12.6、OpenFeign日志打印功能"></a>12.6、OpenFeign日志打印功能</h4><h5 id="12-6-1、是什么？"><a href="#12-6-1、是什么？" class="headerlink" title="12.6.1、是什么？"></a>12.6.1、是什么？</h5><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解</p>
<p>Feign中Http请求的细节。说白了就是<strong>对Feign接口的调用情况进行监控和</strong></p>
<p><strong>输出。</strong></p>
<h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><h3 id="13、Hystrix熔断器（豪猪哥）"><a href="#13、Hystrix熔断器（豪猪哥）" class="headerlink" title="13、Hystrix熔断器（豪猪哥）"></a>13、Hystrix熔断器（豪猪哥）</h3><h4 id="13-1、分布式系统面临的问题"><a href="#13-1、分布式系统面临的问题" class="headerlink" title="13.1、分布式系统面临的问题"></a>13.1、分布式系统面临的问题</h4><p><strong>复杂分布式体系结构中的应用程序 ，有数10个依赖关系，每个依赖关系在某些时候将不可避免地失败。</strong></p>
<p><img src="/2021/03/15/springcloud/27.png" alt="img"></p>
<p>服务雪崩：</p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和</p>
<p>微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微</p>
<p>服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系</p>
<p>统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p>
<p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都</p>
<p>在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟</p>
<p>增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故</p>
<p>障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，</p>
<p>不能取消整个应用程序或系统。所以，通常当你发现一个模块下的某个实例失败</p>
<p>后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的</p>
<p>模块，这样就会发生级联故障，或者叫雪崩。</p>
<h4 id="13-2、Hystrix是什么"><a href="#13-2、Hystrix是什么" class="headerlink" title="13.2、Hystrix是什么"></a>13.2、Hystrix是什么</h4><p>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统里，</p>
<p>许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个</p>
<p>依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系</strong></p>
<p><strong>统的弹性</strong>。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故</p>
<p>障监控(类似熔断保险丝)，<strong>向调用方返回一个符合预期的、可处理的备选响应</strong></p>
<p><strong>(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证</p>
<p>了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系</p>
<p>统中的蔓延，乃至雪崩。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://github.com/Netflix/hystrix/wiki">https://github.com/Netflix/hystrix/wiki</a></p>
<h4 id="13-3、作用"><a href="#13-3、作用" class="headerlink" title="13.3、作用"></a>13.3、作用</h4><ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>接近实时的监控</li>
</ul>
<h4 id="13-4、HyStrix重要概念"><a href="#13-4、HyStrix重要概念" class="headerlink" title="13.4、HyStrix重要概念"></a>13.4、HyStrix重要概念</h4><h5 id="13-4-1、服务降级"><a href="#13-4-1、服务降级" class="headerlink" title="13.4.1、服务降级"></a>13.4.1、服务降级</h5><p>服务器忙,请稍后再试,不让客户端等待并立刻返回一个友好提示,fallback</p>
<p>哪些情况会发出降级：</p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量也会导致服务降级</li>
</ul>
<h5 id="13-4-2、服务熔断"><a href="#13-4-2、服务熔断" class="headerlink" title="13.4.2、服务熔断"></a>13.4.2、服务熔断</h5><p>类比保险丝达到最大服务访问后,直接拒绝访问,拉闸限电,然后调用服务降级的方</p>
<p>法并返回友好提示</p>
<p>服务熔断的过程：</p>
<p>服务的降级-&gt;进而熔断-&gt;恢复调用链路</p>
<h5 id="12-4-3、服务限流"><a href="#12-4-3、服务限流" class="headerlink" title="12.4.3、服务限流"></a>12.4.3、服务限流</h5><p>秒杀高并发等操作,严禁一窝蜂的过来拥挤,大家排队,一秒钟N个,有序进行</p>
<h4 id="13-5、依赖"><a href="#13-5、依赖" class="headerlink" title="13.5、依赖"></a>13.5、依赖</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="13-6、高压访问的解决方法"><a href="#13-6、高压访问的解决方法" class="headerlink" title="13.6、高压访问的解决方法"></a>13.6、高压访问的解决方法</h4><p>超时导致服务器变慢(转圈)：超时不再等待</p>
<p>出错(宕机或程序运行出错)：出错要有兜底</p>
<h4 id="13-7、访问降级"><a href="#13-7、访问降级" class="headerlink" title="13.7、访问降级"></a>13.7、访问降级</h4><p>降级配置@HystrixCommand</p>
<h5 id="13-7-1、对于服务提供方："><a href="#13-7-1、对于服务提供方：" class="headerlink" title="13.7.1、对于服务提供方："></a>13.7.1、对于服务提供方：</h5><p>设置自身调用超时时间的峰值,峰值内可以正常运行,  超过了需要有兜底的方法处</p>
<p>理,做服务降级fallback</p>
<p>一旦调用服务方法失败并抛出了错误信息后,会自动调用@HystrixCommand标‘</p>
<p>注好的fallbckMethod调用类中的指定方法</p>
<p>主启动类激活@EnableCircuitBreaker</p>
<p>下图故意制造两个异常：</p>
<ul>
<li>int age = 10/0;计算异常</li>
<li>我们能接受3秒钟，它运行5秒钟，超时异常。</li>
</ul>
<p>当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler</p>
<p><img src="/2021/03/15/springcloud/28.png" alt="img"></p>
<h5 id="13-7-2、对于服务消费方："><a href="#13-7-2、对于服务消费方：" class="headerlink" title="13.7.2、对于服务消费方："></a>13.7.2、对于服务消费方：</h5><p>主启动类激活@EnableHystrix</p>
<p>业务类</p>
<p><img src="/2021/03/15/springcloud/29.png" alt="img"></p>
<h5 id="13-7-3、目前问题"><a href="#13-7-3、目前问题" class="headerlink" title="13.7.3、目前问题"></a>13.7.3、目前问题</h5><ul>
<li>每个业务方法对应一个兜底的方法,代码膨胀</li>
<li>统一和自定义的分开</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>解决第一个问题：代码膨胀</p>
<p>feign接口系列</p>
<p>@DefaultProperties(defaultFallback=””)</p>
<p>每个方法配置一个服务降级方法，技术上可以，实际上导致代码膨胀。</p>
<p>除了个别重要核心业务有专属，其它普通的可以通过</p>
<p>@DefaultProperties(defaultFallback =”)统一跳转到统一处理结果页面</p>
<p><strong>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</strong>。</p>
<p><img src="/2021/03/15/springcloud/30.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/31.png" alt="img"> </p>
</li>
<li><p>解决第二个问题：和业务逻辑混在一起</p>
<p>服务降级,客户端去调用服务端,碰上服务端宕机或关闭。只需要为Feign客户</p>
<p>端定义的接口添加一个服务降级处理的实现类即可实现解耦。</p>
<p>我们可能面临的异常：</p>
<ul>
<li>运行</li>
<li>超时</li>
<li>宕机</li>
</ul>
<p>重新新建一个类(PaymentFallbackService)实现PaymentHystrixService接</p>
<p>口（OpenFeign的服务接口）,<strong>统一为接口里面的方法进行异常处理</strong></p>
<p><img src="/2021/03/15/springcloud/32.png" alt="img"> </p>
<p>PaymentHystrixService接口:</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C211.png" alt="image-20210315011150047"></p>
</li>
</ul>
<h4 id="13-8、服务熔断"><a href="#13-8、服务熔断" class="headerlink" title="13.8、服务熔断"></a>13.8、服务熔断</h4><h5 id="13-8-1、是什么？"><a href="#13-8-1、是什么？" class="headerlink" title="13.8.1、是什么？"></a>13.8.1、是什么？</h5><p><a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p>
<p>熔断机制概述</p>
<p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务</p>
<p>出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的</p>
<p>调用，快速返回错误的响应信息。</p>
<p>当<strong>检测到该节点微服务调用响应正常后，恢复调用链路</strong>。</p>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调</p>
<p>用的状况，当失败的调用到一定國值，缺省是5秒内20次调用失败，就会启动熔</p>
<p>断机制。熔断机制的注解是@HystrixCommand。</p>
<h5 id="12-8-2、服务熔断的注解-HystrixCommand-Service层"><a href="#12-8-2、服务熔断的注解-HystrixCommand-Service层" class="headerlink" title="12.8.2、服务熔断的注解@HystrixCommand(Service层)"></a>12.8.2、服务熔断的注解@HystrixCommand(Service层)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="12-8-3、大神结论"><a href="#12-8-3、大神结论" class="headerlink" title="12.8.3、大神结论"></a>12.8.3、大神结论</h5><p><img src="/2021/03/15/springcloud/33.png" alt="img"> </p>
<p>熔断类型：</p>
<ul>
<li><p>熔断打开（Open）：</p>
<p>请求不再调用当前服务,内部设置一般为MTTR(平均故障处理时间),当打开长达导所设时钟则进入半熔断状态</p>
</li>
<li><p>熔断关闭（Closed）：</p>
<p>熔断关闭后不会对服务进行熔断</p>
</li>
<li><p>熔断半开（Half Open）：</p>
<p>部分请求根据规则调用当前服务,如果请求成功且符合规则则认为当前服务恢复正常,关闭熔断</p>
</li>
</ul>
<h5 id="12-8-4、断路流程图"><a href="#12-8-4、断路流程图" class="headerlink" title="12.8.4、断路流程图"></a>12.8.4、断路流程图</h5><p><img src="/2021/03/15/springcloud/34.png" alt="img"> </p>
<p>步骤：</p>
<p><img src="/2021/03/15/springcloud/35.png" alt="img"> </p>
<p>断路器在什么情况下开始起作用 </p>
<p><img src="/2021/03/15/springcloud/36.png" alt="image-20210310003224243"></p>
<p>涉及到断路器的三个重要参数：<strong>快照时间窗、请求总数阀值、错误百分比</strong></p>
<p><strong>阀值</strong></p>
<ul>
<li><p>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统</p>
<p>计的时间范围就是快照时间窗，默认为最近的10秒。</p>
</li>
<li><p>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔</p>
<p>断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足</p>
<p>20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p>
</li>
<li><p>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了</p>
<p>30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超</p>
<p>过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路</p>
<p>器打开。</p>
</li>
</ul>
<p>断路器开启或者关闭的条件:</p>
<ol>
<li><p>当满足一定的阈值的时候(默认10秒钟超过20个请求次数)</p>
</li>
<li><p>当失败率达到一定的时候(默认10秒内超过50%的请求次数)</p>
</li>
<li><p>到达以上阈值,断路器将会开启</p>
</li>
<li><p>当开启的时候,所有请求都不会进行转发</p>
</li>
<li><p>一段时间之后(默认5秒),这个时候断路器是半开状态,会让其他一个请求</p>
<p>进行转发. 如果成功,断路器会关闭,若失败,继续开启.重复4和5</p>
</li>
</ol>
<p>断路器打开之后:</p>
<ol>
<li><p>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级</p>
<p>fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主</p>
<p>逻辑，减少响应延迟的效果。</p>
</li>
<li><p>原来的主逻辑要如何恢复呢？</p>
<p>对于这一问题，hystrix也为我们实现了自动恢复功能。</p>
<p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间</p>
<p>窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到</p>
<p>期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此</p>
<p>次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求</p>
<p>依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 </p>
</li>
</ol>
<p>ALL配置：</p>
<p><img src="/2021/03/15/springcloud/37.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/38.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/39.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/40.png" alt="img"> </p>
<h4 id="13-9、服务限流"><a href="#13-9、服务限流" class="headerlink" title="13.9、服务限流"></a>13.9、服务限流</h4><p>alibaba的Sentinel说明</p>
<h4 id="13-10、Hystrix的工作流程"><a href="#13-10、Hystrix的工作流程" class="headerlink" title="13.10、Hystrix的工作流程"></a>13.10、Hystrix的工作流程</h4><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p>
<p>官网图例</p>
<p><img src="/2021/03/15/springcloud/41.png" alt="img"> </p>
<p>步骤说明</p>
<p><img src="/2021/03/15/springcloud/42.png" alt="img"> </p>
<h4 id="13-11、服务监控hystrixDashboard"><a href="#13-11、服务监控hystrixDashboard" class="headerlink" title="13.11、服务监控hystrixDashboard"></a>13.11、服务监控hystrixDashboard</h4><h5 id="13-11-1、概述"><a href="#13-11-1、概述" class="headerlink" title="13.11.1、概述"></a>13.11.1、概述</h5><p> 除了隔离依赖服务的调用以外，Hystrix还提供了<strong>准实时的调用监控</strong></p>
<p>**(Hystrix Dashboard)**，Hystrix会持续地记录所有通过Hystrix发起的请求</p>
<p>的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少</p>
<p>请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项</p>
<p>目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的</p>
<p>整合，对监控内容转化成可视化界面。</p>
<h5 id="13-11-2、依赖"><a href="#13-11-2、依赖" class="headerlink" title="13.11.2、依赖"></a>13.11.2、依赖</h5><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="13-11-3、步骤"><a href="#13-11-3、步骤" class="headerlink" title="13.11.3、步骤"></a>13.11.3、步骤</h5><ol>
<li><p>主启动类加注解激活@EnableHystrixDashboard</p>
</li>
<li><p>所有Provider微服务提供类都需要监控依赖部署</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>访问网址<a target="_blank" rel="noopener" href="http://localhost:9001/hystrix%EF%BC%889001%E4%B8%BA%E7%AB%AF%E5%8F%A3%E5%90%8D%EF%BC%89">http://localhost:9001/hystrix（9001为端口名）</a></p>
</li>
</ol>
<h5 id="13-11-4、断路器演示-服务监控hystrixDashboard"><a href="#13-11-4、断路器演示-服务监控hystrixDashboard" class="headerlink" title="13.11.4、断路器演示(服务监控hystrixDashboard)"></a>13.11.4、断路器演示(服务监控hystrixDashboard)</h5><p>新版本Hystrix需要在主启动MainAppHystrix8001（微服务提供方）中指</p>
<p>定监控路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个eureka或者3个eureka集群进行监控测试</p>
<p>填写监控地址<a target="_blank" rel="noopener" href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a></p>
<p><img src="/2021/03/15/springcloud/43.png" alt="img"> </p>
<h5 id="13-11-5、如何看hystrixDashboard服务监控图"><a href="#13-11-5、如何看hystrixDashboard服务监控图" class="headerlink" title="13.11.5、如何看hystrixDashboard服务监控图"></a>13.11.5、如何看hystrixDashboard服务监控图</h5><ul>
<li><p>七色</p>
<p><img src="/2021/03/15/springcloud/44.png" alt="img"> </p>
</li>
<li><p>一圈：</p>
<p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它</p>
<p>的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</p>
<p>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生</p>
<p>变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在</p>
<p>大量的实例中快速的发现<strong>故障实例和高压力实例</strong>。 </p>
</li>
<li><p>一线：</p>
<p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升与下降趋势 </p>
</li>
<li><p>整图说明：</p>
<p><img src="/2021/03/15/springcloud/45.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/Users/风间&琉璃/AppData/Local/Temp/mindmaster/1223393c341/bin/DF646587-C4E1-40BF-9FFD-7D10773D9637.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/46.png" alt="img"> </p>
</li>
<li><p>搞懂一个才能看懂复杂的</p>
<p><img src="/2021/03/15/springcloud/47.png" alt="img"> </p>
</li>
</ul>
<h2 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h2><h3 id="14、Gateway新一代网关"><a href="#14、Gateway新一代网关" class="headerlink" title="14、Gateway新一代网关"></a>14、Gateway新一代网关</h3><h4 id="14-1、是什么？"><a href="#14-1、是什么？" class="headerlink" title="14.1、是什么？"></a>14.1、是什么？</h4><p>一句话：</p>
<p>SpringCloud Gateway使用的是Webflux中的reactor-netty响应式编程组</p>
<p>件,底层使用了Netty通讯框架。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></p>
<p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul</p>
<p>网关；但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发</p>
<p>了一个网关替代Zuul，那就是SpringCloud Gateway一句话：</p>
<p><strong>gateway是原zuul1.x版的替代</strong> </p>
<p><img src="/2021/03/15/springcloud/48.png" alt="img"> </p>
<p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring </p>
<p>5,Spring Boot 2和Project Reactor等技术。</p>
<p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些</p>
<p>强大的过滤器功能，例如：熔断、限流、重试等</p>
<p><img src="/2021/03/15/springcloud/49.png" alt="image-20210310010754927"></p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，基于 Spring </p>
<p>5.0+Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微</p>
<p>服务架构提供一种简单有效的统一的API路由管理方式。 </p>
<p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 </p>
<p>Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新</p>
<p>高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。</p>
<p>而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现</p>
<p>的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter 链的方式</p>
<p>提供了网关基本的功能，例如：安全，监控/指标，和限流。</p>
<p> 源码架构：</p>
<p><img src="/2021/03/15/springcloud/50.png" alt="img"> </p>
<h4 id="14-2、作用"><a href="#14-2、作用" class="headerlink" title="14.2、作用"></a>14.2、作用</h4><ul>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
<li>……</li>
</ul>
<h4 id="14-3、微服务架构中网关在哪里"><a href="#14-3、微服务架构中网关在哪里" class="headerlink" title="14.3、微服务架构中网关在哪里"></a>14.3、微服务架构中网关在哪里</h4><p><img src="/2021/03/15/springcloud/51.png" alt="img"> </p>
<h4 id="14-4、Zool与Gateway"><a href="#14-4、Zool与Gateway" class="headerlink" title="14.4、Zool与Gateway"></a>14.4、Zool与Gateway</h4><ol>
<li><p>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是</p>
<p>Spring Cloud团队研发的，是亲儿子产品，值得信赖。而且很多功能</p>
<p>Zuul都没有用起来也非常的简单便捷。</p>
</li>
</ol>
<p>   Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担</p>
<p>   心。虽然Netfix早就发布了最新的Zuul 2.x，但 Spring Cloud貌似没有</p>
<p>   整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？</p>
<p>   多方面综合考虑Gateway是很理想的网关选择。</p>
<ol start="2">
<li><p>Spring Cloud Gateway 具有如下特性：</p>
<p><strong>基于Spring Framework 5,Project Reactor和 Spring Boot 2.0 进行构建</strong>； </p>
<ul>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定 Predicate (断言)和 Filter (过滤器)；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成 Spring Cloud 服务发现功能；</li>
<li>易于编写的Predicate (断言)和Filter (过滤器)；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ul>
</li>
<li><p>Spring Cloud Gateway 与 Zuul的区别:</p>
<p>在SpringCloud <strong>F</strong>inchley正式版之前，Spring Cloud 推荐的网关是 </p>
<p>Netflix 提供的Zuul:</p>
<ul>
<li><p>Zuul 1.x，是一个基于阻塞I/O的API Gateway</p>
</li>
<li><p>Zuul 1.x 基于<strong>Servlet 2.5</strong>使用阻塞架构，它不支持任何长连接(如 </p>
<p>WebSocket)。 Zuul 的设计模式和Nginx较像，每次I/ O 操作都</p>
<p>是<strong>从工作线程中选择一个执行</strong>，请求线程<strong>被阻塞到工作线程完成</strong>，</p>
<p>但是差别是:Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身</p>
<p>会有第一次加载较慢的情况，使得Zuul的性能相对较差。</p>
</li>
<li><p>Zuul 2.x理念更先进，想<strong>基于Netty非阻塞和支持长连接</strong>，但</p>
<p>SpringCloud目前还没有整合。Zuul 2.x的性能较 Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</p>
</li>
<li><p>Spring Cloud Gateway 建立在 <strong>Spring Framework 5、Project</strong> </p>
<p><strong>Reactor和 Spring Boot 2</strong>之上，使用<strong>非阻塞API</strong>。</p>
</li>
<li><p>Spring Cloud Gateway 还支持WebSocket，并且与Spring紧密集</p>
<p>成拥有更好的开发体验。</p>
</li>
</ul>
</li>
<li><p>springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传</p>
<p>统的Servlet IO处理模型。</p>
<p>Servlet的生命周期：servlet由servlet container进行生命周期管理。</p>
<ul>
<li><p>container启动时构造servlet对象并调用servlet init()进行初始化；</p>
</li>
<li><p>container运行时接受请求，并为每个请求分配一个线程(一般从线</p>
<p>程池中获取空闲线程)然后调用service();</p>
</li>
<li><p>container关闭时调用servlet destory()销毁servlet;</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/52.png" alt="image-20210310012934921"></p>
</li>
<li><p>上述模式的缺点：</p>
<p>servlet是一个<strong>简单的网络IO模型</strong>，当请求进入servlet container时，</p>
<p>servlet container就会为其绑定一个线程，在<strong>并发不高的场景</strong>下这种模</p>
<p>型是适用的。但是一旦高并发(比如抽风用jemeter压)，线程数量就会</p>
<p>上涨，而线程资源代价是昂贵的(<strong>上线文切换，内存消耗大</strong>)严重影响请</p>
<p>求的处理时间。在一些简单业务场景下，不希望为每个request分配一</p>
<p>个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场</p>
<p>景下servlet模型没有优势。</p>
<p>而Zuul 1.X是<strong>基于servlet之上的一个阻塞式处理模型</strong>，即spring实现</p>
<p>了处理所有request请求的一个servlet(DispatcherServlet)并由该</p>
<p>servlet阻塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型</p>
<p>的弊端。</p>
</li>
<li><p>WebFlux：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux</a></p>
<p><img src="/2021/03/15/springcloud/53.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/54.png" alt="img"> </p>
<p>传统的Web框架，此如说：struts2，springmvc等都是基于Servlet </p>
<p>API与Servlet容器基础之上运行的。</p>
<p>但是，<strong>在Servlet3.1之后有了异步非阻赛的支持</strong>。而WebFlux是一个典</p>
<p>型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相</p>
<p>对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支</p>
<p>持Servlet3.1的容器上。非阻塞式+函数式编程(Spring5必须让你使用</p>
<p>java8)</p>
<p>Spring WebFlux 是Spring 5.0 引入的新的响应式框架，区别于 Spring </p>
<p>MVC，它不需要依赖Servlet API，它是<strong>完全异步非阻塞的</strong>，并且<strong>基于</strong> </p>
<p><strong>Reactor 来实现响应式流规范</strong>。</p>
<h4 id="14-5、三大核心概念"><a href="#14-5、三大核心概念" class="headerlink" title="14.5、三大核心概念"></a>14.5、三大核心概念</h4></li>
</ol>
<ul>
<li><p>Route(路由)：</p>
<p>路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组</p>
<p>成,如断言为true则匹配该路由。</p>
</li>
<li><p>Predicate(断言)：</p>
<p>参考的是Java8的java.util.function.Predicate</p>
<p>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如</p>
<p>果请求与断言相匹配则进行路由。</p>
</li>
<li><p>Filter(过滤)：</p>
<p>指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路</p>
<p>由前或者之后对请求进行修改。</p>
</li>
</ul>
<p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过</p>
<p>程的前后，进行一些精细化控制。</p>
<p>predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。</p>
<p><img src="/2021/03/15/springcloud/55.png" alt="image-20210310014051292"> </p>
<h4 id="14-6、Gateway工作流程（路由转发-执行过滤器链）"><a href="#14-6、Gateway工作流程（路由转发-执行过滤器链）" class="headerlink" title="14.6、Gateway工作流程（路由转发+执行过滤器链）"></a>14.6、Gateway工作流程（路由转发+执行过滤器链）</h4><p>官网总结</p>
<p><img src="/2021/03/15/springcloud/56.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/Users/风间&琉璃/AppData/Local/Temp/mindmaster/1223393c341/bin/3008859F-0E2E-4542-92C5-A049333E2AC6.png" alt="img"> </p>
<p>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler </p>
<p>Mapping中找到与请求相匹配的路由，将其发送到Gateway Web </p>
<p>Handler。</p>
<p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务</p>
<p>逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之</p>
<p>后(“post”)执行业务逻辑。</p>
<p>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输</p>
<p>出、协议转换等，</p>
<p>在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流</p>
<p>量监控等有着非常重要的作用。</p>
<h4 id="14-7、依赖"><a href="#14-7、依赖" class="headerlink" title="14.7、依赖"></a>14.7、依赖</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置：</p>
<p><img src="/2021/03/15/springcloud/57.png" alt="img"></p>
<p>访问：</p>
<p>添加网关前：<a target="_blank" rel="noopener" href="http://localhost:8001/payment/get/31">http://localhost:8001/payment/get/31</a></p>
<p>添加网关后：<a target="_blank" rel="noopener" href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a></p>
<h4 id="14-8、Gateway网关路由有两种配置方式"><a href="#14-8、Gateway网关路由有两种配置方式" class="headerlink" title="14.8、Gateway网关路由有两种配置方式"></a>14.8、Gateway网关路由有两种配置方式</h4><p>1、在配置文件yml中配置</p>
<p>2、代码中注入RouteLocator的Bean</p>
<p>示例：</p>
<p>百度国内新闻网站,需要外网<a target="_blank" rel="noopener" href="https://news.baidu.com/guonei">https://news.baidu.com/guonei</a></p>
<p>业务需求：通过9527网关访问到外网的百度新闻网址</p>
<p>实现：在cloud-gateway-gateway9527编写配置类</p>
<p><img src="/2021/03/15/springcloud/58.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/59.png" alt="img"> </p>
<h4 id="14-9、通过服务名实现动态"><a href="#14-9、通过服务名实现动态" class="headerlink" title="14.9、通过服务名实现动态"></a>14.9、通过服务名实现动态</h4><p>默认情况下Gatway会根据注册中心注册的服务列表,  以注册中心上微服务</p>
<p>名为路径<strong>创建动态路由进行转发,从而实现动态路由的功能</strong>。</p>
<p>启动：一个eureka+两个服务提供者</p>
<p>application.yml配置：</p>
<p>需要注意的是uri的协议lb,表示启用Gateway的负载均衡功能。</p>
<p>lb://serverName是spring cloud  gatway在微服务中自动为我们创建的负载均衡uri</p>
<p><img src="/2021/03/15/springcloud/209.png" alt="img"> </p>
<h4 id="14-10、Predicate（断言）"><a href="#14-10、Predicate（断言）" class="headerlink" title="14.10、Predicate（断言）"></a>14.10、Predicate（断言）</h4><p>说白了,Predicate就是为了实现一组匹配规则,  让请求过来找到对应的</p>
<p>Route进行处理。</p>
<p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping</p>
<p>基础架构的一部分。</p>
<p>Spring Cloud Gateway包括许多内置的Route PredicateI工厂。所有这些</p>
<p>Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以</p>
<p>进行组合。</p>
<p>Spring Cloud Gateway 创建 Route 对象时，使用 RoutePredicateFactory</p>
<p>创建 Predicate 对象，Predicate 对象可以赋值给Route。Spring Cloud </p>
<p>Gateway 包含许多内置的Route Predicate Factories。</p>
<p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通</p>
<p>过逻辑and。</p>
<p><img src="/2021/03/15/springcloud/60.png" alt="img">  </p>
<p>常用的Route Predicate</p>
<p><img src="/2021/03/15/springcloud/61.png" alt="img"> </p>
<ul>
<li><p>After Route Predicate：在设置时间之后</p>
</li>
<li><p>Before Route Predicate：在设置时间之前</p>
</li>
<li><p>Between Route Predicate：在设置时间中间</p>
</li>
<li><p>Cookie Route Predicate：请求要带有cookie</p>
</li>
<li><p>Header Route Predicate：请求要带有请求头，且请求头的值要符合要求</p>
</li>
<li><p>Host Route Predicate：要使用符合要求的主机进行访问</p>
</li>
<li><p>Method Route Predicate：请求方式要是符合要求</p>
</li>
<li><p>Path Route Predicate：路径相匹配的进行路由</p>
</li>
<li><p>Query Route Predicate：要有参数名并且值还要是符合要求的才能路由</p>
</li>
<li><p>RemoteAddr Route Predicate：通过无类别域间路由(IPv4 or IPv6)列</p>
<p>表匹配路由（- RemoteAddr=192.168.1.1/24）(不常用)</p>
</li>
<li><p>Weight Route Predicate：接收一个[组名,权重], 然后对于同一个组内</p>
<p>的路由按照权重转发（-Weight= group3, 9）（不常用）</p>
</li>
</ul>
<p>application.yml配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2021-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Before=2021-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Between=2021-03-09T01:19:24.226+08:00[Asia/Shanghai],2022-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,xgh #请求要带有cookie（URL + -- cookie &quot;username=xgh&quot;）</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式（URL + --H &quot;X-Request-Id:123&quot;）</span></span><br><span class="line">            <span class="comment">#- Host=**.atguigu.com #主机要带有atguigu.com</span></span><br><span class="line">            <span class="comment">#- Method=GET #请求方式要是get</span></span><br><span class="line">            <span class="comment">#- Query=username,\d+ #要有参数名并且值还要是整数的才能路由</span></span><br><span class="line">          <span class="comment">#filters:</span></span><br><span class="line">            <span class="comment">#- AddRequestHeader=X-Request-Id,1024 #过滤器工厂会在匹配的请求头上加上一对请求头，名称为X-Request-Id，值为1024</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">gateway9527</span></span><br><span class="line">    <span class="comment">#访问路径可以显示IP地址</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#单机版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">      <span class="comment"># 集群版</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-11、Filter（过滤器）"><a href="#14-11、Filter（过滤器）" class="headerlink" title="14.11、Filter（过滤器）"></a>14.11、Filter（过滤器）</h4><h5 id="14-11-1、是什么？"><a href="#14-11-1、是什么？" class="headerlink" title="14.11.1、是什么？"></a>14.11.1、是什么？</h5><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器</p>
<p>只能指定路由进行使用。</p>
<p>Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的</p>
<p>工厂类来产生。</p>
<p><img src="/2021/03/15/springcloud/62.png" alt="image-20210310021404546"> </p>
<h5 id="14-11-2、生命周期"><a href="#14-11-2、生命周期" class="headerlink" title="14.11.2、生命周期"></a>14.11.2、生命周期</h5><ul>
<li>post</li>
<li>pre</li>
</ul>
<h5 id="14-11-3、种类"><a href="#14-11-3、种类" class="headerlink" title="14.11.3、种类"></a>14.11.3、种类</h5><ul>
<li>GatewayFilter（31种）：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></li>
<li>GlobalFilter（10种）：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#global-filters">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#global-filters</a></li>
</ul>
<p>常用的GatewayFilter：</p>
<p>在yml里面配置：</p>
<p><img src="/2021/03/15/springcloud/63.png" alt="img"> </p>
<p>自定义过滤器：</p>
<p>自定义全局GlobalFilter</p>
<p>两个主要接口</p>
<ul>
<li><p>GlobalFilter</p>
</li>
<li><p>Ordered</p>
</li>
</ul>
<p>作用：</p>
<ul>
<li>全局日志记录</li>
<li>统一网关鉴权</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**************come in MylogGateWayGilter:  &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;********用户名为空，非法用户。&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截的级别，值越小，级别越大</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h2><h3 id="15、SpringCloud-config"><a href="#15、SpringCloud-config" class="headerlink" title="15、SpringCloud config"></a>15、SpringCloud config</h3><h4 id="15-1、分布式系统面临的问题"><a href="#15-1、分布式系统面临的问题" class="headerlink" title="15.1、分布式系统面临的问题"></a>15.1、分布式系统面临的问题</h4><p>配置问题：</p>
<p>到目前为止，我们对 Eureka、Robbin、OpenFeign、Hystrix、Gateway</p>
<p>等有了相应的了解，每个微服务都是单独一个模块，微服务彼此还支持集群</p>
<p>环境。</p>
<p>但是在微服务项目的开发中，还面临着一个严重的配置问题。每一个微服务</p>
<p>都需要一个配置文件，如果有几个微服务需要连接数据库，name就需要进</p>
<p>行 4 次数据库的配置。当数据库发生改变，那么就需要同时修改 4 个微服</p>
<p>务的配置文件才可以。那么如果有40台呢？如果是集群模式呢？？</p>
<p>如果能够做到：一处修改、处处生效，这样就可以减轻修改配置压力，从而</p>
<p>增强配置管理方面的功能，此时就需要 Spring Cloud Config 和 Spring </p>
<p>Cloud Bus 上场了。</p>
<p>使用 Config + Bus，可以实现 ：</p>
<ul>
<li><p>一处修改、处处生效</p>
</li>
<li><p>灵活的对版本(dev/test/prod)进行切换，这样就足够方便了</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/64.png" alt="img"></p>
<h4 id="15-2、是什么："><a href="#15-2、是什么：" class="headerlink" title="15.2、是什么："></a>15.2、是什么：</h4><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>
<p>Springcloud config为微服务架构中的微服务提供集中化的外部配置支持，</p>
<p>配置服务器为各个不同微服务应用的所有环境提供一个中心化的外部配</p>
<p>置。各个不同微服务应用 Springcloud config为微服务架构中的微服务提</p>
<p>供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境</p>
<p>提供一个中心化的外部配置。中心化的外部配置。</p>
<h4 id="15-3、怎么用："><a href="#15-3、怎么用：" class="headerlink" title="15.3、怎么用："></a>15.3、怎么用：</h4><p>Springcloud Config分为<strong>服务端</strong>和<strong>客户端</strong>两部分。</p>
<ul>
<li><p>服务端（Config Server）：也称分布式配置中心，它是一个独立的微服</p>
<p>务应用，用来连接配置服务器并未客户端提供获取配置信息，加密、解</p>
<p>密信息等访问接口。</p>
</li>
<li><p>客户端：通过指定的 <strong>配置中心(Config Server)</strong> 来管理应用资源，以及与业务相关的配置内容，并在启动的时候从 <strong>配置中心</strong> 获取和加载配置信息。</p>
</li>
</ul>
<h4 id="15-4、作用"><a href="#15-4、作用" class="headerlink" title="15.4、作用"></a>15.4、作用</h4><ul>
<li><p>集中管理配置文件</p>
</li>
<li><p>不同环境不同配置，动态化的配置更新，分环境部署比如</p>
<p>dev/test/prod/beta/release</p>
</li>
<li><p>运行期间动态调整配置，不再需要字啊每个服务器的机器上编写配置文</p>
<p>件，服务会向配置中心同意拉去配置自己的信息</p>
</li>
<li><p>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的</p>
<p>配置</p>
</li>
<li><p>将配置信息以REST接口的形式暴露</p>
<ul>
<li>post,curl访问刷新均可</li>
</ul>
</li>
</ul>
<h4 id="15-5、与GitHub整合配置"><a href="#15-5、与GitHub整合配置" class="headerlink" title="15.5、与GitHub整合配置"></a>15.5、与GitHub整合配置</h4><p>由于SpringCloud Config默认使用Git来存储配置文件（也有其他方式，比</p>
<p>如注册SVN和本地文件），但最推荐的还是Git，而且使用的是http/https服</p>
<p>务的形式。</p>
<p>步骤：</p>
<ol>
<li><p>创建存储 Config 的新 Repository</p>
</li>
<li><p>将新建的GitHub远程仓库克隆到本地</p>
<p>Repository 创建成功，即可获取自己的仓库地址，将项目克隆到本</p>
<p>地，方便对数据的修改。（GitHub 也支持直接修改，你也可以不克</p>
<p>隆，此处克隆只是为了更方便处理数据。）</p>
</li>
<li><p>进入克隆目录，新建三个配置文件，分别是 <strong><code>config-dev.yml</code>**、</strong><code>config-test.yml</code><strong>、</strong><code>config-prod.yml</code>**。然后通过命令将其推送到远程GitHub仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *.yml(将提交的文件加入暂存区，为git commit做准备)</span><br><span class="line">git commit -m “first commit” (完成对文件内容提交至Git版本库)</span><br><span class="line">git push -u origin master(将本地仓库内容，推送至GitHub远程仓库)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对配置修改后，通过以上三个命令，便可以再次将修改后的内容推送至 GitHub。你也可以使用 IDEA 等工具进行</p>
<p><img src="/2021/03/15/springcloud/69.png" alt="在这里插入图片描述"></p>
</li>
<li><p>Github 远程仓库内容</p>
<p><img src="/2021/03/15/springcloud/70.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>服务端</strong>配置测试 (Config 结构图中的 <strong>Config Server</strong>)</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入spring-cloud-config-server依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span>   <span class="comment">#端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span>  <span class="comment">#注册进Eureka 服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/Liuzebiao/springcloud-config.git</span>  <span class="comment">#GitHub远程仓库地址</span></span><br><span class="line">          <span class="comment"># 搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">#读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span>  <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>主启动类 配置**@EnableConfigServer**注解</p>
<p>启动测试：<a target="_blank" rel="noopener" href="http://localhost:3344/master/config-dev.yml">http://localhost:3344/master/config-dev.yml</a></p>
</li>
<li><p>GitHub配置文件<strong>读取规则</strong>：</p>
<p>远程 GitHub 仓库，配置文件的命名也是有具体规则的。Spring Cloud </p>
<p>Config 官方共支持 5 种方式的配置（<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start</a></p>
<p>参数说明：</p>
<ol>
<li><code>label</code>：GitHub 分支(branch)名称</li>
<li><code>application</code>：服务名</li>
<li><code>profile</code>：环境(<code>dev/test/prod</code>)</li>
</ol>
<ul>
<li><p>/{application}/{profile}/{label}：</p>
<p>返回的是 Json 对象，需要自己解析所要的内容</p>
<p><img src="/2021/03/15/springcloud/71.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{application}-{profile}.yml：</p>
<p>(这种不带label方式，默认使用application.yml 配置)因为 </p>
<p>applicaiton.yml 文件已经有配置过 label，不带label 方式，默认走</p>
<p>的就是 yml 配置的 label，返回的是配置内容</p>
<p><img src="/2021/03/15/springcloud/72.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{label}/{application}-{profile}.yml：</p>
<p>(推荐使用第三种)这种方式简明扼要，条理清晰，返回的是配置内</p>
<p>容</p>
<p><img src="/2021/03/15/springcloud/73.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{application}-{profile}.properties：</p>
<p>同第2种</p>
</li>
<li><p>/{label}/{application}-{profile}.properties：</p>
<p>同第3种</p>
</li>
</ul>
</li>
<li><p><strong>客户端</strong>配置测试 (Config 结构图中的 Client A、Client B、Client C)</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入spring-cloud-starter-config依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件 bootstrap.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span> <span class="comment">#端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span> <span class="comment">#名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span>  <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span>  <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span>   <span class="comment"># 读取后缀名称   上述3个综合：master分支上config-dev.yml 的配置文件被读取(http://config-3344.com:3344/master/fongig-dev.yml)</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span>   <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>主启动类 配置**@EnableConfigServer**注解</p>
<p>controller业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span> <span class="comment">//通过这种方式，可以直接读取ConfigServer中的配置信息</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试：<a target="_blank" rel="noopener" href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<h4 id="15-6、bootstrap-yml与application-yml"><a href="#15-6、bootstrap-yml与application-yml" class="headerlink" title="15.6、bootstrap.yml与application.yml"></a>15.6、bootstrap.yml与application.yml</h4></li>
</ol>
<p>applicaiton.yml是用户级的资源配置项</p>
<p>bootstrap.yml是系统级的，<strong>优先级更加高</strong></p>
<p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用</p>
<p>的<code>Application Context</code>的<strong>父上下文</strong>。初始化的时候，</p>
<p><code>BootstrapContext</code>负责从<strong>外部源</strong>加载配置属性并解析配置。这两个上下</p>
<p>文共享一个从外部获取的<code>Environment</code>。</p>
<p>“Bootstrap”属性有<strong>高优先级</strong>，默认情况下，它们不会被本地配置覆</p>
<p>盖。<code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所</p>
<p>以新增了一个bootstrap.yml’文件，保证<code>Bootstrap Context</code>和</p>
<p><code>Application Context</code>配置的分离。</p>
<p><strong>要将Client模块下的application.yml文件改为bootstrap.yml,这是很关</strong></p>
<p><strong>键的</strong>，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml</p>
<p>优先级高于application.yml。 </p>
<h4 id="15-7、分布式配置的动态刷新问题"><a href="#15-7、分布式配置的动态刷新问题" class="headerlink" title="15.7、分布式配置的动态刷新问题"></a>15.7、分布式配置的动态刷新问题</h4><ol>
<li><p>POM引入actuator监控</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入actuator监控--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改YML,暴露监控接口</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span> </span><br><span class="line">	<span class="attr">endpoints:</span> </span><br><span class="line">		<span class="attr">web:</span> </span><br><span class="line">			<span class="attr">exposure:</span> </span><br><span class="line">				<span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@RefreshScope业务类Controller修改</p>
</li>
<li><p>需要运维人员发送Post请求刷新3355客户端</p>
<ul>
<li>必须是POST请求</li>
<li>curl  -X POST “<a target="_blank" rel="noopener" href="http://localhost:3355/actuator/refresh&quot;">http://localhost:3355/actuator/refresh&quot;</a></li>
</ul>
</li>
</ol>
<h4 id="15-8、残留问题"><a href="#15-8、残留问题" class="headerlink" title="15.8、残留问题"></a>15.8、残留问题</h4><ul>
<li><p>假如有 N 多个台，就需要 N 多次的curl的手动刷新</p>
<p>解决想法：</p>
<p>大规模 <strong><code>微服务/集群模式</code>**，</strong>我们可以采用广播的方式，一次通知，处处生效。<strong>类似于 **<code>消息队列的 Topic</code></strong> ，**<code>微信公众号</code>** 的概念，一次订阅，所有订阅者都能接收到新消息。</p>
</li>
<li><p>无法实现精确通知,只通知集群中的某些服务(精确通知，比如有100台机器，只通知前98台)</p>
</li>
</ul>
<p>解决以上两个问题的方法：bus消息总线</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><h3 id="16、SpringCloud-Bus"><a href="#16、SpringCloud-Bus" class="headerlink" title="16、SpringCloud Bus"></a>16、SpringCloud Bus</h3><h4 id="16-1、是什么"><a href="#16-1、是什么" class="headerlink" title="16.1、是什么"></a>16.1、是什么</h4><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.2.1.RELEASE/reference/html/</a></p>
<p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个<strong>共用的消</strong></p>
<p><strong>息主题</strong>，并让系统中所有的微服务实例都连接上来。由于<strong>该主题中产生的消</strong></p>
<p><strong>息会被所有实例监听和消费，所以称它为消息总线</strong>在总线上的各个实例，都</p>
<p>可以方便的广播一些需要让其他链接在该主题上的实例都知道的消息。</p>
<p>Spring Cloud Bus 是用来将 <strong>分布式系统的节点</strong>与 <strong>轻量级消息系统</strong>连接起来</p>
<p>的框架，它整合了 Java 的<strong>事件处理机制</strong>和<strong>消息中间件</strong>的功能。Spring </p>
<p>Cloud Bus 目前仅支持<code>RabbitMQ</code>和<code>Kafka</code>。</p>
<h4 id="16-2、作用"><a href="#16-2、作用" class="headerlink" title="16.2、作用"></a>16.2、作用</h4><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行</p>
<p>器，可用于广播状态更改，事件推送等，也可以作为微服务的通信通道。</p>
<p><img src="/2021/03/15/springcloud/65.png" alt="img"></p>
<h4 id="16-3、基本原理与执行流程"><a href="#16-3、基本原理与执行流程" class="headerlink" title="16.3、基本原理与执行流程"></a>16.3、基本原理与执行流程</h4><p>ConfigClient实例都监听MQ中的同一个topic(默认是<strong>SpringcloudBus</strong>)。</p>
<p>当一个服务刷新数据的时候，它会把这个信息放入到topic中，这样其它监</p>
<p>听同一个topic的服务就能得到通知，然后去更新自身的配置。其实就是<strong>通</strong></p>
<p><strong>过 MQ 消息队列的 Topic 机制，达到广播的效果。</strong></p>
<p><img src="/2021/03/15/springcloud/66.png" alt="img"></p>
<h4 id="16-4、Bus的两种设计思想"><a href="#16-4、Bus的两种设计思想" class="headerlink" title="16.4、Bus的两种设计思想"></a>16.4、Bus的两种设计思想</h4><ol>
<li><p>触发<strong>客户端</strong>：</p>
<p>利用消息总线触发一个<strong>客户端</strong>的<code>/bus/refresh</code>,而刷新所有客户端的配置</p>
<p><img src="/2021/03/15/springcloud/67.png" alt="img"></p>
</li>
<li><p>触发<strong>服务端</strong>：</p>
<p>利用消息总线触发一个<strong>服务端</strong>ConfigServer的<code>/bus/refresh</code>端点，而</p>
<p>刷新所有客户端的配置</p>
<p><img src="/2021/03/15/springcloud/68.png" alt="img"></p>
</li>
</ol>
<p>如何选型：</p>
<p>根据架构图显然<strong>第二种</strong>更加合适，所以推荐使用<strong>触发服务端 Config Server</strong> </p>
<p>的方式。第一种触发客户端方式 不适合的原因如下：</p>
<ol>
<li><p>利用消息总线触发客户端方式，<strong>打破了微服务的职责单一性</strong>，因为微服</p>
<p>务本身是业务模块，它本不应该承担配置刷新的职责；</p>
</li>
<li><p>触发客户端方式，<strong>破坏了微服务各个节点之间的对等性</strong>（比如说：</p>
<p>3355/3366/3377 集群方式提供服务，此时 3355 还需要消息通知，影</p>
<p>响节点的对等性）</p>
</li>
<li><p><strong>有一定的局限性</strong>。当微服务迁移时，网络地址会经常发生变化，如果此</p>
<p>时需要做到自动刷新，则会增加更多的修改。</p>
</li>
</ol>
<h4 id="16-5、Bus-动态刷新全局广播配置"><a href="#16-5、Bus-动态刷新全局广播配置" class="headerlink" title="16.5、Bus 动态刷新全局广播配置"></a>16.5、Bus 动态刷新全局广播配置</h4><ul>
<li><p>集群版客户端组建（搭建两个或多个客户端）</p>
</li>
<li><p><strong>服务端</strong>配置中心/<strong>客户端</strong> pom 引入Bus总线依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端配置中心 application.yml 修改 (添加 rabbitmq 相关配置)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加rabbitmq相关支持（新加）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置，暴露bus舒心配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span>  <span class="comment">#为什么配置 bus-refresh，看传染病那张图</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端 application.yml 修改 (同样添加 rabbitmq 相关配置)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加rabbitmq相关支持</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#此处有很多选项可以配置，为了省事 ,直接配置 *</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动模块，开始测试</p>
<p>启动：服务端配置中心 Config Server (3344)、客户端集群</p>
<p>(3355/3366)、Eureka Server(7001)。修改 GitHub 参数配置，然后向 </p>
<p>服务端 发送 Post 请求，命令：<code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;</code>，</p>
<p>当向 Config Server 发送 Post 请求后，总线上的各个实例(客户端 </p>
<p>3355/3366 )都能够及时 <strong><code>监听和消费</code></strong> 配置的变更。使用广播的方式，真</p>
<p>正的实现 **<code>一处通知，处处生效</code>**。</p>
<p>使用 MQ 广播的方式，实现<code>一处通知，处处生效</code>的效果。此时我们登陆 </p>
<p>Rabbit MQ 客户端，在<code>Exchanges</code>模块，就能够看到一个叫做 </p>
<p><code>springCloudBus</code>的<code>Topic</code>。</p>
<p>与本文 2.2 Bus 原理 中介绍吻合：<strong>Config 客户端示例，都去监听 MQ</strong> </p>
<p><strong>中的同一个 topic（默认是 springCloudBus）。当一个服务刷新数据</strong></p>
<p>**的时候，它会把这个消息放入到 Topic 中，这样其他监听同一 Topic **</p>
<p><strong>的服务就能够得到通知，然后去更新自身的配置</strong>。</p>
</li>
</ul>
<h4 id="16-6、Bus-动态刷新定点通知配置"><a href="#16-6、Bus-动态刷新定点通知配置" class="headerlink" title="16.6、Bus 动态刷新定点通知配置"></a>16.6、Bus 动态刷新定点通知配置</h4><p>如果需要<strong>差异化通知</strong>，并不想进行全局广播，此时就用到了 Bus 的<strong>定点通</strong></p>
<p><strong>知</strong>功能。</p>
<p>此次我们通过客户端集群(3344/3355)演示。GitHub 远程配置修改后 ，进</p>
<p>行差异化定点通知，只通知 3355，不通知 3366。此处命令和全局广播有点</p>
<p>不同，命令为：http://配置中心IP:配置中心的端口号/actuator/bus-</p>
<p>refresh/{destination}</p>
<p>通过指定 /bus/refresh请求不再发送到具体的服务实例上，而是发给 </p>
<p>Config Server 并通过 <strong>{destination} 参数</strong>来指定需要更新配置的服务或实</p>
<p>例。</p>
<p><strong>{destination} 参数</strong> = 微服务名 ：端口号。3355 微服务名为：config-</p>
<p>client。此处最终发送的 Post 请求命令为：curl -X POST <a target="_blank" rel="noopener" href="http://localhost:3/">http://localhost:3</a></p>
<p>344/actuator/bus-refresh/config-client:3355，真正的实现<strong>精确通知</strong>功</p>
<p>能。</p>
<h2 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h2><h3 id="17、Spring-Cloud-Stream消息驱动"><a href="#17、Spring-Cloud-Stream消息驱动" class="headerlink" title="17、Spring Cloud Stream消息驱动"></a>17、Spring Cloud Stream消息驱动</h3><h4 id="17-1、目前微服务面临的问题"><a href="#17-1、目前微服务面临的问题" class="headerlink" title="17.1、目前微服务面临的问题"></a>17.1、目前微服务面临的问题</h4><p>在项目开发中，常用的四种消息中间件：<code>ActiveMQ</code>、<code>RabbitMQ</code>、</p>
<p><code>RocketMQ</code>、<code>Kafka</code>。由于每个项目需求的不同，在消息中间件的选型</p>
<p>上也就会不同。</p>
<p>在项目开发中，你会遇到以下一些问题：</p>
<ul>
<li><p>自己学的是 RabbitMQ，公司用的却是 Kafka 。再学 Kafka？学习成本</p>
<p>太高，负担太重；</p>
</li>
<li><p>多部门配合，MQ差异化带来的联调问题。A部门使用 RabbitMQ 进行</p>
<p>消息发送，大数据部门却用 Kafka， MQ 选型的不同，MQ 切换、维</p>
<p>护、开发等困难随之而来。</p>
</li>
</ul>
<p>有没有一种技术，可以让我们不再关注 MQ 的细节，只需要用一种<strong>适配绑</strong></p>
<p><strong>定</strong>的方式，就可以帮助我们自动的在各种 MQ 之间切换呢？答案就是</p>
<p>Spring Cloud Stream 消息驱动。</p>
<p>Spring Cloud Stream 消息驱动，它可以<strong>屏蔽底层 MQ 之间的细节差异</strong>。我</p>
<p>们只需要操作Spring Cloud Stream 就可以操作底层多种多样的MQ。从而</p>
<p>解决我们在 MQ 切换、维护、开发方面的难度问题。</p>
<h4 id="17-2、是什么"><a href="#17-2、是什么" class="headerlink" title="17.2、是什么"></a>17.2、是什么</h4><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a></p>
<p>Spring Cloud Stream 是一个<strong>构建消息驱动</strong>微服务的框架。应用程序通过 </p>
<p><strong>inputs</strong>或者<strong>outputs</strong>来与 Spring Cloud Stream 中的 <strong>binder</strong> 对象交互。通</p>
<p>过我们的配置来进行 binding(绑定)， 然后 Spring Cloud Stream <strong>通过</strong> </p>
<p><strong>binder 对象与消息中间件交互</strong>。所以，我们只需要搞清楚如何与 Spring </p>
<p>Cloud Stream 交互，就可以方便使用消息驱动的方式。</p>
<p>Spring Cloud Stream 通过使用 <strong>Spring Integration</strong> 来连接消息代理中间</p>
<p>件，以实现消息时间驱动。Spring Cloud Stream 为一些供应商的消息中间</p>
<p>件产品提供了个性化的自动配置发现，引用了<code>发布-订阅</code>、<code>消费组</code>、<code>分区 </code>三</p>
<p>个核心概念。目前仅支持<code>RabbitMQ</code>、<code>Kafka</code>。</p>
<p>一句话总结： Spring Cloud Stream 屏蔽了底层消息中间件的差异，降低</p>
<p>MQ 切换成本，统一消息的编程模型。开发中使用的就是各种<strong>xxxBinder</strong></p>
<p><img src="/2021/03/15/springcloud/74.png" alt="img"></p>
<h4 id="17-3、设计思想"><a href="#17-3、设计思想" class="headerlink" title="17.3、设计思想"></a>17.3、设计思想</h4><h5 id="17-3-1、标志MQ"><a href="#17-3-1、标志MQ" class="headerlink" title="17.3.1、标志MQ"></a>17.3.1、标志MQ</h5><p><strong><code>生产者/消费者</code></strong> 之间通过 <strong><code>消息媒介</code></strong> 传递消息内容</p>
<p>生产者/消费者之间靠消息媒介传递信息内容：Message</p>
<p>消息必须走特定的通道：MessageChannel</p>
<p>消息通道MessageChannel的子接口SubscribeChannel，由</p>
<p>MessageHandler消息处理器所订阅</p>
<p>结构图：</p>
<p><img src="/2021/03/15/springcloud/75.png" alt="在这里插入图片描述"></p>
<h5 id="17-3-2、Spring-Cloud-Stream"><a href="#17-3-2、Spring-Cloud-Stream" class="headerlink" title="17.3.2、Spring Cloud Stream"></a>17.3.2、Spring Cloud Stream</h5><p>比如说我们用到了RabbitMQ和 Kafka，由于这两个消息中间件的架构上的</p>
<p>不同。像RabbitMQ 有<code>exchange</code>、Kafka有<code>Topic</code>和<code>Partions</code>分区的概念。</p>
<p>这些中间件的差异性，给我们实际项目的开发造成了一定的困扰。我们如果</p>
<p>用了两个消息队列中的其中一个，后面的业务需求如果向往另外一种消息队</p>
<p>列进行迁移，这需求简直是灾难性的。<strong>因为它们之间的耦合性过高，导致一</strong></p>
<p><strong>大堆东西都要重新推到来做</strong>，这时候 Spring Cloud Stream 无疑是一个好的</p>
<p>选择，它为我们提供了一种解耦合的方式。</p>
<p>结构图：</p>
<p><img src="/2021/03/15/springcloud/76.png" alt="在这里插入图片描述"></p>
<h4 id="17-4、Spring-Cloud-Stream如何统一底层差异"><a href="#17-4、Spring-Cloud-Stream如何统一底层差异" class="headerlink" title="17.4、Spring Cloud Stream如何统一底层差异"></a>17.4、Spring Cloud Stream如何统一底层差异</h4><p>在没有绑定器这个概念的情况下，我们的 Spring Boot 应用直接与消息中间</p>
<p>件进行信息交互时，由于个消息中间件构建的初衷不同，它们的实现细节上</p>
<p>会有较大的差异性。</p>
<p><strong>通过定义绑定器(Binder)作为中间层，就可以完美的实现应用程序与消息中</strong></p>
<p><strong>间件细节的隔离</strong>。 通过向应用程序暴露统一的 Channel 通道，使得应用程</p>
<p>序不需要在考虑各种不同的消息中间件的实现。</p>
<h4 id="17-5、Binder"><a href="#17-5、Binder" class="headerlink" title="17.5、Binder"></a>17.5、Binder</h4><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中</p>
<p>间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现</p>
<p>细节上会有较大的差异性，<strong>通过定义绑定器作为中间层，完美地实现了应用</strong></p>
<p><strong>程序与消息中间件细节之间的隔离</strong>。Stream对消息中间件的进一步封装，</p>
<p>可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq</p>
<p>切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务</p>
<p>流程。</p>
<p><img src="/2021/03/15/springcloud/77.png" alt="img"></p>
<ul>
<li>INPUT：适用于消费者</li>
<li>OUTPUT：适用于生产者</li>
</ul>
<p>默认情况下，RabbitMQ Binder实现<strong>将每个目标映射到TopicExchange</strong>。 </p>
<p>对于每个使用者组，队列都绑定到该 TopicExchange。 每个使用者实例在</p>
<p>其组的队列中都有一个对应的 RabbitMQ使用者实例。 对于分区的生产者</p>
<p>和使用者，队列以分区索引为后缀，并使用分区索引作为路由键。 对于匿</p>
<p>名使用者（没有组属性的使用者），将使用自动删除队列（具有随机的唯一</p>
<p>名称）。</p>
<h4 id="17-6、Spring-Cloud-Stream-执行流程"><a href="#17-6、Spring-Cloud-Stream-执行流程" class="headerlink" title="17.6、Spring Cloud Stream 执行流程"></a>17.6、Spring Cloud Stream 执行流程</h4><p><img src="/2021/03/15/springcloud/78.png" alt="在这里插入图片描述"></p>
<p>说明：</p>
<ol>
<li><code>Source/Sink</code>：Source 输入消息，Sink 输出消息</li>
<li><code>Channel</code>：通道，是队列 Queue 的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel 对队列进行配置；</li>
<li><code>Binder</code>：很方便的 **<code>连接中间件</code>**，屏蔽 MQ 之间的差异</li>
</ol>
<h4 id="17-7、编码API和常用注解"><a href="#17-7、编码API和常用注解" class="headerlink" title="17.7、编码API和常用注解"></a>17.7、编码API和常用注解</h4><p><img src="/2021/03/15/springcloud/79.png" alt="在这里插入图片描述"></p>
<h4 id="17-8、详细配置与代码"><a href="#17-8、详细配置与代码" class="headerlink" title="17.8、详细配置与代码"></a>17.8、详细配置与代码</h4><p>选用 RabbitMQ，在不需要任何 RabbitMQ 包依赖的基础上，使用 Spring </p>
<p>Cloud Stream 消息驱动来实现消息的发送&amp;接收。</p>
<p>步骤：</p>
<ol>
<li><p>生产者配置</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入stream-rabbit依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicaiton.yml 配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于binding整合(可以自定义名称)</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">default-binder:</span> <span class="string">defaultRabbit</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span>  <span class="comment"># 设置要绑定的消息服务的具体设置(需与自定义名称一致)(飘红：Settings-&gt;Editor-&gt;Inspections-&gt;Spring-&gt;Spring Boot-&gt;Spring Boot application.yml 对勾去掉)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>业务类：</p>
<ul>
<li><p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>interface 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>service</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@EnableBinding 指信道channel和exchange绑定在一起</span></span><br><span class="line"><span class="comment">//@EnableBinding(Source.class) 就是将 Source(源) 放到 Channel 的意思</span></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span>  <span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>测试启动：<a target="_blank" rel="noopener" href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<p>可以看到后台有显示发送消息，进入 RabbitMQ 可视化界面，可以看到</p>
<p>有发送消息波峰出现。</p>
</li>
<li><p>消费者配置</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入stream-rabbit依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicaiton.yml 配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合(可以自定义名称)</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span>  <span class="comment"># 设置要绑定的消息服务的具体设置(需与自定义名称一致)(飘红：Settings-&gt;Editor-&gt;Inspections-&gt;Spring-&gt;Spring Boot-&gt;Spring Boot application.yml 对勾去掉)</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListenerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号消费者，接收：&quot;</span>+message.getPayload()+<span class="string">&quot;\t port:&quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试：启动 RabbitMQ，调用<a target="_blank" rel="noopener" href="http://localhost:880/sendMessage">http://localhost:880/sendMessage</a></p>
<p>进行消息发送，可以看到消费者后台在实时接收消息。</p>
</li>
</ol>
<p>这样，我们并没有引入任何相关 RabbitMQ 包，也并不了解 Rabbit MQ。</p>
<p>便能够使用 Rabbit MQ 进行 **<code>消息发送 &amp; 接收</code>**。这就是Spring Cloud </p>
<p>Stream 消息驱动的优越之处。</p>
<h4 id="17-9、Stream-重复消费-持久化问题"><a href="#17-9、Stream-重复消费-持久化问题" class="headerlink" title="17.9、Stream 重复消费/持久化问题"></a>17.9、Stream 重复消费/持久化问题</h4><h5 id="17-9-1、重复消费问题"><a href="#17-9-1、重复消费问题" class="headerlink" title="17.9.1、重复消费问题"></a>17.9.1、重复消费问题</h5><p>当集群方式进行消息消费时，就会存在消息的重复消费问题。比如支付微服</p>
<p>务，购物支付完成后，消息重复消费就会导致支付多次的问题出现，这显然</p>
<p>是不能接受的。</p>
<p>这是因为<strong>没有进行分组的原因，不同组就会出现重复消费</strong>；<strong>同一组</strong>内会发生</p>
<p><strong>竞争关系</strong>，<strong>只有一个可以消费</strong>。 如果我们不指定(8802、8803)集群分组信</p>
<p>息，它会默认将其当做两个分组来对待。这个时候，如果发送一条消息到 </p>
<p>MQ，不同的组就都会收到消息，就会造成消息的重复消费。</p>
<p><strong>解决方法：</strong></p>
<p>只需要用到 Stream 当中 group 属性对消息进行分组即可。将8802、8803</p>
<p>分到一个组即可。<strong>（项目中，是否分组就视业务情况而定吧）</strong></p>
<p><img src="/2021/03/15/springcloud/80.png" alt="在这里插入图片描述"></p>
<h5 id="17-9-2、持久化问题"><a href="#17-9-2、持久化问题" class="headerlink" title="17.9.2、持久化问题"></a>17.9.2、持久化问题</h5><p>服务端发送消息时，此时客户端断开服务（宕机）：若客户端没有分组，此</p>
<p>时客户端不会接收到服务端发送的消息，导致<strong>消息丢失</strong>。</p>
<p>解决方法：</p>
<p>加一个 group 分组属性就行了。如果有客户端有进行分组，重启之后则可</p>
<p>以消费待消费的消息。特别的，但多个客户端都为同一组时，既使其中有一</p>
<p>个客户端宕机，其同组的<strong>一个客户端</strong>也可以接收到消息，不会导致消息丢失</p>
<p>（无需重启）。</p>
<h2 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h2><h3 id="18、Spring-Cloud-Sleuth-Zipkin-分布式链路追踪"><a href="#18、Spring-Cloud-Sleuth-Zipkin-分布式链路追踪" class="headerlink" title="18、Spring Cloud Sleuth + Zipkin 分布式链路追踪"></a>18、Spring Cloud Sleuth + Zipkin 分布式链路追踪</h3><h4 id="18-1、目前微服务面临的问题"><a href="#18-1、目前微服务面临的问题" class="headerlink" title="18.1、目前微服务面临的问题"></a>18.1、目前微服务面临的问题</h4><p>在微服务框架中，一个由客户端发起的请求，在后端系统中会经过多个不同</p>
<p>的微服务节点调用，协同操作产生最后的请求结果。每一个前端请求都会形</p>
<p>成一条复杂的分布式服务调用链路，链路中的任何一环出现<code>高延时</code>或者<code>错</code></p>
<p><code>误</code>，都会引起整个请求最后的失败。</p>
<h4 id="18-2、是什么？"><a href="#18-2、是什么？" class="headerlink" title="18.2、是什么？"></a>18.2、是什么？</h4><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-sleuth#overview">https://spring.io/projects/spring-cloud-sleuth#overview</a></p>
<p>Spring Cloud Sleuth 提供了分布式系统中一套完整的服务跟踪的解决方</p>
<p>案，并且兼容支持了zipkin，完美的解决了多个微服务之间链路调用的问</p>
<p>题。</p>
<p>一句话总结： 就是用来处理服务之间调用关系的。</p>
<h4 id="18-3、调用结构图"><a href="#18-3、调用结构图" class="headerlink" title="18.3、调用结构图"></a>18.3、调用结构图</h4><p><img src="/2021/03/15/springcloud/81.png" alt="在这里插入图片描述"></p>
<h4 id="18-4、搭建链路监控步骤"><a href="#18-4、搭建链路监控步骤" class="headerlink" title="18.4、搭建链路监控步骤"></a>18.4、搭建链路监控步骤</h4><h5 id="18-4-1、环境准备"><a href="#18-4-1、环境准备" class="headerlink" title="18.4.1、环境准备"></a>18.4.1、环境准备</h5><p>Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的</p>
<p>监控数据，并提供查询接口。</p>
<p>我们需要先准备一个 Zipkin 环境。<strong>Spring Cloud 从F版起已不需要自己构</strong></p>
<p><strong>建Zipkin server了</strong>，只需要调用jar包即可。当前使用版本为 H版。我们只</p>
<p>需要下载 Zipkin jar包，在安装目录的路径下使用 java -jar xxx的方式启动</p>
<p>即可。点击链接：<a target="_blank" rel="noopener" href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server</a> ，下载 zipkin-server-2.12.9-exec.jar 。启动就OK了，如</p>
<p>图所示。</p>
<p><img src="/2021/03/15/springcloud/82.png" alt="在这里插入图片描述"></p>
<p>通过 <a target="_blank" rel="noopener" href="http://loclahost:9411/">http://loclahost:9411</a> 就能进入到 Zipkin 为我们提供的可视化界面（中文）</p>
<p><img src="/2021/03/15/springcloud/83.png" alt="在这里插入图片描述"></p>
<p>一次请求完整的调用链路：</p>
<p><img src="/2021/03/15/springcloud/84.png" alt="img"></p>
<p>简单概述上图：</p>
<p><img src="/2021/03/15/springcloud/85.png" alt="img"></p>
<p>术词：</p>
<ul>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li>
<li>span:表示调用链路来源，通俗的理解span就是一次请求信息</li>
</ul>
<h5 id="18-4-2、Sleuth测试环境搭建"><a href="#18-4-2、Sleuth测试环境搭建" class="headerlink" title="18.4.2、Sleuth测试环境搭建"></a>18.4.2、Sleuth测试环境搭建</h5><ol>
<li><p>服务端/客户端 进行相同配置</p>
<p>引入 zipkin + sleuth pom 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入sleuth+zipkin依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 applicaiton.yml 添加 zipkin、sleuth 相同配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span> <span class="comment">#监控数据要打到9411zipkin上</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span>  <span class="comment">#采样率值介于0到1，1则表示全部采集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用测试：</p>
<p>通过<code>http://localhost/consumer/payment/get/31</code>进行服务调用，</p>
<p>调用成功后，我们打开 <code>http://localhost:9411</code> Zipkin 控制台就可</p>
<p>以看到具体服务调用情况。</p>
<p>点击相对应请求，还可以看到 <strong><code>模块间调用情况</code>**、</strong><code>调用耗时</code>** 等更详细的</p>
<p>信息。点击导航栏中的 <strong><code>依赖</code></strong> 项，还可以查看模块(调用、被调用)的依</p>
<p>赖关系等，<strong>链路调用关系一目了然。</strong></p>
<p><img src="/2021/03/15/springcloud/springcloud%5C86.png" alt="image-20210311024420119"></p>
<p>点进每个具体的请求：</p>
<p><img src="/2021/03/15/springcloud/87.png" alt="image-20210311024741448"></p>
<p>点进依赖：（查看微服务间的依赖关系）</p>
<p><img src="/2021/03/15/springcloud/88.png" alt="image-20210311024859419"></p>
</li>
</ol>
<h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><h4 id="1、什么是维护模式"><a href="#1、什么是维护模式" class="headerlink" title="1、什么是维护模式"></a>1、什么是维护模式</h4><p>随着 Spring Cloud Netflix 项目进入维护模式（Maintenance Mode），Eureka、Hystrix、Ribbon、Zuul 等项目都进入了维护模式。</p>
<p>将模块置于<code>维护模式</code>意味着 Spring Cloud 团队将不再向该模块添加新功能。我们将修复<code>block</code>级别的<code>bug</code>和安全性问题，还将考虑并审查社区中的小请求。自 Spring Cloud Greenwich 版本发行(2018.12.12)以来，Spring Cloud 打算继续为这些模块提供至少一年的支持。（摘自：官网）</p>
<p>现在针对 Spring Cloud Netflix 相关模块已经不再提供支持。我们都知道 Spring Cloud 版本迭代算是比较快的，因而出现了很多重大ISSUE都还来不及Fix就又推出另一个 Release 版本了。进入维护模式意味着：以后一段时间 Spring Cloud Netflix 提供的服务和功能就这么多了，不再开发新的组件和功能了，这显然无法满足接下来微服务的开发要求。</p>
<p>伴随着 Spring Cloud Netflix 倒下，停更的组件自然就需要寻找替代者来继续下去。Alibaba 为了能够在微服务领域占据一定的话语权，此时便趁虚而入，将其代替，于2018.10.31 Spring Cloud Alibaba 正式入驻 Spring Cloud 官方孵化器，并在 Maven Spring Cloud for Alibaba 0.2.0 released。（附：Spring Cloud Alibaba 官方介绍）</p>
<p><img src="/2021/03/15/springcloud/3.jpg" alt="3"></p>
<h4 id="2、Spring-Cloud-Alibaba"><a href="#2、Spring-Cloud-Alibaba" class="headerlink" title="2、Spring Cloud Alibaba"></a>2、Spring Cloud Alibaba</h4><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
<h5 id="2-1、Spring-Cloud-Alibaba包含的组件"><a href="#2-1、Spring-Cloud-Alibaba包含的组件" class="headerlink" title="2.1、Spring Cloud Alibaba包含的组件"></a>2.1、Spring Cloud Alibaba包含的组件</h5><ol>
<li>**<code>Sentinel</code>**：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li>**<code>Nacos</code>**：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li>**<code>RocketMQ</code>**：Apache RocketMQ™ 基于 Java 的高性能、高吞吐量的分布式消息和流计算平台。</li>
<li>**<code>Dubbo</code>**：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li>**<code>Seata</code>**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li>**<code>Alibaba Cloud OSS</code>**：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>**<code>Alibaba Cloud SchedulerX</code>**：阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</li>
<li>**<code>Alibaba Cloud SMS</code>**：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ol>
<h5 id="2-2、主要功能"><a href="#2-2、主要功能" class="headerlink" title="2.2、主要功能"></a>2.2、主要功能</h5><ol>
<li>**<code>服务限流降级</code>**： 默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li>**<code>服务注册与发现</code>**： 适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li>**<code>分布式配置管理</code>**： 支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li>**<code>消息驱动能力</code>**： 基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li>**<code>分布式事务</code>**： 使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li>
<li>**<code>阿里云对象存储</code>**： 阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>**<code>分布式任务调度</code>**： 提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li>**<code>阿里云短信服务</code>**： 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ol>
<h4 id="3、学习组件"><a href="#3、学习组件" class="headerlink" title="3、学习组件"></a>3、学习组件</h4><p><strong><code>Alibaba Cloud OSS</code>**、</strong><code>Alibaba Cloud SchedulerX</code><strong>、</strong><code>Alibaba Cloud SMS</code>** 是阿里云相关的付费业务。接下来，我们主要介绍 Nacos、Sentinel、Seata 这三个模块。</p>
<h4 id="4、官网资料"><a href="#4、官网资料" class="headerlink" title="4、官网资料"></a>4、官网资料</h4><ol>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-alibaba#overview">Spring Cloud Alibaba官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba">Github英文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">Spring英文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">Github中文文档</a></li>
</ol>
<h3 id="19、Spring-Cloud-Alibaba-Nacos服务注册中心与配置中心"><a href="#19、Spring-Cloud-Alibaba-Nacos服务注册中心与配置中心" class="headerlink" title="19、Spring Cloud Alibaba Nacos服务注册中心与配置中心"></a>19、Spring Cloud Alibaba Nacos服务注册中心与配置中心</h3><h4 id="19-1、什么是-Nacos"><a href="#19-1、什么是-Nacos" class="headerlink" title="19.1、什么是 Nacos"></a>19.1、什么是 Nacos</h4><p>Nacos（Dynamic <strong>Na</strong>ming and <strong>Co</strong>nfiguration <strong>S</strong>ervice）：一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心。</p>
<p>我们可以理解为：<strong>Nacos = 服务注册中心 + 配置中心</strong>；等价于 Nacos = Eureka + Spring Cloud Config + Spring Cloud Bus。</p>
<h4 id="19-2、能干嘛"><a href="#19-2、能干嘛" class="headerlink" title="19.2、能干嘛"></a>19.2、能干嘛</h4><p>Nacos 可以替代 Eureka 来实现<code>服务注册中心</code>、可以替代 Spring Cloud Config 来实现<code>服务配置中心</code>、可以替代 Spring Cloud Bus 来实现<code>配置的全局广播</code>。Nacos 是更强调云原生时代支持 “<strong>服务治理、服务沉淀、共享、持续发展</strong>” 理念的注册中心和配置中心。(附：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/index.html">Nacos 官网</a>与<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html">官方文档</a>)</p>
<p>与各种注册中心比较（粗劣）：</p>
<p><img src="/2021/03/15/springcloud/89.png" alt="img"></p>
<h4 id="19-3、Nacos-安装运行"><a href="#19-3、Nacos-安装运行" class="headerlink" title="19.3、Nacos 安装运行"></a>19.3、Nacos 安装运行</h4><p>本地环境：java8+maven环境</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">官网</a>下载，你也可以选择指定版本下载：<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/tags">选择指定版本下载</a>。此处以 window 版进行演示，后续 Nacos 集群环境会在 Linux 环境配置。</p>
<p>下载完成后，解压缩，直接运行 bin 目录下的<code>startup.cmd</code>，<strong>此处需注意</strong>：若你下载的nacos为<strong>较新版本</strong>，nacos默认是集群方式开启，会出现：<code>nacos is starting with cluster</code>，无法正常启动（此时nacos并未集群）。</p>
<p><img src="/2021/03/15/springcloud/90.png" alt="img"></p>
<p>此时需以单机方式启动，执行以下命令<code>startup.cmd -m standalone</code>即可启动Nacos服务，我们可以看到它使用的是 8848 端口，启动结果如图所示：</p>
<p><img src="/2021/03/15/springcloud/91.png" alt="在这里插入图片描述"></p>
<p>运行成功后，直接访问 <a target="_blank" rel="noopener" href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> 就可以进入 Nacos 的为我们提供的 web 控制台。**<code>用户名、密码默认为 nacos</code>**(1.2.0 版本不需要输入密码)，控制台还是挺清新的哈，还提供中文支持。</p>
<p><img src="/2021/03/15/springcloud/92.png" alt="在这里插入图片描述"></p>
<h4 id="19-4、Nacos与其他注册中心对比"><a href="#19-4、Nacos与其他注册中心对比" class="headerlink" title="19.4、Nacos与其他注册中心对比"></a>19.4、Nacos与其他注册中心对比</h4><p>Nacos和CAP：</p>
<p><img src="/2021/03/15/springcloud/96.png" alt="在这里插入图片描述"></p>
<p>CAP：</p>
<p><code>C</code>一致性<code>A</code>高可用<code>P</code>容错性。参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP原则</a>，主流选用的都是 AP 模式，保证系统的高可用。</p>
<p>何时选择使用何种模式？</p>
<p>一般来说，如果<strong>不需要存储服务级别的信息</strong>，且服务实例是通过<code>Nacos-client</code>注册，并能够<strong>保证心跳上报</strong>，那么就可以选择 AP 模式。当前主流的服务如 Spring Cloud 和 Dubbo 服务，都适用于 AP 模式，**AP模式为了服务的可用行而减弱了一致性，因此 AP 模式下只支持注册<code>临时实例</code>**。</p>
<p>如果需要在服务级别<strong>编辑或者存储配置信息</strong>，那么 CP 是必须的，<code>K8S服务</code>和<code>DNS服务</code>则适用于 CP 模式。CP模式下则支持注册**<code>持久化实例</code><strong>，此时则是以<code>Raft协议</code>为集群运行模式，</strong>该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。**</p>
<p>而Nacos支持AP和CP模式的切换：</p>
<p><img src="/2021/03/15/springcloud/97.png" alt="在这里插入图片描述"></p>
<p>Nacos的全景图：</p>
<p><img src="/2021/03/15/springcloud/98.png" alt="img"></p>
<p>Nacos AP/CP模式切换：</p>
<p>Nacos 集群默认支持的是CAP原则中的 AP原则，但是也可切换为CP原则，切换命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span><br></pre></td></tr></table></figure>

<p>同时微服务的 bootstrap.yml需配置如下选项指明注册为临时/永久实例，<code>AP模式</code>不支持数据一致性，所以只支持服务注册的<code>临时实例</code>，<code>CP模式</code>支持服务注册的<code>永久实例</code>，满足配置文件的一致性。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#false为永久实例，true表示临时实例开启，注册为临时实例</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">nacos:</span> </span><br><span class="line">	  <span class="attr">discovery:</span> </span><br><span class="line">		<span class="attr">ephemeral:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="19-5、Nacos用作服务注册中心"><a href="#19-5、Nacos用作服务注册中心" class="headerlink" title="19.5、Nacos用作服务注册中心"></a>19.5、Nacos用作服务注册中心</h4><p>Nacos 可以替代 Eureka 来作为 **<code>服务注册中心</code>**。附：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_nacos_discovery">Nacos 服务注册中心官方文档</a></p>
<ul>
<li><p><strong>基于Nacos的服务提供者(provider)</strong></p>
<ol>
<li><p>父pom引入spring-cloud-alibaba 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当前模块pom引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--引入 nacos-discovery 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicaiton.yml 文件配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加上@EnableDiscoveryClient</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alibaba Nacos registry,server &quot;</span>+ serverPort+<span class="string">&quot;----- id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务模块，查看服务是否注册到 Nacos</p>
<p>启动服务模块，进入 Nacos 控制台，在 <strong><code>服务管理 → 服务列表</code></strong> 中可以看到，我们定义的服务名 <code>nacos-payment-provider</code> 已经成功注册到 Nacos 注册中心。</p>
<p><img src="/2021/03/15/springcloud/93.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>可以多来个服务端，与 9021 组成集群（9022、9023等等，做法与上一致）</p>
<p><strong>提示：</strong>9022 和 9023 除端口外，其他配置都相同。在<strong>测试环境</strong>（只能在测试环境里用，可能出现未知的bug）使用时，此处还有个取巧的方法，**<code>可以通过直接拷贝虚拟端口映射，来创建 9002 模块</code>**。我们使用 9021 来创建9022/9023，（实质端口为9021）如下图所示：</p>
<p><img src="/2021/03/15/springcloud/94.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>基于Nacos的服务消费者（consumer）</strong></p>
<ol>
<li><p>当前模块pom引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Nacos 默认支持负载均衡</p>
<p>spring-cloud-starter-alibaba-nacos-discovery包里就整合有ribbon</p>
<p><img src="/2021/03/15/springcloud/95.png" alt="在这里插入图片描述"></p>
<p>也就是说：我们可以使用ribbon的负载均衡与RestTemplate</p>
</li>
<li><p>applicaiton.yml 文件配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-nacos-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称</span></span><br><span class="line"><span class="attr">server-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加注解@EnableDiscoveryClient</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RestTemplate配置类（注意加上@LoadBalanced实现负载均衡）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务消费者，查看服务是否注册到 Nacos</p>
</li>
<li><p>服务调用测试，是否实现负载均衡。通过服务端对客户端服务进行调用：<a target="_blank" rel="noopener" href="http://localhost:83/consumer/payment/nacos/31%E3%80%82%E9%87%87%E7%94%A8%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82">http://localhost:83/consumer/payment/nacos/31。采用轮询的方式，实现了负载均衡。</a></p>
</li>
</ol>
</li>
<li><p><strong>也可以用OpenFeign+Nacos实现服务消费者（consumer）</strong></p>
<ol>
<li><p>引入 spring-cloud-openfeign 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 spring-cloud-openfeign 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置同上（改端口也行）</p>
</li>
<li><p>主启动类加上@EnableDiscoveryClient与@EnableFeignClients两个注解。</p>
</li>
<li><p>编写OpenFeign的服务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderNacosService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此处注意：</strong>注解@FeignClient里的服务名”nacos-payment-provider”必须和服务提供端的yml配置一致,大小写敏感(Eureka 大小写不敏感,Nacos 不同,大小写会导致调用失败)</p>
<p>具体可参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/issues/2188">ISSUE</a></p>
</li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderNacosService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getPayment(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动测试</p>
</li>
</ol>
</li>
</ul>
<h4 id="19-6、Nacos用作服务配置中心"><a href="#19-6、Nacos用作服务配置中心" class="headerlink" title="19.6、Nacos用作服务配置中心"></a>19.6、Nacos用作服务配置中心</h4><h5 id="19-6-1、Nacos作为配置中心–基础配置"><a href="#19-6-1、Nacos作为配置中心–基础配置" class="headerlink" title="19.6.1、Nacos作为配置中心–基础配置"></a>19.6.1、Nacos作为配置中心–基础配置</h5><ol>
<li><p>当前模块 pom 引入 nacos-config 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入nacos-config配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册到 Nacos，需引入nacos-discovery配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入nacos-discovery配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行yml配置：</p>
<p>此处需要配置<code>bootstrap.yml</code>和<code>application.yml</code>两个文件<code>bootstrap.yml</code>用作系统级资源配置项，<code>application.yml</code>用作用户级的资源配置项。在项目中两者配合共同生效，<code>bootstrap.yml</code>优先级更高。<br>bootstrap.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>

<p>application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加 @EnableDiscoveryClient 注解</p>
</li>
<li><p>业务类：(添加 @RefreshScope 实现配置自动更新)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">//支持Nacos的动态刷新功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nacos中添加配置项：</p>
<p>进入 <strong><code>Nacos → 配置管理 → 配置列表 → + 号</code></strong> 添加配置项。Data ID 按规则编写，Group 在接下来的 <strong><code>分类配置</code></strong> 会有介绍。</p>
<p><img src="/2021/03/15/springcloud/99.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/100.png" alt="在这里插入图片描述"></p>
</li>
<li><p>启动测试，是否能够获取Nacos配置：</p>
<p>通过 <a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a> 测试，发现可以正确获取 Nacos 配置中心的配置信息</p>
<p><img src="/2021/03/15/springcloud/101.png" alt="在这里插入图片描述"></p>
</li>
<li><p>Nacos 自带动态刷新：</p>
<p>在使用 Spring Cloud Config 时，需要配合 Spring Cloud Bus + RabbitMQ 中间件，用<code>curl</code>进行广播方式才能 <strong><code>实现动态刷新</code>**。</strong><code>Nacos则自带动态刷新,修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</code>**</p>
</li>
</ol>
<h5 id="19-6-2、dataId-命名规则"><a href="#19-6-2、dataId-命名规则" class="headerlink" title="19.6.2、dataId 命名规则"></a>19.6.2、dataId 命名规则</h5><p>在 Nacos Spring Cloud 中， <code>dataId</code> 有明确的配置规则，官方也有说明。进入链接查看：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">官网链接</a>。</p>
<p><code>dataId</code> 的完整格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。</li>
<li>spring.profile.active 即为当前环境对应的 profile。注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}（建议：不要让 spring.profile.active 为空，或许会有一些意外的问题,未知的bug）</li>
<li>file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</li>
</ul>
<p><img src="/2021/03/15/springcloud/102.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/103.png" alt="img"></p>
<p><strong>此处注意：</strong>在Nacos网页中进行添加配置项时，在填写<code>Data ID</code>需要注意,若你采用的是yaml格式的话，如<code>nacos-config-dev.yaml</code>中的yaml不能省略成yml，即<code>nacos-config-dev.yml</code>。若省略，程序启动会报错（找不到配置项config.info）。这是Nacos的一个小坑（bug）。</p>
<h5 id="19-6-3、Nacos作为配置中心–分类配置"><a href="#19-6-3、Nacos作为配置中心–分类配置" class="headerlink" title="19.6.3、Nacos作为配置中心–分类配置"></a>19.6.3、Nacos作为配置中心–分类配置</h5><p>项目开发中，一定会遇到<code>多环境</code>、<code>多项目管理</code>问题。遇到下面问题时，Nacos 基础配置显然无法解决这些问题，接下来就对<code>Nacos 命名空间</code>及<code>Group</code>相关概念的了解。</p>
<ul>
<li>问题1： 实际开发中，通常一个系统会准备<code>dev开发环境</code>、<code>test测试环境</code>、<code>prod生产环境</code>，如何保证指定环境启动时服务能够正确读取到 Nacos 上相应环境的配置文件？</li>
<li>问题2： 一个大型的分布式微服务系统会有很多个微服务<code>子项目</code>，每个微服务项目又都会有相应的<code>dev开发环境</code>、<code>test测试环境</code>、<code>prod生产环境 </code>等，那怎么对这些微服务配置进行管理呢？</li>
</ul>
<p>这是就可以用到Nacos的分类功能了。</p>
<h6 id="19-6-3-1、Nacos的命名规则说明"><a href="#19-6-3-1、Nacos的命名规则说明" class="headerlink" title="19.6.3.1、Nacos的命名规则说明"></a>19.6.3.1、Nacos的命名规则说明</h6><p>Nacos 命名由<code>Namespace(命名空间) </code>+ <code>Group(分组)</code> + <code>Data ID(实例ID)</code> 三部分组成，类似于 Java 中的 package(报名) + class(类名) 方式。最外层 <strong>Namespace 用于区分部署环境</strong>；<strong>Group 和 Data ID 逻辑上用于区分两个目标对象</strong>。</p>
<p><img src="/2021/03/15/springcloud/104.png" alt="在这里插入图片描述"></p>
<p>默认情况下：</p>
<p><strong>Namespace = public，Group = DEFAULT_GROUP，Cluster=DEFAULT</strong></p>
<p><strong><code>Namespace</code>**主要用来实现</strong>隔离**，Nacos 默认的命名空间是<code>public</code>。比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个 Namespace，不同的 Namespace 之间是隔离的；</p>
<p><strong><code>Group</code>**是一组</strong>配置集<strong>，是组织配置的维度之一。默认是<code>DEFAULT_GROUP</code>。通过一个有意义的<code>名称</code>对配置集进行分组，从而区分 Data ID 相同的配置集。</strong>配置分组的常见场景：不同的应用或组件使用了相同的配置类型，就可以把不同的微服务划分到同一个分组里面去，从而解决问题2；如 database_url 配置和 MQ_topic 配置。**</p>
<p><strong><code>Service</code>**微服务；一个 Service 可以包含多个<code>Cluster(集群)</code>，Nacos 默认 Cluster 是<code>DEFAULT</code>，Cluster 是对指定微服务的一个</strong>虚拟划分<strong>。</strong>比方说为了容灾，将 Service 微服务分别部署在了杭州机房和广州机房，这是就可以给杭州机房的 Service 微服务起一个集群名称(HZ)，给广州机房的 Service 微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。**</p>
<p><strong><code>Instance</code>**，就是一个个</strong>微服务实例**。</p>
<p><img src="/2021/03/15/springcloud/105.png" alt="img"></p>
<p>保留空间public是不能被删除的。。</p>
<p><img src="/2021/03/15/springcloud/106.png" alt="img"></p>
<h6 id="19-6-3-2、新建Namespace"><a href="#19-6-3-2、新建Namespace" class="headerlink" title="19.6.3.2、新建Namespace"></a>19.6.3.2、新建Namespace</h6><p>选择 <strong><code>命名空间 → 新建命名空间</code>**，进行命名空间的设置。在 Nacos 1.1.4 版本，还<code>不支持自定义命名空间ID</code>，Nacos 1.2.0 版本后开始支持自定义命名空间ID 了。</strong>更推荐你使用自定义命名空间**。</p>
<p><img src="/2021/03/15/springcloud/107.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/108.png" alt="在这里插入图片描述"></p>
<h6 id="19-6-3-3、新建-Group"><a href="#19-6-3-3、新建-Group" class="headerlink" title="19.6.3.3、新建 Group"></a>19.6.3.3、新建 Group</h6><p>新建配置自定义Group名称。<strong>Group 就是根据需求的不同，将微服务划分到同一个分组里面去，来解决问题2</strong></p>
<p><img src="/2021/03/15/springcloud/109.png" alt="在这里插入图片描述"></p>
<h6 id="19-6-3-4、将-namespace-和-Group-应用到项目中"><a href="#19-6-3-4、将-namespace-和-Group-应用到项目中" class="headerlink" title="19.6.3.4、将 namespace 和 Group 应用到项目中"></a>19.6.3.4、将 namespace 和 Group 应用到项目中</h6><p>只需要在<code>bootstrap.yml</code>中添加 <code>namespace</code> 和 <code>group</code> 两个属性即可。**<code>namespace</code>** 属性：此处配置为 namespace **<code>命名空间 ID</code>**，自定义namespace时，推荐还是自定义名称，否则就是一串很长的字符串流水号，而且还语意不明。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="comment"># 指定 namespace 和 group </span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev-nsid</span> <span class="comment">#指定Namespace命名空间</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">Group_A</span> <span class="comment">#指定Group分组</span></span><br></pre></td></tr></table></figure>

<h6 id="19-6-3-5、指定-namespace-和-group-后，读取的便是对应配置内容"><a href="#19-6-3-5、指定-namespace-和-group-后，读取的便是对应配置内容" class="headerlink" title="19.6.3.5、指定 namespace 和 group 后，读取的便是对应配置内容"></a>19.6.3.5、指定 namespace 和 group 后，读取的便是对应配置内容</h6><p><img src="/2021/03/15/springcloud/110.png" alt="在这里插入图片描述"></p>
<h4 id="19-7、Nacos-集群搭建和持久化配置-Linux-Mysql"><a href="#19-7、Nacos-集群搭建和持久化配置-Linux-Mysql" class="headerlink" title="19.7、Nacos 集群搭建和持久化配置(Linux + Mysql)"></a>19.7、Nacos 集群搭建和持久化配置(Linux + Mysql)</h4><h5 id="19-7-1、Nacos集群官方架构图"><a href="#19-7-1、Nacos集群官方架构图" class="headerlink" title="19.7.1、Nacos集群官方架构图"></a>19.7.1、Nacos集群官方架构图</h5><p><img src="/2021/03/15/springcloud/111.png" alt="在这里插入图片描述"></p>
<p><strong>VIP</strong>：此处的 VIP 指代的是 <code>Virtual IP</code>（虚拟IP）的意思，通常情况下指代的是<code>Nginx</code>。</p>
<p>说明： 开源时，推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面：</p>
<p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连ip模式，机器挂则需要修改ip才可以使用。<br><a href="http://VIP:port/openAPI">http://VIP:port/openAPI</a> 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。<br><strong><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + VIP模式，可读性好，而且换ip方便，推荐模式。</strong></p>
<h5 id="19-7-2、Nacos集群真实架构图"><a href="#19-7-2、Nacos集群真实架构图" class="headerlink" title="19.7.2、Nacos集群真实架构图"></a>19.7.2、Nacos集群真实架构图</h5><p><img src="/2021/03/15/springcloud/112.png" alt="在这里插入图片描述"></p>
<h5 id="19-7-3、Nacos在linux下安装下载"><a href="#19-7-3、Nacos在linux下安装下载" class="headerlink" title="19.7.3、Nacos在linux下安装下载"></a>19.7.3、Nacos在linux下安装下载</h5><p>1、在<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">官网</a>下载xxx.tar.gz文件，并转移进Linux服务器。</p>
<p>2、<strong>nacos 安装目录：<code>/usr/local/nacos/</code></strong></p>
<p>3、使用tar -zxvf 命令解压</p>
<h5 id="19-7-4、Nacos数据库支持（derby-）"><a href="#19-7-4、Nacos数据库支持（derby-）" class="headerlink" title="19.7.4、Nacos数据库支持（derby ）"></a>19.7.4、Nacos数据库支持（derby ）</h5><p>手动将Nacos服务关闭再启动。存储在Nacos中的配置信息并不会丢失。这是因为 Nacos 默认内置<code>DerBy</code>数据库。 嵌入式数据库，nacos pom.xml 有引入<code>derby</code>依赖。以下摘自Nacos的<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/blob/develop/config/pom.xml">github源码</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.derby<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>derby<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Nacos的derby数据库记录的数据放在nacos安装目录下的/conf/nacos-mysql.sql的sql文件里。</p>
<p>在<code>Nacos 0.7</code>版本之前，在单机模式时nacos使用嵌入式数据库(<code>derby</code>)实现数据的存储，不方便观察数据存储的基本情况。<strong>0.7 版本增加了支持 mysql 数据源能力</strong>。 具体的操作步骤：</p>
<ol>
<li>安装数据库，版本要求：5.6.5+</li>
<li>初始化mysql数据库，数据库初始化文件：<code>nacos-mysql.sql</code></li>
<li>修改<code>conf/application.properties</code>文件，增加支持mysql数据源配置（<strong>目前只支持mysql</strong>），添加mysql数据源的url、用户名和密码。</li>
<li>再启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql。</li>
</ol>
<h5 id="19-7-5、Nacos-集群部署搭建"><a href="#19-7-5、Nacos-集群部署搭建" class="headerlink" title="19.7.5、Nacos 集群部署搭建"></a>19.7.5、Nacos 集群部署搭建</h5><p>Nacos支持三种部署模式</p>
<ul>
<li>单机模式 - 用于测试和单机试用。</li>
<li><strong><code>集群模式 - 用于生产环境，确保高可用。</code></strong></li>
<li>多集群模式 - 用于多数据中心场景。</li>
</ul>
<p>  此处附：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">Nacos集群模式部署官方文档</a></p>
<p>若单机要集群Nacos的话要删除其中的<code>data</code>文件夹。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/to-make-life-better/p/14534539.html">资料</a></p>
<h6 id="19-7-5-1、节点部署情况"><a href="#19-7-5-1、节点部署情况" class="headerlink" title="19.7.5.1、节点部署情况"></a>19.7.5.1、节点部署情况</h6><table>
<thead>
<tr>
<th align="center">服务器IP</th>
<th align="center">部署服务</th>
<th align="center">端口</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.204.202</td>
<td align="center">MySQL 5.7.28</td>
<td align="center">3306</td>
<td align="center">测试，使用单机 MySQL，高可用参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lzb348110175/article/details/103081631">MySQL 5.7.28 主从复制实现</a></td>
</tr>
<tr>
<td align="center">192.168.204.202</td>
<td align="center">Nginx 1.4.1</td>
<td align="center">8807</td>
<td align="center">测试，使用单机 Nginx，Nginx集群搭建请自行了解(Nginx默认端口为80，此处负载均衡使用8087端口)</td>
</tr>
<tr>
<td align="center">192.168.204.202</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点01：nacos 01</td>
</tr>
<tr>
<td align="center">192.168.204.203</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点02：nacos 02</td>
</tr>
<tr>
<td align="center">192.168.204.204</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点03：nacos 03</td>
</tr>
</tbody></table>
<p>提示： 三台机器配置相同，此处对一台进行配置。使用命令 scp 发送到其他两台机器即可，此处以<code>192.168.204.202</code>为例说明。</p>
<h6 id="19-7-5-2、derby-切换-mysql-数据库配置"><a href="#19-7-5-2、derby-切换-mysql-数据库配置" class="headerlink" title="19.7.5.2、derby 切换 mysql 数据库配置"></a>19.7.5.2、derby 切换 mysql 数据库配置</h6><ol>
<li><p>执行nacos-mysql.sql脚本：</p>
<p>进入 nacos 安装目录 conf 文件下，找到 <code>nacos-mysql.sql 脚本</code>。</p>
<p>创建 nacos_config 数据库，并执行 nacos-mysql.sql 脚本。</p>
<p><img src="/2021/03/15/springcloud/113.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/114.png" alt="在这里插入图片描述"></p>
</li>
<li><p>修改application.properties，添加mysql支持：</p>
<p>进入nacos安装目录 conf 文件下，<code>application.properties</code> 配置文件添加 mysql 支持。</p>
<p>其中：</p>
<ul>
<li><p>在修改所有文件之前建议保存副本</p>
<p><img src="/2021/03/15/springcloud/115.png" alt="img"></p>
</li>
<li><p>db.user与db.password填写本机的用户名与密码</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://192.168.204.202:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/116.png" alt="img"></p>
</li>
<li><p>cluster.conf 配置:</p>
<p>进入 conf 目录，使用命令：<code>cp cluster.conf.example cluster.conf</code>拷贝一份，重命名为<code>cluster.conf</code>，在 cluster.conf 中进行配置，说明哪几台机器组成集群（填写的是 nacos 集群3个节点所在 IP:端口号，不要写<code>127.0.0.1</code>，必须是Linux的<strong>真实IP</strong>）,可以通过命令<code>hostname -i</code>查看Linux的真实IP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.204.202:8848</span><br><span class="line">192.168.204.203:8848</span><br><span class="line">192.168.204.204:8848</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 nacos 启动堆栈大小：</p>
<p>（nacos 启动时，默认 <code>-Xms2g -Xmx2g</code>。如果你是在多台虚拟机测试，配置紧张，这一步就比较重要了。如果服务器配置很优秀，这一步可以绕过。）</p>
<p><strong>配置紧张会导致以下情况的出现：</strong></p>
<ol>
<li><strong>nacos 服务启动很慢很慢的情况；</strong></li>
<li><strong>nacos 服务注册中心，有3个提供服务，你可能只能看到 2个、1个、0个服务节点，还会来回跳动的问题。</strong></li>
<li><strong>反正还是会出现一些意想不到的问题，视情况而配置。</strong></li>
</ol>
<blockquote>
<p><code>Xms 是指设定程序启动时占用内存大小。</code>一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。<br><code>Xmx 是指设定程序运行期间最大可占用的内存大小。</code>如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。</p>
</blockquote>
<p>我们进入 bin 目录，使用 <code>vim startup.sh</code> 对其进行修改，将其按照配置修改到指定大小即可。（好像可以通过启动时添加 Xms 参数方式修改，我忘了怎么搞了，此处就直接修改 <code>.sh</code> 启动脚本了）（建议修改之前进行备份）</p>
<p><img src="/2021/03/15/springcloud/117.png" alt="在这里插入图片描述"></p>
</li>
<li><p>使用scp命令，进行nacos配置分发：</p>
<p>192.168.204.202 一台 nacos 集群环境配置完成，使用 scp 命令，将 nacos 目录分发到 203/204两台机器。scp 命令的使用如下：(scp命令使用介绍，请参考：Linux命令—scp)，不使用 scp 命令，你也可以 rz、sz 以打包的方式进行上传。</p>
<blockquote>
<p>scp -r /usr/local/env/nacos <a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x32;&#48;&#x34;&#x2e;&#50;&#x30;&#51;">&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x32;&#48;&#x34;&#x2e;&#50;&#x30;&#51;</a>:/usr/local/nacos/<br>scp -r /usr/local/env/nacos <a href="mailto:&#x72;&#x6f;&#111;&#116;&#64;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#x2e;&#x32;&#x30;&#x34;&#46;&#x32;&#48;&#52;">&#x72;&#x6f;&#111;&#116;&#64;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#x2e;&#x32;&#x30;&#x34;&#46;&#x32;&#48;&#52;</a>:/usr/local/nacos/</p>
</blockquote>
</li>
<li><p>以上第5步也可以通过编辑Nacos的启动脚本<code>startup.sh</code>,使他能够接受不同的启动端口（建议备份）：</p>
<p><img src="/2021/03/15/springcloud/118.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/119.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/120.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/121.png" alt="img"></p>
<p>之后就可以通过<code>./startup.sh -p 端口号</code>执行：</p>
<p><img src="/2021/03/15/springcloud/122.png" alt="img"></p>
</li>
</ol>
<h6 id="19-7-5-2、Nginx的配置，由他作为负载均衡器"><a href="#19-7-5-2、Nginx的配置，由他作为负载均衡器" class="headerlink" title="19.7.5.2、Nginx的配置，由他作为负载均衡器"></a>19.7.5.2、Nginx的配置，由他作为负载均衡器</h6><p>在此处，已经默认 Nginx 服务已经OK，Nginx 服务跑在<code>192.168.204.202</code>。如需 Nginx 的搭建过程，请自行。</p>
<p>进入<code>nginx/conf</code> 目录，对 <code>nginx.conf</code>添加 nacos 集群配置，配置如下图所示：</p>
<p><img src="/2021/03/15/springcloud/123.png" alt="在这里插入图片描述"></p>
<p>配置完成，进入 sbin 目录，使用<code>./nginx -c /usr/local/nginx/nginx-1.16.0/conf/nginx.conf</code>启动 nginx，使用<code>-c</code>加载指定配置文件，路径为 nginx.conf 所在路径。启动完成，通过命令：<code>ps aux | grep nginx</code>查看 nginx 是否启动。如图已经启动成功。</p>
<p><img src="/2021/03/15/springcloud/124.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-3、启动nacos集群"><a href="#19-7-5-3、启动nacos集群" class="headerlink" title="19.7.5.3、启动nacos集群"></a>19.7.5.3、启动nacos集群</h6><p>启动集群中的3台nacos。可以通过命令<code>ps -ef|grep nacos|grep -v grep grep |wc -l</code>查看nacos集群启用的端口数量，也可以通过nacos安装路径logs目录，使用 <code>tail -f nacos.log</code> 查看日志。</p>
<p><strong>启动成功提示：</strong></p>
<p><strong><code>如果虚拟机资源紧张，此处会一直很长时间在 nacos is starting... 状态,一定注意自己服务器的配置。</code></strong></p>
<p><img src="/2021/03/15/springcloud/126.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-4、进入Nacos控制台"><a href="#19-7-5-4、进入Nacos控制台" class="headerlink" title="19.7.5.4、进入Nacos控制台"></a>19.7.5.4、进入Nacos控制台</h6><p>已经配置 Nginx 负载均衡，所以我们使用 Nginx 8087 端口进入Nacos 控制台：**<code>http://192.168.204.202:8087/nacos/</code>**</p>
<p><img src="/2021/03/15/springcloud/127.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-5、查看集群节点启动情况"><a href="#19-7-5-5、查看集群节点启动情况" class="headerlink" title="19.7.5.5、查看集群节点启动情况"></a>19.7.5.5、查看集群节点启动情况</h6><p><img src="/2021/03/15/springcloud/128.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-6、Nacos集群环境，项目application-yml中nacos地址需写-Nginx-地址"><a href="#19-7-5-6、Nacos集群环境，项目application-yml中nacos地址需写-Nginx-地址" class="headerlink" title="19.7.5.6、Nacos集群环境，项目application.yml中nacos地址需写 Nginx 地址"></a>19.7.5.6、Nacos集群环境，项目application.yml中nacos地址需写 Nginx 地址</h6><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.204</span><span class="number">.202</span><span class="string">:8087</span> <span class="comment">#配置Nacos地址(集群使用Nginx，此处需配置Nginx地址)</span></span><br></pre></td></tr></table></figure>

<p>通过访问8087端口（Ngnix）来实际访问三个nacos端口。</p>
<p><img src="/2021/03/15/springcloud/129.png" alt="在这里插入图片描述"></p>
<h3 id="20、Sentinel实现服务降级、服务熔断、服务限流"><a href="#20、Sentinel实现服务降级、服务熔断、服务限流" class="headerlink" title="20、Sentinel实现服务降级、服务熔断、服务限流"></a>20、Sentinel实现服务降级、服务熔断、服务限流</h3><p>资料查询：</p>
<p>  附官网：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel GitHub 官网</a></p>
<p>  中文介绍文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">Sentinel Wiki中文介绍文档</a></p>
<p>  Sentinel 使用介绍：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_sentinel">Spring Cloud 关于 Sentinel 使用文档</a></p>
<h4 id="20-1、是什么"><a href="#20-1、是什么" class="headerlink" title="20.1、是什么"></a>20.1、是什么</h4><p>(本段内容摘自：Sentinel Wiki 中文文档，一句话解释Sentinel，就是之前介绍过的：Hystrix 实现服务降级、服务熔断、服务限流，Sentinel 后起之秀，更优秀)</p>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载保护</strong>等多个维度保护服务的稳定性。</p>
<p><img src="/2021/03/15/springcloud/130.png" alt="img"></p>
<h4 id="20-2、Sentinel的特征"><a href="#20-2、Sentinel的特征" class="headerlink" title="20.2、Sentinel的特征"></a>20.2、Sentinel的特征</h4><ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h4 id="20-3、Sentinel的作用"><a href="#20-3、Sentinel的作用" class="headerlink" title="20.3、Sentinel的作用"></a>20.3、Sentinel的作用</h4><p><img src="/2021/03/15/springcloud/131.png" alt="在这里插入图片描述"></p>
<p><strong>Sentinel 的开源生态：</strong></p>
<p><img src="/2021/03/15/springcloud/132.png" alt="在这里插入图片描述"></p>
<p>Sentinel 分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）：基于 Spring Boot 开发，打包后使用 java -jar xxx.jar 方式可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<h4 id="20-4、安装Sentinel控制台-Dashboard"><a href="#20-4、安装Sentinel控制台-Dashboard" class="headerlink" title="20.4、安装Sentinel控制台(Dashboard)"></a>20.4、安装Sentinel控制台(Dashboard)</h4><ol>
<li><p>Sentinel Dashboard 下载地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">Sentinel Dashboard 下载地址</a></p>
</li>
<li><p>环境：JDK 8，端口：<strong>8080 不被占用。</strong></p>
</li>
<li><p>在安装目录进入 cmd 控制台，使用 <strong><code>java -jar sentinel-dashboard-1.7.2.jar</code></strong> 方式直接运行。</p>
<p><img src="/2021/03/15/springcloud/133.png" alt="image-20210313024314111"></p>
</li>
<li><p>使用 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 访问 Sentinel 图形管理界面。</p>
<p>登陆账号、密码均为：**<code>sentinel</code>**</p>
<p><img src="/2021/03/15/springcloud/134.png" alt="image-20210313024508488"></p>
</li>
<li><p>至此，Sentinel控制台(Dashboard)安装成功。</p>
</li>
</ol>
<h4 id="20-5、微服务项目整合Sentinel"><a href="#20-5、微服务项目整合Sentinel" class="headerlink" title="20.5、微服务项目整合Sentinel"></a>20.5、微服务项目整合Sentinel</h4><p>使用 <code>Sentinel</code> 最好配好 <code>Nacos</code> 一起使用。</p>
<p>启动Sentinel与Nacos的微服务，并通过<a href="http://localhost:8080与http://localhost:8848/nacos/#/login进行访问。">http://localhost:8080与http://localhost:8848/nacos/#/login进行访问。</a></p>
<p>新建微服务模块：</p>
<ol>
<li><p>添加pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 sentinel 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--nacos服务注册依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sentinel持久化需要的依赖(后续持久化会用到,此处可有可无)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="comment"># 添加sentinel相关配置</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#sentinel默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露，用于监控等</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加 <strong>@EnableDiscoveryClient</strong> 注解</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动项目，查看Sentinel是否成功监控：</p>
<p>此时进入 Sentinel 图形管理界面，并没有看到关于微服务任何信息。这是因为 <strong>Sentinel 采用的<code>懒加载机制</code>，只有执行一次方法调用，才能被Sentinel监控到</strong>。 然后多次调用 /testA 接口，在实时监控便能够看到接口 调用时间、QPS、响应时间 等内容。 说明：<strong>Sentinel 8080 已经在监控微服务 8401，监控会有一丁点的延迟。服务一段时间不调用，实时监控会消失。</strong></p>
</li>
</ol>
<h4 id="20-6、Spring-Cloud-Alibaba-Sentinel-流控、降级、热点、系统规则"><a href="#20-6、Spring-Cloud-Alibaba-Sentinel-流控、降级、热点、系统规则" class="headerlink" title="20.6、Spring Cloud Alibaba Sentinel 流控、降级、热点、系统规则"></a>20.6、Spring Cloud Alibaba Sentinel 流控、降级、热点、系统规则</h4><p><img src="/2021/03/15/springcloud/135.png" alt="image-20210313190605946"></p>
<h5 id="20-6-1、流控规则"><a href="#20-6-1、流控规则" class="headerlink" title="20.6.1、流控规则"></a>20.6.1、流控规则</h5><p>流控规则，即：流量控制规则。可自行参考官网介绍：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">GitHub 流量控制</a>。具体配置有 <strong><code>资源名</code>**、</strong><code>针对来源</code><strong>、</strong><code>阈值类型</code><strong>、</strong><code>是否集群</code><strong>、</strong><code>流控模式</code><strong>、</strong><code>单机阈值</code><strong>、</strong><code>流控效果</code>** 这几项，它们配合进行使用。</p>
<p>可以通过<code>簇点链路</code>的方式添加，也可以通过<code>流控规则</code>方式添加。</p>
<p><img src="/2021/03/15/springcloud/136.png" alt="image-20210313190901838"></p>
<blockquote>
<p>**<code>资源名</code>**：唯一路径，默认为请求路径（也可以是后续介绍的 @SentinelResource 注解的 value 属性值）<br>**<code>针对来源</code>**：Sentinel 可以针对调用者进行限流，填写微服务名。默认为 default（不区分来源）<br>**<code>是否集群</code>**：本文为单机测试，是否集群不选</p>
</blockquote>
<h6 id="20-6-1-1、阈值类型：QPS"><a href="#20-6-1-1、阈值类型：QPS" class="headerlink" title="20.6.1.1、阈值类型：QPS"></a>20.6.1.1、阈值类型：QPS</h6><p><strong>QPS（每秒钟的请求数量）</strong>：当调用该 API 的 <strong><code>QPS</code></strong> 达到阈值的时候，进行限流。</p>
<p><strong>配置(默认流控模式为<code>直接</code>，流控效果为<code>快速失败</code>)：</strong></p>
<p><img src="/2021/03/15/springcloud/137.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：/testA 服务，每秒只允许调用 1 次，超出阈值后，直接失败（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-2、阈值类型：线程数"><a href="#20-6-1-2、阈值类型：线程数" class="headerlink" title="20.6.1.2、阈值类型：线程数"></a>20.6.1.2、阈值类型：线程数</h6><p><strong>线程数</strong>：当调用该 API 的 <strong><code>线程数</code></strong> 达到阈值的时候，进行限流。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/138.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p>/testA 服务，单个线程只允许调用 1 次，超出阈值后，直接失败（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-3、流控模式：直接"><a href="#20-6-1-3、流控模式：直接" class="headerlink" title="20.6.1.3、流控模式：直接"></a>20.6.1.3、流控模式：直接</h6><p><strong>效果</strong>：超出阈值后，直接失败。</p>
<h6 id="20-6-1-4、流控模式：关联"><a href="#20-6-1-4、流控模式：关联" class="headerlink" title="20.6.1.4、流控模式：关联"></a>20.6.1.4、流控模式：关联</h6><p><strong>关联</strong>：当关联的资源达到阈值时，就限流自己。**<code>当与 A 资源关联的 B 资源达到阈值时，就限流自己(A)</code>**，即：B惹事，A挂了</p>
<p><strong>应用场景：</strong></p>
<p>双十一，<code>支付接口</code>和<code>下单接口</code>关联。当支付接口达到阈值，就限流下单接口。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/139.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p><code>/testA</code> 服务关联<code>/testB</code> 服务，1s 调用 1次，服务正常。当狂点刷新调用 <code>/testB</code> 服务，超出阈值 QPS = 1 后，此时 /testA 被限流了，这就是 **<code>B惹事，A挂了</code>**。</p>
<h6 id="20-6-1-5、流控模式：链路"><a href="#20-6-1-5、流控模式：链路" class="headerlink" title="20.6.1.5、流控模式：链路"></a>20.6.1.5、流控模式：链路</h6><p>链路：当链路中的资源达到阈值时，就会对使用到该资源的链路进行流控。当A01 资源达到设定阈值时，所有调用该服务的链路，都会被限流，即：A01 挂了，用到我的链路都得挂。</p>
<p>此处会用到 @SentinelResource 注解 value 属性值 作为资源名。此处只是使用一下。</p>
<p>模拟两条请求链路：</p>
<p>A链路： A → A01 → A04 → A05<br>B链路： B → A01 → A02 → A03</p>
<p><img src="/2021/03/15/springcloud/140.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/141.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p>对 <strong><code>testA01</code></strong> 服务进行 <strong><code>链路</code></strong> 流控，该服务关联有 A 和 B 两条链路。当 A 链路1s 调用 1次，服务正常。当该链路调用 **<code>超出阈值 QPS = 1 后，此时A链路都会被限流，同时因为B链路也调用 testA01，所以B链路也会同时被限流调用</code>**。</p>
<h6 id="20-6-1-6、用postman进行循环访问"><a href="#20-6-1-6、用postman进行循环访问" class="headerlink" title="20.6.1.6、用postman进行循环访问"></a>20.6.1.6、用postman进行循环访问</h6><ol>
<li><p>postman里新建多线程集合组：</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C142.png" alt="img"></p>
</li>
<li><p>访问地址添加进新线程组：</p>
<p><img src="/2021/03/15/springcloud/143.png" alt="img"></p>
</li>
<li><p>run：</p>
<p><img src="/2021/03/15/springcloud/144.png" alt="img"></p>
</li>
</ol>
<h6 id="20-6-1-7、流控效果：快速失败"><a href="#20-6-1-7、流控效果：快速失败" class="headerlink" title="20.6.1.7、流控效果：快速失败"></a>20.6.1.7、流控效果：快速失败</h6><p>效果：</p>
<p>直接失败。（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-8、流控效果：Warm-Up"><a href="#20-6-1-8、流控效果：Warm-Up" class="headerlink" title="20.6.1.8、流控效果：Warm Up"></a>20.6.1.8、流控效果：Warm Up</h6><p><strong>Warm Up</strong>：某个服务，日常访问量很少，基本为 0，突然1s访问量 10w，这种极端情况，会直接将服务击垮。所以通过配置 <strong><code>流控效果：Warm Up</code>**，允许系统慢慢呼呼的进行</strong>预热**，经<code>预热时长</code>逐渐升至设定的QPS阈值。以下图片来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">官网</a>。</p>
<p><img src="/2021/03/15/springcloud/145.png" alt="image">限限流 冷启动：（以下来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">官网</a>）</p>
<p>当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的增多，经过预期的时间以后，到达系统处理请求个数的最大值。Warm Up（冷启动，预热）模式就是为了实现这个目的的。</p>
<p>这个场景主要用于启动需要额外开销的场景，例如建立数据库连接等。</p>
<p>它的实现是在 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java">Guava</a> 的算法的基础上实现的。然而，和 Guava 的场景不同，Guava 的场景主要用于调节请求的间隔，即 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky Bucket</a>，而 Sentinel 则主要用于控制每秒的 QPS，即我们满足每秒通过的 QPS 即可，我们不需要关注每个请求的间隔，换言之，我们更像一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket</a>。</p>
<p>默认 <code>coldFactor</code> 为 3，即请求 QPS 从 <code>threshold / 3</code> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p>
<blockquote>
<p><strong>公式：</strong>阈值/coldFactor（默认值为3）</p>
</blockquote>
<p>源码：</p>
<p><img src="/2021/03/15/springcloud/147.png" alt="img"></p>
<p><strong>应用场景：</strong></p>
<p>秒杀系统。秒杀系统在开启的瞬间，会有很多的流量上来，很有可能将系统打死。预热方式就是为了保护系统，可以慢慢的将流量放进来，最终将阈值增长到指定的数值。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/146.png" alt="在这里插入图片描述"></p>
<p>效果：</p>
<p><code>/testA</code> 服务，设置 QPS 单机阈值为 10，采用 Warm Up 预热的方式，预热时长为 5s。根据计算公式 **<code>10 / 3 = 3</code>**，前 5s 的阈值为 3，预热 5s 后阈值增长到 10。</p>
<p>即：前5s内，<strong>访问超过 3 次便会被限流；5s 后，阈值增长到 10，此时访问超过 3 次也不会被限流</strong>，<strong>这就是 Warm Up 预热效果。</strong></p>
<h6 id="20-6-1-9、流控效果：排队等待"><a href="#20-6-1-9、流控效果：排队等待" class="headerlink" title="20.6.1.9、流控效果：排队等待"></a>20.6.1.9、流控效果：排队等待</h6><p><strong>排队等待</strong>：让请求以均匀的速度通过，对应的是<code>漏桶算法</code>。这种方式主要用于处理间隔性突发的流量，例如消息队列。</p>
<p><strong>应用场景：</strong></p>
<p>在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态。我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。**<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">官网</a>**</p>
<blockquote>
<p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
</blockquote>
<p><img src="/2021/03/15/springcloud/210.png" alt="image"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/148.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p><code>/testA</code> 服务，设置 QPS 单机阈值为 2，每秒只接收 2 个请求。设置超时时间 5s。采用漏斗算法，让后台匀速的处理请求，而不是直接拒绝更多的请求。超时的请求则被抛弃，返回错误信息。（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h5 id="20-6-2、降级规则"><a href="#20-6-2、降级规则" class="headerlink" title="20.6.2、降级规则"></a>20.6.2、降级规则</h5><p>降级规则。可自行参考官网介绍：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">GitHub 熔断降级</a>。降级策略有 <strong><code>慢调用比例</code>**、</strong><code>异常比例</code><strong>、</strong><code>异常数</code>** 三种。</p>
<p>熔断状态:</p>
<p>熔断有三种状态，分别为<code>OPEN</code>、<code>HALF_OPEN</code>、<code>CLOSED</code></p>
<p><img src="/2021/03/15/springcloud/150.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/149.png" alt="image-20210313202500145"></p>
<blockquote>
<p>**<code>资源名</code>**：唯一路径，默认为请求路径（也可以是后续介绍的 @SentinelResource 注解的 value 属性值）</p>
</blockquote>
<h6 id="20-6-2-1、慢调用比例"><a href="#20-6-2-1、慢调用比例" class="headerlink" title="20.6.2.1、慢调用比例"></a>20.6.2.1、慢调用比例</h6><p>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以<code>慢调用比例作为阈值</code>，需要设置允许的慢调用<code>RT（即最大的响应时间）</code>，请求的响应时间<code>大于</code>该值则统计为慢调用。当单位<code>统计时长</code>（<code>statIntervalMs</code>）内请求数目<code>大于</code>设置的<code>最小请求数目</code>，<strong>并且</strong>慢调用的比例<code>大于</code>阈值，则接下来的熔断时长内请求会<strong>自动被熔断</strong>。经过熔断时长后熔断器会进入<strong>探测恢复状态</strong>（<code>HALF-OPEN</code>状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。（以上来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">官网</a>）</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C151.png" alt="img"></p>
<p><strong>执行逻辑</strong>：</p>
<ul>
<li><p><strong>熔断（OPEN）：请求数大于最小请求数并且慢调用的比率大于比例阈值则发生熔断</strong>，熔断时长为用户自定义设置。</p>
</li>
<li><p><strong>探测（HALFOPEN）</strong>：当熔断过了定义的熔断时长，状态由熔断（OPEN）变为探测（HALFOPEN）。</p>
</li>
<li><p>如果接下来的一个请求小于最大RT，说明慢调用已经恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）</p>
</li>
<li><p>如果接下来的一个请求大于最大RT，说明慢调用未恢复，继续熔断，熔断时长保持一致</p>
</li>
</ul>
<p>注意Sentinel默认统计的RT上限是<code>4900ms</code>，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项<code>-Dcsp.sentinel.statistic.max.rt=xxx</code>来配置。</p>
<h6 id="20-6-2-2、异常比例"><a href="#20-6-2-2、异常比例" class="headerlink" title="20.6.2.2、异常比例"></a>20.6.2.2、异常比例</h6><p><strong>异常比例</strong>：<code>QPS &gt;= 5</code> &amp;&amp; <code>异常比例超过设定的阈值</code>，便会发生服务降级 。</p>
<p>异常比例为 0.0~1.0 范围内值。**<code>时间窗口就是断路器开启时间长短(降级时间)</code>** 。要看官网介绍来这里：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5">异常比例介绍</a></p>
<p><strong>图示：</strong></p>
<p><img src="/2021/03/15/springcloud/152.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/153.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p><code>/testA</code> 服务，设置 降级策略为 **<code>异常比例</code>**，异常比例设为 **<code>0.5</code>**，时间窗口为 **<code>5s</code>**。即：1s 发送6个请求，异常比例超过 50%，就会被熔断，断路器打开5s，5s后自动关闭，继续提供服务。</p>
<p>如果1s发送6次请求，前3次网页报错，因为第4次访问后，异常比例 &gt; 50%，第4次便会被熔断，报 **<code>Blocked by Sentinel(flow limiting)</code>**。5s后继续提供服务哦。</p>
<h6 id="20-6-2-3、异常数"><a href="#20-6-2-3、异常数" class="headerlink" title="20.6.2.3、异常数"></a>20.6.2.3、异常数</h6><p><strong>异常数</strong>：指的是资源 <strong><code>近1分钟</code></strong> 的异常数目，超过阈值之后会进行熔断。<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5">官网</a></p>
<p><strong>重点注意：</strong>异常数，统计时间窗口是分钟级别，若 timeWindow 小于 60s，则结束熔断状态后仍可能再次进入熔断状态。推荐 <strong><code>时间窗口一定要&gt;=60s</code></strong></p>
<p><strong>图示：</strong></p>
<p><img src="/2021/03/15/springcloud/154.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/155.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p><code>/testA</code> 服务，设置 降级策略为 **<code>异常数</code>**，异常数设为 **<code>5</code>**，时间窗口为 **<code>60s</code>**。即：调用服务，当异常数超过5个时，开启断路器，执行熔断操作。60s 后，断路器关闭，服务恢复正常。</p>
<p>执行 /testA 服务请求，因为每个请求都是异常，前5次调用正常返回，只是报异常到前台(错误页面)；第6次服务调用时，便会被降级熔断。报 **<code>Blocked by Sentinel(flow limiting)</code>**。60s后继续提供服务哦。</p>
<h5 id="20-6-3、热点规则"><a href="#20-6-3、热点规则" class="headerlink" title="20.6.3、热点规则"></a>20.6.3、热点规则</h5><p>(本段内容摘自：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">Github 热点规则官方介绍</a>)</p>
<h6 id="20-6-3-1、何为热点？"><a href="#20-6-3-1、何为热点？" class="headerlink" title="20.6.3.1、何为热点？"></a>20.6.3.1、何为热点？</h6><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<blockquote>
<p>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制<br>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</p>
</blockquote>
<p><code>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流</code>。 <strong>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</strong></p>
<p>Sentinel 利用<code>LRU 策略</code>统计最近最常访问的热点参数，结合<code>令牌桶算法</code>来进行参数级别的流控。热点参数限流支持集群模式。</p>
<p><img src="/2021/03/15/springcloud/156.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-3-2、何为热点限流"><a href="#20-6-3-2、何为热点限流" class="headerlink" title="20.6.3.2、何为热点限流"></a>20.6.3.2、何为热点限流</h6><p>一句话解释：根据 url 传递进来的参数进行限流。<strong>带这个参数就限流，不带就不限流</strong>。</p>
<h6 id="20-6-3-3、热点规则"><a href="#20-6-3-3、热点规则" class="headerlink" title="20.6.3.3、热点规则"></a>20.6.3.3、热点规则</h6><p>共有 <strong><code>资源名</code>**、</strong><code>限流模式(只支持QPS模式)</code><strong>、</strong><code>参数索引</code><strong>、</strong><code>单机阈值</code><strong>、</strong><code>统计窗口时长</code><strong>、</strong><code>是否集群</code>** 六种参数；高级选项还有额外一些参数。</p>
<p><img src="/2021/03/15/springcloud/157.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong><code>资源名</code>**：唯一路径，默认为请求路径。</strong>此处必须是 @SentinelResource 注解的 value 属性值，配置@GetMapping 的请求路径无效）**<br><strong><code>参数索引</code>**：参数索引（从</strong><code>0</code>**开始，0表示第一个参数、1表示第二个参数）</p>
</blockquote>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/158.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p>对 <code>/testC</code> 服务，配置热点key限流。当 1.第<code>二</code>个参数存在   2.一秒内调用 <code>/testC</code> 服务 &gt; 5次，满足限流规则。服务将被熔断。断路器打开，5s 后服务恢复正常。</p>
<p><strong>参数例外项配置：</strong></p>
<p><strong>需求</strong>(当请求参数name的值为Wade时，改变其限流阈值)：</p>
<p>当 name 参数值为 Wade 时，限流阈值变更为 100。此时就需要对 参数例外项 进行配置了。</p>
<p><code>参数类型</code>支持：int、double、String、long、float、char、byte 7种类型，参数值 指 name 参数的值，<code>限流阈值</code>指该参数值允许的阈值。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/159.png" alt="在这里插入图片描述"></p>
<p><strong>测试：</strong></p>
<p>调用 URL：</p>
<p><code>http://localhost:8401/testC?id=1&amp;name=Wade</code>，阈值为200；</p>
<p><code>http://localhost:8401/testC?id=1&amp;name=Jhon</code>，阈值为200；</p>
<h5 id="20-6-4、系统规则（不常用）"><a href="#20-6-4、系统规则（不常用）" class="headerlink" title="20.6.4、系统规则（不常用）"></a>20.6.4、系统规则（不常用）</h5><h6 id="20-6-4-1、是什么"><a href="#20-6-4-1、是什么" class="headerlink" title="20.6.4.1、是什么"></a>20.6.4.1、是什么</h6><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的<code>load</code>、<code>CPU 使用率</code>、<code>平均 RT</code>、<code>入口 QPS</code>和<code>并发线程数</code>等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">官网</a></p>
<h6 id="20-6-4-2、系统规则支持的模式"><a href="#20-6-4-2、系统规则支持的模式" class="headerlink" title="20.6.4.2、系统规则支持的模式"></a>20.6.4.2、系统规则支持的模式</h6><ul>
<li>Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</li>
<li>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h6 id="20-6-4-3、入口QPS配置"><a href="#20-6-4-3、入口QPS配置" class="headerlink" title="20.6.4.3、入口QPS配置"></a>20.6.4.3、入口QPS配置</h6><p>入口QPS，实用性还是比较危险的。 如果 sentinel 密码被修改，将你的整个系统 <strong><code>入口QPS</code></strong> 配置很小，那么整个系统就瘫痪了。</p>
<p>但是 入口QPS 有总控的功能。最终选择是否使用，还是视情况而定吧</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/160.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p>整个系统，每个请求 QPS = 1 正常访问，当该请求 QPS &gt;1 就会被限流。</p>
<h5 id="20-6-5、-SentinelResource"><a href="#20-6-5、-SentinelResource" class="headerlink" title="20.6.5、@SentinelResource"></a>20.6.5、@SentinelResource</h5><p><code>@SentinelResource</code>可以说是 Sentinel 学习的突破口，搞懂了这个注解的应用，基本上就搞清楚了 Sentinel 的大部分应用场景。Sentinel 提供了 <strong>@SentinelResource 注解用于定义资源，并提供了AspectJ的扩展用于自动定义资源、处理BlockException等。</strong></p>
<h6 id="20-6-5-1、-SentinelResource-属性介绍"><a href="#20-6-5-1、-SentinelResource-属性介绍" class="headerlink" title="20.6.5.1、@SentinelResource 属性介绍"></a>20.6.5.1、@SentinelResource 属性介绍</h6><table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">是否必填</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>value</strong></td>
<td align="center">是</td>
<td align="left">资源名称（必填项，需要通过 <code>value</code> 值找到对应的规则进行配置）</td>
</tr>
<tr>
<td align="center">entryType</td>
<td align="center">否</td>
<td align="left">entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td>
</tr>
<tr>
<td align="center"><strong>blockHandler</strong></td>
<td align="center">否</td>
<td align="left">**处理<code>BlockException</code>的函数名称(可以理解为对Sentinel的配置进行方法兜底)**。函数要求：<br>1.必须是<code>public</code>修饰<br>2.<code>返回类型</code>与<code>原方法</code>一致<br>3. <code>参数类型</code>需要和<code>原方法</code>相匹配，并在最后加 <code>BlockException</code>类型的参数。<br>4. 默认需和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>blockHandlerClass</code>，并<code>指定</code>blockHandlerClass里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>blockHandlerClass</strong></td>
<td align="center">否</td>
<td align="left"><strong>存放blockHandler的类</strong>。<br>对应的处理函数必须<code>public static</code>修饰，否则无法解析，其他要求：同blockHandler。</td>
</tr>
<tr>
<td align="center"><strong>fallback</strong></td>
<td align="center">否</td>
<td align="left">**用于在抛出异常的时候提供fallback处理逻辑(可以理解为对<code>java异常</code>情况方法兜底)**。<br>fallback函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。函数要求：<br>1.<code>返回类型</code>与<code>原方法</code>一致<br>2.<code>参数类型</code>需要和<code>原方法</code>相匹配，Sentinel 1.6开始，也可在方法最后加<code>Throwable</code>类型的参数。<br>3.默认需和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>fallbackClass</code> ，并<code>指定</code>fallbackClass里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>fallbackClass</strong></td>
<td align="center">否</td>
<td align="left"><strong>存放fallback的类</strong>。<br>对应的处理函数必须<code>static</code>修饰，否则无法解析，其他要求：同fallback。</td>
</tr>
<tr>
<td align="center"><strong>defaultFallback</strong></td>
<td align="center">否</td>
<td align="left"><strong>用于通用的 fallback 逻辑</strong>。<br>默认 fallback 函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。<strong>若同时配置了 fallback 和 defaultFallback，以fallback为准</strong>。函数要求：<br>1.<code>返回类型</code>与<code>原方法</code>一致<br>2.方法参数列表为<code>空</code>，或者有一个<code>Throwable </code>类型的参数。<br>3.默认需要和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>fallbackClass</code> ，并<code>指定</code>fallbackClass 里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>exceptionsToIgnore</strong></td>
<td align="center">否</td>
<td align="left"><strong>指定排除掉哪些异常。</strong><br>排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。</td>
</tr>
<tr>
<td align="center">exceptionsToTrace</td>
<td align="center">否</td>
<td align="left">需要trace的异常</td>
</tr>
</tbody></table>
<p>（加深标注属性为常用属性）</p>
<p><img src="/2021/03/15/springcloud/164.png" alt="img"></p>
<h6 id="20-6-5-2、fallback-指定java异常兜底方法"><a href="#20-6-5-2、fallback-指定java异常兜底方法" class="headerlink" title="20.6.5.2、fallback 指定java异常兜底方法"></a>20.6.5.2、fallback 指定java异常兜底方法</h6><p>**<code>fallback只用来处理与Java逻辑异常相关的兜底</code>**。比如：NullPointerException、ArrayIndexOutOfBoundsException 等java代码中的异常，fallback 指定的兜底方法便会生效。</p>
<p><strong>兜底方法与业务方法耦合</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;, fallback = &quot;fallbackMethod&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;限流请求连接(Java类异常)的兜底方法：&quot;</span> + e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 fallbackClass 将兜底方法与业务解耦合</strong>：</p>
<p><img src="/2021/03/15/springcloud/161.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-5-3、blockHandler-指定-Sentinel-配置兜底方法"><a href="#20-6-5-3、blockHandler-指定-Sentinel-配置兜底方法" class="headerlink" title="20.6.5.3、blockHandler 指定 Sentinel 配置兜底方法"></a>20.6.5.3、blockHandler 指定 Sentinel 配置兜底方法</h6><p>**<code>blockHandler 只用来处理 与 Sentinel 配置有关的兜底</code>**。比如：配置某资源 QPS =1，当 QPS &gt;1 时，blockHandler 指定的兜底方法便会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testB&quot;,blockHandler = &quot;exceptionMethod&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testB&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">exceptionMethod</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;限流@SentinelResource value 属性的兜底方法:&quot;</span> + exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 fallbackClass 将兜底方法与业务解耦合</strong></p>
<p><img src="/2021/03/15/springcloud/162.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-5-4、exceptionsToIgnore-用于指定异常不走兜底方法"><a href="#20-6-5-4、exceptionsToIgnore-用于指定异常不走兜底方法" class="headerlink" title="20.6.5.4、exceptionsToIgnore 用于指定异常不走兜底方法"></a>20.6.5.4、exceptionsToIgnore 用于指定异常不走兜底方法</h6><p>使用<code>exceptionsTolgnore</code>属性，来<code>指定某些异常不执行兜底方法，直接显示错误信息</code>。配置 ArithmeticException 异常不走兜底方法。java.lang.ArithmeticException: / by zero ，便不会再执行兜底方法，直接显示错误信息给前台页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;, </span></span><br><span class="line"><span class="meta">					fallback = &quot;fallbackMethod&quot;,</span></span><br><span class="line"><span class="meta">					fallbackClass = CustomerFallback.class, </span></span><br><span class="line"><span class="meta">					exceptionsToIgnore = ArithmeticException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="20-6-5-5、defaultFallback-用于指定通用的-fallback-兜底方法"><a href="#20-6-5-5、defaultFallback-用于指定通用的-fallback-兜底方法" class="headerlink" title="20.6.5.5、defaultFallback 用于指定通用的 fallback 兜底方法"></a>20.6.5.5、defaultFallback 用于指定通用的 fallback 兜底方法</h6><p>使用 defaultFallback 来指定通用的 fallback 兜底方法。</p>
<ul>
<li>如果当前业务配置有 defaultFallback 和 fallback 两个属性，则优先执行 fallback 指定的方法。</li>
<li>如果 fallback 指定的方法不存在，还会执行 defaultFallback 指定的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallbackMethod&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomerFallback.class,</span></span><br><span class="line"><span class="meta">        defaultFallback = &quot;defaultFallbackMethod&quot; //直接指定即可，使用比较简单</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单独一个类，存放兜底方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerFallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">defaultFallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;通用的fallback兜底方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;限流请求连接(Java类异常)的兜底方法：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面兜底方案面临的问题：</p>
<ol>
<li>系统默认的，没有体现我们自己的业务要求。</li>
<li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。</li>
<li>每个业务方法都添加一个兜底的，那代码膨胀加剧。</li>
<li>全局统一的处理方法没有体现。</li>
</ol>
<p>客户自定义限流处理逻辑：</p>
<ol>
<li><p>创建CustomerBlockHandler类用于自定义限流处理逻辑：</p>
</li>
<li><p>自定义限流处理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RateLimitController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">            blockHandlerClass = CustomerBlockHandler.class,</span></span><br><span class="line"><span class="meta">            blockHandler = &quot;handlerException2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按客戶自定义&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/163.png" alt="img"></p>
</li>
</ol>
<p>Sentinel的三个核心API：</p>
<p><img src="/2021/03/15/springcloud/文件/java/我/java后台学习笔记/springcloud/springcloud/165.png" alt="image-20210314010417987"></p>
<p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(key, EntryType.IN, key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write your biz code here.</span></span><br><span class="line">  <span class="comment">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-7、服务熔断"><a href="#20-7、服务熔断" class="headerlink" title="20.7、服务熔断"></a>20.7、服务熔断</h4><p>sentinel整合ribbon+openFeign+fallback</p>
<p>公共：</p>
<ol>
<li><p>启动nacos和启动sentinel服务</p>
</li>
<li><p>新建两个服务提供端（实现负载均衡）（详情看上面微服务项目整合Sentinel）</p>
</li>
<li><p>服务提供端的业务类PaymentController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long,Payment&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 模拟数据库</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> Payment(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> Payment(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> Payment(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入1、2、3得到数据，输入4报空指针异常</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Payment payment = hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建服务消费端</p>
</li>
<li><p>业务类CircleBreakerController</p>
</li>
</ol>
<h5 id="20-7-1、Ribbon系列"><a href="#20-7-1、Ribbon系列" class="headerlink" title="20.7.1、Ribbon系列"></a>20.7.1、Ribbon系列</h5><ol>
<li><p>添加sentinel依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置文件：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动添加@EnableDiscoveryClient</p>
</li>
<li><p>添加RestTemplate配置类ApplicationContextConfig(<strong>添加@LoadBalanced</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="20-7-2、OpenFeign系列（Feign组件一般是在消费者侧）"><a href="#20-7-2、OpenFeign系列（Feign组件一般是在消费者侧）" class="headerlink" title="20.7.2、OpenFeign系列（Feign组件一般是在消费者侧）"></a>20.7.2、OpenFeign系列（Feign组件一般是在消费者侧）</h5><ol>
<li><p>添加OpenFeign依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud openfeign --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置文件（激活Sentinel对Feign的支持）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加注解：@EnableFeignClients</p>
</li>
<li><p>service接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局fallback实现service接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">44444</span>,<span class="string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="keyword">new</span> Payment(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>业务类CircleBreakerController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span></span><br><span class="line"><span class="meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line">空指针异常</span><br><span class="line">        <span class="comment">// 输入4报非法参数异常，输入其他报空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;IllegalArgumentException,非法参数异常，输入其他报....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是fallback</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是blockHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,BlockException blockException)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================OpenFeign</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有配置：@SentinelResource(value = “fallback”) （不友好）</p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/2">http://lcaolhost:84/consumer/fallback/2</a></p>
<p><img src="/2021/03/15/springcloud/167.png" alt="image-20210314020226329"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4">http://lcaolhost:84/consumer/fallback/4</a></p>
<p><img src="/2021/03/15/springcloud/168.png" alt="image-20210314020528745"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/5">http://lcaolhost:84/consumer/fallback/5</a></p>
<p><img src="/2021/03/15/springcloud/169.png" alt="image-20210314020917296"></p>
</li>
</ul>
</li>
<li><p>只配置fallback（只负责运行异常）：@SentinelResource(value = “fallback”,fallback = “handlerFallback”)</p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4">http://lcaolhost:84/consumer/fallback/4</a></p>
<p><img src="/2021/03/15/springcloud/170.png" alt="image-20210314021545779"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/5">http://lcaolhost:84/consumer/fallback/5</a></p>
<p><img src="/2021/03/15/springcloud/171.png" alt="image-20210314021737234"></p>
</li>
</ul>
</li>
<li><p>只配置blockHandler（只负责sentinel控制台配置违规）：@SentinelResource(value = “fallback”,blockHandler = “blockHandler”)</p>
<p>配置sentinel控制台：</p>
<p><img src="/2021/03/15/springcloud/172.png" alt="image-20210314022142172"></p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4%E7%82%B9%E5%87%BB%E4%B8%80%E6%AC%A1">http://lcaolhost:84/consumer/fallback/4点击一次</a></p>
<p><img src="/2021/03/15/springcloud/168.png" alt="image-20210314020528745"></p>
<p>连续点击：</p>
<p><img src="/2021/03/15/springcloud/173.png" alt="image-20210314022337780"></p>
</li>
</ul>
</li>
<li><p>fallback和blockHandler都配置：</p>
<p>若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时<strong>只会进入blockHandler处理逻辑</strong>。</p>
</li>
</ul>
<h5 id="20-7-3、熔断框架比较"><a href="#20-7-3、熔断框架比较" class="headerlink" title="20.7.3、熔断框架比较"></a>20.7.3、熔断框架比较</h5><p><img src="/2021/03/15/springcloud/174.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/175.png" alt="img"></p>
<h4 id="20-8、Sentinel-控制台规则持久化（持久化到Nacos比较鸡肋）"><a href="#20-8、Sentinel-控制台规则持久化（持久化到Nacos比较鸡肋）" class="headerlink" title="20.8、Sentinel 控制台规则持久化（持久化到Nacos比较鸡肋）"></a>20.8、Sentinel 控制台规则持久化（持久化到Nacos比较鸡肋）</h4><p>Sentinel 控制台规则持久化问题：</p>
<p>在 Sentinel 中，我们会为多个服务进行 流控、限流、热点 等规则 的配置，但是当服务重启后再进入 Sentinel 后，发现之前配置过的规则都不在了，这样子的体验显然不友好，此时就需要我们对 Sentinel 中配置的规则规则进行持久化操作。</p>
<p>目前控制台的规则推送也是通过<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E6%9F%A5%E8%AF%A2%E6%9B%B4%E6%94%B9%E8%A7%84%E5%88%99">规则查询更改 HTTP API</a>来更改规则。这也意味着这些规则 仅在内存态生效，应用重启之后，该规则会丢失。</p>
<p>以上是原始模式。当了解了原始模式之后，我们非常鼓励您通过<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">动态规则</a> 并结合各种外部存储来定制自己的规则源。我们推荐通过动态配置源的控制台来进行规则写入和推送，而不是通过 Sentinel 客户端直接写入到动态配置源中。在生产环境中，我们推荐 push 模式，具体可以参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">在生产环境使用 Sentinel</a>。也可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42437633/article/details/106443342">博客</a></p>
<p>规则管理及推送：</p>
<p><img src="/2021/03/15/springcloud/166.png" alt="在这里插入图片描述"></p>
<h5 id="20-8-1、持久化配置（鸡肋）"><a href="#20-8-1、持久化配置（鸡肋）" class="headerlink" title="20.8.1、持久化配置（鸡肋）"></a>20.8.1、持久化配置（鸡肋）</h5><p><strong>将限流配置规则持久化进Nacos保存</strong>，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。</p>
<p>步骤：</p>
<ol>
<li><p>添加依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改添加application.yml（主要是datasource）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="comment">#添加nacos数据源配置</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure>

<p>其中dataId的值为${spring.application.name}。</p>
</li>
<li><p>添加nacos业务配置规则</p>
<p><img src="/2021/03/15/springcloud/176.png" alt="img"></p>
<p>其中Data ID的值为${spring.application.name}的值。</p>
</li>
<li><p>在配置中的选择json，并添加内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;resource&quot;</span>:<span class="string">&quot;/rateLimit/byUrl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;grade&quot;</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;strategy&quot;</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="attr">&quot;controlBehavior&quot;</span>:<span class="number">0</span>,</span><br><span class="line">		&quot;clusterMode&quot;; false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>resource：资源名称；</li>
<li>limitApp：来源应用；</li>
<li>grade：國值类型，0表示线程数，1表示QPS；</li>
<li>count：单机國值；</li>
<li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li>
<li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</li>
<li>clusterMode：是否集群。</li>
</ul>
</li>
<li><p>重启微服务，刷新sentinel。</p>
<p>发现业务规则有了</p>
<p><img src="/2021/03/15/springcloud/177.png" alt="img"></p>
</li>
<li><p>快速访问测试接口：配置成功。</p>
<p><img src="/2021/03/15/springcloud/178.png" alt="image-20210314025406567"></p>
</li>
<li><p>关闭微服务再看sentinel：</p>
<p><img src="/2021/03/15/springcloud/179.png" alt="img"></p>
</li>
<li><p>重启微服务再看sentinel：（鸡肋）</p>
<p><img src="/2021/03/15/springcloud/180.png" alt="image-20210314025455716"></p>
</li>
</ol>
<h5 id="20-8-2、Alibaba-AHAS-与-Alibaba-Sentinel"><a href="#20-8-2、Alibaba-AHAS-与-Alibaba-Sentinel" class="headerlink" title="20.8.2、Alibaba AHAS 与 Alibaba Sentinel"></a>20.8.2、Alibaba AHAS 与 Alibaba Sentinel</h5><h6 id="20-8-2-1、AHAS是什么："><a href="#20-8-2-1、AHAS是什么：" class="headerlink" title="20.8.2.1、AHAS是什么："></a>20.8.2.1、AHAS是什么：</h6><p>应用高可用服务AHAS是一款专注于提高应用高可用能力的SaaS产品，提供应用架构自动探测、故障注入式高可用能力演练、一键应用防护和增加功能开关等功能，可以快速低成本地提升应用可用性。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/product/87450.html">官网</a></p>
<p>Alibaba AHAS是<code>商业化</code>的（说白了就是要用钱买）</p>
<p>Alibaba Sentinel是<code>开源</code>的，任何人都能用</p>
<p>Alibaba AHAS完成了对配置信息持久化的更深一层的包装。</p>
<p>更多资料：</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/knowledge_detail/167568.html">Alibaba AHAS 与 Alibaba Sentinel的对比</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lettuce_/article/details/102799028">springcloud（11）Alibaba-AHAS 限流方式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hosaos/article/details/91413895">Sentinel-集成阿里云AHAS控制台实现集群流控</a></p>
<h3 id="21、SpringCloud-Alibaba-Seata处理分布式事务"><a href="#21、SpringCloud-Alibaba-Seata处理分布式事务" class="headerlink" title="21、SpringCloud Alibaba Seata处理分布式事务"></a>21、SpringCloud Alibaba Seata处理分布式事务</h3><h4 id="21-1、目前微服务面临的问题"><a href="#21-1、目前微服务面临的问题" class="headerlink" title="21.1、目前微服务面临的问题"></a>21.1、目前微服务面临的问题</h4><p>在之前 <strong><code>单机单库</code></strong> 环境下，针对事务的处理还是比较简单的。尤其是结合 Spring 框架，可以说是一个@Transaction 注解走天下。事务 &amp; Spring 事务相关内容，点击链接去了解吧：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lzb348110175/article/details/104854696">事务 &amp; Spring 事务内容介绍</a></p>
<p>在如今 Spring Cloud 分布式微服务架构体系中，按业务模块划分，一个模块使用一个数据库。多个模块配合来完成一个业务，我们就从 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/user/quickstart.html">官网</a> 的一个微服务实例开始吧。</p>
<h5 id="21-1-1、-用例"><a href="#21-1-1、-用例" class="headerlink" title="21.1.1、 用例"></a>21.1.1、 用例</h5><p><strong>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</strong></p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>帐户服务：从用户帐户中扣除余额。</li>
</ul>
<h5 id="21-1-2、架构图"><a href="#21-1-2、架构图" class="headerlink" title="21.1.2、架构图"></a>21.1.2、架构图</h5><p><img src="/2021/03/15/springcloud/181.png" alt="在这里插入图片描述"></p>
<h5 id="21-1-3、分布式事务解决方案"><a href="#21-1-3、分布式事务解决方案" class="headerlink" title="21.1.3、分布式事务解决方案"></a>21.1.3、分布式事务解决方案</h5><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个<code>独立的数据源</code>，业务操作需要调用三个服务来完成。此时<strong>每个服务内部的数据一致性由<code>本地事务</code>来保证</strong>，但是<strong>全局数据一致性问题是无法保证的</strong>。所以，Alibaba Seata来处理分布式事务</p>
<h4 id="21-2、是什么"><a href="#21-2、是什么" class="headerlink" title="21.2、是什么"></a>21.2、是什么</h4><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。 Seata 将为用户提供了**<code>AT</code>**、<code>TCC</code>、<code>SAGA</code>和<code>XA</code>事务模式，为用户打造一站式的分布式解决方案。</p>
<p>在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着<code>分布式一致性中间件</code>的角色，帮助经济体平稳的度过历年的双11，对各部门业务进行了有力的支撑。经过多年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。2019.1 为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，未来 Seata 将以社区共建的形式帮助其技术更加可靠与完备。</p>
<p>此处重点介绍 **<code>AT模式</code>**，在工作中也最常用，用起来也比较简单。</p>
<p>Seata的四个模式<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官网</a>、<a target="_blank" rel="noopener" href="https://my.oschina.net/sofastack/blog/3092880">资料</a>：</p>
<ul>
<li><p><strong>AT 模式：</strong></p>
<p>提供无侵入自动补偿的事务模式，目前已支持 MySQL、 Oracle 、PostgreSQL和 TiDB的AT模式，H2 开发中</p>
</li>
<li><p>TCC 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/huaishu/article/details/89880971">资料</a>：</p>
<p>支持 TCC 模式并可与 AT 混用，灵活度更高</p>
</li>
<li><p>SAGA 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38308374/article/details/108907413">资料</a>：</p>
<p>为长事务提供有效的解决方案</p>
</li>
<li><p>XA 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/yyl2733291216/article/details/106149336/">资料</a>：</p>
<p>支持已实现 XA 接口的数据库的 XA 模式</p>
</li>
</ul>
<h4 id="21-3、Seata-术语表"><a href="#21-3、Seata-术语表" class="headerlink" title="21.3、Seata 术语表"></a>21.3、Seata 术语表</h4><p>（术语即：名词介绍，以下内容摘自：Seata 官方文档 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/overview/terminology.html%EF%BC%89">http://seata.io/zh-cn/docs/overview/terminology.html）</a></p>
<ul>
<li><strong>TC (Transaction Coordinator) - 事务协调者</strong><br>维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><strong>TM (Transaction Manager) - 事务管理器</strong><br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM (Resource Manager) - 资源管理器</strong><br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>其中，TC 为单独部署的 <strong>Server</strong> 服务端，TM 和 RM 为嵌入到应用中的 <strong>Client</strong> 客户端。</p>
<p><img src="/2021/03/15/springcloud/182.png" alt="在这里插入图片描述"></p>
<p>Seata管理的分布式事务的典型生命周期（执行过程）：</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li>
<li>XID 在微服务调用链路的上下文中传播；</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的全局分支事务，完成分支提交或回滚请求。</li>
</ol>
<h4 id="21-4、AT模式"><a href="#21-4、AT模式" class="headerlink" title="21.4、AT模式"></a>21.4、AT模式</h4><h5 id="21-4-1、AT-前提"><a href="#21-4-1、AT-前提" class="headerlink" title="21.4.1、AT 前提"></a>21.4.1、AT 前提</h5><ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库。</li>
</ul>
<h5 id="21-4-2、AT-整体机制"><a href="#21-4-2、AT-整体机制" class="headerlink" title="21.4.2、AT 整体机制"></a>21.4.2、AT 整体机制</h5><p>两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li>
<li>二阶段：<ul>
<li>提交异步化，非常快速地完成。</li>
<li>回滚通过一阶段的回滚日志进行<code>反向补偿</code>。</li>
</ul>
</li>
</ul>
<h5 id="21-4-3、写隔离"><a href="#21-4-3、写隔离" class="headerlink" title="21.4.3、写隔离"></a>21.4.3、写隔离</h5><ul>
<li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li>
<li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li>
<li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li>
</ul>
<p>以一个示例来说明：</p>
<p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p>
<p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p>
<p><img src="/2021/03/15/springcloud/183.png" alt="img"></p>
<p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p>
<p><img src="/2021/03/15/springcloud/184.png" alt="img"></p>
<p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p>
<p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p>
<p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p>
<h5 id="21-4-4、读隔离"><a href="#21-4-4、读隔离" class="headerlink" title="21.4.4、读隔离"></a>21.4.4、读隔离</h5><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p>
<p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>
<p><img src="/2021/03/15/springcloud/185.png" alt="img"></p>
<p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p>
<p>出于总体性能上的考虑，Seata 目前的方案<strong>并没有对所有 SELECT 语句都进行代理</strong>，仅针对 FOR UPDATE 的 SELECT 语句。</p>
<h5 id="21-4-5、工作机制"><a href="#21-4-5、工作机制" class="headerlink" title="21.4.5、工作机制"></a>21.4.5、工作机制</h5><p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p><strong>AT 分支事务的业务逻辑：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="21-4-5-1、一阶段"><a href="#21-4-5-1、一阶段" class="headerlink" title="21.4.5.1、一阶段"></a>21.4.5.1、一阶段</h6><p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, since <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2021</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, since <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span><span class="string">`;</span></span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2021</td>
</tr>
</tbody></table>
<p>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span>: <span class="number">641789253</span>,</span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span>: [&#123;</span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2021&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2021&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span>: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	&#125;],</span><br><span class="line">	<span class="attr">&quot;xid&quot;</span>: <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的<strong>全局锁</strong>.</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<h6 id="21-4-5-2、二阶段-回滚"><a href="#21-4-5-2、二阶段-回滚" class="headerlink" title="21.4.5.2、二阶段-回滚"></a>21.4.5.2、二阶段-回滚</h6><ol>
<li><p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p>
</li>
<li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>
</li>
<li><p>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改（脏写）。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</p>
</li>
<li><p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p>
</li>
</ol>
<h6 id="21-4-5-3、二阶段-提交"><a href="#21-4-5-3、二阶段-提交" class="headerlink" title="21.4.5.3、二阶段-提交"></a>21.4.5.3、二阶段-提交</h6><ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应<code>UNDO LOG</code>记录。</li>
</ol>
<p>回滚事务表：</p>
<p>UNDO_LOG Table：不同数据库在类型上会略有差别。</p>
<p>以 MySQL 为例：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>branch_id</td>
<td>bigint PK</td>
</tr>
<tr>
<td>xid</td>
<td>varchar(100)</td>
</tr>
<tr>
<td>context</td>
<td>varchar(128)</td>
</tr>
<tr>
<td>rollback_info</td>
<td>longblob</td>
</tr>
<tr>
<td>log_status</td>
<td>tinyint</td>
</tr>
<tr>
<td>log_created</td>
<td>datetime</td>
</tr>
<tr>
<td>log_modified</td>
<td>datetime</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.7.0+ 增加字段 context</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h6 id="21-4-5-4、总结"><a href="#21-4-5-4、总结" class="headerlink" title="21.4.5.4、总结"></a>21.4.5.4、总结</h6><ul>
<li>是什么</li>
</ul>
<p><img src="/2021/03/15/springcloud/186.png" alt="img"></p>
<ul>
<li>一阶段加载：</li>
</ul>
<p><img src="/2021/03/15/springcloud/187.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/188.png" alt="img"></p>
<ul>
<li>二阶段提交：</li>
</ul>
<p><img src="/2021/03/15/springcloud/189.png" alt="img"></p>
<ul>
<li>二阶段回滚：</li>
</ul>
<p><img src="/2021/03/15/springcloud/190.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/191.png" alt="img"></p>
<h4 id="21-5、Spring-Cloud-整合-Nacos-1-3-1-Seata-1-2-0-集群部署-Windows版"><a href="#21-5、Spring-Cloud-整合-Nacos-1-3-1-Seata-1-2-0-集群部署-Windows版" class="headerlink" title="21.5、Spring Cloud 整合 Nacos 1.3.1 + Seata 1.2.0 集群部署(Windows版)"></a>21.5、Spring Cloud 整合 Nacos 1.3.1 + Seata 1.2.0 集群部署(Windows版)</h4><h5 id="21-5-1、环境说明"><a href="#21-5-1、环境说明" class="headerlink" title="21.5.1、环境说明"></a>21.5.1、环境说明</h5><p><strong>部署环境+版本：</strong> <strong><code>MySQL 5.7.x</code></strong> + <strong><code>Nacos 1.3.1</code></strong> + <strong><code>Seata 1.2.0</code></strong> + **<code>Windows 环境演示</code>**，Linux 部署类似。</p>
<h5 id="21-5-2、Seata-1-2-0-下载"><a href="#21-5-2、Seata-1-2-0-下载" class="headerlink" title="21.5.2、Seata 1.2.0 下载"></a>21.5.2、Seata 1.2.0 下载</h5><p>进入 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/blog/download.html">Seata 官网下载地址</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases/tag/v1.2.0">Seata Github下载地址</a>，选择 Seata 1.2.0 版本下载。</p>
<h5 id="21-5-3、官网新人文档中的资源目录介绍"><a href="#21-5-3、官网新人文档中的资源目录介绍" class="headerlink" title="21.5.3、官网新人文档中的资源目录介绍"></a>21.5.3、官网新人文档中的资源目录介绍</h5><p><img src="/2021/03/15/springcloud/192.png" alt="在这里插入图片描述"></p>
<p><strong>详细说明</strong></p>
<p><img src="/2021/03/15/springcloud/193.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-4、Seata-Server-端配置"><a href="#21-5-4、Seata-Server-端配置" class="headerlink" title="21.5.4、Seata Server 端配置"></a>21.5.4、Seata Server 端配置</h5><h6 id="21-5-4-1、解压"><a href="#21-5-4-1、解压" class="headerlink" title="21.5.4.1、解压"></a>21.5.4.1、解压</h6><p>将下载的 <strong><code>seata-server-1.2.0.zip</code></strong> 解压到某个路径下（注意该路径不要有中文或空格）。</p>
<h6 id="21-5-4-2、MySQL-数据库配置"><a href="#21-5-4-2、MySQL-数据库配置" class="headerlink" title="21.5.4.2、MySQL 数据库配置"></a>21.5.4.2、MySQL 数据库配置</h6><p>1、执行MySQL数据库操作前，需要我们手动创建一个名称为 <strong><code>seata</code></strong> 的数据库，然后在该数据库下建表。建库命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/194.png" alt="image-20210314232019841"></p>
<p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/server/db/mysql.sql</code></strong> ，执行SQL语句。建表语句如下，你也可以点击链接获取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/195.png" alt="在这里插入图片描述"></p>
<h6 id="21-5-4-3、Server端参数项配置"><a href="#21-5-4-3、Server端参数项配置" class="headerlink" title="21.5.4.3、Server端参数项配置"></a>21.5.4.3、Server端参数项配置</h6><p>解压后，进入 <strong><code>conf</code></strong> 目录开始参数的配置。我们修改 <strong><code>file.conf</code></strong> 和 <strong><code>registry.conf</code></strong> 这两个文件。</p>
<p><img src="/2021/03/15/springcloud/196.png" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>对 file.conf 配置：</strong></p>
<p><img src="/2021/03/15/springcloud/197.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>对 registry.conf 配置：</strong></p>
<p><img src="/2021/03/15/springcloud/198.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h6 id="21-5-4-4、启动Seata-Server端"><a href="#21-5-4-4、启动Seata-Server端" class="headerlink" title="21.5.4.4、启动Seata Server端"></a>21.5.4.4、启动Seata Server端</h6><p>进入 bin 目录，双击 <strong><code>seata-server.bat</code></strong> 启动。（Linux环境请选择 seata-server.sh 启动）</p>
<p><img src="/2021/03/15/springcloud/199.png" alt="在这里插入图片描述"></p>
<p>到此为止，Seata Server 端启动完成。</p>
<h4 id="21-5-5、config-center-配置中心配置"><a href="#21-5-5、config-center-配置中心配置" class="headerlink" title="21.5.5、config-center 配置中心配置"></a>21.5.5、config-center 配置中心配置</h4><p>配置中心的配置，本文使用 nacos 作为配置中心。</p>
<h6 id="21-5-5-1、获取要配置的参数信息"><a href="#21-5-5-1、获取要配置的参数信息" class="headerlink" title="21.5.5.1、获取要配置的参数信息"></a>21.5.5.1、获取要配置的参数信息</h6><p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/config-center/config.txt</code></strong> ，展示的是 Seata 1.2.0 版本所有配置中心的内容，全部配置点击链接查看。本文使用db方式，故选择db相关配置，需要用到的配置如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service.vgroupMapping.my_test_tx_group=default  </span><br><span class="line">service.default.grouplist=127.0.0.1:8091</span><br><span class="line">service.enableDegrade=false</span><br><span class="line">service.disableGlobalTransaction=false</span><br><span class="line">store.mode=db  /*此处修改为db*/</span><br><span class="line">store.db.datasource=druid</span><br><span class="line">store.db.dbType=mysql</span><br><span class="line">store.db.driverClassName=com.mysql.jdbc.Driver  /*自定义修改*/</span><br><span class="line">store.db.url=jdbc:mysql://192.168.204.201:3306/seata?useUnicode=true /*自定义修改*/</span><br><span class="line">store.db.user=root  /*自定义修改*/</span><br><span class="line">store.db.password=root  /*自定义修改*/</span><br><span class="line">store.db.minConn=5</span><br><span class="line">store.db.maxConn=30</span><br><span class="line">store.db.globalTable=global_table</span><br><span class="line">store.db.branchTable=branch_table</span><br><span class="line">store.db.queryLimit=100</span><br><span class="line">store.db.lockTable=lock_table</span><br><span class="line">store.db.maxWait=5000</span><br></pre></td></tr></table></figure>

<h6 id="21-5-5-2、将参数配置到Nacos配置中心"><a href="#21-5-5-2、将参数配置到Nacos配置中心" class="headerlink" title="21.5.5.2、将参数配置到Nacos配置中心"></a>21.5.5.2、将参数配置到Nacos配置中心</h6><p>进入 资源目录 seata/script/config-center/nacos/nacos-config.sh ，该配置会将 seata 相关配置批量添加到 nacos 服务器。</p>
<p>该脚本可以随便放在某个位置，只要脚本 nacos-config.sh 能够读取到 config.txt 文件即可。本文放在如下为止</p>
<p><img src="/2021/03/15/springcloud/200.png" alt="在这里插入图片描述"></p>
<p>你自己打开<code>nacos-config.sh</code>脚本 看看它查找 config.txt 的逻辑就可以了，只要能够读取到 config.txt 文件即可。nacos-config.sh 脚本支持传入<code>四个参数</code>：</p>
<ul>
<li>-h nacos 所在服务器的IP地址，默认为 localhost</li>
<li>-p nacos 端口号，默认为 8848</li>
<li>-g nacos 配置所属 group 名称，默认为 SEATA_GROUP</li>
<li>-t 将 nacos 配置保存到指定的命名空间，默认为 “”，代表 public 命名空间（注意：-t 参数值接收的是 命名空间ID，不是 命名空间名称） </li>
</ul>
<p>使用 <strong>git 命令框</strong> 执行 <strong><code>sh nacos-config.sh</code></strong> ，就可以将配置批量保存到 nacos 服务器。如下图所示：</p>
<p><img src="/2021/03/15/springcloud/201.gif" alt="在这里插入图片描述"></p>
<p>到此为止，Config Center 配置中心参数，配置完成。</p>
<h4 id="21-5-6、client-客户端配置"><a href="#21-5-6、client-客户端配置" class="headerlink" title="21.5.6、client 客户端配置"></a>21.5.6、client 客户端配置</h4><h5 id="21-5-6-1、业务场景"><a href="#21-5-6-1、业务场景" class="headerlink" title="21.5.6.1、业务场景"></a>21.5.6.1、业务场景</h5><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<ul>
<li>订单服务A：根据采购需求创建订单。</li>
<li>仓储服务B：对给定的商品扣除仓储数量。</li>
<li>帐户服务C：从用户帐户中扣除余额。</li>
</ul>
<p>用户A购买商品，调用<code>A服务</code>创建订单完成，调用<code>B服务</code>扣减库存，然后调用<code>C服务</code>扣减账户余额。<strong>每个服务内部的数据一致性由本地事务来保证，多个服务调用来完成业务，全局事务数据一致性则由 Seata 来保证。</strong></p>
<h5 id="21-5-6-2、业务数据库准备"><a href="#21-5-6-2、业务数据库准备" class="headerlink" title="21.5.6.2、业务数据库准备"></a>21.5.6.2、业务数据库准备</h5><p>配置三个业务分别对应各自的数据库。</p>
<ul>
<li>A服务 对应数据库：seata_order ；表：t_order</li>
<li>B服务 对应数据库：seata_storage ；表：t_storage</li>
<li>C服务 对应数据库：seata_account ；表：t_account</li>
</ul>
<p><strong>建库，建表语句如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_order数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_order;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_order表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_order.t_order(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    <span class="string">`count`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    <span class="string">`money`</span> <span class="built_in">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">    <span class="string">`status`</span> <span class="built_in">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;订单状态：0：创建中; 1：已完结&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_storage数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_storage;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_storage表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_storage.t_storage(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    <span class="string">`total`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">    <span class="string">`used`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line">    <span class="string">`residue`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一条数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_storage.t_storage(<span class="string">`id`</span>,<span class="string">`product_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;100&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_account数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_account;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_account表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_account.t_account(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    <span class="string">`total`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">    <span class="string">`used`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line">    <span class="string">`residue`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一条数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_account.t_account(<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>) <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-3、创建-undo-log-表"><a href="#21-5-6-3、创建-undo-log-表" class="headerlink" title="21.5.6.3、创建 undo_log 表"></a>21.5.6.3、创建 undo_log 表</h5><p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/client/at/db/mysql.sql</code></strong> ，展示的就是 undo_log 表的建表语句，该表需要在涉及到事务处理的每个库中都添加以下。undo_log 表建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-4、库表创建完成图示"><a href="#21-5-6-4、库表创建完成图示" class="headerlink" title="21.5.6.4、库表创建完成图示"></a>21.5.6.4、库表创建完成图示</h5><p><img src="/2021/03/15/springcloud/202.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-6-5、添加-pom-依赖"><a href="#21-5-6-5、添加-pom-依赖" class="headerlink" title="21.5.6.5、添加 pom 依赖"></a>21.5.6.5、添加 pom 依赖</h5><p>pom.xml 部分的注意事项，可参考：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html">部署指南-注意事项</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-7、application-yml-针对-seata-进行配置"><a href="#21-5-6-7、application-yml-针对-seata-进行配置" class="headerlink" title="21.5.6.7、application.yml 针对 seata 进行配置"></a>21.5.6.7、application.yml 针对 seata 进行配置</h5><p>进入<a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a><code>seata/script/client/spring/</code>，展示的就是 seata 整合 Spring 的全部配置内容，提供了<code>.properties</code>、<code>.yml</code>两种格式的配置。详细的配置项还挺多，此处就不粘贴了，你可以点击 资源目录 查看。此处挑选了本案例需要的部分内容进行配置，配置如下所示：（项目application.yml完整配置，请参考文末项目完整代码）</p>
<p><code>该配置在每个服务模块都需要配置一份</code>，你也可以通过 nacos 配置中心的方式配置使用。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span>  <span class="comment"># 此处key需要与tx-service-group的value一致，否则会报 no available service &#x27;null&#x27; found, please make sure registry config correct 异常</span></span><br><span class="line">    <span class="attr">grouplist:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8091</span></span><br><span class="line">    <span class="attr">enable-degrade:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable-global-transaction:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">serverAddr:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">userName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span>  <span class="comment"># 此处名称需和 seata server 服务端 application一致,否则会报 no available service &#x27;null&#x27; found, please make sure registry config correct 异常</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">userName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>业务代码略</p>
<h4 id="21-5-7、Seata-高可用集群部署"><a href="#21-5-7、Seata-高可用集群部署" class="headerlink" title="21.5.7、Seata 高可用集群部署"></a>21.5.7、Seata 高可用集群部署</h4><h5 id="21-5-7-1、集群部署"><a href="#21-5-7-1、集群部署" class="headerlink" title="21.5.7.1、集群部署"></a>21.5.7.1、集群部署</h5><p>Seata 集群部署比较简单，只需将已配置好的 seata-server 再启动一个即可。seata 默认使用 8091 端口，此次我在 Windows 部署，所以 seata-server 第二个节点选用 8092 端口，进入 cmd 命令行，使用命令：<code>seata-server.bat -p 8092</code>启动seata-server 第二台节点。(Linux 正式环境，多机器的话，只需要 scp 到另一台机器，启动即可)</p>
<p>通过 nacos 服务列表，seata-server 实例数由 1 变为 2。端口分别为 8091、8092 。集群搭建完成，挺简单的。想要几个节点就来几个节点，so easy。<br><img src="/2021/03/15/springcloud/203.gif" alt="在这里插入图片描述"></p>
<h5 id="21-5-7-2、服务注册成功"><a href="#21-5-7-2、服务注册成功" class="headerlink" title="21.5.7.2、服务注册成功"></a>21.5.7.2、服务注册成功</h5><p>3个服务启动成功后，均会通过 RPC 的方式注册到 Seata 集群的两个节点上来，如下图所示：</p>
<p><img src="/2021/03/15/springcloud/204.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-7-3、Seata集群测试"><a href="#21-5-7-3、Seata集群测试" class="headerlink" title="21.5.7.3、Seata集群测试"></a>21.5.7.3、Seata集群测试</h5><p>使用 postman 发送 50 个请求，中途关闭 8091 节点。由于集群之间通过 Nacos 通信原因，一个节点的突然宕机，会导致部分请求失败，但是服务很快便会恢复正常。</p>
<p>当再次将 8091 节点启动后，服务还是能够正常请求，8091 节点也有事务相应的日志显示，说明Seata 集群能够正常提供服务。测试如图所示：<br><img src="/2021/03/15/springcloud/205.gif" alt="在这里插入图片描述"></p>
<h4 id="21-5-8、全局事务服务-GTS-阿里云"><a href="#21-5-8、全局事务服务-GTS-阿里云" class="headerlink" title="21.5.8、全局事务服务 GTS-阿里云"></a>21.5.8、全局事务服务 GTS-阿里云</h4><h5 id="21-5-8-1、是什么"><a href="#21-5-8-1、是什么" class="headerlink" title="21.5.8.1、是什么"></a>21.5.8.1、是什么</h5><p><a target="_blank" rel="noopener" href="https://help.aliyun.com/product/48444.html">官网</a></p>
<p>全局事务服务（Global Transaction Service，简称 GTS）是一款高性能、高可靠、接入简单的分布式事务中间件，用于解决分布式环境下的事务一致性问题。 在单机数据库下很容易维持事务的 ACID（Atomicity、Consistency、Isolation、Durability）特性，但在分布式系统中并不容易，GTS 可以保证分布式系统中的分布式事务的 ACID 特性。 GTS 支持 DRDS、RDS、MySQL 等多种数据源，可以配合 EDAS 和 Dubbo 等微服务框架使用， 兼容 MQ 实现事务消息。通过各种组合，可以轻松实现分布式数据库事务、多库事务、消息事务、服务链路级事务等多种业务需求。</p>
<h5 id="21-5-8-2、GTS与Seata"><a href="#21-5-8-2、GTS与Seata" class="headerlink" title="21.5.8.2、GTS与Seata"></a>21.5.8.2、GTS与Seata</h5><ul>
<li>Seata：开源框架</li>
<li>GTS：付费的商用框架</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/" class="post-title-link" itemprop="url">springboot项目打成jar包后台运行在linux上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 03:15:47 / 修改时间：03:16:42" itemprop="dateCreated datePublished" datetime="2020-11-23T03:15:47+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">springboot项目打成jar包后台运行在linux上</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>背景：springboot2为为主体搭建的项目，直接打成jar包，上传到linux上面</p>
<p>启动项目：java -jar xx.jar 这样很方便，但是不能关闭窗口，否则项目就停了</p>
<p>后台启动： nohup java -jar xx.jar &amp; </p>
<p>这样就能后台启动了</p>
<p>有时候我们并不是部署单机版的，需要部署多个，可能部署到一台机器上，但是端口肯定得不一样吧，要是再重新打包一份就太麻烦了，我们可以在启动命令上加上启动端口参数</p>
<p>命令：nohup java -jar xx.jar –server.port=8083 &amp;</p>
<p>此时你会发现在当前目录下多了nohup.out 的文件，这个文件就是你项目的日志文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">　　　　<span class="comment">&lt;!-- 打包可执行jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.sanro.test.CMApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">springboot项目的远程部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 03:11:44 / 修改时间：03:19:06" itemprop="dateCreated datePublished" datetime="2020-11-23T03:11:44+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">springboot项目的远程部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前写过一篇博客关于ssm项目远程部署<br> 地址：<a href="https://xgh-user.github.io/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">在这里</a></p>
<p>该教程是基于上篇，只是有部分修改而已。</p>
<p>Springboot 远程部署需要修改一下几点：</p>
<h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><p>（1）打包方式，这里将jar —&gt; war<br> <img src="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/1.jpg" alt="1"><br> （2）关于依赖<br> springboot由于内置了tomcat，所以在使用war包部署是需要移除内置tomcat，并添加servlet容器支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--移除嵌入式tomcat插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加servlet-api的依赖，使用war包部署这个必须要有--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="二、SpringbootApplication启动类"><a href="#二、SpringbootApplication启动类" class="headerlink" title="二、SpringbootApplication启动类"></a>二、SpringbootApplication启动类</h3><p>启动类需要继承 <strong>SpringBootServletInitializer</strong>  类，并且重写<strong>configure</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringbootApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(HelloSpringbootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloSpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需以上两部就可以完成Springboot项目远程部署。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/android_ztz/article/details/79262416">https://blog.csdn.net/android_ztz/article/details/79262416</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">ssm+maven项目的远程部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 02:58:56 / 修改时间：03:11:06" itemprop="dateCreated datePublished" datetime="2020-11-23T02:58:56+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">ssm+maven项目的远程部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><p>本教程使用的环境如下 </p>
<ul>
<li><p>idea 2017 </p>
</li>
<li><p>tomcat 8.5 </p>
</li>
<li><p>centos 7 </p>
</li>
<li><p>maven 3.5</p>
<p>注意：tomcat6 和 tomcat7、8、9会有一些区别，下面会详细介绍</p>
</li>
</ul>
<h3 id="二、配置【只需完成下面三步】"><a href="#二、配置【只需完成下面三步】" class="headerlink" title="二、配置【只需完成下面三步】"></a>二、配置【只需完成下面三步】</h3><h4 id="1、Tomcat-服务器配置"><a href="#1、Tomcat-服务器配置" class="headerlink" title="1、Tomcat 服务器配置"></a>1、Tomcat 服务器配置</h4><p>如果不了解 Tomcat 的安装，参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/android_ztz/article/details/79249467">http://blog.csdn.net/android_ztz/article/details/79249467</a> </p>
<p>找到[tomcat安装的根路径]/conf/tomcat-users.xml 文件，编辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tomcat-users xmlns&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml&quot;</span><br><span class="line">              xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml tomcat-users.xsd&quot;</span><br><span class="line">              version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-jmx&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-status&quot;&#x2F;&gt;</span><br><span class="line">  &lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;tomcat-users&gt;</span><br></pre></td></tr></table></figure>

<p>role标签都是定义权限，user标签定义的是用户，usernme和password都是自定义的，roles是赋予该用户的权限。</p>
<blockquote>
<p>测试配置是否成功</p>
</blockquote>
<p>在浏览器中访问 <a href="http://yourIp:port/manager/text">http://yourIp:port/manager/text</a> (tomcat 7、8、9) ；<br> <a href="http://yourIp:port/manager/html">http://yourIp:port/manager/html</a> （tomcat 6）<br> 如果出现输入账户和密码的弹框，表示成功。</p>
<p>但是有可能会出现 <strong>【管理页面403 Access Denied】错误</strong>，详情见下面问题2：</p>
<p>【修改Tomcat端口号-默认是8080】<br> 如果需要修改，找到[tomcat安装的根路径]/conf/server.xml ，找到这一段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>只需修改port的值即可。</p>
<h3 id="二、配置Maven"><a href="#二、配置Maven" class="headerlink" title="二、配置Maven"></a>二、配置Maven</h3><p>打开[Maven的安装路径]/conf/setting.xml文件 ，找到这一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;tomcat8&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;username&gt;tomcat&lt;&#x2F;username&gt;</span><br><span class="line">      &lt;password&gt;tomcat&lt;&#x2F;password&gt;</span><br><span class="line">    &lt;&#x2F;server&gt;</span><br><span class="line">  &lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure>

<p>id : tomcat+版本号<br> username : 在Tomcat配置的用户名<br> password : 在Tomcat配置的密码</p>
<h3 id="三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下："><a href="#三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下：" class="headerlink" title="三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下："></a>三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.ztz&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;deploy-project&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;name&gt;deploy-project Maven Webapp&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;defaultGoal&gt;compile&lt;&#x2F;defaultGoal&gt;</span><br><span class="line">    &lt;finalName&gt;deploy-project&lt;&#x2F;finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;!-- maven项目插件运行配置 --&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">          &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">          &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">      &lt;!-- maven远程项目部署插件 --&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;!-- 填写自己服务器的IP地址和端口号,并且其他的不变,Tomcat7、8、9使用这个，Tomcat6使用另一个--&gt;</span><br><span class="line">          &lt;url&gt;http:&#x2F;&#x2F;192.168.199.133&#x2F;manager&#x2F;text&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;server&gt;tomcat8&lt;&#x2F;server&gt;</span><br><span class="line">          &lt;!-- 这个账户和密码是自定义的，和Maven，Tomcat中配置要保持一致--&gt;</span><br><span class="line">          &lt;username&gt;tomcat&lt;&#x2F;username&gt;</span><br><span class="line">          &lt;password&gt;tomcat&lt;&#x2F;password&gt;</span><br><span class="line">          &lt;port&gt;80&lt;&#x2F;port&gt;</span><br><span class="line">          &lt;!-- 若tomcat项目中已存在，且使&quot;mvn tomcat7:deploy&quot;命令必须要设置下面的代码 --&gt;</span><br><span class="line">          &lt;!-- 更新项目时，仅需要执行&quot;mvn tomcat7:redeploy&quot;命令即可 --&gt;</span><br><span class="line">          &lt;!-- 上述命令无论服务器是tomcat7、8或9，均是使用&quot;mvn tomcat7:deploy&quot;或&quot;mvn tomcat7:redeploy&quot; --&gt;</span><br><span class="line">          &lt;update&gt;true&lt;&#x2F;update&gt;</span><br><span class="line">          &lt;!-- 项目路径 --&gt;</span><br><span class="line">          &lt;path&gt;&#x2F;deploy-project&lt;&#x2F;path&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">  &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>最主要的配置就是<built>标签中，关于<built>详解：<br> finalName：项目名<br> server： 服务器名和版本<br> username： 和tomcat、maven中保持一致<br> password：和tomcat、maven中保持一致<br> port：需要部署到的端口，要和服务器配置的端口一致<br> path：访问项目的路径</built></built></p>
<blockquote>
<p>其他就可以和上面保持一致。</p>
</blockquote>
<p>现在已经完成了所有的配置，那么就开始测试一下能否部署成功，在idea 中点击右栏[Maven标签]<br><img src="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/1.jpg"></p>
<p> 双击【tomcat7:deploy】完成部署，查看控制台信息<br><img src="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/2.jpg" alt="2"></p>
<p>—————————————- 华丽 ——————————————–</p>
<p>遇到的问题1： </p>
<ul>
<li><p>Tomcat已启动，内网可以访问，但是外网不可以访问。 </p>
<p>答 ： 这很有可能是防火墙阻止了浏览器的访问。 </p>
</li>
<li><p>解决方式：</p>
<p>centos7使用的防火墙是 firewall 而不是 iptables 可以开要访问的端口，先查看一下防火墙状态：  firewall-cmd –state ， 结是running 或者 not running ， 建议running状态下添加开放端口。 比如需要访问的是8080端口，则可以这样 </p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp     # --permanent 表示永久添加；去掉标识临时，重启后恢复 </span><br><span class="line"> firewall-cmd --reload     # 加载配置，使得修改有效。 </span><br><span class="line"> 查看端口是否开放成功？  </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports      #查看开启的端口</span><br></pre></td></tr></table></figure>

<p>如果出现 8080/tcp 表示成功 。  </p>
<p>需要了解firewall更多，点击这里。 </p>
<hr>
<ul>
<li><p>遇到的问题2： </p>
<p>管理页面403 Access Denied </p>
<p>这说明你没有权限访问， </p>
</li>
<li><p>解决方式：</p>
<p>打开/webapps/manager/META-INF/目录下context.xml文件，将下面这段注释掉或者修改为下面这段。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">allow</span>=<span class="string">&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|\d+\.\d+\.\d+\.\d+&quot;</span> /&gt;</span>12</span><br></pre></td></tr></table></figure>

<p>原因是： \d+.\d+.\d+.\d+ 标识任访问，如果不添加这个，则只允许前面两种类型IP访问，allow中是用正则表达式来表示的。</p>
<hr>
<ul>
<li><p>遇到的问题3 ： </p>
<p>[ERROR] Failed to execute goal  org.apache.tomcat.maven:tomcat7-maven-plugin: 2.0-SNAPSHOT:deploy  (default-cli) on project helloworld: Cannot invoke Tomcat manager:  Server returned HTTP response code: 401 for URL: <a target="_blank" rel="noopener" href="http://localhost:8080/manager/text/deploy?path=/helloworld">http://localhost:8080/manager/text/deploy?path=%2Fhelloworld</a> -&gt; [Help 1]</p>
</li>
</ul>
<p>该错误是在部署时出现的，是由于权限问题，可能是你的 tomcat-users.xml中user的权限不够，也可能是你的idea中pom文件的用户名和密码错了。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/android_ztz/article/details/79249335">https://blog.csdn.net/android_ztz/article/details/79249335</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
